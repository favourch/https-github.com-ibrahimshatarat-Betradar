<?xml version="1.0"?>
<doc>
  <assembly>
    <name>BookmakerSdk</name>
  </assembly>
  <members>
    <member name="T:Sportradar.SDK.Services.Sdk.LiveOddsFeedProviderVfc">
      <summary>
            Virtual football cup LiveOdds provider.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.Sdk.LiveOddsFeedProviderVfc.ProviderType">
      <summary>
            Gets the type of the provider.
            </summary>
      <value>
            The type of the provider.
            </value>
    </member>
    <member name="T:Sportradar.SDK.Services.Sdk.Sdk">
      <summary>
             Main entry point for the SDK client application.
             </summary>
      <example>
        <code>
             try
             {
                 Sdk.Instance.Initialize();
            
                 Sdk.Instance.OnQueueLimits += QueueLimits;
                 Sdk.Instance.OnQueueLimitRetreated += QueueLimitRetreated;
            
                 Sdk.Instance.Start();
            
                 if (Sdk.Instance.LiveOdds != null)
                 {
                     Sdk.Instance.LiveOdds.OnConnectionStable += FlagConnectionAsStable;
                     Sdk.Instance.LiveOdds.OnConnectionUnstable += ConnectionUnstable;
            
                     Sdk.Instance.LiveOdds.OnAlive += AliveReceived;
                     Sdk.Instance.LiveOdds.OnFeedError += FeedErrorOccurred;
                     Sdk.Instance.LiveOdds.OnBetCancel += MatchBetCancelled;
                     Sdk.Instance.LiveOdds.OnBetCancelUndo += MatchBetCancelUndo;
                     Sdk.Instance.LiveOdds.OnBetClear += MatchBetCleared;
                     Sdk.Instance.LiveOdds.OnBetClearRollback += MatchBetClearRollbacked;
                     Sdk.Instance.LiveOdds.OnBetStart += BetStarted;
                     Sdk.Instance.LiveOdds.OnBetStop += BetStopped;
                     Sdk.Instance.LiveOdds.OnMetaInfo += MetaInfoReceived;
                     Sdk.Instance.LiveOdds.OnOddsChange += OddsChanged;
                     Sdk.Instance.LiveOdds.OnScoreCardSummary += ScoreCardReceived;
            
                     Sdk.Instance.LiveOdds.Start();
                 }
                 else
                 {
                     throw new ApplicationException("Error initializing SDK.LiveOdds provider");
                 }
            
                 /* ... start using the SDK ... */
                 Console.ReadLine();
             }
             finally
             {
                 if (Sdk.Instance.LiveOdds != null)
                 {
                 	Sdk.Instance.LiveOdds.Stop();
            
                 	Sdk.Instance.LiveOdds.OnConnectionStable -= FlagConnectionAsStable;
                 	Sdk.Instance.LiveOdds.OnConnectionUnstable -= ConnectionUnstable;
            
                 	Sdk.Instance.LiveOdds.OnAlive -= AliveReceived;
                 	Sdk.Instance.LiveOdds.OnFeedError -= FeedErrorOccurred;
                 	Sdk.Instance.LiveOdds.OnBetCancel -= MatchBetCancelled;
                 	Sdk.Instance.LiveOdds.OnBetCancelUndo -= MatchBetCancelUndo;
                 	Sdk.Instance.LiveOdds.OnBetClear -= MatchBetCleared;
                 	Sdk.Instance.LiveOdds.OnBetClearRollback -= MatchBetClearRollbacked;
                 	Sdk.Instance.LiveOdds.OnBetStart -= BetStarted;
                 	Sdk.Instance.LiveOdds.OnBetStop -= BetStopped;
                 	Sdk.Instance.LiveOdds.OnMetaInfo -= MetaInfoReceived;
                 	Sdk.Instance.LiveOdds.OnOddsChange -= OddsChanged;
                 	Sdk.Instance.LiveOdds.OnScoreCardSummary -= ScoreCardReceived;
                 }
            
                 Sdk.Instance.OnQueueLimits -= QueueLimits;
                 Sdk.Instance.OnQueueLimitRetreated -= QueueLimitRetreated;
            
                 Sdk.Instance.Stop();
             }
             </code>
      </example>
    </member>
    <member name="M:Sportradar.SDK.Services.Sdk.Sdk.Initialize">
      <summary>
            Initialize the SDK.
            Default section name is used from the app.config.
            <see cref="F:Sportradar.SDK.Services.SdkConfiguration.AppConfigFactory.DEFAULT_SECTION_NAME" /></summary>
    </member>
    <member name="M:Sportradar.SDK.Services.Sdk.Sdk.Initialize(System.String,Sportradar.SDK.Common.Interfaces.IDeadLetterQueue)">
      <summary>
            Initialize the SDK.
            </summary>
      <param name="section_name">Name of the section in the configuration file</param>
      <param name="dead_letter_queue">Optional interface where a client can be notified about messages that could not be delivered (can be null)</param>
    </member>
    <member name="M:Sportradar.SDK.Services.Sdk.Sdk.Initialize(Sportradar.SDK.Services.SdkConfiguration.IConfigFactory,Sportradar.SDK.Common.Interfaces.IDeadLetterQueue)">
      <summary>
            Initialize the SDK.
            </summary>
      <param name="config_factory">A factory for obtaining the configuration <see cref="T:Sportradar.SDK.Services.SdkConfiguration.AppConfigFactory" /></param>
      <param name="dead_letter_queue">Optional interface where a client can be notified about messages that could not be delivered (can be null)</param>
      <example>
            Initialize(AppConfigFactory.FromSection("Sdk"), DeadLetterInstance)
            </example>
      <remarks>
            Config factory is used explicitly instead of actual configuration to emphasize that configuration is immutable
            for the application after it is built (internally). It can (depending on the type of the factory) still be updated in run-time by
            changing the configuration file.
            </remarks>
    </member>
    <member name="M:Sportradar.SDK.Services.Sdk.Sdk.Start">
      <summary>
            Starts the SDK instance but does not start the configured feed providers (e.g. LiveScout or LiveOdds).
            SDK message dispatcher pump will start delivering messages after this.
            <remarks>
            Feed providers should be started explicitly after SDK singleton is started.
            </remarks></summary>
    </member>
    <member name="M:Sportradar.SDK.Services.Sdk.Sdk.Stop">
      <summary>
            Stops the SDK. Stops the message pump and all feeds.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Services.Sdk.Sdk.Dispose">
      <summary>
            Releases unmanaged resources held by an instance of this class.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Services.Sdk.Sdk.Dispose(System.Boolean)">
      <summary>
            Releases unmanaged resources held by an instance of this class.
            </summary>
      <param name="is_disposing">Whether this object is being disposed.</param>
    </member>
    <member name="P:Sportradar.SDK.Services.Sdk.Sdk.Instance">
      <summary>
            SDK singleton instance.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.Sdk.Sdk.IsInitialized">
      <summary>
            True if the SDK initialized, false otherwise.
            See the <see cref="M:Sportradar.SDK.Services.Sdk.Sdk.Initialize" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.Sdk.Sdk.IsStarted">
      <summary>
            True if the SDK started, false otherwise.
            See the <see cref="M:Sportradar.SDK.Services.Sdk.Sdk.Initialize" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.Sdk.Sdk.QueueStats">
      <summary>
            Queue statistics.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.Sdk.Sdk.Container">
      <summary>
            Internal to avoid using the service locator anti-pattern
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.Sdk.Sdk.BetPal">
      <summary>
            BetPal provider.
            <remarks><see cref="M:Sportradar.SDK.Services.Sdk.Sdk.Initialize" /> must be called before accessing this member.
            If provider is not enabled through configuration, this member will be null.
            </remarks></summary>
    </member>
    <member name="P:Sportradar.SDK.Services.Sdk.Sdk.Lcoo">
      <summary>
            Live Cycle of Odds provider.
            <remarks><see cref="M:Sportradar.SDK.Services.Sdk.Sdk.Initialize" /> must be called before accessing this member.
            If provider is not enabled through configuration, this member will be null.
            </remarks></summary>
    </member>
    <member name="P:Sportradar.SDK.Services.Sdk.Sdk.LiveOdds">
      <summary>
            LivePlex provider. BetPal and LiveOdds combined in single feed.
            <remarks><see cref="M:Sportradar.SDK.Services.Sdk.Sdk.Initialize" /> must be called before accessing this member.
            If provider is not enabled through configuration, this member will be null.
            </remarks></summary>
    </member>
    <member name="P:Sportradar.SDK.Services.Sdk.Sdk.LiveOddsVbl">
      <summary>
            LiveOdds Virtual Basketball League provider.
            <remarks><see cref="M:Sportradar.SDK.Services.Sdk.Sdk.Initialize" /> must be called before accessing this member.
            If provider is not enabled through configuration, this member will be null.
            </remarks></summary>
    </member>
    <member name="P:Sportradar.SDK.Services.Sdk.Sdk.LiveOddsVdr">
      <summary>
            LiveOdds Virtual Football League provider.
            <remarks><see cref="M:Sportradar.SDK.Services.Sdk.Sdk.Initialize" /> must be called before accessing this member.
            If provider is not enabled through configuration, this member will be null.
            </remarks></summary>
    </member>
    <member name="P:Sportradar.SDK.Services.Sdk.Sdk.LiveOddsVfl">
      <summary>
            LiveOdds Virtual Football League provider.
            <remarks><see cref="M:Sportradar.SDK.Services.Sdk.Sdk.Initialize" /> must be called before accessing this member.
            If provider is not enabled through configuration, this member will be null.
            </remarks></summary>
    </member>
    <member name="P:Sportradar.SDK.Services.Sdk.Sdk.LiveOddsVfc">
      <summary>
            LiveOdds Virtual Football cup provider.
            <remarks><see cref="M:Sportradar.SDK.Services.Sdk.Sdk.Initialize" /> must be called before accessing this member.
            If provider is not enabled through configuration, this member will be null.
            </remarks></summary>
    </member>
    <member name="P:Sportradar.SDK.Services.Sdk.Sdk.LiveOddsVhc">
      <summary>
            LiveOdds Virtual Football League provider.
            <remarks><see cref="M:Sportradar.SDK.Services.Sdk.Sdk.Initialize" /> must be called before accessing this member.
            If provider is not enabled through configuration, this member will be null.
            </remarks></summary>
    </member>
    <member name="P:Sportradar.SDK.Services.Sdk.Sdk.LiveOddsVto">
      <summary>
            LiveOdds Virtual Tennis Open provider.
            <remarks><see cref="M:Sportradar.SDK.Services.Sdk.Sdk.Initialize" /> must be called before accessing this member.
            If provider is not enabled through configuration, this member will be null.
            </remarks></summary>
    </member>
    <member name="P:Sportradar.SDK.Services.Sdk.Sdk.LivePlex">
      <summary>
            LivePlex provider. BetPal and LiveOdds combined in single feed.
            <remarks><see cref="M:Sportradar.SDK.Services.Sdk.Sdk.Initialize" /> must be called before accessing this member.
            If provider is not enabled through configuration, this member will be null.
            </remarks></summary>
    </member>
    <member name="P:Sportradar.SDK.Services.Sdk.Sdk.LiveScout">
      <summary>
            LiveScout provider.
            <remarks><see cref="M:Sportradar.SDK.Services.Sdk.Sdk.Initialize" /> must be called before accessing this member.
            If provider is not enabled through configuration, this member will be null.
            </remarks></summary>
    </member>
    <member name="P:Sportradar.SDK.Services.Sdk.Sdk.OddsCreator">
      <summary>
            OddsCreator provider.
            <remarks><see cref="M:Sportradar.SDK.Services.Sdk.Sdk.Initialize" /> must be called before accessing this member.
            If provider is not enabled through configuration, this member will be null.
            </remarks></summary>
    </member>
    <member name="P:Sportradar.SDK.Services.Sdk.Sdk.SoccerRoulette">
      <summary>
            SoccerRoulette provider.
            <remarks><see cref="M:Sportradar.SDK.Services.Sdk.Sdk.Initialize" /> must be called before accessing this member.
            If provider is not enabled through configuration, this member will be null.
            </remarks></summary>
    </member>
    <member name="E:Sportradar.SDK.Services.Sdk.Sdk.OnQueueLimits">
      <summary>
            Indicates that a queue limit (NORMAL, LOW, HIGH) was either reached or retreated for a specific queue.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.ReferenceAttribute">
      <summary>
            Specifies assignment by reference rather than by copying.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IfExistsAttribute">
      <summary>
            Suppresses any on-demand behaviors.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryBehavior">
      <summary>
            Defines the contract for customizing dictionary access.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryBehavior.Copy">
      <summary>
            Copies the dictionary behavior.
            </summary>
      <returns>null if should not be copied.  Otherwise copy.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.IDictionaryBehavior.ExecutionOrder">
      <summary>
            Determines relative order to apply related behaviors.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.DictionaryBehaviorAttribute">
      <summary>
            Assigns a specific dictionary key.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryPropertySetter">
      <summary>
            Defines the contract for updating dictionary values.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryPropertySetter.SetPropertyValue(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,System.Object@,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Sets the stored dictionary value.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="value">The stored value.</param>
      <param name="property">The property.</param>
      <returns>true if the property should be stored.</returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.RemoveIfAttribute">
      <summary>
            Removes a property if matches value.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.ICondition">
      <summary>
            Contract for value matching.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.RemoveIfEmptyAttribute">
      <summary>
            Removes a property if null or empty string, guid or collection.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.VolatileAttribute">
      <summary>
            Indicates that underlying values are changeable and should not be cached.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryInitializer">
      <summary>
             Contract for dictionary initialization.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryInitializer.Initialize(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.Object[])">
      <summary>
            Performs any initialization of the <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter" /></summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="behaviors">The dictionary behaviors.</param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryAdapterVisitor">
      <summary>
            Conract for traversing a <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter" />.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapterVisitor">
      <summary>
            Abstract implementation of <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapterVisitor" />.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryCreate">
      <summary>
            Contract for creating additional Dictionary adapters.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryEdit">
      <summary>
            Contract for editing the Dictionary adapter.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryNotify">
      <summary>
            Contract for managing Dictionary adapter notifications.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryValidate">
      <summary>
            Contract for validating Dictionary adapter.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter">
      <summary>
            Contract for manipulating the Dictionary adapter.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryBehaviorBuilder">
      <summary>
            Defines the contract for building <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryBehavior" />s.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryBehaviorBuilder.BuildBehaviors">
      <summary>
            Builds the dictionary behaviors.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter">
      <summary>
            Abstract adapter for the <see cref="T:System.Collections.IDictionary" /> support
            needed by the <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory" /></summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Add(System.Object,System.Object)">
      <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <param name="key">The <see cref="T:System.Object"></see> to use as the key of the element to add.</param>
      <param name="value">The <see cref="T:System.Object"></see> to use as the value of the element to add.</param>
      <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.IDictionary"></see> object. </exception>
      <exception cref="T:System.ArgumentNullException">key is null. </exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary"></see> is read-only.-or- The <see cref="T:System.Collections.IDictionary"></see> has a fixed size. </exception>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Clear">
      <summary>
            Removes all elements from the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary"></see> object is read-only. </exception>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Contains(System.Object)">
      <summary>
            Determines whether the <see cref="T:System.Collections.IDictionary"></see> object contains an element with the specified key.
            </summary>
      <param name="key">The key to locate in the <see cref="T:System.Collections.IDictionary"></see> object.</param>
      <returns>
            true if the <see cref="T:System.Collections.IDictionary"></see> contains an element with the key; otherwise, false.
            </returns>
      <exception cref="T:System.ArgumentNullException">key is null. </exception>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.GetEnumerator">
      <summary>
            Returns an <see cref="T:System.Collections.IDictionaryEnumerator"></see> object for the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IDictionaryEnumerator"></see> object for the <see cref="T:System.Collections.IDictionary"></see> object.
            </returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Remove(System.Object)">
      <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <param name="key">The key of the element to remove.</param>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary"></see> object is read-only.-or- The <see cref="T:System.Collections.IDictionary"></see> has a fixed size. </exception>
      <exception cref="T:System.ArgumentNullException">key is null. </exception>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.CopyTo(System.Array,System.Int32)">
      <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"></see> to an <see cref="T:System.Array"></see>, starting at a particular <see cref="T:System.Array"></see> index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array"></see> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection"></see>. The <see cref="T:System.Array"></see> must have zero-based indexing.</param>
      <param name="index">The zero-based index in array at which copying begins.</param>
      <exception cref="T:System.ArgumentNullException">array is null. </exception>
      <exception cref="T:System.ArgumentException">The type of the source <see cref="T:System.Collections.ICollection"></see> cannot be cast automatically to the type of the destination array. </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">index is less than zero. </exception>
      <exception cref="T:System.ArgumentException">array is multidimensional.-or- index is equal to or greater than the length of array.-or- The number of elements in the source <see cref="T:System.Collections.ICollection"></see> is greater than the available space from index to the end of the destination array. </exception>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.IsFixedSize">
      <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary"></see> object has a fixed size.
            </summary>
      <value>
      </value>
      <returns>true if the <see cref="T:System.Collections.IDictionary"></see> object has a fixed size; otherwise, false.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.IsReadOnly">
      <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary"></see> object is read-only.
            </summary>
      <value>
      </value>
      <returns>true if the <see cref="T:System.Collections.IDictionary"></see> object is read-only; otherwise, false.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Keys">
      <summary>
            Gets an <see cref="T:System.Collections.ICollection"></see> object containing the keys of the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <value>
      </value>
      <returns>An <see cref="T:System.Collections.ICollection"></see> object containing the keys of the <see cref="T:System.Collections.IDictionary"></see> object.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Values">
      <summary>
            Gets an <see cref="T:System.Collections.ICollection"></see> object containing the values in the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <value>
      </value>
      <returns>An <see cref="T:System.Collections.ICollection"></see> object containing the values in the <see cref="T:System.Collections.IDictionary"></see> object.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Item(System.Object)">
      <summary>
            Gets or sets the <see cref="T:System.Object" /> with the specified key.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Count">
      <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.ICollection"></see>.
            </summary>
      <value>
      </value>
      <returns>The number of elements contained in the <see cref="T:System.Collections.ICollection"></see>.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.IsSynchronized">
      <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"></see> is synchronized (thread safe).
            </summary>
      <value>
      </value>
      <returns>true if access to the <see cref="T:System.Collections.ICollection"></see> is synchronized (thread safe); otherwise, false.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.SyncRoot">
      <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"></see>.
            </summary>
      <value>
      </value>
      <returns>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"></see>.</returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.BindingList`1">
      <summary>
              Provides a generic collection that supports data binding.
            </summary>
      <remarks>
              This class wraps the CLR <see cref="T:System.ComponentModel.BindingList`1" />
              in order to implement the Castle-specific <see cref="T:Castle.Components.DictionaryAdapter.IBindingList`1" />.
            </remarks>
      <typeparam name="T">The type of elements in the list.</typeparam>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.BindingList`1.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.BindingList`1" /> class
              using default values.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.BindingList`1.#ctor(System.Collections.Generic.IList{`0})">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.BindingList`1" /> class
              with the specified list.
            </summary>
      <param name="list">
              An <see cref="T:System.Collections.Generic.IList`1" /> of items
              to be contained in the <see cref="T:Castle.Components.DictionaryAdapter.BindingList`1" />.
            </param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.BindingList`1.#ctor(System.ComponentModel.BindingList{`0})">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.BindingList`1" /> class
              wrapping the specified <see cref="T:System.ComponentModel.BindingList`1" /> instance.
            </summary>
      <param name="list">
              A <see cref="T:System.ComponentModel.BindingList`1" />
              to be wrapped by the <see cref="T:Castle.Components.DictionaryAdapter.BindingList`1" />.
            </param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter">
      <summary>
            Defines the contract for retrieving dictionary values.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter.GetPropertyValue(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,System.Object,Castle.Components.DictionaryAdapter.PropertyDescriptor,System.Boolean)">
      <summary>
            Gets the effective dictionary value.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="storedValue">The stored value.</param>
      <param name="property">The property.</param>
      <param name="ifExists">true if return only existing.</param>
      <returns>The effective property value.</returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.Xml.XmlAdapter.#ctor(Castle.Components.DictionaryAdapter.Xml.IXmlNode,Castle.Components.DictionaryAdapter.Xml.XmlReferenceManager)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.Xml.XmlAdapter" /> class
            that represents a child object in a larger object graph.
            </summary>
      <param name="node">
      </param>
      <param name="references">
      </param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer">
      <summary>
             Contract for dictionary meta-data initialization.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer.Initialize(Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory,Castle.Components.DictionaryAdapter.DictionaryAdapterMeta)">
      <summary>
            	Initializes the given <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> object.
            </summary>
      <param name="factory">The dictionary adapter factory.</param>
      <param name="dictionaryMeta">The dictionary adapter meta.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer.ShouldHaveBehavior(System.Object)">
      <summary>
            	Determines whether the given behavior should be included in a new
            	<see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> object.
            </summary>
      <param name="behavior">A dictionary behavior or annotation.</param>
      <returns>True if the behavior should be included; otherwise, false.</returns>
      <remarks>
        <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer" /> behaviors are always included,
            	regardless of the result of this method.
            </remarks>
    </member>
    <member name="M:Castle.Core.Internal.CollectionExtensions.IsNullOrEmpty(System.Collections.IEnumerable)">
      <summary>
              Checks whether or not collection is null or empty. Assumes colleciton can be safely enumerated multiple times.
            </summary>
      <param name="this">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Internal.ExceptionMessageBuilder.CreateMessageForInaccessibleType(System.Type,System.Type)">
      <summary>
            Creates a message to inform clients that a proxy couldn't be created due to reliance on an
            inaccessible type (perhaps itself).
            </summary>
      <param name="inaccessibleType">the inaccessible type that prevents proxy creation</param>
      <param name="typeToProxy">the type that couldn't be proxied</param>
    </member>
    <member name="M:Castle.Core.Internal.TypeExtensions.GetBestName(System.Type)">
      <summary>
            Find the best available name to describe a type.
            </summary>
      <remarks>
            Usually the best name will be <see cref="P:System.Type.FullName" />, but
            sometimes that's null (see http://msdn.microsoft.com/en-us/library/system.type.fullname%28v=vs.110%29.aspx)
            in which case the method falls back to <see cref="P:System.Reflection.MemberInfo.Name" />.
            </remarks>
      <param name="type">the type to name</param>
      <returns>the best name</returns>
    </member>
    <member name="F:Castle.Core.Internal.InternalsVisible.ToCastleCore">
      <summary>
              Constant to use when making assembly internals visible to Castle.Core 
              <c>[assembly: InternalsVisibleTo(CoreInternalsVisible.ToCastleCore)]</c></summary>
    </member>
    <member name="F:Castle.Core.Internal.InternalsVisible.ToDynamicProxyGenAssembly2">
      <summary>
              Constant to use when making assembly internals visible to proxy types generated by DynamicProxy. Required when proxying internal types.
              <c>[assembly: InternalsVisibleTo(CoreInternalsVisible.ToDynamicProxyGenAssembly2)]</c></summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder">
      <summary>
            Defines the contract for building typed dictionary keys.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder.GetKey(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Builds the specified key.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The current key.</param>
      <param name="property">The property.</param>
      <returns>The updated key</returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.ComponentAttribute">
      <summary>
            Identifies a property should be represented as a nested component.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.ComponentAttribute.NoPrefix">
      <summary>
            Applies no prefix.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.ComponentAttribute.Prefix">
      <summary>
            Gets or sets the prefix.
            </summary>
      <value>The prefix.</value>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.DictionaryAdapterAttribute">
      <summary>
            Identifies the dictionary adapter types.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.FetchAttribute">
      <summary>
            Identifies an interface or property to be pre-fetched.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.FetchAttribute.#ctor">
      <summary>
            Instructs fetching to occur.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.FetchAttribute.#ctor(System.Boolean)">
      <summary>
            Instructs fetching according to <paramref name="fetch" /></summary>
      <param name="fetch">
      </param>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.FetchAttribute.Fetch">
      <summary>
            Gets whether or not fetching should occur.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.GroupAttribute">
      <summary>
            Assigns a property to a group.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.GroupAttribute.#ctor(System.Object)">
      <summary>
            Constructs a group assignment.
            </summary>
      <param name="group">The group name.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.GroupAttribute.#ctor(System.Object[])">
      <summary>
            Constructs a group assignment.
            </summary>
      <param name="group">The group name.</param>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.GroupAttribute.Group">
      <summary>
            Gets the group the property is assigned to.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.KeyAttribute">
      <summary>
            Assigns a specific dictionary key.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.KeyAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.KeyAttribute" /> class.
            </summary>
      <param name="key">The key.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.KeyAttribute.#ctor(System.String[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.KeyAttribute" /> class.
            </summary>
      <param name="keys">The compound key.</param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.KeyPrefixAttribute">
      <summary>
            Assigns a prefix to the keyed properties of an interface.
            </summary>
      <remarks>
            Key prefixes are not inherited by sub-interfaces.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.KeyPrefixAttribute.#ctor">
      <summary>
            Initializes a default instance of the <see cref="T:Castle.Components.DictionaryAdapter.KeyPrefixAttribute" /> class.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.KeyPrefixAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.KeyPrefixAttribute" /> class.
            </summary>
      <param name="keyPrefix">The prefix for the keyed properties of the interface.</param>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.KeyPrefixAttribute.KeyPrefix">
      <summary>
            Gets the prefix key added to the properties of the interface.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.KeySubstitutionAttribute">
      <summary>
            Substitutes part of key with another string.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.KeySubstitutionAttribute.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.KeySubstitutionAttribute" /> class.
            </summary>
      <param name="oldValue">The old value.</param>
      <param name="newValue">The new value.</param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.MultiLevelEditAttribute">
      <summary>
            Requests support for multi-level editing.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.NewGuidAttribute">
      <summary>
            Generates a new GUID on demand.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.OnDemandAttribute">
      <summary>
            Support for on-demand value resolution.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.StringFormatAttribute">
      <summary>
            Provides simple string formatting from existing properties.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.StringFormatAttribute.Format">
      <summary>
            Gets the string format.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.StringFormatAttribute.Properties">
      <summary>
            Gets the format properties.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.StringListAttribute">
      <summary>
            Identifies a property should be represented as a delimited string value.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.StringListAttribute.Separator">
      <summary>
            Gets the separator.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.StringValuesAttribute">
      <summary>
            Converts all properties to strings.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.StringValuesAttribute.Format">
      <summary>
            Gets or sets the format.
            </summary>
      <value>The format.</value>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IPropertyDescriptorInitializer">
      <summary>
             Contract for property descriptor initialization.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IPropertyDescriptorInitializer.Initialize(Castle.Components.DictionaryAdapter.PropertyDescriptor,System.Object[])">
      <summary>
            Performs any initialization of the <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /></summary>
      <param name="propertyDescriptor">The property descriptor.</param>
      <param name="behaviors">The property behaviors.</param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.SuppressNotificationsAttribute">
      <summary>
            Suppress property change notifications.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.TypeKeyPrefixAttribute">
      <summary>
            Assigns a prefix to the keyed properties using the interface name.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.DefaultPropertyGetter">
      <summary>
            Manages conversion between property values.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DefaultPropertyGetter.#ctor(System.ComponentModel.TypeConverter)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.DefaultPropertyGetter" /> class.
            </summary>
      <param name="converter">The converter.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DefaultPropertyGetter.GetPropertyValue(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,System.Object,Castle.Components.DictionaryAdapter.PropertyDescriptor,System.Boolean)">
      <summary>
            Gets the effective dictionary value.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="storedValue">The stored value.</param>
      <param name="property">The property.</param>
      <param name="ifExists">true if return only existing.</param>
      <returns>The effective property value.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.DefaultPropertyGetter.ExecutionOrder">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory">
      <summary>
            Defines the contract for building typed dictionary adapters.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter``1(System.Collections.IDictionary)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Collections.IDictionary" />.
            </summary>
      <typeparam name="T">The typed interface.</typeparam>
      <param name="dictionary">The underlying source of properties.</param>
      <returns>An implementation of the typed interface bound to the dictionary.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter(System.Type,System.Collections.IDictionary)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Collections.IDictionary" />.
            </summary>
      <param name="type">The typed interface.</param>
      <param name="dictionary">The underlying source of properties.</param>
      <returns>An implementation of the typed interface bound to the dictionary.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter(System.Type,System.Collections.IDictionary,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Collections.IDictionary" />.
            </summary>
      <param name="type">The typed interface.</param>
      <param name="dictionary">The underlying source of properties.</param>
      <param name="descriptor">The property descriptor.</param>
      <returns>An implementation of the typed interface bound to the dictionary.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter``1(System.Collections.Specialized.NameValueCollection)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Collections.Specialized.NameValueCollection" />.
            </summary>
      <typeparam name="T">The typed interface.</typeparam>
      <param name="nameValues">The underlying source of properties.</param>
      <returns>An implementation of the typed interface bound to the namedValues.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter(System.Type,System.Collections.Specialized.NameValueCollection)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Collections.Specialized.NameValueCollection" />.
            </summary>
      <param name="type">The typed interface.</param>
      <param name="nameValues">The underlying source of properties.</param>
      <returns>An implementation of the typed interface bound to the namedValues.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter``1(System.Xml.XmlNode)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Xml.XmlNode" />.
            </summary>
      <typeparam name="T">The typed interface.</typeparam>
      <param name="xmlNode">The underlying source of properties.</param>
      <returns>An implementation of the typed interface bound to the <see cref="T:System.Xml.XmlNode" />.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter(System.Type,System.Xml.XmlNode)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Xml.XmlNode" />.
            </summary>
      <param name="type">The typed interface.</param>
      <param name="xmlNode">The underlying source of properties.</param>
      <returns>An implementation of the typed interface bound to the <see cref="T:System.Xml.XmlNode" />.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapterMeta(System.Type)">
      <summary>
            Gets the <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> associated with the type.
            </summary>
      <param name="type">The typed interface.</param>
      <returns>The adapter meta-data.</returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapterMeta(System.Type,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Gets the <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> associated with the type.
            </summary>
      <param name="type">The typed interface.</param>
      <param name="descriptor">The property descriptor.</param>
      <returns>The adapter meta-data.</returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapterMeta(System.Type,Castle.Components.DictionaryAdapter.DictionaryAdapterMeta)">
      <summary>
            Gets the <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> associated with the type.
            </summary>
      <param name="type">The typed interface.</param>
      <param name="other">Another <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> from which to copy behaviors.</param>
      <returns>The adapter meta-data.</returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory">
      <summary>
            Uses Reflection.Emit to expose the properties of a dictionary
            through a dynamic implementation of a typed interface.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter``1(System.Collections.IDictionary)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter(System.Type,System.Collections.IDictionary)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter(System.Type,System.Collections.IDictionary,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter``2(System.Collections.Generic.IDictionary{System.String,``1})">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter``1(System.Type,System.Collections.Generic.IDictionary{System.String,``0})">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter``1(System.Collections.Specialized.NameValueCollection)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter(System.Type,System.Collections.Specialized.NameValueCollection)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter``1(System.Xml.XmlNode)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter(System.Type,System.Xml.XmlNode)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapterMeta(System.Type)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapterMeta(System.Type,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapterMeta(System.Type,Castle.Components.DictionaryAdapter.DictionaryAdapterMeta)">
      <inheritdoc />
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryValidator">
      <summary>
            Contract for dictionary validation.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryValidator.IsValid(Castle.Components.DictionaryAdapter.IDictionaryAdapter)">
      <summary>
            Determines if <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter" /> is valid.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <returns>true if valid.</returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryValidator.Validate(Castle.Components.DictionaryAdapter.IDictionaryAdapter)">
      <summary>
            Validates the <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter" />.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <returns>The error summary information.</returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryValidator.Validate(Castle.Components.DictionaryAdapter.IDictionaryAdapter,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Validates the <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter" /> for a property.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="property">The property to validate.</param>
      <returns>The property summary information.</returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryValidator.Invalidate(Castle.Components.DictionaryAdapter.IDictionaryAdapter)">
      <summary>
            Invalidates any results cached by the validator.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.NameValueCollectionAdapter">
      <summary>
      </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.NameValueCollectionAdapter.#ctor(System.Collections.Specialized.NameValueCollection)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.NameValueCollectionAdapter" /> class.
            </summary>
      <param name="nameValues">The name values.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.NameValueCollectionAdapter.Contains(System.Object)">
      <summary>
            Determines whether the <see cref="T:System.Collections.IDictionary"></see> object contains an element with the specified key.
            </summary>
      <param name="key">The key to locate in the <see cref="T:System.Collections.IDictionary"></see> object.</param>
      <returns>
            true if the <see cref="T:System.Collections.IDictionary"></see> contains an element with the key; otherwise, false.
            </returns>
      <exception cref="T:System.ArgumentNullException">key is null. </exception>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.NameValueCollectionAdapter.Adapt(System.Collections.Specialized.NameValueCollection)">
      <summary>
            Adapts the specified name values.
            </summary>
      <param name="nameValues">The name values.</param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.NameValueCollectionAdapter.IsReadOnly">
      <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary"></see> object is read-only.
            </summary>
      <value>
      </value>
      <returns>true if the <see cref="T:System.Collections.IDictionary"></see> object is read-only; otherwise, false.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.NameValueCollectionAdapter.Item(System.Object)">
      <summary>
            Gets or sets the <see cref="T:System.Object" /> with the specified key.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.PropertyDescriptor">
      <summary>
            Describes a dictionary property.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.#ctor">
      <summary>
            Initializes an empty <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /> class.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.#ctor(System.Reflection.PropertyInfo,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /> class.
            </summary>
      <param name="property">The property.</param>
      <param name="annotations">The annotations.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.#ctor(System.Object[])">
      <summary>
            Initializes a new instance <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /> class.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.#ctor(Castle.Components.DictionaryAdapter.PropertyDescriptor,System.Boolean)">
      <summary>
             Copies an existinginstance of the <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /> class.
            </summary>
      <param name="source">
      </param>
      <param name="copyBehaviors">
      </param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.GetKey(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Gets the key.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="descriptor">The descriptor.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.GetPropertyValue(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,System.Object,Castle.Components.DictionaryAdapter.PropertyDescriptor,System.Boolean)">
      <summary>
            Gets the property value.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="storedValue">The stored value.</param>
      <param name="descriptor">The descriptor.</param>
      <param name="ifExists">true if return only existing.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.SetPropertyValue(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,System.Object@,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Sets the property value.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="value">The value.</param>
      <param name="descriptor">The descriptor.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.AddBehavior(Castle.Components.DictionaryAdapter.IDictionaryBehavior)">
      <summary>
            Adds a single behavior.
            </summary>
      <param name="behavior">The behavior.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.AddBehaviors(Castle.Components.DictionaryAdapter.IDictionaryBehavior[])">
      <summary>
            Adds the behaviors.
            </summary>
      <param name="behaviors">The behaviors.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.AddBehaviors(System.Collections.Generic.IEnumerable{Castle.Components.DictionaryAdapter.IDictionaryBehavior})">
      <summary>
            Adds the behaviors.
            </summary>
      <param name="behaviors">The behaviors.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.CopyBehaviors(Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Copies the behaviors to the other <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /></summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.Copy">
      <summary>
            Copies the <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /></summary>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.ExecutionOrder">
      <summary>
      </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.PropertyName">
      <summary>
            Gets the property name.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.PropertyType">
      <summary>
            Gets the property type.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Property">
      <summary>
            Gets the property.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.IsDynamicProperty">
      <summary>
            Returns true if the property is dynamic.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.State">
      <summary>
            Gets additional state.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Fetch">
      <summary>
            Determines if property should be fetched.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.IfExists">
      <summary>
            Determines if property must exist first.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.SuppressNotifications">
      <summary>
            Determines if notifications should occur.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Annotations">
      <summary>
            Gets the property behaviors.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.TypeConverter">
      <summary>
            Gets the type converter.
            </summary>
      <value>The type converter.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.ExtendedProperties">
      <summary>
            Gets the extended properties.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Behaviors">
      <summary>
            Gets the setter.
            </summary>
      <value>The setter.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.KeyBuilders">
      <summary>
            Gets the key builders.
            </summary>
      <value>The key builders.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Setters">
      <summary>
            Gets the setter.
            </summary>
      <value>The setter.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Getters">
      <summary>
            Gets the getter.
            </summary>
      <value>The getter.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Initializers">
      <summary>
            Gets the initializers.
            </summary>
      <value>The initializers.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.MetaInitializers">
      <summary>
            Gets the meta-data initializers.
            </summary>
      <value>The meta-data initializers.</value>
    </member>
    <member name="T:Castle.Core.Internal.AttributesUtil">
      <summary>
              Helper class for retrieving attributes.
            </summary>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.GetAttribute``1(System.Reflection.ICustomAttributeProvider)">
      <summary>
              Gets the attribute.
            </summary>
      <param name="member">The member.</param>
      <returns>The member attribute.</returns>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.GetAttributes``1(System.Reflection.ICustomAttributeProvider)">
      <summary>
              Gets the attributes. Does not consider inherited attributes!
            </summary>
      <param name="member">The member.</param>
      <returns>The member attributes.</returns>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.GetTypeAttribute``1(System.Type)">
      <summary>
              Gets the type attribute.
            </summary>
      <param name="type">The type.</param>
      <returns>The type attribute.</returns>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.GetTypeAttributes``1(System.Type)">
      <summary>
              Gets the type attributes.
            </summary>
      <param name="type">The type.</param>
      <returns>The type attributes.</returns>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.GetTypeConverter(System.Reflection.MemberInfo)">
      <summary>
              Gets the type converter.
            </summary>
      <param name="member">The member.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.HasAttribute``1(System.Reflection.ICustomAttributeProvider)">
      <summary>
              Gets the attribute.
            </summary>
      <param name="member">The member.</param>
      <returns>The member attribute.</returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDynamicValue">
      <summary>
            Contract for dynamic value resolution.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDynamicValue`1">
      <summary>
            Contract for typed dynamic value resolution.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Castle.Core.Logging.LoggerLevel">
      <summary>
              Supporting Logger levels.
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Off">
      <summary>
              Logging will be off
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Fatal">
      <summary>
              Fatal logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Error">
      <summary>
              Error logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Warn">
      <summary>
              Warn logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Info">
      <summary>
              Info logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Debug">
      <summary>
              Debug logging level
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.IInvocation">
      <summary>
              Encapsulates an invocation of a proxied method.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IInvocation.GetArgumentValue(System.Int32)">
      <summary>
              Gets the value of the argument at the specified <paramref name="index" />.
            </summary>
      <param name="index">The index.</param>
      <returns>The value of the argument at the specified <paramref name="index" />.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.IInvocation.GetConcreteMethod">
      <summary>
              Returns the concrete instantiation of the <see cref="P:Castle.DynamicProxy.IInvocation.Method" /> on the proxy, with any generic
              parameters bound to real types.
            </summary>
      <returns>
              The concrete instantiation of the <see cref="P:Castle.DynamicProxy.IInvocation.Method" /> on the proxy, or the <see cref="P:Castle.DynamicProxy.IInvocation.Method" /> if
              not a generic method.
            </returns>
      <remarks>
              Can be slower than calling <see cref="P:Castle.DynamicProxy.IInvocation.Method" />.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.IInvocation.GetConcreteMethodInvocationTarget">
      <summary>
              Returns the concrete instantiation of <see cref="P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" />, with any
              generic parameters bound to real types.
              For interface proxies, this will point to the <see cref="T:System.Reflection.MethodInfo" /> on the target class.
            </summary>
      <returns>The concrete instantiation of <see cref="P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" />, or
              <see cref="P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" /> if not a generic method.</returns>
      <remarks>
              In debug builds this can be slower than calling <see cref="P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" />.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.IInvocation.Proceed">
      <summary>
              Proceeds the call to the next interceptor in line, and ultimately to the target method.
            </summary>
      <remarks>
              Since interface proxies without a target don't have the target implementation to proceed to,
              it is important, that the last interceptor does not call this method, otherwise a
              <see cref="T:System.NotImplementedException" /> will be thrown.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.IInvocation.SetArgumentValue(System.Int32,System.Object)">
      <summary>
              Overrides the value of an argument at the given <paramref name="index" /> with the
              new <paramref name="value" /> provided.
            </summary>
      <remarks>
              This method accepts an <see cref="T:System.Object" />, however the value provided must be compatible
              with the type of the argument defined on the method, otherwise an exception will be thrown.
            </remarks>
      <param name="index">The index of the argument to override.</param>
      <param name="value">The new value for the argument.</param>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.Arguments">
      <summary>
              Gets the arguments that the <see cref="P:Castle.DynamicProxy.IInvocation.Method" /> has been invoked with.
            </summary>
      <value>The arguments the method was invoked with.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.GenericArguments">
      <summary>
              Gets the generic arguments of the method.
            </summary>
      <value>The generic arguments, or null if not a generic method.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.InvocationTarget">
      <summary>
              Gets the object on which the invocation is performed. This is different from proxy object
              because most of the time this will be the proxy target object.
            </summary>
      <seealso cref="T:Castle.DynamicProxy.IChangeProxyTarget" />
      <value>The invocation target.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.Method">
      <summary>
              Gets the <see cref="T:System.Reflection.MethodInfo" /> representing the method being invoked on the proxy.
            </summary>
      <value>The <see cref="T:System.Reflection.MethodInfo" /> representing the method being invoked.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget">
      <summary>
              For interface proxies, this will point to the <see cref="T:System.Reflection.MethodInfo" /> on the target class.
            </summary>
      <value>The method invocation target.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.Proxy">
      <summary>
              Gets the proxy object on which the intercepted method is invoked.
            </summary>
      <value>Proxy object on which the intercepted method is invoked.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.ReturnValue">
      <summary>
              Gets or sets the return value of the method.
            </summary>
      <value>The return value of the method.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.TargetType">
      <summary>
              Gets the type of the target object for the intercepted method.
            </summary>
      <value>The type of the target object.</value>
    </member>
    <member name="T:Castle.DynamicProxy.IProxyGenerationHook">
      <summary>
              Used during the target type inspection process. Implementors have a chance to customize the
              proxy generation process.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyGenerationHook.MethodsInspected">
      <summary>
              Invoked by the generation process to notify that the whole process has completed.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyGenerationHook.NonProxyableMemberNotification(System.Type,System.Reflection.MemberInfo)">
      <summary>
              Invoked by the generation process to notify that a member was not marked as virtual.
            </summary>
      <param name="type">The type which declares the non-virtual member.</param>
      <param name="memberInfo">The non-virtual member.</param>
      <remarks>
              This method gives an opportunity to inspect any non-proxyable member of a type that has 
              been requested to be proxied, and if appropriate - throw an exception to notify the caller.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyGenerationHook.ShouldInterceptMethod(System.Type,System.Reflection.MethodInfo)">
      <summary>
              Invoked by the generation process to determine if the specified method should be proxied.
            </summary>
      <param name="type">The type which declares the given method.</param>
      <param name="methodInfo">The method to inspect.</param>
      <returns>True if the given method should be proxied; false otherwise.</returns>
    </member>
    <member name="T:Castle.DynamicProxy.Contributors.ITypeContributor">
      <summary>
              Interface describing elements composing generated type
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Contributors.MembersCollector.AcceptMethod(System.Reflection.MethodInfo,System.Boolean,Castle.DynamicProxy.IProxyGenerationHook)">
      <summary>
              Performs some basic screening and invokes the <see cref="T:Castle.DynamicProxy.IProxyGenerationHook" />
              to select methods.
            </summary>
      <param name="method">
      </param>
      <param name="onlyVirtuals">
      </param>
      <param name="hook">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.DynamicProxy.IAttributeDisassembler">
      <summary>
              Provides functionality for disassembling instances of attributes to CustomAttributeBuilder form, during the process of emiting new types by Dynamic Proxy.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IAttributeDisassembler.Disassemble(System.Attribute)">
      <summary>
              Disassembles given attribute instance back to corresponding CustomAttributeBuilder.
            </summary>
      <param name="attribute">An instance of attribute to disassemble</param>
      <returns>
        <see cref="T:System.Reflection.Emit.CustomAttributeBuilder" /> corresponding 1 to 1 to given attribute instance, or null reference.</returns>
      <remarks>
              Implementers should return <see cref="T:System.Reflection.Emit.CustomAttributeBuilder" /> that corresponds to given attribute instance 1 to 1,
              that is after calling specified constructor with specified arguments, and setting specified properties and fields with values specified
              we should be able to get an attribute instance identical to the one passed in <paramref name="attribute" />. Implementer can return null
              if it wishes to opt out of replicating the attribute. Notice however, that for some cases, like attributes passed explicitly by the user
              it is illegal to return null, and doing so will result in exception.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.HandleError(System.Type,System.Exception)">
      <summary>
              Handles error during disassembly process
            </summary>
      <param name="attributeType">Type of the attribute being disassembled</param>
      <param name="exception">Exception thrown during the process</param>
      <returns>usually null, or (re)throws the exception</returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.InitializeConstructorArgs(System.Type,System.Attribute,System.Reflection.ParameterInfo[])">
      <summary>
              Here we try to match a constructor argument to its value.
              Since we can't get the values from the assembly, we use some heuristics to get it.
              a/ we first try to match all the properties on the attributes by name (case insensitive) to the argument
              b/ if we fail we try to match them by property type, with some smarts about convertions (i,e: can use Guid for string).
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.ReplaceIfBetterMatch(System.Reflection.ParameterInfo,System.Reflection.PropertyInfo,System.Reflection.PropertyInfo)">
      <summary>
              We have the following rules here.
              Try to find a matching type, failing that, if the parameter is string, get the first property (under the assumption that
              we can convert it.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.ConvertValue(System.Object,System.Type)">
      <summary>
              Attributes can only accept simple types, so we return null for null,
              if the value is passed as string we call to string (should help with converting), 
              otherwise, we use the value as is (enums, integer, etc).
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.TypeUtil.GetAllInterfaces(System.Type[])">
      <summary>
              Returns list of all unique interfaces implemented given types, including their base interfaces.
            </summary>
      <param name="types">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.DynamicProxy.Serialization.CacheMappingsAttribute">
      <summary>
              Applied to the assemblies saved by <see cref="T:Castle.DynamicProxy.ModuleScope" /> in order to persist the cache data included in the persisted assembly.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.BaseProxyGenerator">
      <summary>
              Base class that exposes the common functionalities
              to proxy generation.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.AddMappingNoCheck(System.Type,Castle.DynamicProxy.Contributors.ITypeContributor,System.Collections.Generic.IDictionary{System.Type,Castle.DynamicProxy.Contributors.ITypeContributor})">
      <summary>
              It is safe to add mapping (no mapping for the interface exists)
            </summary>
      <param name="implementer">
      </param>
      <param name="interface">
      </param>
      <param name="mapping">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.GenerateParameterlessConstructor(Castle.DynamicProxy.Generators.Emitters.ClassEmitter,System.Type,Castle.DynamicProxy.Generators.Emitters.SimpleAST.FieldReference)">
      <summary>
              Generates a parameters constructor that initializes the proxy
              state with <see cref="T:Castle.DynamicProxy.StandardInterceptor" /> just to make it non-null.
              <para>
                This constructor is important to allow proxies to be XML serializable
              </para></summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.InvocationTypeGenerator.GetBaseCtorArguments(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,System.Reflection.ConstructorInfo@)">
      <summary>
              Generates the constructor for the class that extends
              <see cref="T:Castle.DynamicProxy.AbstractInvocation" /></summary>
      <param name="targetFieldType">
      </param>
      <param name="proxyGenerationOptions">
      </param>
      <param name="baseConstructor">
      </param>
    </member>
    <member name="T:Castle.DynamicProxy.IProxyBuilder">
      <summary>
              Abstracts the implementation of proxy type construction.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateClassProxyType(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates a proxy type for given <paramref name="classToProxy" />, implementing <paramref name="additionalInterfacesToProxy" />, using <paramref name="options" /> provided.
            </summary>
      <param name="classToProxy">The class type to proxy.</param>
      <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
      <param name="options">The proxy generation options.</param>
      <returns>The generated proxy type.</returns>
      <remarks>
              Implementers should return a proxy type for the specified class and interfaces.
              Additional interfaces should be only 'mark' interfaces, that is, they should work like interface proxy without target. (See <see cref="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)" /> method.)
            </remarks>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
      <seealso cref="T:Castle.DynamicProxy.Generators.ClassProxyGenerator" />
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithTarget(System.Type,System.Type[],System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates a proxy type that proxies calls to <paramref name="interfaceToProxy" /> members on <paramref name="targetType" />, implementing <paramref name="additionalInterfacesToProxy" />, using <paramref name="options" /> provided.
            </summary>
      <param name="interfaceToProxy">The interface type to proxy.</param>
      <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
      <param name="targetType">Type implementing <paramref name="interfaceToProxy" /> on which calls to the interface members should be intercepted.</param>
      <param name="options">The proxy generation options.</param>
      <returns>The generated proxy type.</returns>
      <remarks>
              Implementers should return a proxy type for the specified interface that 'proceeds' executions to the specified target.
              Additional interfaces should be only 'mark' interfaces, that is, they should work like interface proxy without target. (See <see cref="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)" /> method.)
            </remarks>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
      <seealso cref="T:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetGenerator" />
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithTargetInterface(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates a proxy type for given <paramref name="interfaceToProxy" /> and <parmaref name="additionalInterfacesToProxy" /> that delegates all calls to the provided interceptors and allows interceptors to switch the actual target of invocation.
            </summary>
      <param name="interfaceToProxy">The interface type to proxy.</param>
      <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
      <param name="options">The proxy generation options.</param>
      <returns>The generated proxy type.</returns>
      <remarks>
              Implementers should return a proxy type for the specified interface(s) that delegate all executions to the specified interceptors
              and uses an instance of the interface as their targets (i.e. <see cref="P:Castle.DynamicProxy.IInvocation.InvocationTarget" />), rather than a class. All <see cref="T:Castle.DynamicProxy.IInvocation" /> classes should then implement <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface,
              to allow interceptors to switch invocation target with instance of another type implementing called interface.
            </remarks>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
      <seealso cref="T:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetInterfaceGenerator" />
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates a proxy type for given <paramref name="interfaceToProxy" /> that delegates all calls to the provided interceptors.
            </summary>
      <param name="interfaceToProxy">The interface type to proxy.</param>
      <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
      <param name="options">The proxy generation options.</param>
      <returns>The generated proxy type.</returns>
      <remarks>
              Implementers should return a proxy type for the specified interface and additional interfaces that delegate all executions to the specified interceptors.
            </remarks>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
      <seealso cref="T:Castle.DynamicProxy.Generators.InterfaceProxyWithoutTargetGenerator" />
    </member>
    <member name="P:Castle.DynamicProxy.IProxyBuilder.Logger">
      <summary>
              Gets or sets the <see cref="T:Castle.Core.Logging.ILogger" /> that this <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> logs to.
            </summary>
    </member>
    <member name="P:Castle.DynamicProxy.IProxyBuilder.ModuleScope">
      <summary>
              Gets the <see cref="P:Castle.DynamicProxy.IProxyBuilder.ModuleScope" /> associated with this builder.
            </summary>
      <value>The module scope associated with this builder.</value>
    </member>
    <member name="T:Castle.DynamicProxy.DefaultProxyBuilder">
      <summary>
              Default implementation of <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> interface producing in-memory proxy assemblies.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.DefaultProxyBuilder.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.DefaultProxyBuilder" /> class with new <see cref="P:Castle.DynamicProxy.DefaultProxyBuilder.ModuleScope" />.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.DefaultProxyBuilder.#ctor(Castle.DynamicProxy.ModuleScope)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.DefaultProxyBuilder" /> class.
            </summary>
      <param name="scope">The module scope for generated proxy types.</param>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.AttributeUtil.AddDisassembler``1(Castle.DynamicProxy.IAttributeDisassembler)">
      <summary>
              Registers custom disassembler to handle disassembly of specified type of attributes.
            </summary>
      <typeparam name="TAttribute">Type of attributes to handle</typeparam>
      <param name="disassembler">Disassembler converting existing instances of Attributes to CustomAttributeBuilders</param>
      <remarks>
              When disassembling an attribute Dynamic Proxy will first check if an custom disassembler has been registered to handle attributes of that type, 
              and if none is found, it'll use the <see cref="P:Castle.DynamicProxy.Internal.AttributeUtil.FallbackDisassembler" />.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.AttributeUtil.ShouldSkipAttributeReplication(System.Type)">
      <summary>
              Attributes should be replicated if they are non-inheritable,
              but there are some special cases where the attributes means
              something to the CLR, where they should be skipped.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.CacheKey.#ctor(System.Reflection.MemberInfo,System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.Generators.CacheKey" /> class.
            </summary>
      <param name="target">Target element. This is either target type or target method for invocation types.</param>
      <param name="type">The type of the proxy. This is base type for invocation types.</param>
      <param name="interfaces">The interfaces.</param>
      <param name="options">The options.</param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.CacheKey.#ctor(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.Generators.CacheKey" /> class.
            </summary>
      <param name="target">Type of the target.</param>
      <param name="interfaces">The interfaces.</param>
      <param name="options">The options.</param>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.LdcOpCodesDictionary">
      <summary>
              s
              Provides appropriate Ldc.X opcode for the type of primitive value to be loaded.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.LdindOpCodesDictionary">
      <summary>
              Provides appropriate Ldind.X opcode for 
              the type of primitive value to be loaded indirectly.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadIndirectOpCodeForType(System.Reflection.Emit.ILGenerator,System.Type)">
      <summary>
              Emits a load indirect opcode of the appropriate type for a value or object reference.
              Pops a pointer off the evaluation stack, dereferences it and loads
              a value of the specified type.
            </summary>
      <param name="gen">
      </param>
      <param name="type">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadOpCodeForConstantValue(System.Reflection.Emit.ILGenerator,System.Object)">
      <summary>
              Emits a load opcode of the appropriate kind for a constant string or
              primitive value.
            </summary>
      <param name="gen">
      </param>
      <param name="value">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadOpCodeForDefaultValueOfType(System.Reflection.Emit.ILGenerator,System.Type)">
      <summary>
              Emits a load opcode of the appropriate kind for the constant default value of a
              type, such as 0 for value types and null for reference types.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitStoreIndirectOpCodeForType(System.Reflection.Emit.ILGenerator,System.Type)">
      <summary>
              Emits a store indirectopcode of the appropriate type for a value or object reference.
              Pops a value of the specified type and a pointer off the evaluation stack, and
              stores the value.
            </summary>
      <param name="gen">
      </param>
      <param name="type">
      </param>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.PropertiesCollection">
      <summary>
              Summary description for PropertiesCollection.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.IndirectReference">
      <summary>
              Wraps a reference that is passed 
              ByRef and provides indirect load/store support.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.NewArrayExpression">
      <summary>
              Summary description for NewArrayExpression.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.ReferencesToObjectArrayExpression">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.StindOpCodesDictionary">
      <summary>
              Provides appropriate Stind.X opcode 
              for the type of primitive value to be stored indirectly.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.MetaEvent.#ctor(System.String,System.Type,System.Type,Castle.DynamicProxy.Generators.MetaMethod,Castle.DynamicProxy.Generators.MetaMethod,System.Reflection.EventAttributes)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.Generators.MetaEvent" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="declaringType">Type declaring the original event being overriten, or null.</param>
      <param name="eventDelegateType">
      </param>
      <param name="adder">The add method.</param>
      <param name="remover">The remove method.</param>
      <param name="attributes">The attributes.</param>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.INamingScope">
      <summary>
              Represents the scope of uniquenes of names for types and their members
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.INamingScope.GetUniqueName(System.String)">
      <summary>
              Gets a unique name based on <paramref name="suggestedName" /></summary>
      <param name="suggestedName">Name suggested by the caller</param>
      <returns>Unique name based on <paramref name="suggestedName" />.</returns>
      <remarks>
              Implementers should provide name as closely resembling <paramref name="suggestedName" /> as possible.
              Generally if no collision occurs it is suggested to return suggested name, otherwise append sequential suffix.
              Implementers must return deterministic names, that is when <see cref="M:Castle.DynamicProxy.Generators.INamingScope.GetUniqueName(System.String)" /> is called twice 
              with the same suggested name, the same returned name should be provided each time. Non-deterministic return
              values, like appending random suffices will break serialization of proxies.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.INamingScope.SafeSubScope">
      <summary>
              Returns new, disposable naming scope. It is responsibilty of the caller to make sure that no naming collision
              with enclosing scope, or other subscopes is possible.
            </summary>
      <returns>New naming scope.</returns>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.MethodFinder">
      <summary>
              Returns the methods implemented by a type. Use this instead of Type.GetMethods() to work around a CLR issue
              where duplicate MethodInfos are returned by Type.GetMethods() after a token of a generic type's method was loaded.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.InternalsUtil.IsInternal(System.Reflection.MethodBase)">
      <summary>
              Determines whether the specified method is internal.
            </summary>
      <param name="method">The method.</param>
      <returns>
        <c>true</c> if the specified method is internal; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.InternalsUtil.IsInternalToDynamicProxy(System.Reflection.Assembly)">
      <summary>
              Determines whether this assembly has internals visible to dynamic proxy.
            </summary>
      <param name="asm">The assembly to inspect.</param>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.InternalsUtil.IsAccessible(System.Reflection.MethodBase)">
      <summary>
              Checks if the method is public or protected.
            </summary>
      <param name="method">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.MixinData.#ctor(System.Collections.Generic.IEnumerable{System.Object})">
      <summary>
              Because we need to cache the types based on the mixed in mixins, we do the following here:
              - Get all the mixin interfaces
              - Sort them by full name
              - Return them by position
            
            The idea is to have reproducible behavior for the case that mixins are registered in different orders.
            This method is here because it is required 
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.ModuleScope">
      <summary>
              Summary description for ModuleScope.
            </summary>
    </member>
    <member name="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME">
      <summary>
              The default file name used when the assembly is saved using <see cref="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME" />.
            </summary>
    </member>
    <member name="F:Castle.DynamicProxy.ModuleScope.DEFAULT_ASSEMBLY_NAME">
      <summary>
              The default assembly (simple) name used for the assemblies generated by a <see cref="T:Castle.DynamicProxy.ModuleScope" /> instance.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class; assemblies created by this instance will not be saved.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved.
            </summary>
      <param name="savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean,System.Boolean)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved.
            </summary>
      <param name="savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
      <param name="disableSignedModule">If set to <c>true</c> disables ability to generate signed module. This should be used in cases where ran under constrained permissions.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean,System.Boolean,System.String,System.String,System.String,System.String)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved and what simple names are to be assigned to them.
            </summary>
      <param name="savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
      <param name="disableSignedModule">If set to <c>true</c> disables ability to generate signed module. This should be used in cases where ran under constrained permissions.</param>
      <param name="strongAssemblyName">The simple name of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="strongModulePath">The path and file name of the manifest module of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="weakAssemblyName">The simple name of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="weakModulePath">The path and file name of the manifest module of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean,System.Boolean,Castle.DynamicProxy.Generators.INamingScope,System.String,System.String,System.String,System.String)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved and what simple names are to be assigned to them.
            </summary>
      <param name="savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
      <param name="disableSignedModule">If set to <c>true</c> disables ability to generate signed module. This should be used in cases where ran under constrained permissions.</param>
      <param name="namingScope">Naming scope used to provide unique names to generated types and their members (usually via sub-scopes).</param>
      <param name="strongAssemblyName">The simple name of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="strongModulePath">The path and file name of the manifest module of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="weakAssemblyName">The simple name of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="weakModulePath">The path and file name of the manifest module of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.GetFromCache(Castle.DynamicProxy.Generators.CacheKey)">
      <summary>
              Returns a type from this scope's type cache, or null if the key cannot be found.
            </summary>
      <param name="key">The key to be looked up in the cache.</param>
      <returns>The type from this scope's type cache matching the key, or null if the key cannot be found</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.RegisterInCache(Castle.DynamicProxy.Generators.CacheKey,System.Type)">
      <summary>
              Registers a type in this scope's type cache.
            </summary>
      <param name="key">The key to be associated with the type.</param>
      <param name="type">The type to be stored in the cache.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.GetKeyPair">
      <summary>
              Gets the key pair used to sign the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModule(System.Boolean)">
      <summary>
              Gets the specified module generated by this scope, creating a new one if none has yet been generated.
            </summary>
      <param name="isStrongNamed">If set to true, a strong-named module is returned; otherwise, a weak-named module is returned.</param>
      <returns>A strong-named or weak-named module generated by this scope, as specified by the <paramref name="isStrongNamed" /> parameter.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModuleWithStrongName">
      <summary>
              Gets the strong-named module generated by this scope, creating a new one if none has yet been generated.
            </summary>
      <returns>A strong-named module generated by this scope.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModuleWithWeakName">
      <summary>
              Gets the weak-named module generated by this scope, creating a new one if none has yet been generated.
            </summary>
      <returns>A weak-named module generated by this scope.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.SaveAssembly">
      <summary>
              Saves the generated assembly with the name and directory information given when this <see cref="T:Castle.DynamicProxy.ModuleScope" /> instance was created (or with
              the <see cref="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME" /> and current directory if none was given).
            </summary>
      <remarks>
        <para>
                This method stores the generated assembly in the directory passed as part of the module information specified when this instance was
                constructed (if any, else the current directory is used). If both a strong-named and a weak-named assembly
                have been generated, it will throw an exception; in this case, use the <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly(System.Boolean)" /> overload.
              </para>
        <para>
                If this <see cref="T:Castle.DynamicProxy.ModuleScope" /> was created without indicating that the assembly should be saved, this method does nothing.
              </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">Both a strong-named and a weak-named assembly have been generated.</exception>
      <returns>The path of the generated assembly file, or null if no file has been generated.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.SaveAssembly(System.Boolean)">
      <summary>
              Saves the specified generated assembly with the name and directory information given when this <see cref="T:Castle.DynamicProxy.ModuleScope" /> instance was created
              (or with the <see cref="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME" /> and current directory if none was given).
            </summary>
      <param name="strongNamed">True if the generated assembly with a strong name should be saved (see <see cref="P:Castle.DynamicProxy.ModuleScope.StrongNamedModule" />);
              false if the generated assembly without a strong name should be saved (see <see cref="P:Castle.DynamicProxy.ModuleScope.WeakNamedModule" />.</param>
      <remarks>
        <para>
                This method stores the specified generated assembly in the directory passed as part of the module information specified when this instance was
                constructed (if any, else the current directory is used).
              </para>
        <para>
                If this <see cref="T:Castle.DynamicProxy.ModuleScope" /> was created without indicating that the assembly should be saved, this method does nothing.
              </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">No assembly has been generated that matches the <paramref name="strongNamed" /> parameter.
            </exception>
      <returns>The path of the generated assembly file, or null if no file has been generated.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.LoadAssemblyIntoCache(System.Reflection.Assembly)">
      <summary>
              Loads the generated types from the given assembly into this <see cref="T:Castle.DynamicProxy.ModuleScope" />'s cache.
            </summary>
      <param name="assembly">The assembly to load types from. This assembly must have been saved via <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly(System.Boolean)" /> or
              <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly" />, or it must have the <see cref="T:Castle.DynamicProxy.Serialization.CacheMappingsAttribute" /> manually applied.</param>
      <remarks>
              This method can be used to load previously generated and persisted proxy types from disk into this scope's type cache, eg. in order
              to avoid the performance hit associated with proxy generation.
            </remarks>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.Lock">
      <summary>
              Users of this <see cref="T:Castle.DynamicProxy.ModuleScope" /> should use this lock when accessing the cache.
            </summary>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModule">
      <summary>
              Gets the strong-named module generated by this scope, or <see langword="null" /> if none has yet been generated.
            </summary>
      <value>The strong-named module generated by this scope, or <see langword="null" /> if none has yet been generated.</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModuleName">
      <summary>
              Gets the file name of the strongly named module generated by this scope.
            </summary>
      <value>The file name of the strongly named module generated by this scope.</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModuleDirectory">
      <summary>
              Gets the directory where the strongly named module generated by this scope will be saved, or <see langword="null" /> if the current directory
              is used.
            </summary>
      <value>The directory where the strongly named module generated by this scope will be saved when <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly" /> is called
              (if this scope was created to save modules).</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModule">
      <summary>
              Gets the weak-named module generated by this scope, or <see langword="null" /> if none has yet been generated.
            </summary>
      <value>The weak-named module generated by this scope, or <see langword="null" /> if none has yet been generated.</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModuleName">
      <summary>
              Gets the file name of the weakly named module generated by this scope.
            </summary>
      <value>The file name of the weakly named module generated by this scope.</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModuleDirectory">
      <summary>
              Gets the directory where the weakly named module generated by this scope will be saved, or <see langword="null" /> if the current directory
              is used.
            </summary>
      <value>The directory where the weakly named module generated by this scope will be saved when <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly" /> is called
              (if this scope was created to save modules).</value>
    </member>
    <member name="T:Castle.DynamicProxy.PersistentProxyBuilder">
      <summary>
              ProxyBuilder that persists the generated type.
            </summary>
      <remarks>
              The saved assembly contains just the last generated type.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.PersistentProxyBuilder.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.PersistentProxyBuilder" /> class.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.PersistentProxyBuilder.SaveAssembly">
      <summary>
              Saves the generated assembly to a physical file. Note that this renders the <see cref="T:Castle.DynamicProxy.PersistentProxyBuilder" /> unusable.
            </summary>
      <returns>The path of the generated assembly file, or null if no assembly has been generated.</returns>
      <remarks>
              This method does not support saving multiple files. If both a signed and an unsigned module have been generated, use the 
              respective methods of the <see cref="T:Castle.DynamicProxy.ModuleScope" />.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerationOptions.#ctor(Castle.DynamicProxy.IProxyGenerationHook)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerationOptions" /> class.
            </summary>
      <param name="hook">The hook.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerationOptions.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerationOptions" /> class.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.ProxyGenerator">
      <summary>
              Provides proxy objects for classes and interfaces.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor(Castle.DynamicProxy.IProxyBuilder)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> class.
            </summary>
      <param name="builder">Proxy types builder.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> class.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor(System.Boolean)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> class.
            </summary>
      <param name="disableSignedModule">If <c>true</c> forces all types to be generated into an unsigned module.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget``1(``0,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TInterface">Type of the interface implemented by <paramref name="target" /> which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>Object proxying calls to members of <typeparamref name="TInterface" /> on <paramref name="target" /> object.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" />is not an interface type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TInterface">Type of the interface implemented by <paramref name="target" /> which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" />is not an interface type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types  on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <typeparam name="TInterface">Type of the interface implemented by <paramref name="target" /> which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> type on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" /> is not an interface type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <typeparam name="TInterface">Type of the interface implemented by <paramref name="target" /> which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> type on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" /> is not an interface type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget``1(Castle.DynamicProxy.IInterceptor)">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on target object generated at runtime with given <paramref name="interceptor" />.
            </summary>
      <typeparam name="TInterface">Type of the interface which will be proxied.</typeparam>
      <param name="interceptor">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptor" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              As a result of that also at least one <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementation must be provided.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget``1(Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TInterface">Type of the interface which will be proxied.</typeparam>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              As a result of that also at least one <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementation must be provided.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget``1(Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TInterface">Type of the interface which will be proxied.</typeparam>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              As a result of that also at least one <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementation must be provided.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,Castle.DynamicProxy.IInterceptor)">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptor" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="interceptor">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptor" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" />  is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of <paramref name="additionalInterfacesToProxy" /> to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget``1(``0,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name="TClass" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TClass">Type of class which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <typeparamref name="TClass" /> proxying calls to virtual members of <typeparamref name="TClass" /> type.
            </returns>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TClass" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name="TClass" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name="TClass" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name="TClass" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TClass">Type of class which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <typeparamref name="TClass" /> proxying calls to virtual members of <typeparamref name="TClass" /> type.
            </returns>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TClass" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name="TClass" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name="TClass" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no parameterless constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy``1(Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name="TClass" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TClass">Type of class which will be proxied.</typeparam>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <typeparamref name="TClass" /> proxying calls to virtual members of <typeparamref name="TClass" /> type.
            </returns>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TClass" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name="TClass" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name="TClass" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy``1(Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name="TClass" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TClass">Type of class which will be proxied.</typeparam>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <typeparamref name="TClass" /> proxying calls to virtual members of <typeparamref name="TClass" /> type.
            </returns>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TClass" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name="TClass" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name="TClass" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no parameterless constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyType(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates the proxy type for class proxy with given <paramref name="classToProxy" /> class, implementing given <paramref name="additionalInterfacesToProxy" /> and using provided <paramref name="options" />.
            </summary>
      <param name="classToProxy">The base class for proxy type.</param>
      <param name="additionalInterfacesToProxy">The interfaces that proxy type should implement.</param>
      <param name="options">The options for proxy generation process.</param>
      <returns>
        <see cref="T:System.Type" /> of proxy.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithTarget(System.Type,System.Type[],System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates the proxy type for interface proxy with target for given <paramref name="interfaceToProxy" /> interface, implementing given <paramref name="additionalInterfacesToProxy" /> on given <paramref name="targetType" /> and using provided <paramref name="options" />.
            </summary>
      <param name="interfaceToProxy">The interface proxy type should implement.</param>
      <param name="additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
      <param name="targetType">Actual type that the proxy type will encompass.</param>
      <param name="options">The options for proxy generation process.</param>
      <returns>
        <see cref="T:System.Type" /> of proxy.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithTargetInterface(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates the proxy type for interface proxy with target interface for given <paramref name="interfaceToProxy" /> interface, implementing given <paramref name="additionalInterfacesToProxy" /> on given <paramref name="interfaceToProxy" /> and using provided <paramref name="options" />.
            </summary>
      <param name="interfaceToProxy">The interface proxy type should implement.</param>
      <param name="additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
      <param name="options">The options for proxy generation process.</param>
      <returns>
        <see cref="T:System.Type" /> of proxy.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates the proxy type for interface proxy without target for given <paramref name="interfaceToProxy" /> interface, implementing given <paramref name="additionalInterfacesToProxy" /> and using provided <paramref name="options" />.
            </summary>
      <param name="interfaceToProxy">The interface proxy type should implement.</param>
      <param name="additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
      <param name="options">The options for proxy generation process.</param>
      <returns>
        <see cref="T:System.Type" /> of proxy.</returns>
    </member>
    <member name="P:Castle.DynamicProxy.ProxyGenerator.Logger">
      <summary>
              Gets or sets the <see cref="T:Castle.Core.Logging.ILogger" /> that this <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> log to.
            </summary>
    </member>
    <member name="P:Castle.DynamicProxy.ProxyGenerator.ProxyBuilder">
      <summary>
              Gets the proxy builder instance used to generate proxy types.
            </summary>
      <value>The proxy builder.</value>
    </member>
    <member name="M:Castle.DynamicProxy.Serialization.RemotableInvocation.Proceed">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.DynamicProxy.Serialization.RemotableInvocation.Method">
      <summary>
      </summary>
    </member>
    <member name="P:Castle.DynamicProxy.Serialization.RemotableInvocation.MethodInvocationTarget">
      <summary>
              For interface proxies, this will point to the
              <see cref="T:System.Reflection.MethodInfo" /> on the target class
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Serialization.ProxyObjectReference">
      <summary>
              Handles the deserialization of proxies.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.ResetScope">
      <summary>
              Resets the <see cref="P:Castle.DynamicProxy.Serialization.ProxyObjectReference.ModuleScope" /> used for deserialization to a new scope.
            </summary>
      <remarks>
              This is useful for test cases.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.SetScope(Castle.DynamicProxy.ModuleScope)">
      <summary>
              Resets the <see cref="P:Castle.DynamicProxy.Serialization.ProxyObjectReference.ModuleScope" /> used for deserialization to a given <paramref name="scope" />.
            </summary>
      <param name="scope"> The scope to be used for deserialization. </param>
      <remarks>
              By default, the deserialization process uses a different scope than the rest of the application, which can lead to multiple proxies
              being generated for the same type. By explicitly setting the deserialization scope to the application's scope, this can be avoided.
            </remarks>
    </member>
    <member name="P:Castle.DynamicProxy.Serialization.ProxyObjectReference.ModuleScope">
      <summary>
              Gets the <see cref="P:Castle.DynamicProxy.Serialization.ProxyObjectReference.ModuleScope" /> used for deserialization.
            </summary>
      <value> As <see cref="T:Castle.DynamicProxy.Serialization.ProxyObjectReference" /> has no way of automatically determining the scope used by the application (and the application might use more than one scope at the same time), <see cref="T:Castle.DynamicProxy.Serialization.ProxyObjectReference" /> uses a dedicated scope instance for deserializing proxy types. This instance can be reset and set to a specific value via <see cref="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.ResetScope" /> and <see cref="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.SetScope(Castle.DynamicProxy.ModuleScope)" /> . </value>
    </member>
    <member name="T:Castle.DynamicProxy.Tokens.InvocationMethods">
      <summary>
              Holds <see cref="T:System.Reflection.MethodInfo" /> objects representing methods of <see cref="T:Castle.DynamicProxy.AbstractInvocation" /> class.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Tokens.SerializationInfoMethods">
      <summary>
              Holds <see cref="T:System.Reflection.MethodInfo" /> objects representing methods of <see cref="T:System.Runtime.Serialization.SerializationInfo" /> class.
            </summary>
    </member>
    <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.AddValue_Bool">
      <summary>
        <see cref="M:System.Runtime.Serialization.SerializationInfo.AddValue(System.String,System.Boolean)" />
      </summary>
    </member>
    <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.AddValue_Int32">
      <summary>
        <see cref="M:System.Runtime.Serialization.SerializationInfo.AddValue(System.String,System.Int32)" />
      </summary>
    </member>
    <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.AddValue_Object">
      <summary>
        <see cref="M:System.Runtime.Serialization.SerializationInfo.AddValue(System.String,System.Object)" />
      </summary>
    </member>
    <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.GetValue">
      <summary>
        <see cref="M:System.Runtime.Serialization.SerializationInfo.GetValue(System.String,System.Type)" />
      </summary>
    </member>
    <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.SetType">
      <summary>
        <see cref="M:System.Runtime.Serialization.SerializationInfo.SetType(System.Type)" />
      </summary>
    </member>
    <member name="T:Castle.DynamicProxy.IInterceptorSelector">
      <summary>
              Provides an extension point that allows proxies to choose specific interceptors on
              a per method basis.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IInterceptorSelector.SelectInterceptors(System.Type,System.Reflection.MethodInfo,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Selects the interceptors that should intercept calls to the given <paramref name="method" />.
            </summary>
      <param name="type">The type declaring the method to intercept.</param>
      <param name="method">The method that will be intercepted.</param>
      <param name="interceptors">All interceptors registered with the proxy.</param>
      <returns>An array of interceptors to invoke upon calling the <paramref name="method" />.</returns>
      <remarks>
              This method is called only once per proxy instance, upon the first call to the
              <paramref name="method" />. Either an empty array or null are valid return values to indicate
              that no interceptor should intercept calls to the method. Although it is not advised, it is
              legal to return other <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations than these provided in
              <paramref name="interceptors" />.
            </remarks>
    </member>
    <member name="M:Castle.Core.Internal.Lock.Create">
      <summary>
            Creates a new lock.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.IServiceProviderExAccessor">
      <summary>
            This interface should be implemented by classes
            that are available in a bigger context, exposing
            the container to different areas in the same application.
            <para>
            For example, in Web application, the (global) HttpApplication
            subclasses should implement this interface to expose 
            the configured container
            </para></summary>
    </member>
    <member name="T:Castle.DynamicProxy.IChangeProxyTarget">
      <summary>
              Exposes means to change target objects of proxies and invocations
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IChangeProxyTarget.ChangeInvocationTarget(System.Object)">
      <summary>
              Changes the target object (<see cref="P:Castle.DynamicProxy.IInvocation.InvocationTarget" />) of current <see cref="T:Castle.DynamicProxy.IInvocation" />.
            </summary>
      <param name="target">The new value of target of invocation.</param>
      <remarks>
              Although the method takes <see cref="T:System.Object" /> the actual instance must be of type assignable to <see cref="P:Castle.DynamicProxy.IInvocation.TargetType" />, otherwise an <see cref="T:System.InvalidCastException" /> will be thrown.
              Also while it's technically legal to pass null reference (Nothing in Visual Basic) as <paramref name="target" />, for obvious reasons Dynamic Proxy will not be able to call the intercepted method on such target.
              In this case last interceptor in the pipeline mustn't call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see cref="T:System.NotImplementedException" /> will be throws.
              Also while it's technically legal to pass proxy itself as <paramref name="target" />, this would create stack overflow.
              In this case last interceptor in the pipeline mustn't call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see cref="T:System.InvalidOperationException" /> will be throws.
            </remarks>
      <exception cref="T:System.InvalidCastException">Thrown when <paramref name="target" /> is not assignable to the proxied type.</exception>
    </member>
    <member name="M:Castle.DynamicProxy.IChangeProxyTarget.ChangeProxyTarget(System.Object)">
      <summary>
              Permanently changes the target object of the proxy. This does not affect target of the current invocation.
            </summary>
      <param name="target">The new value of target of the proxy.</param>
      <remarks>
              Although the method takes <see cref="T:System.Object" /> the actual instance must be of type assignable to proxy's target type, otherwise an <see cref="T:System.InvalidCastException" /> will be thrown.
              Also while it's technically legal to pass null reference (Nothing in Visual Basic) as <paramref name="target" />, for obvious reasons Dynamic Proxy will not be able to call the intercepted method on such target.
              In this case last interceptor in the pipeline mustn't call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see cref="T:System.NotImplementedException" /> will be throws.
              Also while it's technically legal to pass proxy itself as <paramref name="target" />, this would create stack overflow.
              In this case last interceptor in the pipeline mustn't call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see cref="T:System.InvalidOperationException" /> will be throws.
            </remarks>
      <exception cref="T:System.InvalidCastException">Thrown when <paramref name="target" /> is not assignable to the proxied type.</exception>
    </member>
    <member name="T:Castle.DynamicProxy.IInterceptor">
      <summary>
              New interface that is going to be used by DynamicProxy 2
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyTargetAccessor.DynProxyGetTarget">
      <summary>
              Get the proxy target (note that null is a valid target!)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyTargetAccessor.GetInterceptors">
      <summary>
              Gets the interceptors for the proxy
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.IServiceEnabledComponent">
      <summary>
            Defines that the implementation wants a 
            <see cref="T:System.IServiceProvider" /> in order to 
            access other components. The creator must be aware
            that the component might (or might not) implement 
            the interface.
            </summary>
      <remarks>
            Used by Castle Project components to, for example, 
            gather logging factories
            </remarks>
    </member>
    <member name="T:Castle.Core.IServiceProviderEx">
      <summary>
            Increments <c>IServiceProvider</c> with a generic service resolution operation.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.ILoggerFactory">
      <summary>
              Manages the instantiation of <see cref="T:Castle.Core.Logging.ILogger" />s.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.Type)">
      <summary>
              Creates a new logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.String)">
      <summary>
              Creates a new logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new logger.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.IExtendedLoggerFactory">
      <summary>
              Provides a factory that can produce either <see cref="T:Castle.Core.Logging.ILogger" /> or
              <see cref="T:Castle.Core.Logging.IExtendedLogger" /> classes.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.Type)">
      <summary>
              Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.String)">
      <summary>
              Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Create(System.Type)">
      <summary>
              Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Create(System.String)">
      <summary>
              Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.GetConfigFile(System.String)">
      <summary>
              Gets the configuration file.
            </summary>
      <param name="fileName">i.e. log4net.config</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Logging.AbstractLoggerFactory.GetConfigFile(System.String)">
      <summary>
              Gets the configuration file.
            </summary>
      <param name="fileName">i.e. log4net.config</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Logging.TraceLoggerFactory">
      <summary>
              Used to create the TraceLogger implementation of ILogger interface. See <see cref="T:Castle.Core.Logging.TraceLogger" />.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.IContextProperties">
      <summary>
              Interface for Context Properties implementations
            </summary>
      <remarks>
        <para>
                This interface defines a basic property get set accessor.
              </para>
        <para>
                Based on the ContextPropertiesBase of log4net, by Nicko Cadell.
              </para>
      </remarks>
    </member>
    <member name="P:Castle.Core.Logging.IContextProperties.Item(System.String)">
      <summary>
              Gets or sets the value of a property
            </summary>
      <value>
              The value for the property with the specified key
            </value>
      <remarks>
        <para>
                Gets or sets the value of a property
              </para>
      </remarks>
    </member>
    <member name="T:Castle.Core.Logging.NullLogFactory">
      <summary>
            NullLogFactory used when logging is turned off.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.NullLogFactory.Create(System.String)">
      <summary>
              Creates an instance of ILogger with the specified name.
            </summary>
      <param name="name">Name.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Logging.NullLogFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates an instance of ILogger with the specified name and LoggerLevel.
            </summary>
      <param name="name">Name.</param>
      <param name="level">Level.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Logging.StreamLoggerFactory">
      <summary>
              Creates <see cref="T:Castle.Core.Logging.StreamLogger" /> outputing 
              to files. The name of the file is derived from the log name
              plus the 'log' extension.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.ILogger">
      <summary>
              Manages logging.
            </summary>
      <remarks>
              This is a facade for the different logging subsystems.
              It offers a simplified interface that follows IOC patterns
              and a simplified priority/level/severity abstraction.
            </remarks>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.CreateChildLogger(System.String)">
      <summary>
              Create a new child logger.
              The name of the child logger is [current-loggers-name].[passed-in-name]
            </summary>
      <param name="loggerName">The Subname of this logger.</param>
      <returns>The New ILogger instance.</returns>
      <exception cref="T:System.ArgumentException">If the name has an empty element name.</exception>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Debug(System.String)">
      <summary>
              Logs a debug message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Debug(System.Func{System.String})">
      <summary>
              Logs a debug message with lazily constructed message. The message will be constructed only if the <see cref="P:Castle.Core.Logging.ILogger.IsDebugEnabled" /> is true.
            </summary>
      <param name="messageFactory">
      </param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Debug(System.String,System.Exception)">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Error(System.String)">
      <summary>
              Logs an error message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Error(System.Func{System.String})">
      <summary>
              Logs an error message with lazily constructed message. The message will be constructed only if the <see cref="P:Castle.Core.Logging.ILogger.IsErrorEnabled" /> is true.
            </summary>
      <param name="messageFactory">
      </param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Error(System.String,System.Exception)">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String)">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Fatal(System.Func{System.String})">
      <summary>
              Logs a fatal message with lazily constructed message. The message will be constructed only if the <see cref="P:Castle.Core.Logging.ILogger.IsFatalEnabled" /> is true.
            </summary>
      <param name="messageFactory">
      </param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String,System.Exception)">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Info(System.String)">
      <summary>
              Logs an info message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Info(System.Func{System.String})">
      <summary>
              Logs a info message with lazily constructed message. The message will be constructed only if the <see cref="P:Castle.Core.Logging.ILogger.IsInfoEnabled" /> is true.
            </summary>
      <param name="messageFactory">
      </param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Info(System.String,System.Exception)">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Warn(System.String)">
      <summary>
              Logs a warn message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Warn(System.Func{System.String})">
      <summary>
              Logs a warn message with lazily constructed message. The message will be constructed only if the <see cref="P:Castle.Core.Logging.ILogger.IsWarnEnabled" /> is true.
            </summary>
      <param name="messageFactory">
      </param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Warn(System.String,System.Exception)">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsDebugEnabled">
      <summary>
              Determines if messages of priority "debug" will be logged.
            </summary>
      <value>True if "debug" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsErrorEnabled">
      <summary>
              Determines if messages of priority "error" will be logged.
            </summary>
      <value>True if "error" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsFatalEnabled">
      <summary>
              Determines if messages of priority "fatal" will be logged.
            </summary>
      <value>True if "fatal" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsInfoEnabled">
      <summary>
              Determines if messages of priority "info" will be logged.
            </summary>
      <value>True if "info" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsWarnEnabled">
      <summary>
              Determines if messages of priority "warn" will be logged.
            </summary>
      <value>True if "warn" messages will be logged.</value>
    </member>
    <member name="T:Castle.Core.Logging.IExtendedLogger">
      <summary>
              Provides an interface that supports <see cref="T:Castle.Core.Logging.ILogger" /> and
              allows the storage and retrieval of Contexts. These are supported in
              both log4net and NLog.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.IExtendedLogger.GlobalProperties">
      <summary>
              Exposes the Global Context of the extended logger.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.IExtendedLogger.ThreadProperties">
      <summary>
              Exposes the Thread Context of the extended logger.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.IExtendedLogger.ThreadStacks">
      <summary>
              Exposes the Thread Stack of the extended logger.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.LevelFilteredLogger">
      <summary>
            The Level Filtered Logger class.  This is a base clase which
            provides a LogLevel attribute and reroutes all functions into
            one Log method.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.#ctor">
      <summary>
              Creates a new <c>LevelFilteredLogger</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InitializeLifetimeService">
      <summary>
            Keep the instance alive in a remoting scenario
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Debug(System.String)">
      <summary>
              Logs a debug message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Debug(System.String,System.Exception)">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Info(System.String)">
      <summary>
              Logs an info message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Info(System.String,System.Exception)">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Warn(System.String)">
      <summary>
              Logs a warn message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Warn(System.String,System.Exception)">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Error(System.String)">
      <summary>
              Logs an error message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Error(System.String,System.Exception)">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Fatal(System.String)">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Fatal(System.String,System.Exception)">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Log(Castle.Core.Logging.LoggerLevel,System.String,System.String,System.Exception)">
      <summary>
              Implementors output the log content by implementing this method only.
              Note that exception can be null
            </summary>
      <param name="loggerLevel">
      </param>
      <param name="loggerName">
      </param>
      <param name="message">
      </param>
      <param name="exception">
      </param>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.Level">
      <value>
              The <c>LoggerLevel</c> that this logger
              will be using. Defaults to <c>LoggerLevel.Off</c></value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.Name">
      <value>
              The name that this logger will be using. 
              Defaults to <c>String.Empty</c></value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsDebugEnabled">
      <summary>
              Determines if messages of priority "debug" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Debug" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsInfoEnabled">
      <summary>
              Determines if messages of priority "info" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Info" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsWarnEnabled">
      <summary>
              Determines if messages of priority "warn" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Warn" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsErrorEnabled">
      <summary>
              Determines if messages of priority "error" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Error" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsFatalEnabled">
      <summary>
              Determines if messages of priority "fatal" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Fatal" /> bit</value>
    </member>
    <member name="T:Castle.Core.Logging.ConsoleLogger">
      <summary>
            The Logger sending everything to the standard output streams.
            This is mainly for the cases when you have a utility that
            does not have a logger to supply.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor">
      <summary>
              Creates a new ConsoleLogger with the <c>Level</c>
              set to <c>LoggerLevel.Debug</c> and the <c>Name</c>
              set to <c>String.Empty</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new ConsoleLogger with the <c>Name</c>
              set to <c>String.Empty</c>.
            </summary>
      <param name="logLevel">The logs Level.</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(System.String)">
      <summary>
              Creates a new ConsoleLogger with the <c>Level</c>
              set to <c>LoggerLevel.Debug</c>.
            </summary>
      <param name="name">The logs Name.</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new ConsoleLogger.
            </summary>
      <param name="name">The logs Name.</param>
      <param name="logLevel">The logs Level.</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.Log(Castle.Core.Logging.LoggerLevel,System.String,System.String,System.Exception)">
      <summary>
              A Common method to log.
            </summary>
      <param name="loggerLevel">The level of logging</param>
      <param name="loggerName">The name of the logger</param>
      <param name="message">The Message</param>
      <param name="exception">The Exception</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.CreateChildLogger(System.String)">
      <summary>
              Returns a new <c>ConsoleLogger</c> with the name
              added after this loggers name, with a dot in between.
            </summary>
      <param name="loggerName">The added hierarchical name.</param>
      <returns>A new <c>ConsoleLogger</c>.</returns>
    </member>
    <member name="T:Castle.Core.Logging.DiagnosticsLogger">
      <summary>
              The Logger using standart Diagnostics namespace.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String)">
      <summary>
              Creates a logger based on <see cref="T:System.Diagnostics.EventLog" />.
            </summary>
      <param name="logName">
        <see cref="P:System.Diagnostics.EventLog.Log" />
      </param>
    </member>
    <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String,System.String)">
      <summary>
              Creates a logger based on <see cref="T:System.Diagnostics.EventLog" />.
            </summary>
      <param name="logName">
        <see cref="P:System.Diagnostics.EventLog.Log" />
      </param>
      <param name="source">
        <see cref="P:System.Diagnostics.EventLog.Source" />
      </param>
    </member>
    <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String,System.String,System.String)">
      <summary>
              Creates a logger based on <see cref="T:System.Diagnostics.EventLog" />.
            </summary>
      <param name="logName">
        <see cref="P:System.Diagnostics.EventLog.Log" />
      </param>
      <param name="machineName">
        <see cref="P:System.Diagnostics.EventLog.MachineName" />
      </param>
      <param name="source">
        <see cref="P:System.Diagnostics.EventLog.Source" />
      </param>
    </member>
    <member name="T:Castle.Core.Logging.NullLogger">
      <summary>
              The Null Logger class.  This is useful for implementations where you need
              to provide a logger to a utility class, but do not want any output from it.
              It also helps when you have a utility that does not have a logger to supply.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.CreateChildLogger(System.String)">
      <summary>
              Returns this <c>NullLogger</c>.
            </summary>
      <param name="loggerName">Ignored</param>
      <returns>This ILogger instance.</returns>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String)">
      <summary>
              No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String,System.Exception)">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.Exception,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Error(System.String)">
      <summary>
              No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Error(System.String,System.Exception)">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.Exception,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String)">
      <summary>
              No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String,System.Exception)">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.Exception,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Info(System.String)">
      <summary>
              No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Info(System.String,System.Exception)">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.Exception,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String)">
      <summary>
              No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String,System.Exception)">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.Exception,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.GlobalProperties">
      <summary>
              Returns empty context properties.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.ThreadProperties">
      <summary>
              Returns empty context properties.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.ThreadStacks">
      <summary>
              Returns empty context stacks.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsDebugEnabled">
      <summary>
              No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsErrorEnabled">
      <summary>
              No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsFatalEnabled">
      <summary>
              No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsInfoEnabled">
      <summary>
              No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsWarnEnabled">
      <summary>
              No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="T:Castle.Core.Logging.StreamLogger">
      <summary>
            The Stream Logger class.  This class can stream log information
            to any stream, it is suitable for storing a log file to disk,
            or to a <c>MemoryStream</c> for testing your components.
            </summary>
      <remarks>
            This logger is not thread safe.
            </remarks>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream)">
      <summary>
              Creates a new <c>StreamLogger</c> with default encoding 
              and buffer size. Initial Level is set to Debug.
            </summary>
      <param name="name">
              The name of the log.
            </param>
      <param name="stream">
              The stream that will be used for logging,
              seeking while the logger is alive 
            </param>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream,System.Text.Encoding)">
      <summary>
              Creates a new <c>StreamLogger</c> with default buffer size.
              Initial Level is set to Debug.
            </summary>
      <param name="name">
              The name of the log.
            </param>
      <param name="stream">
              The stream that will be used for logging,
              seeking while the logger is alive 
            </param>
      <param name="encoding">
              The encoding that will be used for this stream.
              <see cref="T:System.IO.StreamWriter" /></param>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream,System.Text.Encoding,System.Int32)">
      <summary>
              Creates a new <c>StreamLogger</c>. 
              Initial Level is set to Debug.
            </summary>
      <param name="name">
              The name of the log.
            </param>
      <param name="stream">
              The stream that will be used for logging,
              seeking while the logger is alive 
            </param>
      <param name="encoding">
              The encoding that will be used for this stream.
              <see cref="T:System.IO.StreamWriter" /></param>
      <param name="bufferSize">
              The buffer size that will be used for this stream.
              <see cref="T:System.IO.StreamWriter" /></param>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.StreamWriter)">
      <summary>
              Creates a new <c>StreamLogger</c> with 
              Debug as default Level.
            </summary>
      <param name="name">The name of the log.</param>
      <param name="writer">The <c>StreamWriter</c> the log will write to.</param>
    </member>
    <member name="T:Castle.Core.Logging.TraceLogger">
      <summary>
              The TraceLogger sends all logging to the System.Diagnostics.TraceSource
              built into the .net framework.
            </summary>
      <remarks>
              Logging can be configured in the system.diagnostics configuration 
              section. 
            
              If logger doesn't find a source name with a full match it will
              use source names which match the namespace partially. For example you can
              configure from all castle components by adding a source name with the
              name "Castle". 
            
              If no portion of the namespace matches the source named "Default" will
              be used.
            </remarks>
    </member>
    <member name="M:Castle.Core.Logging.TraceLogger.#ctor(System.String)">
      <summary>
            Build a new trace logger based on the named TraceSource
            </summary>
      <param name="name">The name used to locate the best TraceSource. In most cases comes from the using type's fullname.</param>
    </member>
    <member name="M:Castle.Core.Logging.TraceLogger.#ctor(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Build a new trace logger based on the named TraceSource
            </summary>
      <param name="name">The name used to locate the best TraceSource. In most cases comes from the using type's fullname.</param>
      <param name="level">The default logging level at which this source should write messages. In almost all cases this
            default value will be overridden in the config file. </param>
    </member>
    <member name="M:Castle.Core.Logging.TraceLogger.CreateChildLogger(System.String)">
      <summary>
            Create a new child logger.
            The name of the child logger is [current-loggers-name].[passed-in-name]
            </summary>
      <param name="loggerName">The Subname of this logger.</param>
      <returns>The New ILogger instance.</returns>
    </member>
    <member name="T:Castle.Core.Configuration.IConfiguration">
      <summary>
        <see cref="T:Castle.Core.Configuration.IConfiguration" /> is a interface encapsulating a configuration node
            used to retrieve configuration values.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.IConfiguration.GetValue(System.Type,System.Object)">
      <summary>
            Gets the value of the node and converts it 
            into specified <see cref="T:System.Type" />.
            </summary>
      <param name="type">The <see cref="T:System.Type" /></param>
      <param name="defaultValue">
            The Default value returned if the conversion fails.
            </param>
      <returns>The Value converted into the specified type.</returns>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Name">
      <summary>
            Gets the name of the node.
            </summary>
      <value>
            The Name of the node.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Value">
      <summary>
            Gets the value of the node.
            </summary>
      <value>
            The Value of the node.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Children">
      <summary>
            Gets an <see cref="T:Castle.Core.Configuration.ConfigurationCollection" /> of <see cref="T:Castle.Core.Configuration.IConfiguration" />
            elements containing all node children.
            </summary>
      <value>The Collection of child nodes.</value>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Attributes">
      <summary>
            Gets an <see cref="T:System.Collections.IDictionary" /> of the configuration attributes.
            </summary>
    </member>
    <member name="T:Castle.Core.Configuration.AbstractConfiguration">
      <summary>
              This is an abstract <see cref="T:Castle.Core.Configuration.IConfiguration" /> implementation
              that deals with methods that can be abstracted away
              from underlying implementations.
            </summary>
      <remarks>
        <para>
          <b>AbstractConfiguration</b> makes easier to implementers 
                to create a new version of <see cref="T:Castle.Core.Configuration.IConfiguration" /></para>
      </remarks>
    </member>
    <member name="M:Castle.Core.Configuration.AbstractConfiguration.GetValue(System.Type,System.Object)">
      <summary>
              Gets the value of the node and converts it
              into specified <see cref="T:System.Type" />.
            </summary>
      <param name="type">The <see cref="T:System.Type" /></param>
      <param name="defaultValue">
              The Default value returned if the conversion fails.
            </param>
      <returns>The Value converted into the specified type.</returns>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Attributes">
      <summary>
              Gets node attributes.
            </summary>
      <value>
              All attributes of the node.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Children">
      <summary>
              Gets all child nodes.
            </summary>
      <value>The <see cref="T:Castle.Core.Configuration.ConfigurationCollection" /> of child nodes.</value>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Name">
      <summary>
              Gets the name of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <value>
              The Name of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Value">
      <summary>
              Gets the value of <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <value>
              The Value of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </value>
    </member>
    <member name="T:Castle.Core.Configuration.ConfigurationCollection">
      <summary>
            A collection of <see cref="T:Castle.Core.Configuration.IConfiguration" /> objects.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.#ctor">
      <summary>
            Creates a new instance of <c>ConfigurationCollection</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.#ctor(System.Collections.Generic.IEnumerable{Castle.Core.Configuration.IConfiguration})">
      <summary>
            Creates a new instance of <c>ConfigurationCollection</c>.
            </summary>
    </member>
    <member name="T:Castle.Core.Configuration.MutableConfiguration">
      <summary>
            Summary description for MutableConfiguration.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.MutableConfiguration.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.Configuration.MutableConfiguration" /> class.
            </summary>
      <param name="name">The name.</param>
    </member>
    <member name="P:Castle.Core.Configuration.MutableConfiguration.Value">
      <summary>
            Gets the value of <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <value>
            The Value of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </value>
    </member>
    <member name="M:Castle.Core.Configuration.Xml.XmlConfigurationDeserializer.Deserialize(System.Xml.XmlNode)">
      <summary>
              Deserializes the specified node into an abstract representation of configuration.
            </summary>
      <param name="node">The node.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Configuration.Xml.XmlConfigurationDeserializer.GetConfigValue(System.String)">
      <summary>
              If a config value is an empty string we return null, this is to keep
              backward compatibility with old code
            </summary>
    </member>
    <member name="T:Castle.Core.Pair`2">
      <summary>
            General purpose class to represent a standard pair of values. 
            </summary>
      <typeparam name="TFirst">Type of the first value</typeparam>
      <typeparam name="TSecond">Type of the second value</typeparam>
    </member>
    <member name="M:Castle.Core.Pair`2.#ctor(`0,`1)">
      <summary>
            Constructs a pair with its values
            </summary>
      <param name="first">
      </param>
      <param name="second">
      </param>
    </member>
    <member name="T:Castle.Core.ProxyServices">
      <summary>
            List of utility methods related to dynamic proxy operations
            </summary>
    </member>
    <member name="M:Castle.Core.ProxyServices.IsDynamicProxy(System.Type)">
      <summary>
            Determines whether the specified type is a proxy generated by
            DynamicProxy (1 or 2).
            </summary>
      <param name="type">The type.</param>
      <returns>
        <c>true</c> if it is a proxy; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Castle.Core.ReflectionBasedDictionaryAdapter">
      <summary>
            Readonly implementation of <see cref="T:System.Collections.IDictionary" /> which uses an anonymous object as its source. Uses names of properties as keys, and property values as... well - values. Keys are not case sensitive.
            </summary>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.#ctor(System.Object)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.ReflectionBasedDictionaryAdapter" /> class.
            </summary>
      <param name="target">The target.</param>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Add(System.Object,System.Object)">
      <summary>
              Adds an element with the provided key and value to the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <param name="key">The <see cref="T:System.Object" /> to use as the key of the element to add.</param>
      <param name="value">The <see cref="T:System.Object" /> to use as the value of the element to add.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null. </exception>
      <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.IDictionary" /> object. </exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary" /> is read-only.-or- The <see cref="T:System.Collections.IDictionary" /> has a fixed size. </exception>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Clear">
      <summary>
              Removes all elements from the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary" /> object is read-only. </exception>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Contains(System.Object)">
      <summary>
              Determines whether the <see cref="T:System.Collections.IDictionary" /> object contains an element with the specified key.
            </summary>
      <param name="key">The key to locate in the <see cref="T:System.Collections.IDictionary" /> object.</param>
      <returns>
              true if the <see cref="T:System.Collections.IDictionary" /> contains an element with the key; otherwise, false.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null. </exception>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Remove(System.Object)">
      <summary>
              Removes the element with the specified key from the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <param name="key">The key of the element to remove.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null. </exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary" /> object is read-only.-or- The <see cref="T:System.Collections.IDictionary" /> has a fixed size. </exception>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.GetEnumerator">
      <summary>
              Returns an enumerator that iterates through a collection.
            </summary>
      <returns>
              An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Read(System.Collections.IDictionary,System.Object)">
      <summary>
              Reads values of properties from <paramref name="valuesAsAnonymousObject" /> and inserts them into <paramref name="targetDictionary" /> using property names as keys.
            </summary>
      <param name="targetDictionary">
      </param>
      <param name="valuesAsAnonymousObject">
      </param>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Count">
      <summary>
              Gets the number of elements contained in the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
      </value>
      <returns>The number of elements contained in the <see cref="T:System.Collections.ICollection" />.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.IsSynchronized">
      <summary>
              Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe).
            </summary>
      <value>
      </value>
      <returns>true if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe); otherwise, false.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.SyncRoot">
      <summary>
              Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
      </value>
      <returns>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.IsReadOnly">
      <summary>
              Gets a value indicating whether the <see cref="T:System.Collections.IDictionary" /> object is read-only.
            </summary>
      <value>
      </value>
      <returns>true if the <see cref="T:System.Collections.IDictionary" /> object is read-only; otherwise, false.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Item(System.Object)">
      <summary>
              Gets or sets the <see cref="T:System.Object" /> with the specified key.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Keys">
      <summary>
              Gets an <see cref="T:System.Collections.ICollection" /> object containing the keys of the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <value>
      </value>
      <returns>An <see cref="T:System.Collections.ICollection" /> object containing the keys of the <see cref="T:System.Collections.IDictionary" /> object.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Values">
      <summary>
              Gets an <see cref="T:System.Collections.ICollection" /> object containing the values in the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <value>
      </value>
      <returns>An <see cref="T:System.Collections.ICollection" /> object containing the values in the <see cref="T:System.Collections.IDictionary" /> object.</returns>
    </member>
    <member name="T:Castle.Core.Resource.IResource">
      <summary>
            Represents a 'streamable' resource. Can
            be a file, a resource in an assembly.
            </summary>
    </member>
    <member name="M:Castle.Core.Resource.IResource.GetStreamReader">
      <summary>
            Returns a reader for the stream
            </summary>
      <remarks>
            It's up to the caller to dispose the reader.
            </remarks>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResource.GetStreamReader(System.Text.Encoding)">
      <summary>
            Returns a reader for the stream
            </summary>
      <remarks>
            It's up to the caller to dispose the reader.
            </remarks>
      <param name="encoding">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResource.CreateRelative(System.String)">
      <summary>
            Returns an instance of <see cref="T:Castle.Core.Resource.IResource" />
            created according to the <c>relativePath</c>
            using itself as the root.
            </summary>
      <param name="relativePath">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Core.Resource.IResource.FileBasePath">
      <summary>
      </summary>
      <remarks>
            Only valid for resources that
            can be obtained through relative paths
            </remarks>
    </member>
    <member name="T:Castle.Core.Resource.AbstractStreamResource">
      <summary>
      </summary>
    </member>
    <member name="F:Castle.Core.Resource.AbstractStreamResource.createStream">
      <summary>
            This returns a new stream instance each time it is called.
            It is the responsibility of the caller to dispose of this stream
            </summary>
    </member>
    <member name="T:Castle.Core.Resource.IResourceFactory">
      <summary>
            Depicts the contract for resource factories.
            </summary>
    </member>
    <member name="M:Castle.Core.Resource.IResourceFactory.Accept(Castle.Core.Resource.CustomUri)">
      <summary>
            Used to check whether the resource factory
            is able to deal with the given resource
            identifier.
            </summary>
      <remarks>
            Implementors should return <c>true</c>
            only if the given identifier is supported
            by the resource factory
            </remarks>
      <param name="uri">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResourceFactory.Create(Castle.Core.Resource.CustomUri)">
      <summary>
            Creates an <see cref="T:Castle.Core.Resource.IResource" /> instance
            for the given resource identifier
            </summary>
      <param name="uri">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResourceFactory.Create(Castle.Core.Resource.CustomUri,System.String)">
      <summary>
            Creates an <see cref="T:Castle.Core.Resource.IResource" /> instance
            for the given resource identifier
            </summary>
      <param name="uri">
      </param>
      <param name="basePath">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Resource.FileResource">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Core.Resource.FileResourceFactory">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Core.Resource.StaticContentResource">
      <summary>
            Adapts a static string content as an <see cref="T:Castle.Core.Resource.IResource" /></summary>
    </member>
    <member name="T:Castle.Core.Resource.UncResource">
      <summary>
            Enable access to files on network shares
            </summary>
    </member>
    <member name="T:Castle.Core.Smtp.IEmailSender">
      <summary>
            Email sender abstraction.
            </summary>
    </member>
    <member name="M:Castle.Core.Smtp.IEmailSender.Send(System.String,System.String,System.String,System.String)">
      <summary>
            Sends a mail message.
            </summary>
      <param name="from">From field</param>
      <param name="to">To field</param>
      <param name="subject">E-mail's subject</param>
      <param name="messageText">message's body</param>
    </member>
    <member name="M:Castle.Core.Smtp.IEmailSender.Send(System.Net.Mail.MailMessage)">
      <summary>
            Sends a <see cref="T:System.Net.Mail.MailMessage">message</see>. 
            </summary>
      <param name="message">
        <see cref="T:System.Net.Mail.MailMessage">Message</see> instance</param>
    </member>
    <member name="M:Castle.Core.Smtp.IEmailSender.Send(System.Collections.Generic.IEnumerable{System.Net.Mail.MailMessage})">
      <summary>
            Sends multiple <see cref="T:System.Net.Mail.MailMessage">messages</see>. 
            </summary>
      <param name="messages">List of <see cref="T:System.Net.Mail.MailMessage">messages</see></param>
    </member>
    <member name="T:Castle.Core.Smtp.DefaultSmtpSender">
      <summary>
            Default <see cref="T:Castle.Core.Smtp.IEmailSender" /> implementation.
            </summary>
    </member>
    <member name="M:Castle.Core.Smtp.DefaultSmtpSender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.Smtp.DefaultSmtpSender" /> class based on the <see cref="T:System.Net.Mail.SmtpClient" /> configuration provided in the application configuration file.
            </summary>
      <remarks>
            This constructor is based on the default <see cref="T:System.Net.Mail.SmtpClient" /> configuration in the application configuration file.
            </remarks>
    </member>
    <member name="M:Castle.Core.Smtp.DefaultSmtpSender.#ctor(System.String)">
      <summary>
            This service implementation
            requires a host name in order to work
            </summary>
      <param name="hostname">The smtp server name</param>
    </member>
    <member name="M:Castle.Core.Smtp.DefaultSmtpSender.Send(System.String,System.String,System.String,System.String)">
      <summary>
            Sends a message. 
            </summary>
      <exception cref="T:System.ArgumentNullException">If any of the parameters is null</exception>
      <param name="from">From field</param>
      <param name="to">To field</param>
      <param name="subject">e-mail's subject</param>
      <param name="messageText">message's body</param>
    </member>
    <member name="M:Castle.Core.Smtp.DefaultSmtpSender.Send(System.Net.Mail.MailMessage)">
      <summary>
            Sends a message. 
            </summary>
      <exception cref="T:System.ArgumentNullException">If the message is null</exception>
      <param name="message">Message instance</param>
    </member>
    <member name="M:Castle.Core.Smtp.DefaultSmtpSender.Configure(System.Net.Mail.SmtpClient)">
      <summary>
            Configures the sender
            with port information and eventual credential
            informed
            </summary>
      <param name="smtpClient">Message instance</param>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.Port">
      <summary>
            Gets or sets the port used to 
            access the SMTP server
            </summary>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.Hostname">
      <summary>
            Gets the hostname.
            </summary>
      <value>The hostname.</value>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.AsyncSend">
      <summary>
            Gets or sets a value which is used to 
            configure if emails are going to be sent asynchronously or not.
            </summary>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.Timeout">
      <summary>
            Gets or sets a value that specifies 
            the amount of time after which a synchronous Send call times out.
            </summary>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.UseSsl">
      <summary>
            Gets or sets a value indicating whether the email should be sent using 
            a secure communication channel.
            </summary>
      <value>
        <c>true</c> if should use SSL; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.Domain">
      <summary>
            Gets or sets the domain.
            </summary>
      <value>The domain.</value>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.UserName">
      <summary>
            Gets or sets the name of the user.
            </summary>
      <value>The name of the user.</value>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.Password">
      <summary>
            Gets or sets the password.
            </summary>
      <value>The password.</value>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.HasCredentials">
      <summary>
            Gets a value indicating whether credentials were informed.
            </summary>
      <value>
        <see langword="true" /> if this instance has credentials; otherwise, <see langword="false" />.
            </value>
    </member>
    <member name="T:Castle.Facilities.EventWiring.EventSubscribers">
      <summary>
              Collects information about subscribers for given event
            </summary>
    </member>
    <member name="T:Castle.Facilities.EventWiring.EventWiringException">
      <summary>
            Exception that is thrown when a error occurs during the Event Wiring process
            </summary>
    </member>
    <member name="M:Castle.Facilities.EventWiring.EventWiringException.#ctor(System.String)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Facilities.EventWiring.EventWiringException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Castle.Facilities.EventWiring.EventWiringException.#ctor(System.String,System.Exception)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Facilities.EventWiring.EventWiringException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="M:Castle.Facilities.EventWiring.EventWiringException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Facilities.EventWiring.EventWiringException" /> class.
            </summary>
      <param name="info">The object that holds the serialized object data.</param>
      <param name="context">The contextual information about the source or destination.</param>
    </member>
    <member name="T:Castle.Facilities.EventWiring.EventWiringFacility">
      <summary>
              Facility to allow components to dynamically subscribe to events offered by 
              other components. We call the component that offers events publishers and 
              the components that uses them, subscribers.
            </summary>
      <remarks>
              A component that wish to subscribe to an event must use the external configuration
              adding a node <c>subscribers</c> on the publisher. This node can have multiple entries using the 
              <c>subscriber</c> node.
            </remarks>
      <example>
        <para>This example shows two simple components: one is the event publisher and the other is the 
                subscriber. The subscription will be done by the facility, using the publisher associated configuration.</para>
        <para>The Publisher class:</para>
        <code>
                public class SimplePublisher
                {
                public event PublishEventHandler Event;
            
                public void Trigger()
                {
                if (Event != null)
                {
                Event(this, new EventArgs()); 
                }
                }
                }
              </code>
        <para>The Subscriber class:</para>
        <code>
                public class SimpleListener
                {
                private bool _listened;
                private object _sender;
             
                public void OnPublish(object sender, EventArgs e)
                {
                _sender = sender; 
                _listened = sender != null;
                }
             
                public bool Listened
                {
                get { return _listened;	}
                }
             
                public object Sender
                {
                get { return _sender; }
                }
                }
              </code>
        <para>The configuration file:</para>
        <code><![CDATA[
             <?xml version="1.0" encoding="utf-8" ?>
             <configuration>
             	<facilities>
             		<facility 
             			id="event.wiring"
             			type="Castle.Facilities.EventWiring.EventWiringFacility, Castle.Windsor" />
             	</facilities>
             
             	<components>
             		<component 
             			id="SimpleListener" 
             			type="Castle.Facilities.EventWiring.Tests.Model.SimpleListener, Castle.Facilities.EventWiring.Tests" />
             
             		<component 
             			id="SimplePublisher" 
             			type="Castle.Facilities.EventWiring.Tests.Model.SimplePublisher, Castle.Facilities.EventWiring.Tests" >
             			<subscribers>
             				<subscriber id="SimpleListener" event="Event" handler="OnPublish"/>
             			</subscribers>
             		</component>
             	</components>
             </configuration>
             ]]></code>
      </example>
    </member>
    <member name="M:Castle.Facilities.EventWiring.EventWiringFacility.Init">
      <summary>
              Overridden. Initializes the facility, subscribing to the <see cref="E:Castle.MicroKernel.IKernelEvents.ComponentModelCreated" />,
              <see cref="E:Castle.MicroKernel.IKernelEvents.ComponentCreated" />, <see cref="E:Castle.MicroKernel.IKernelEvents.ComponentDestroyed" /> Kernel events.
            </summary>
    </member>
    <member name="M:Castle.Facilities.EventWiring.EventWiringFacility.OnComponentCreated(Castle.Core.ComponentModel,System.Object)">
      <summary>
              Checks if the component we're dealing is a publisher. If it is, 
              iterates the subscribers starting them and wiring the events.
            </summary>
      <param name="model">The component model.</param>
      <param name="instance">The instance representing the component.</param>
      <exception cref="T:Castle.Facilities.EventWiring.EventWiringException">When the subscriber is not found
              <br /> or <br />
              The handler method isn't found
              <br /> or <br />
              The event isn't found
            </exception>
    </member>
    <member name="T:Castle.Facilities.EventWiring.WireInfo">
      <summary>
              Represents the information about an event.
            </summary>
    </member>
    <member name="M:Castle.Facilities.EventWiring.WireInfo.#ctor(System.String,System.String)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Facilities.EventWiring.WireInfo" /> class.
            </summary>
      <param name="eventName">Name of the event.</param>
      <param name="handler">The name of the handler method.</param>
    </member>
    <member name="M:Castle.Facilities.EventWiring.WireInfo.Equals(System.Object)">
      <summary>
              Determines whether the specified <see cref="T:System.Object"></see> is equal to the current <see cref="T:System.Object"></see>.
            </summary>
      <param name="obj">The <see cref="T:System.Object"></see> to compare with the current <see cref="T:System.Object"></see>.</param>
      <returns>
              true if the specified <see cref="T:System.Object"></see> is equal to the current <see cref="T:System.Object"></see>; otherwise, false.
            </returns>
    </member>
    <member name="M:Castle.Facilities.EventWiring.WireInfo.GetHashCode">
      <summary>
              Serves as a hash function for a particular type.
            </summary>
      <returns>
              A hash code for the current <see cref="T:System.Object"></see>.
            </returns>
    </member>
    <member name="P:Castle.Facilities.EventWiring.WireInfo.EventName">
      <summary>
              Gets the name of the event.
            </summary>
      <value>The name of the event.</value>
    </member>
    <member name="P:Castle.Facilities.EventWiring.WireInfo.Handler">
      <summary>
              Gets the handler method name.
            </summary>
      <value>The handler.</value>
    </member>
    <member name="T:Castle.Facilities.EventWiring.NaiveMethodNameExtractor">
      <summary>
              Extracts MethodInfo of metho invoked in delegate. Based on ILReader class from http://www.gocosmos.org project
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.IFacility">
      <summary>
              Unit of extension. A facility should use 
              the extension points offered by the kernel
              to augment its functionality.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.IFacility.Init(Castle.MicroKernel.IKernel,Castle.Core.Configuration.IConfiguration)">
      <summary>
      </summary>
      <param name="kernel">
      </param>
      <param name="facilityConfig">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IFacility.Terminate">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.MicroKernel.Facilities.AbstractFacility">
      <summary>
              Base class for facilities.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Facilities.AbstractFacility.Init">
      <summary>
              The custom initialization for the Facility.
            </summary>
      <remarks>
              It must be overridden.
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.Facilities.AbstractFacility.Dispose">
      <summary>
              Performs the tasks associated with freeing, releasing, or resetting 
              the facility resources.
            </summary>
      <remarks>
              It can be overriden.
            </remarks>
    </member>
    <member name="P:Castle.MicroKernel.Facilities.AbstractFacility.FacilityConfig">
      <summary>
              Gets the facility configuration.
            </summary>
      <value>The <see cref="T:Castle.Core.Configuration.IConfiguration" /> representing 
              the facility configuration.</value>
    </member>
    <member name="P:Castle.MicroKernel.Facilities.AbstractFacility.Kernel">
      <summary>
              Gets the <see cref="T:Castle.MicroKernel.IKernel" /> where the facility is registered.
            </summary>
      <value>The <see cref="T:Castle.MicroKernel.IKernel" />.</value>
    </member>
    <member name="M:Castle.Facilities.Startable.StartableFacility.LegacyStartFlag.TryStart(Castle.MicroKernel.IHandler)">
      <summary>Request the component instance</summary>
      <param name="handler">
      </param>
    </member>
    <member name="M:Castle.Facilities.Startable.StartableFacility.DeferredStart">
      <summary>
                This method changes behavior of the facility. Deferred mode should be used when you have single call to <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])" /> and register all your components there. Enabling
                this mode will optimize the behavior of the facility so that it will wait 'till the end of installation and only after all <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller" />s were ran it will instantiate and
                start all the startable components. An exception will be thrown if a startable component can't be instantiated and started. This will help you fail fast and diagnose issues quickly. If you don't
                want the exception to be thrown and you prefer the component to fail silently, use <see cref="M:Castle.Facilities.Startable.StartableFacility.DeferredTryStart" /> method instead.
            </summary>
      <remarks>It is recommended to use this method over <see cref="M:Castle.Facilities.Startable.StartableFacility.DeferredTryStart" /> method.</remarks>
    </member>
    <member name="M:Castle.Facilities.Startable.StartableFacility.DeferredStart(Castle.Facilities.Startable.StartFlag)">
      <summary>
                Startable components will be started when <see cref="M:Castle.Facilities.Startable.StartFlag.Signal" /> method is invoked. This is particularily usedul when you need to perform some extra initialization outside of container
                before starting the Startable components.
            </summary>
    </member>
    <member name="M:Castle.Facilities.Startable.StartableFacility.DeferredTryStart">
      <summary>
                This method changes behavior of the facility. Deferred mode should be used when you have single call to <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])" /> and register all your components there. Enabling
                this mode will optimize the behavior of the facility so that it will wait 'till the end of installation and only after all <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller" />s were ran it will instantiate and
                start all the startable components. No exception will be thrown if a startable component can't be instantiated and started. If you'd rather fail fast and diagnose issues quickly, use
                <see cref="M:Castle.Facilities.Startable.StartableFacility.DeferredStart" /> method instead.
            </summary>
      <remarks>It is recommended to use <see cref="M:Castle.Facilities.Startable.StartableFacility.DeferredStart" /> method over this method.</remarks>
    </member>
    <member name="T:Castle.MicroKernel.IComponentActivator">
      <summary>
              Implements the instance creation logic. The default
              implementation should rely on an ordinary call to 
              Activator.CreateInstance().
            </summary>
      <remarks>
              This interface is provided in order to allow custom components
              to be created using a different logic, such as using a specific factory
              or builder.
              <para>
                The constructor for implementation has the following signature:
              </para><code>
                ComponentModel model, IKernel kernel, 
                ComponentInstanceDelegate onCreation, 
                ComponentInstanceDelegate onDestruction
              </code><para>
                The Activator should raise the events onCreation and onDestruction
                in order to correctly implement the contract. Usually the best
                way of creating a custom activator is by extending the existing ones.
              </para><seealso cref="T:Castle.MicroKernel.ComponentActivator.AbstractComponentActivator" /><seealso cref="T:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator" /></remarks>
    </member>
    <member name="M:Castle.MicroKernel.IComponentActivator.Create(Castle.MicroKernel.Context.CreationContext,Castle.MicroKernel.Burden)">
      <summary>
              Should return a new component instance.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IComponentActivator.Destroy(System.Object)">
      <summary>
              Should perform all necessary work to dispose the instance
              and/or any resource related to it.
            </summary>
      <param name="instance">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.ComponentActivator.AbstractComponentActivator">
      <summary>
            Abstract implementation of <see cref="T:Castle.MicroKernel.IComponentActivator" />. The implementors must only override the InternalCreate and InternalDestroy methods in order to perform their creation and destruction
            logic.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ComponentActivator.AbstractComponentActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernelInternal,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
      <summary>
            Constructs an AbstractComponentActivator
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator">
      <summary>
            	Standard implementation of <see cref="T:Castle.MicroKernel.IComponentActivator" />. Handles the selection of the best constructor, fills the writable properties the component exposes, run the commission and
            	decommission lifecycles, etc.
            </summary>
      <remarks>
            	Custom implementors can just override the <c>CreateInstance</c> method. Please note however that the activator is responsible for the proxy creation when needed.
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernelInternal,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
      <summary>
            	Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator" /> class.
            </summary>
      <param name="model">
      </param>
      <param name="kernel">
      </param>
      <param name="onCreation">
      </param>
      <param name="onDestruction">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.ComponentActivator.WebUserControlComponentActivator">
      <summary>
            Attempts to dynamically load a UserControl by invoking Page.LoadControl. There are two uses of this class.
                <para> 1) Add a component to the Kernel and add a VirtualPath attribute specifying the relative path of the .ascx file for the associated UserControl. (easy) </para><example><code>
                  &lt;component id="BasketView" 
                  service="Castle.ShoppingCart.IBasketView, Castle.ShoppingCart"
                  type="Castle.ShoppingCart.BasketView, Castle.ShoppingCart" 
                  lifestyle="transient"
                  virtualPath="~/Views/BasketView.ascx"
                  /&gt;
                </code></example><para> 2) Precompile a UserControl and add the pre-compiled class to the Kernel. (hard) Has not been tested with proxies. </para></summary>
    </member>
    <member name="M:Castle.MicroKernel.ComponentActivator.WebUserControlComponentActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernelInternal,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentActivator.WebUserControlComponentActivator" /> class.
            </summary>
      <param name="model"> The model. </param>
      <param name="kernel"> The kernel. </param>
      <param name="onCreation"> The on creation. </param>
      <param name="onDestruction"> The on destruction. </param>
    </member>
    <member name="M:Castle.MicroKernel.ComponentActivator.WebUserControlComponentActivator.CreateInstance(Castle.MicroKernel.Context.CreationContext,Castle.Core.ConstructorCandidate,System.Object[])">
      <summary>
            Creates the instance.
            </summary>
      <param name="context"> The context. </param>
      <param name="constructor">
      </param>
      <param name="arguments"> The arguments. </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.LifestyleAttribute">
      <summary>
              Base for Attributes that want to express lifestyle
              chosen by the component.
            </summary>
    </member>
    <member name="M:Castle.Core.LifestyleAttribute.#ctor(Castle.Core.LifestyleType)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.LifestyleAttribute" /> class.
            </summary>
      <param name="type">The type.</param>
    </member>
    <member name="P:Castle.Core.LifestyleAttribute.Lifestyle">
      <summary>
              Gets or sets the lifestyle.
            </summary>
      <value>The lifestyle.</value>
    </member>
    <member name="T:Castle.Core.BoundToAttribute">
      <summary>
              Indicates that the target components wants instance lifetime and reuse scope to be bound to another component further up the object graph.
              Good scenario for this would be unit of work bound to a presenter in a two tier MVP application.
              The <see cref="P:Castle.Core.BoundToAttribute.ScopeRootBinderType" /> attribute must point to a type
              having default accessible constructor and public method matching signature of <code>Func&lt;IHandler[], IHandler&gt;</code> delegate.
            </summary>
    </member>
    <member name="M:Castle.Core.BoundToAttribute.#ctor(System.Type)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.BoundToAttribute" /> class.
            </summary>
      <param name="scopeRootBinderType">type having default accessible constructor and public method matching signature of <code>Func&lt;IHandler[], IHandler&gt;</code> delegate. The method will be used to pick <see cref="T:Castle.MicroKernel.IHandler" /> of the component current instance should be bound to.</param>
    </member>
    <member name="P:Castle.Core.BoundToAttribute.ScopeRootBinderType">
      <summary>
              type having default accessible constructor and public method matching signature of <code>Func&lt;IHandler[], IHandler&gt;</code> delegate. The method will be used to pick <see cref="T:Castle.MicroKernel.IHandler" /> of the component current instance should be bound to.
            </summary>
    </member>
    <member name="T:Castle.Core.DependencyModel">
      <summary>
              Represents a dependency (other component or a 
              fixed value available through external configuration).
            </summary>
    </member>
    <member name="M:Castle.Core.DependencyModel.#ctor(System.String,System.Type,System.Boolean)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.DependencyModel" /> class.
            </summary>
      <param name="dependencyKey"> The dependency key. </param>
      <param name="targetType"> Type of the target. </param>
      <param name="isOptional"> if set to <c>true</c> [is optional]. </param>
    </member>
    <member name="M:Castle.Core.DependencyModel.ToString">
      <summary>
              Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns> A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" /> . </returns>
    </member>
    <member name="P:Castle.Core.DependencyModel.DefaultValue">
      <summary>
            The default value of this dependency. Note that <c>null</c> is a valid default value. Use <see cref="P:Castle.Core.DependencyModel.HasDefaultValue" /> to determine whether default value was provided.
            </summary>
    </member>
    <member name="P:Castle.Core.DependencyModel.DependencyKey">
      <summary>
              Gets or sets the dependency key.
            </summary>
      <value> The dependency key. </value>
    </member>
    <member name="P:Castle.Core.DependencyModel.HasDefaultValue">
      <summary>
            Specifies whether dependency has a default value (<see cref="P:Castle.Core.DependencyModel.DefaultValue" />). Note that <c>null</c> is a valid default value.
            </summary>
    </member>
    <member name="P:Castle.Core.DependencyModel.IsOptional">
      <summary>
              Gets or sets whether this dependency is optional.
            </summary>
      <value>
        <c>true</c> if this dependency is optional; otherwise, <c>false</c> . </value>
    </member>
    <member name="P:Castle.Core.DependencyModel.TargetItemType">
      <summary>
              Gets the service type of the dependency.
              This is the same type as <see cref="P:Castle.Core.DependencyModel.TargetType" /> or if <see cref="P:Castle.Core.DependencyModel.TargetType" /> is by ref,
              then it's the element type of the reference. (in other words if dependency 
              is <c>out IFoo foo</c> this will be <c>IFoo</c>, while <see cref="P:Castle.Core.DependencyModel.TargetType" /> will be <c>&amp;IFoo</c>);
            </summary>
    </member>
    <member name="P:Castle.Core.DependencyModel.TargetType">
      <summary>
              Gets the type of the target.
            </summary>
      <value> The type of the target. </value>
    </member>
    <member name="T:Castle.Core.CustomLifestyleAttribute">
      <summary>Indicates that the target components wants a custom lifestyle.</summary>
    </member>
    <member name="M:Castle.Core.CustomLifestyleAttribute.#ctor(System.Type)">
      <summary>
                Initializes a new instance of the <see cref="T:Castle.Core.CustomLifestyleAttribute" /> class.
            </summary>
      <param name="customLifestyleType">The custom lifestyle type.</param>
    </member>
    <member name="T:Castle.Core.DoNotSelectAttribute">
      <summary>
              Marks as constructor to be skipped and not be selected
              by the IoC container during new component activation
            </summary>
    </member>
    <member name="T:Castle.Core.CastleComponentAttribute">
      <summary>
              This attribute is useful only when you want to register all components
              on an assembly as a batch process. 
              By doing so, the batch register will look 
              for this attribute to distinguish components from other classes.
            </summary>
    </member>
    <member name="T:Castle.Core.ComponentActivatorAttribute">
      <summary>
              Associates a custom activator with a component
            </summary>
    </member>
    <member name="M:Castle.Core.ComponentActivatorAttribute.#ctor(System.Type)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.ComponentActivatorAttribute" /> class.
            </summary>
      <param name="componentActivatorType">Type of the component activator.</param>
    </member>
    <member name="P:Castle.Core.ComponentActivatorAttribute.ComponentActivatorType">
      <summary>
              Gets the type of the component activator.
            </summary>
      <value>The type of the component activator.</value>
    </member>
    <member name="M:Castle.Core.ComponentName.DefaultFor(System.Type)">
      <summary>
              Gets the default name for component implemented by <paramref name="componentType" /> which will be used in case when user does not provide one explicitly.
            </summary>
      <param name="componentType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.ComponentName.DefaultNameFor(System.Type)">
      <summary>
              Gets the default name for component implemented by <paramref name="componentType" /> which will be used in case when user does not provide one explicitly.
            </summary>
      <param name="componentType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.ComponentProxyBehaviorAttribute">
      <summary>
              Specifies the proxying behavior for a component.
            </summary>
    </member>
    <member name="P:Castle.Core.ComponentProxyBehaviorAttribute.UseMarshalByRefProxy">
      <summary>
              Gets or sets a value indicating whether the generated 
              interface proxy should inherit from <see cref="T:System.MarshalByRefObject" />.
            </summary>
    </member>
    <member name="P:Castle.Core.ComponentProxyBehaviorAttribute.AdditionalInterfaces">
      <summary>
              Gets or sets the additional interfaces used during proxy generation.
            </summary>
    </member>
    <member name="T:Castle.Core.DoNotWireAttribute">
      <summary>
              Marks as property to be skipped and not be wired
              by the IoC container
            </summary>
    </member>
    <member name="T:Castle.Core.ICommissionConcern">
      <summary>
              Represents a concern that will be applied to a component instance
              during commission phase (right after component instance is activated).
            </summary>
    </member>
    <member name="M:Castle.Core.ICommissionConcern.Apply(Castle.Core.ComponentModel,System.Object)">
      <summary>
              Implementors should act on the instance in response to 
              a commission phase.
            </summary>
      <param name="model">The model.</param>
      <param name="component">The component.</param>
    </member>
    <member name="T:Castle.Core.IDecommissionConcern">
      <summary>
              Represents a concern that will be applied to a component instance
              during decommission phase (right before component instance is destroyed).
            </summary>
    </member>
    <member name="M:Castle.Core.IDecommissionConcern.Apply(Castle.Core.ComponentModel,System.Object)">
      <summary>
              Implementors should act on the instance in response to 
              a decommission phase.
            </summary>
      <param name="model">The model.</param>
      <param name="component">The component.</param>
    </member>
    <member name="T:Castle.Core.IInitializable">
      <summary>
              Lifecycle interface. If implemented by a component,
              the method Initialized will be invoked by the container
              before making the component available to the external world.
            </summary>
    </member>
    <member name="M:Castle.Core.IInitializable.Initialize">
      <summary>
              Implementors should perform any initialization logic.
            </summary>
    </member>
    <member name="T:Castle.Core.InterceptorAttribute">
      <summary>
              Used to declare that a component wants interceptors acting on it.
              Out of the box recognized only if applied on component's implementation class.
            </summary>
    </member>
    <member name="M:Castle.Core.InterceptorAttribute.#ctor(System.String)">
      <summary>
              Constructs the InterceptorAttribute pointing to a key to a interceptor
            </summary>
      <param name="componentKey">
      </param>
    </member>
    <member name="M:Castle.Core.InterceptorAttribute.#ctor(System.Type)">
      <summary>
              Constructs the InterceptorAttribute pointing to a service
            </summary>
      <param name="interceptorType">
      </param>
    </member>
    <member name="T:Castle.Core.Internal.SimpleThreadSafeDictionary`2">
      <summary>
              Simple type for thread safe adding/reading to/from keyed store. The difference between this and built in concurrent dictionary is that in this case adding is happening under a lock so never more than one thread will be adding at a time.
            </summary>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TValue">
      </typeparam>
    </member>
    <member name="M:Castle.Core.Internal.SimpleThreadSafeDictionary`2.EjectAllValues">
      <summary>
              Returns all values and clears the dictionary
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Internal.StringExtensions.EqualsText(System.String,System.String)">
      <summary>
              Performs string comparison using <see cref="P:System.StringComparer.OrdinalIgnoreCase" /></summary>
      <param name="one">
      </param>
      <param name="two">
      </param>
      <returns>
      </returns>
    </member>
    <member name="F:Castle.Core.Internal.ThreadSafeFlag.signaled">
      <summary>
              0 == false, 1 = =true
            </summary>
    </member>
    <member name="M:Castle.Core.Internal.ThreadSafeFlag.Signal">
      <summary>
              Signals (sets) the flag.
            </summary>
      <returns>
        <c>true</c> if the current thread signaled the flag, <c>false</c> if some other thread signaled the flag before.</returns>
    </member>
    <member name="T:Castle.Core.Internal.LateBoundComponent">
      <summary>
              Marker class used to denote components that have late bound type
              That is the actual type is not known exactly at the time when <see cref="T:Castle.Core.ComponentModel" />
              is created. Those are for example components instantiated via abstract factory.
            </summary>
    </member>
    <member name="M:Castle.Core.Internal.ReflectionUtil.GetCompatibleArrayItemType(System.Type)">
      <summary>
              If the extended type is a Foo[] or IEnumerable{Foo} which is assignable from Foo[] this method will return typeof(Foo)
              otherwise <c>null</c>.
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Internal.TypeUtil.IsPrimitiveTypeOrCollection(System.Type)">
      <summary>
              Checkis if given <paramref name="type" /> is a primitive type or collection of primitive types. Value types, <see cref="T:System.String" /> are considered primitive and can not be registered as components in Windsor
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Internal.TypeUtil.IsPrimitiveType(System.Type)">
      <summary>
              Checkis if given <paramref name="type" /> is a primitive type. Value types and <see cref="T:System.String" /> are considered primitive and can not be registered as components in Windsor
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Internal.TypeUtil.TryMakeGenericType(System.Type,System.Type[])">
      <summary>
              Calls <see cref="M:System.Type.MakeGenericType(System.Type[])" /> and if a generic constraint is violated returns <c>null</c> instead of throwing <see cref="T:System.ArgumentException" />.
            </summary>
      <param name="openGeneric">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.LifestyleType">
      <summary>
              Enumeration used to mark the component's lifestyle.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Undefined">
      <summary>
              No lifestyle specified.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Singleton">
      <summary>
              Singleton components are instantiated once, and shared
              between all clients.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Thread">
      <summary>
              Thread components have a unique instance per thread.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Transient">
      <summary>
              Transient components are created on demand.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Pooled">
      <summary>
              Optimization of transient components that keeps
              instance in a pool instead of always creating them.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.PerWebRequest">
      <summary>
              PerWebRequest components are created once per Http Request
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Custom">
      <summary>
              Any other logic to create/release components.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Scoped">
      <summary>
              Instances are reused within the scope provided.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Bound">
      <summary>
              Instance lifetime and reuse scope is bound to another component further up the object graph.
              Good scenario for this would be unit of work bound to a presenter in a two tier MVP application.
              When specified in xml a <c>scopeRootBinderType</c> attribute must be specified pointing to a type
              having default accessible constructor and public method matching signature of <code>Func&lt;IHandler[], IHandler&gt;</code> delegate.
            </summary>
    </member>
    <member name="T:Castle.Core.PerThreadAttribute">
      <summary>
              Indicates that the target components wants a
              per thread lifestyle.
            </summary>
    </member>
    <member name="M:Castle.Core.PerThreadAttribute.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.PerThreadAttribute" /> class.
            </summary>
    </member>
    <member name="T:Castle.Core.PerWebRequestAttribute">
      <summary>
              Indicates that the target components wants a
              per web request lifestyle.
            </summary>
    </member>
    <member name="T:Castle.Core.PooledAttribute">
      <summary>
              Indicates that the target components wants a
              pooled lifestyle.
            </summary>
    </member>
    <member name="M:Castle.Core.PooledAttribute.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.PooledAttribute" /> class
              using the default initial pool size (5) and the max pool size (15).
            </summary>
    </member>
    <member name="M:Castle.Core.PooledAttribute.#ctor(System.Int32,System.Int32)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.PooledAttribute" /> class.
            </summary>
      <param name="initialPoolSize">Initial size of the pool.</param>
      <param name="maxPoolSize">Max pool size.</param>
    </member>
    <member name="P:Castle.Core.PooledAttribute.InitialPoolSize">
      <summary>
              Gets the initial size of the pool.
            </summary>
      <value>The initial size of the pool.</value>
    </member>
    <member name="P:Castle.Core.PooledAttribute.MaxPoolSize">
      <summary>
              Gets the maximum pool size.
            </summary>
      <value>The size of the max pool.</value>
    </member>
    <member name="T:Castle.Core.PropertyFilter">
      <summary>
              Specifies rules for designating settable properties on a component as dependencies, and controlling whether they are requred or not.
              This is a shortcut for most common scenarios. More advanced/custom scenarios can be defined dynamically in the registration API.
            </summary>
    </member>
    <member name="F:Castle.Core.PropertyFilter.Default">
      <summary>
              Takes no action. By default that means all settable properties will be exposed as optional dependencies.
            </summary>
    </member>
    <member name="F:Castle.Core.PropertyFilter.RequireAll">
      <summary>
              Makes all property dependencies required.
            </summary>
    </member>
    <member name="F:Castle.Core.PropertyFilter.RequireBase">
      <summary>
              Makes all property dependencies defined at a base class/interfaces level required.
            </summary>
    </member>
    <member name="F:Castle.Core.PropertyFilter.IgnoreAll">
      <summary>
              Makes all properties ignored.
            </summary>
    </member>
    <member name="F:Castle.Core.PropertyFilter.IgnoreBase">
      <summary>
              Ignores all properties defined at a base class/interface level.
            </summary>
      <remarks>
              This option is particularily useful in scenarios like UI controls which in .NET UI frameworks tend to have byzantine inheritance hierarchies.
            </remarks>
    </member>
    <member name="T:Castle.Core.ScopedAttribute">
      <summary>
              Indicates that the target components wants a
              per thread lifestyle.
            </summary>
    </member>
    <member name="M:Castle.Core.ScopedAttribute.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.PerThreadAttribute" /> class.
            </summary>
    </member>
    <member name="T:Castle.Core.SingletonAttribute">
      <summary>
              Indicates that the target components wants a
              singleton lifestyle.
            </summary>
    </member>
    <member name="M:Castle.Core.SingletonAttribute.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.SingletonAttribute" /> class.
            </summary>
    </member>
    <member name="T:Castle.Core.TransientAttribute">
      <summary>
              Indicates that the target components wants a
              transient lifestyle.
            </summary>
    </member>
    <member name="M:Castle.Core.TransientAttribute.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.TransientAttribute" /> class.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction">
      <summary>
              Implementors must inspect the component for 
              a given information or parameter.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
              Usually the implementation will look in the configuration property 
              of the model or the service interface, or the implementation looking for
              something.
            </summary>
      <param name="kernel">The kernel instance</param>
      <param name="model">The component model</param>
    </member>
    <member name="M:Castle.Facilities.TypedFactory.ITypedFactoryComponentSelector.SelectComponent(System.Reflection.MethodInfo,System.Type,System.Object[])">
      <summary>
              Selects one or both of component name and type, for given method 
              called on given typed factory type.
              When component should be requested by type only,
              componentName should be null.
              When component should be requested by name only,
              componentType should be null.
            </summary>
      <param name="method">
      </param>
      <param name="type">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Facilities.TypedFactory.DefaultTypedFactoryComponentSelector.#ctor(System.Boolean,System.Boolean)">
      <param name="getMethodsResolveByName">If set to <c>true</c>, all methods with names like 'GetSomething' will try to resolve by name component 'something'. Defaults to <c>true</c>.</param>
      <param name="fallbackToResolveByTypeIfNameNotFound">If set to <c>true</c>, will fallback to resolving by type, if can not find component with specified name. This property is here for backward compatibility. It is recommended not to use it. Defaults to <c>false</c>.</param>
    </member>
    <member name="M:Castle.Facilities.TypedFactory.DefaultTypedFactoryComponentSelector.BuildFactoryComponent(System.Reflection.MethodInfo,System.String,System.Type,System.Collections.IDictionary)">
      <summary>
              Builds <see cref="T:Castle.Facilities.TypedFactory.TypedFactoryComponentResolver" /> for given call.
              By default if <paramref name="componentType" /> is a collection
              returns factory calling <see cref="M:Castle.MicroKernel.IKernel.ResolveAll(System.Type)" /> on collection's item type,
              otherwise standard <see cref="T:Castle.Facilities.TypedFactory.TypedFactoryComponentResolver" />.
            </summary>
      <param name="method">
      </param>
      <param name="componentName">
      </param>
      <param name="componentType">
      </param>
      <param name="additionalArguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Facilities.TypedFactory.DefaultTypedFactoryComponentSelector.GetArguments(System.Reflection.MethodInfo,System.Object[])">
      <summary>
              Selects arguments to be passed to resolution pipeline.
              By default passes all given <paramref name="arguments" /> 
              keyed by names of their corresponding <paramref name="method" /> parameters.
            </summary>
      <param name="method">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Facilities.TypedFactory.DefaultTypedFactoryComponentSelector.GetComponentName(System.Reflection.MethodInfo,System.Object[])">
      <summary>
              Selects name of the component to resolve.
              If <paramref name="method" /> Name is GetFoo returns "Foo", otherwise <c>null</c>.
            </summary>
      <param name="method">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Facilities.TypedFactory.DefaultTypedFactoryComponentSelector.GetComponentType(System.Reflection.MethodInfo,System.Object[])">
      <summary>
              Selects type of the component to resolve. Uses <paramref name="method" /> return type.
            </summary>
      <param name="method">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Facilities.TypedFactory.DefaultTypedFactoryComponentSelector.FallbackToResolveByTypeIfNameNotFound">
      <summary>
              If set to <c>true</c>, will fallback to resolving by type, if can not find component with specified name. This property is here for backward compatibility. It is recommended not to use it.
            </summary>
    </member>
    <member name="P:Castle.Facilities.TypedFactory.DefaultTypedFactoryComponentSelector.GetMethodsResolveByName">
      <summary>
              If set to <c>true</c>, all methods with names like 'GetSomething' will try to resolve by name component 'something'.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.ComponentActivator.IDependencyAwareActivator">
      <summary>
            Implemented by <see cref="T:Castle.MicroKernel.IComponentActivator" /> which don't necessarily need dependencies from the container to activate new instances of the component.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ComponentActivator.IDependencyAwareActivator.CanProvideRequiredDependencies(Castle.Core.ComponentModel)">
      <summary>
            Should return <c>true</c> if the activator can provide dependencies for the <paramref name="component" />.
            </summary>
      <param name="component">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.ComponentActivator.IDependencyAwareActivator.IsManagedExternally(Castle.Core.ComponentModel)">
      <summary>
            Should return <c>true</c> if the activated instances of the <see cref="T:Castle.Core.ComponentModel" /> are managed externally to the container. That means container will not try to track the objects in <see cref="T:Castle.MicroKernel.IReleasePolicy" />.
            </summary>
      <param name="component">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.MicroKernel.Resolvers.ILazyComponentLoader">
      <summary>
              Provides lazy registration capabilities to the container.
            </summary>
      <remarks>
              When a component is requested from a container and it was not registered, 
              container loads up all registered implementers of this interface and asks 
              them in turn whether they can provide that component, until it finds one that will.
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.Resolvers.ILazyComponentLoader.Load(System.String,System.Type,System.Collections.IDictionary)">
      <summary>
              Used by container to allow the loader to register component for given <paramref name="name" /> and <paramref name="service" /> to the container at the time when it is requested
            </summary>
      <param name="name">Name of the requested component or null</param>
      <param name="service">Type of requested service or null</param>
      <param name="arguments">User supplied arguments or null</param>
      <returns>Registration that registers component for given key and/or service or null.</returns>
      <remarks>
              While either key or service can be null reference it is guaranteed that at least one of them will not be null.
              When implementer opts in to provide the requested component (by returning not-null registration) it is required
              to register component for requested key/service combination (when one of the elements is null, it should be ignored as well).
              When implementer does not want to register the requested component it must return null.
            </remarks>
    </member>
    <member name="T:Castle.Facilities.TypedFactory.FactoryAttribute">
      <summary>
              Specifies default configuration for a typed factory. All Selector* properties are mutually exclusive, that is you're only meant to set one.
            </summary>
    </member>
    <member name="P:Castle.Facilities.TypedFactory.FactoryAttribute.SelectorComponentName">
      <summary>
              Specifies component to use as selector for given factory. This works like any named service override.
            </summary>
    </member>
    <member name="P:Castle.Facilities.TypedFactory.FactoryAttribute.SelectorComponentType">
      <summary>
              Specifies component to use as selector for given factory. This works like any typed service override.
            </summary>
    </member>
    <member name="P:Castle.Facilities.TypedFactory.FactoryAttribute.SelectorType">
      <summary>
              Specifies type of the selector to use for given factory. The type will be instantiated using default constructor. It must implement <see cref="T:Castle.Facilities.TypedFactory.ITypedFactoryComponentSelector" /></summary>
    </member>
    <member name="T:Castle.MicroKernel.ComponentResolutionException">
      <summary>
              Exception thrown when resolution process for a component was unsuccessful at some point for whatever reason.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.ComponentActivator.ComponentActivatorException">
      <summary>
              Exception thrown whe a component could not be activated. THis should come from the component activator.
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.Burden.RequiresPolicyRelease">
      <summary>
              If
              <c>true</c>
              requires release by
              <see cref="T:Castle.MicroKernel.IReleasePolicy" />
              . If
              <c>false</c>
              , the object has a well defined, detectable end of life (web-request end, disposal of the container etc), and will be released externally.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Arguments">
      <summary>
              Represents collection of arguments used when resolving a component.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.ComponentActivator.NoResolvableConstructorFoundException">
      <summary>
              Exception thrown when component has no resolvable constructor that can be used to create an instance.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.HandlerState">
      <summary>
              Possible states for a IHandler instance
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.HandlerState.Valid">
      <summary>
              The component can be requested
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.HandlerState.WaitingDependency">
      <summary>
              The component can not be requested 
              as it still depending on a external 
              dependency not yet available
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Handlers.IDependencyInspector">
      <summary>
              Inspects missings dependencies in the container. Default implementation is used to
              construct helpful message for exceptions and debugger views, but other implementations
              are also possible if needed.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.ISubDependencyResolver">
      <summary>
              Implementors should use a strategy to obtain 
              valid references to properties and/or services 
              requested in the dependency model.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ISubDependencyResolver.CanResolve(Castle.MicroKernel.Context.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
      <summary>
              Returns true if the resolver is able to satisfy this dependency.
            </summary>
      <param name="context">Creation context, which is a resolver itself</param>
      <param name="contextHandlerResolver">Parent resolver - normally the IHandler implementation</param>
      <param name="model">Model of the component that is requesting the dependency</param>
      <param name="dependency">The dependency model</param>
      <returns>
        <c>true</c> if the dependency can be satisfied</returns>
    </member>
    <member name="M:Castle.MicroKernel.ISubDependencyResolver.Resolve(Castle.MicroKernel.Context.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
      <summary>
              Should return an instance of a service or property values as
              specified by the dependency model instance. 
              It is also the responsibility of <see cref="T:Castle.MicroKernel.IDependencyResolver" />
              to throw an exception in the case a non-optional dependency 
              could not be resolved.
            </summary>
      <param name="context">Creation context, which is a resolver itself</param>
      <param name="contextHandlerResolver">Parent resolver - normally the IHandler implementation</param>
      <param name="model">Model of the component that is requesting the dependency</param>
      <param name="dependency">The dependency model</param>
      <returns>The dependency resolved value or null</returns>
    </member>
    <member name="T:Castle.MicroKernel.IHandler">
      <summary>
              Contract for the IHandler, which manages an
              component state and coordinates its creation 
              and destruction (dispatching to activators, lifestyle managers)
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.IHandler.Init(Castle.MicroKernel.IKernelInternal)">
      <summary>
              Initializes the handler with a reference to the
              kernel.
            </summary>
      <param name="kernel">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IHandler.IsBeingResolvedInContext(Castle.MicroKernel.Context.CreationContext)">
      <summary>
              Tests whether the handler is already being resolved in given context.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.IHandler.Release(Castle.MicroKernel.Burden)">
      <summary>
              Implementors should dispose the component instance
            </summary>
      <param name="burden">
      </param>
      <returns>true if destroyed.</returns>
    </member>
    <member name="M:Castle.MicroKernel.IHandler.Resolve(Castle.MicroKernel.Context.CreationContext)">
      <summary>
              Implementors should return a valid instance 
              for the component the handler is responsible.
              It should throw an exception in the case the component
              can't be created for some reason
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IHandler.Supports(System.Type)">
      <summary>
              Returns true if this handler supports <paramref name="service" /></summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IHandler.TryResolve(Castle.MicroKernel.Context.CreationContext)">
      <summary>
              Implementors should return a valid instance 
              for the component the handler is responsible.
              It should return null in the case the component
              can't be created for some reason. No exception should be thrown.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.MicroKernel.IHandler.ComponentModel">
      <summary>
              Gets the model of the component being 
              managed by this handler.
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.IHandler.CurrentState">
      <summary>
              Gets the state of the handler
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Handlers.IExposeDependencyInfo">
      <summary>
              Might be implemented by a handler 
              so it can expose access to dependency information 
              which is used to construct meaningful error messages
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.IExposeDependencyInfo.ObtainDependencyDetails(Castle.MicroKernel.Handlers.IDependencyInspector)">
      <summary>
              Informs the <paramref name="inspector" /> about missing dependencies.
              Implementers should ignore the call if no dependencies are missing and 
              call back the inspector with the information required otherwise
            </summary>
      <param name="inspector">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.Handlers.AbstractHandler">
      <summary>
              Implements the basis of <see cref="T:Castle.MicroKernel.IHandler" /></summary>
    </member>
    <member name="F:Castle.MicroKernel.Handlers.AbstractHandler.missingDependencies">
      <summary>
              Dictionary of key (string) to <see cref="T:Castle.Core.DependencyModel" /></summary>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.#ctor(Castle.Core.ComponentModel)">
      <summary>
              Constructs and initializes the handler
            </summary>
      <param name="model">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.ReleaseCore(Castle.MicroKernel.Burden)">
      <summary>
              Should be implemented by derived classes: disposes the component instance (or recycle it)
            </summary>
      <param name="burden">
      </param>
      <returns> true if destroyed. </returns>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.Resolve(Castle.MicroKernel.Context.CreationContext,System.Boolean)">
      <summary>
              Returns an instance of the component this handler is responsible for
            </summary>
      <param name="context">
      </param>
      <param name="instanceRequired"> when <c>false</c> , handler can not create valid instance and return <c>null</c> instead </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.Init(Castle.MicroKernel.IKernelInternal)">
      <summary>
              Saves the kernel instance, subscribes to <see cref="E:Castle.MicroKernel.IKernelEvents.AddedAsChildKernel" /> event, creates the lifestyle manager instance and computes the handler state.
            </summary>
      <param name="kernel">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.Release(Castle.MicroKernel.Burden)">
      <summary>
              disposes the component instance (or recycle it).
            </summary>
      <param name="burden">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.Resolve(Castle.MicroKernel.Context.CreationContext)">
      <summary>
              Returns an instance of the component this handler is responsible for
            </summary>
      <param name="context">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.AddDependency(Castle.Core.DependencyModel)">
      <summary>
              Invoked by <see cref="M:Castle.MicroKernel.Handlers.AbstractHandler.InitDependencies" /> in order to check if a dependency can be satisfied. If not, the handler is set to a 'waiting dependency' state.
            </summary>
      <remarks>
              This method registers the dependencies within the correct collection or dictionary and changes the handler state to <see cref="F:Castle.MicroKernel.HandlerState.WaitingDependency" /></remarks>
      <param name="dependency">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.DependencySatisfied(System.Boolean@)">
      <summary>
              Invoked by the kernel when one of registered dependencies were satisfied by new components registered.
            </summary>
      <remarks>
              Handler for the event <see cref="E:Castle.MicroKernel.IKernelEvents.HandlerRegistered" /></remarks>
      <param name="stateChanged">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.OnAddedAsChildKernel(System.Object,System.EventArgs)">
      <summary>
              Invoked when the container receives a parent container reference.
            </summary>
      <remarks>
              This method implementation checks whether the parent container is able to supply the dependencies for this handler.
            </remarks>
      <param name="sender">
      </param>
      <param name="e">
      </param>
    </member>
    <member name="P:Castle.MicroKernel.Handlers.AbstractHandler.ComponentModel">
      <summary>
              Gets the component model.
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.Handlers.AbstractHandler.CurrentState">
      <summary>
              Gets the handler state.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Handlers.DefaultHandler">
      <summary>
              Summary description for DefaultHandler.
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.Handlers.DefaultHandler.lifestyleManager">
      <summary>
              Lifestyle manager instance
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.DefaultHandler.#ctor(Castle.Core.ComponentModel)">
      <summary>
              Initializes a new instance of the
              <see cref="T:Castle.MicroKernel.Handlers.DefaultHandler" />
              class.
            </summary>
      <param name="model">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.DefaultHandler.ReleaseCore(Castle.MicroKernel.Burden)">
      <summary>
              disposes the component instance (or recycle it)
            </summary>
      <param name="burden">
      </param>
      <returns> true if destroyed </returns>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.DefaultHandler.ResolveCore(Castle.MicroKernel.Context.CreationContext,System.Boolean,System.Boolean,Castle.MicroKernel.Burden@)">
      <summary>
              Returns an instance of the component this handler
              is responsible for
            </summary>
      <param name="context">
      </param>
      <param name="requiresDecommission">
      </param>
      <param name="instanceRequired">
      </param>
      <param name="burden">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.MicroKernel.Handlers.DefaultHandler.LifestyleManager">
      <summary>
              Lifestyle manager instance
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Handlers.HandlerException">
      <summary>
              Summary description for HandlerException.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.HandlerException.#ctor(System.String,Castle.Core.ComponentName)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.HandlerException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="name">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.HandlerException.#ctor(System.String,Castle.Core.ComponentName,System.Exception)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.HandlerException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="name">
      </param>
      <param name="innerException">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.HandlerException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.HandlerException" /> class.
            </summary>
      <param name="info">The object that holds the serialized object data.</param>
      <param name="context">The contextual information about the source or destination.</param>
    </member>
    <member name="T:Castle.MicroKernel.Handlers.GenericHandlerTypeMismatchException">
      <summary>
              Thrown when <see cref="T:Castle.MicroKernel.Handlers.DefaultGenericHandler" /> can't create proper closed version of itself due to violation of generic constraints.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.GenericHandlerTypeMismatchException.#ctor(System.String,Castle.Core.ComponentName)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.HandlerException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="name">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.GenericHandlerTypeMismatchException.#ctor(System.String,Castle.Core.ComponentName,System.Exception)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.HandlerException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="name">
      </param>
      <param name="innerException">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.GenericHandlerTypeMismatchException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.HandlerException" /> class.
            </summary>
      <param name="info">The object that holds the serialized object data.</param>
      <param name="context">The contextual information about the source or destination.</param>
    </member>
    <member name="T:Castle.MicroKernel.Context.CreationContext">
      <summary>
              Used during a component request, passed along to the whole process.
              This allow some data to be passed along the process, which is used 
              to detected cycled dependency graphs and now it's also being used
              to provide arguments to components.
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.Context.CreationContext.handlerStack">
      <summary>
              The list of handlers that are used to resolve
              the component.
              We track that in order to try to avoid attempts to resolve a service
              with itself.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Context.CreationContext.#ctor(System.Type,Castle.MicroKernel.Context.CreationContext,System.Boolean)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Context.CreationContext" /> class.
            </summary>
      <param name="requestedType"> The type to extract generic arguments. </param>
      <param name="parentContext"> The parent context. </param>
      <param name="propagateInlineDependencies"> When set to <c>true</c> will clone <paramref name="parentContext" /><see cref="P:Castle.MicroKernel.Context.CreationContext.AdditionalArguments" /> . </param>
    </member>
    <member name="M:Castle.MicroKernel.Context.CreationContext.#ctor(Castle.MicroKernel.IHandler,Castle.MicroKernel.IReleasePolicy,System.Type,System.Collections.IDictionary,Castle.MicroKernel.SubSystems.Conversion.ITypeConverter,Castle.MicroKernel.Context.CreationContext)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Context.CreationContext" /> class.
            </summary>
      <param name="handler"> The handler. </param>
      <param name="releasePolicy"> The release policy. </param>
      <param name="requestedType"> The type to extract generic arguments. </param>
      <param name="additionalArguments"> The additional arguments. </param>
      <param name="converter"> The conversion manager. </param>
      <param name="parent"> Parent context </param>
    </member>
    <member name="M:Castle.MicroKernel.Context.CreationContext.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Context.CreationContext" /> class.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Context.CreationContext.IsInResolutionContext(Castle.MicroKernel.IHandler)">
      <summary>
              Method used by handlers to test whether they are being resolved in the context.
            </summary>
      <param name="handler">
      </param>
      <returns>
      </returns>
      <remarks>
              This method is provided as part of double dispatch mechanism for use by handlers.
              Outside of handlers, call <see cref="M:Castle.MicroKernel.IHandler.IsBeingResolvedInContext(Castle.MicroKernel.Context.CreationContext)" /> instead.
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.Context.CreationContext.CreateEmpty">
      <summary>
              Creates a new, empty <see cref="T:Castle.MicroKernel.Context.CreationContext" /> instance.
            </summary>
      <remarks>
              A new CreationContext should be created every time, as the contexts keeps some state related to dependency resolution.
            </remarks>
    </member>
    <member name="T:Castle.MicroKernel.IKernelEvents">
      <summary>
              Summary description for IKernelEvents.
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.IKernelEvents.ComponentRegistered">
      <summary>
              Event fired when a new component is registered 
              on the kernel.
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.IKernelEvents.ComponentModelCreated">
      <summary>
              Event fired after the ComponentModel is created.
              Allows customizations that may affect the handler.
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.IKernelEvents.AddedAsChildKernel">
      <summary>
              Event fired when the kernel was added as child of
              another kernel.
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.IKernelEvents.RemovedAsChildKernel">
      <summary>
              Event fired when the kernel was removed from being a child
              of another kernel.
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.IKernelEvents.ComponentCreated">
      <summary>
              Event fired before the component is created.
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.IKernelEvents.ComponentDestroyed">
      <summary>
              Event fired when a component instance destroyed.
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.IKernelEvents.HandlerRegistered">
      <summary>
              Event fired when a new handler is registered 
              (it might be in a valid or waiting dependency state)
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.IKernelEvents.HandlersChanged">
      <summary>
              Event fired when a new handler is registered 
              (it might be in a valid or waiting dependency state)
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.IKernelEvents.DependencyResolving">
      <summary>
              Event fired when a dependency is being resolved,
              it allows the dependency to be changed,
              but the client ComponentModel must not be changed.
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.IKernelEvents.RegistrationCompleted">
      <summary>
              Event fired when registration / installation process is completed.
              That is when container is about to exit<see cref="M:Castle.MicroKernel.IKernel.Register(Castle.MicroKernel.Registration.IRegistration[])" /> method. This event is raised once regardless of how many components were registered.
              If the <see cref="M:Castle.MicroKernel.IKernel.Register(Castle.MicroKernel.Registration.IRegistration[])" /> is called by <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])" /> the event is raised when that method exits.
            </summary>
    </member>
    <member name="E:Castle.MicroKernel.IKernelEvents.EmptyCollectionResolving">
      <summary>
              Event fired when a collection is being resolved (via <see cref="M:Castle.MicroKernel.IKernel.ResolveAll(System.Type)" /> or another overload) and the collection is empty.
              Implementors would usually log that fact or potentially throw an exception (especially in development).
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.IKernel">
      <summary>
              The <c>IKernel</c> interface exposes all the functionality
              the MicroKernel implements.
            </summary>
      <remarks>
              It allows you to register components and
              request them by their name or the services they expose.
              It also allow you to register facilities and subsystem, thus 
              augmenting the functionality exposed by the kernel alone to fit 
              your needs.
              <seealso cref="T:Castle.MicroKernel.IFacility" /><seealso cref="T:Castle.MicroKernel.ISubSystem" /></remarks>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.AddChildKernel(Castle.MicroKernel.IKernel)">
      <summary>
              Support for kernel hierarchy
            </summary>
      <param name="kernel">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.AddFacility(Castle.MicroKernel.IFacility)">
      <summary>
              Adds a <see cref="T:Castle.MicroKernel.IFacility" /> to the kernel.
            </summary>
      <param name="facility">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.AddFacility``1">
      <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility" /> facility to the kernel.
            </summary>
      <typeparam name="T">The facility type.</typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.AddFacility``1(System.Action{``0})">
      <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility" /> facility to the kernel.
            </summary>
      <typeparam name="T">The facility type.</typeparam>
      <param name="onCreate">The callback for creation.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.AddHandlerSelector(Castle.MicroKernel.IHandlerSelector)">
      <summary>
              Register a new component resolver that can take part in the decision
              making about which handler to resolve
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.AddHandlersFilter(Castle.MicroKernel.IHandlersFilter)">
      <summary>
              Register a new component resolver that can take part in the decision
              making about which handler(s) to resolve and in which order
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.AddSubSystem(System.String,Castle.MicroKernel.ISubSystem)">
      <summary>
              Adds (or replaces) an <see cref="T:Castle.MicroKernel.ISubSystem" /></summary>
      <param name="name">
      </param>
      <param name="subsystem">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.GetAssignableHandlers(System.Type)">
      <summary>
              Return handlers for components that 
              implements the specified service. 
              The check is made using IsAssignableFrom
            </summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.GetFacilities">
      <summary>
              Returns the facilities registered on the kernel.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.GetHandler(System.String)">
      <summary>
              Returns the <see cref="T:Castle.MicroKernel.IHandler" />
              for the specified component name.
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.GetHandler(System.Type)">
      <summary>
              Returns the <see cref="T:Castle.MicroKernel.IHandler" />
              for the specified service.
            </summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.GetHandlers(System.Type)">
      <summary>
              Return handlers for components that 
              implements the specified service.
            </summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.GetSubSystem(System.String)">
      <summary>
              Returns an implementation of <see cref="T:Castle.MicroKernel.ISubSystem" />
              for the specified name. 
              <seealso cref="T:Castle.MicroKernel.SubSystemConstants" /></summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.HasComponent(System.String)">
      <summary>
              Returns <c>true</c> if a component with given <paramref name="name" /> was registered, otherwise <c>false</c>.
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.HasComponent(System.Type)">
      <summary>
              Returns true if the specified service was registered
            </summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.Register(Castle.MicroKernel.Registration.IRegistration[])">
      <summary>
              Registers the components with the <see cref="T:Castle.MicroKernel.IKernel" />. The instances of <see cref="T:Castle.MicroKernel.Registration.IRegistration" /> are produced by fluent registration API.
              Most common entry points are <see cref="M:Castle.MicroKernel.Registration.Component.For``1" /> method to register a single type or (recommended in most cases) 
              <see cref="M:Castle.MicroKernel.Registration.Classes.FromThisAssembly" />.
              Let the Intellisense drive you through the fluent API past those entry points. For details see the documentation at http://j.mp/WindsorApi
            </summary>
      <example>
        <code>
                kernel.Register(Component.For&lt;IService&gt;().ImplementedBy&lt;DefaultService&gt;().LifestyleTransient());
              </code>
      </example>
      <example>
        <code>
                kernel.Register(Classes.FromThisAssembly().BasedOn&lt;IService&gt;().WithServiceDefaultInterfaces().Configure(c =&gt; c.LifestyleTransient()));
              </code>
      </example>
      <param name="registrations">The component registrations created by <see cref="M:Castle.MicroKernel.Registration.Component.For``1" />, <see cref="M:Castle.MicroKernel.Registration.Classes.FromThisAssembly" /> or different entry method to the fluent API.</param>
      <returns>The kernel.</returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.ReleaseComponent(System.Object)">
      <summary>
              Releases a component instance. This allows
              the kernel to execute the proper decommission 
              lifecycles on the component instance.
            </summary>
      <param name="instance">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.RemoveChildKernel(Castle.MicroKernel.IKernel)">
      <summary>
              Remove child kernel
            </summary>
      <param name="kernel">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.AddFacility(System.String,Castle.MicroKernel.IFacility)">
      <summary>
              Adds a <see cref="T:Castle.MicroKernel.IFacility" /> to the kernel.
            </summary>
      <param name="key">
      </param>
      <param name="facility">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.AddFacility``1(System.String)">
      <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility" /> facility to the kernel.
            </summary>
      <typeparam name="T">The facility type.</typeparam>
      <param name="key">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.AddFacility``1(System.String,System.Action{``0})">
      <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility" /> facility to the kernel.
            </summary>
      <typeparam name="T">The facility type.</typeparam>
      <param name="key">
      </param>
      <param name="onCreate">The callback for creation.</param>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.Resolve(System.String,System.Object)">
      <summary>
              Returns the component instance by the component key
              using dynamic arguments
            </summary>
      <param name="key">Key to resolve</param>
      <param name="argumentsAsAnonymousType">Arguments to resolve the services</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.Resolve(System.String,System.Collections.IDictionary)">
      <summary>
              Returns the component instance by the component key
              using dynamic arguments
            </summary>
      <param name="key">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.Resolve(System.Type)">
      <summary>
              Returns the component instance by the service type
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.Resolve(System.Type,System.Collections.IDictionary)">
      <summary>
              Returns the component instance by the service type
              using dynamic arguments
            </summary>
      <param name="service">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.Resolve(System.Type,System.Object)">
      <summary>
              Returns the component instance by the service type
              using dynamic arguments
            </summary>
      <param name="service">Service to resolve</param>
      <param name="argumentsAsAnonymousType">Arguments to resolve the services</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.Resolve(System.String,System.Type)">
      <summary>
              Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.Resolve``1(System.Collections.IDictionary)">
      <summary>
              Returns the component instance by the service type
              using dynamic arguments
            </summary>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.Resolve``1(System.Object)">
      <summary>
              Returns the component instance by the service type
              using dynamic arguments
            </summary>
      <param name="argumentsAsAnonymousType">Arguments to resolve the services</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.Resolve``1">
      <summary>
              Returns the component instance by the component key
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.Resolve``1(System.String)">
      <summary>
              Returns a component instance by the key
            </summary>
      <param name="key">Component's key</param>
      <typeparam name="T">Service type</typeparam>
      <returns>The Component instance</returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.Resolve``1(System.String,System.Collections.IDictionary)">
      <summary>
              Returns a component instance by the key
            </summary>
      <typeparam name="T">Service type</typeparam>
      <param name="key">Component's key</param>
      <param name="arguments">
      </param>
      <returns>The Component instance</returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.Resolve(System.String,System.Type,System.Collections.IDictionary)">
      <summary>
              Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="service">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.ResolveAll(System.Type)">
      <summary>
              Returns all the valid component instances by
              the service type
            </summary>
      <param name="service">The service type</param>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.ResolveAll(System.Type,System.Collections.IDictionary)">
      <summary>
              Returns all the valid component instances by
              the service type
            </summary>
      <param name="service">The service type</param>
      <param name="arguments">Arguments to resolve the services</param>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.ResolveAll(System.Type,System.Object)">
      <summary>
              Returns all the valid component instances by
              the service type
            </summary>
      <param name="service">The service type</param>
      <param name="argumentsAsAnonymousType">Arguments to resolve the services</param>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.ResolveAll``1">
      <summary>
              Returns component instances that implement TService
            </summary>
      <typeparam name="TService">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.ResolveAll``1(System.Collections.IDictionary)">
      <summary>
              Returns component instances that implement TService
            </summary>
      <typeparam name="TService">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernel.ResolveAll``1(System.Object)">
      <summary>
              Returns component instances that implement TService
            </summary>
      <typeparam name="TService">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.MicroKernel.IKernel.ComponentModelBuilder">
      <summary>
              Returns the implementation of <see cref="T:Castle.MicroKernel.IComponentModelBuilder" /></summary>
    </member>
    <member name="P:Castle.MicroKernel.IKernel.ConfigurationStore">
      <summary>
              Gets or sets the implementation of <see cref="T:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore" /></summary>
    </member>
    <member name="P:Castle.MicroKernel.IKernel.GraphNodes">
      <summary>
              Graph of components and interactions.
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.IKernel.HandlerFactory">
      <summary>
              Returns the implementation of <see cref="T:Castle.MicroKernel.IHandlerFactory" /></summary>
    </member>
    <member name="P:Castle.MicroKernel.IKernel.Parent">
      <summary>
              Returns the parent kernel
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.IKernel.ProxyFactory">
      <summary>
              Gets or sets the implementation of <see cref="T:Castle.MicroKernel.IProxyFactory" />
              allowing different strategies for proxy creation.
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.IKernel.ReleasePolicy">
      <summary>
              Gets or sets the implementation for <see cref="T:Castle.MicroKernel.IReleasePolicy" /></summary>
    </member>
    <member name="P:Castle.MicroKernel.IKernel.Resolver">
      <summary>
              Returns the implementation for <see cref="T:Castle.MicroKernel.IDependencyResolver" /></summary>
    </member>
    <member name="P:Castle.MicroKernel.IKernel.Item(System.String)">
      <summary>
              Returns the component instance by the key
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.IKernel.Item(System.Type)">
      <summary>
              Returns the component instance by the service type
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.IKernelInternal">
      <summary>
            Extended contract of kernel, used internally.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.IKernelInternal.AddCustomComponent(Castle.Core.ComponentModel)">
      <summary>
            Adds a custom made <see cref="T:Castle.Core.ComponentModel" />. Used by facilities.
            </summary>
      <param name="model">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IKernelInternal.CreateComponentActivator(Castle.Core.ComponentModel)">
      <summary>
            Constructs an implementation of <see cref="T:Castle.MicroKernel.IComponentActivator" /> for the given <see cref="T:Castle.Core.ComponentModel" /></summary>
      <param name="model">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IKernelInternal.Resolve(System.String,System.Type,System.Collections.IDictionary,Castle.MicroKernel.IReleasePolicy)">
      <summary>
            Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="service">
      </param>
      <param name="arguments">
      </param>
      <param name="policy">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.MicroKernel.IKernelInternal.Logger">
      <summary>
            Internal logger used by the container (not just <see cref="T:Castle.MicroKernel.IKernelInternal" /> implementation itself but also other classes too) to log information about what's happening in the container.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.DefaultKernel">
      <summary>
              Default implementation of <see cref="T:Castle.MicroKernel.IKernel" />. This implementation is complete and also support a kernel hierarchy (sub containers).
            </summary>
      <summary>
              Default implementation of <see cref="T:Castle.MicroKernel.IKernel" />. 
              This implementation is complete and also support a kernel 
              hierarchy (sub containers).
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.DefaultKernel.childKernels">
      <summary>
              List of sub containers.
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.DefaultKernel.facilities">
      <summary>
              List of <see cref="T:Castle.MicroKernel.IFacility" /> registered.
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.DefaultKernel.subsystems">
      <summary>
              Map of subsystems registered.
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.DefaultKernel.parentKernel">
      <summary>
              The parent kernel, if exists.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.#ctor">
      <summary>
              Constructs a DefaultKernel with no component proxy support.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.#ctor(Castle.MicroKernel.IDependencyResolver,Castle.MicroKernel.IProxyFactory)">
      <summary>
              Constructs a DefaultKernel with the specified implementation of <see cref="T:Castle.MicroKernel.IProxyFactory" /> and <see cref="T:Castle.MicroKernel.IDependencyResolver" /></summary>
      <param name="resolver">
      </param>
      <param name="proxyFactory">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.#ctor(Castle.MicroKernel.IProxyFactory)">
      <summary>
              Constructs a DefaultKernel with the specified implementation of <see cref="T:Castle.MicroKernel.IProxyFactory" /></summary>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.Dispose">
      <summary>
              Starts the process of component disposal.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.GetAssignableHandlers(System.Type)">
      <summary>
              Return handlers for components that implements the specified service. The check is made using IsAssignableFrom
            </summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.GetFacilities">
      <summary>
              Returns the facilities registered on the kernel.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.GetHandlers(System.Type)">
      <summary>
              Return handlers for components that implements the specified service.
            </summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.Register(Castle.MicroKernel.Registration.IRegistration[])">
      <summary>
              Registers the components with the <see cref="T:Castle.MicroKernel.IKernel" />. The instances of <see cref="T:Castle.MicroKernel.Registration.IRegistration" /> are produced by fluent registration API. Most common entry points are
              <see cref="M:Castle.MicroKernel.Registration.Component.For``1" /> method to register a single type or (recommended in most cases) <see cref="M:Castle.MicroKernel.Registration.Classes.FromThisAssembly" />. Let the Intellisense drive you through the
              fluent
              API past those entry points. For details see the documentation at http://j.mp/WindsorApi
            </summary>
      <example>
        <code>kernel.Register(Component.For&lt;IService&gt;().ImplementedBy&lt;DefaultService&gt;().LifestyleTransient());</code>
      </example>
      <example>
        <code>kernel.Register(Classes.FromThisAssembly().BasedOn&lt;IService&gt;().WithServiceDefaultInterfaces().Configure(c =&gt; c.LifestyleTransient()));</code>
      </example>
      <param name="registrations"> The component registrations created by <see cref="M:Castle.MicroKernel.Registration.Component.For``1" /> , <see cref="M:Castle.MicroKernel.Registration.Classes.FromThisAssembly" /> or different entry method to the fluent
            API. </param>
      <returns> The kernel. </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.ReleaseComponent(System.Object)">
      <summary>
              Releases a component instance. This allows the kernel to execute the proper decommission lifecycles on the component instance.
            </summary>
      <param name="instance">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.CreateLifestyleManager(Castle.Core.ComponentModel,Castle.MicroKernel.IComponentActivator)">
      <summary>
              Creates an implementation of <see cref="T:Castle.MicroKernel.ILifestyleManager" /> based on <see cref="T:Castle.Core.LifestyleType" /> and invokes <see cref="M:Castle.MicroKernel.ILifestyleManager.Init(Castle.MicroKernel.IComponentActivator,Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)" /> to initialize the newly created manager.
            </summary>
      <param name="model">
      </param>
      <param name="activator">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.DisposeHandler(Castle.MicroKernel.IHandler)">
      <remarks>
              It is the responsibility of the kernel to ensure that handler is only ever disposed once.
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.String,System.Collections.IDictionary)">
      <summary>
              Returns the component instance by the component key
              using dynamic arguments
            </summary>
      <param name="key">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.String,System.Object)">
      <summary>
              Returns the component instance by the component key
              using dynamic arguments
            </summary>
      <param name="key">
      </param>
      <param name="argumentsAsAnonymousType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.String,System.Type)">
      <summary>
              Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.String,System.Type,System.Collections.IDictionary)">
      <summary>
              Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="service">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.Resolve``1(System.Collections.IDictionary)">
      <summary>
              Returns the component instance by the service type
              using dynamic arguments
            </summary>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.Resolve``1(System.Object)">
      <summary>
              Returns the component instance by the service type
              using dynamic arguments
            </summary>
      <param name="argumentsAsAnonymousType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.Resolve``1">
      <summary>
              Returns the component instance by the component key
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.Resolve``1(System.String)">
      <summary>
              Returns a component instance by the key
            </summary>
      <param name="key">Component's key</param>
      <typeparam name="T">Service type</typeparam>
      <returns>
              The Component instance
            </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.Resolve``1(System.String,System.Collections.IDictionary)">
      <summary>
              Returns a component instance by the key
            </summary>
      <typeparam name="T">Service type</typeparam>
      <param name="key">Component's key</param>
      <param name="arguments">
      </param>
      <returns>
              The Component instance
            </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.Type)">
      <summary>
              Returns the component instance by the service type
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.Type,System.Collections.IDictionary)">
      <summary>
              Returns the component instance by the service type
              using dynamic arguments
            </summary>
      <param name="service">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.Type,System.Object)">
      <summary>
              Returns the component instance by the service type
              using dynamic arguments
            </summary>
      <param name="service">
      </param>
      <param name="argumentsAsAnonymousType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll(System.Type)">
      <summary>
              Returns all the valid component instances by
              the service type
            </summary>
      <param name="service">The service type</param>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll(System.Type,System.Collections.IDictionary)">
      <summary>
              Returns all the valid component instances by
              the service type
            </summary>
      <param name="service">The service type</param>
      <param name="arguments">
              Arguments to resolve the services
            </param>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll(System.Type,System.Object)">
      <summary>
              Returns all the valid component instances by
              the service type
            </summary>
      <param name="service">The service type</param>
      <param name="argumentsAsAnonymousType">
              Arguments to resolve the services
            </param>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll``1(System.Object)">
      <summary>
              Returns component instances that implement TService
            </summary>
      <typeparam name="TService">
      </typeparam>
      <param name="argumentsAsAnonymousType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll``1(System.Collections.IDictionary)">
      <summary>
              Returns component instances that implement TService
            </summary>
      <typeparam name="TService">
      </typeparam>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.DefaultKernel.ResolveAll``1">
      <summary>
              Returns component instances that implement TService
            </summary>
      <typeparam name="TService">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.MicroKernel.DefaultKernel.GraphNodes">
      <summary>
              Graph of components and interactions.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.CircularDependencyException">
      <summary>
              Exception throw when a circular dependency is detected
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.CircularDependencyException.#ctor(System.String)">
      <summary>
              Initializes a new instance of the
              <see cref="T:Castle.MicroKernel.CircularDependencyException" />
              class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Castle.MicroKernel.CircularDependencyException.#ctor(System.String,System.Exception)">
      <summary>
              Initializes a new instance of the
              <see cref="T:Castle.MicroKernel.CircularDependencyException" />
              class.
            </summary>
      <param name="message">The message.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="M:Castle.MicroKernel.CircularDependencyException.#ctor(System.String,Castle.Core.ComponentModel)">
      <summary>
              Initializes a new instance of the
              <see cref="T:Castle.MicroKernel.CircularDependencyException" />
              class.
            </summary>
      <param name="message">
      </param>
      <param name="component">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.CircularDependencyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
              Initializes a new instance of the
              <see cref="T:Castle.MicroKernel.CircularDependencyException" />
              class.
            </summary>
      <param name="info">The
              <see cref="T:System.Runtime.Serialization.SerializationInfo" />
              that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The
              <see cref="T:System.Runtime.Serialization.StreamingContext" />
              that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The
              <paramref name="info" />
              parameter is
              <see langword="null" />
              .</exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is
              <see langword="null" />
              or
              <see cref="P:System.Exception.HResult" />
              is zero (0).</exception>
    </member>
    <member name="T:Castle.MicroKernel.ComponentNotFoundException">
      <summary>
              Exception threw when a request for a component
              cannot be satisfied because the component does not
              exist in the container
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ComponentNotFoundException.#ctor(System.String,System.String)">
      <summary>
              Initializes a new instance of the
              <see cref="T:Castle.MicroKernel.ComponentNotFoundException" />
              class.
            </summary>
      <param name="name">The name.</param>
      <param name="message">Exception message.</param>
    </member>
    <member name="M:Castle.MicroKernel.ComponentNotFoundException.#ctor(System.Type,System.String)">
      <summary>
              Initializes a new instance of the
              <see cref="T:Castle.MicroKernel.ComponentNotFoundException" />
              class.
            </summary>
      <param name="service">The service.</param>
      <param name="message">Exception message.</param>
    </member>
    <member name="M:Castle.MicroKernel.ComponentNotFoundException.#ctor(System.Type)">
      <summary>
              Initializes a new instance of the
              <see cref="T:Castle.MicroKernel.ComponentNotFoundException" />
              class.
            </summary>
      <param name="service">The service.</param>
    </member>
    <member name="M:Castle.MicroKernel.ComponentNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
              Initializes a new instance of the
              <see cref="T:Castle.MicroKernel.ComponentNotFoundException" />
              class.
            </summary>
      <param name="info">The object that holds the serialized object data.</param>
      <param name="context">The contextual information about the source or destination.</param>
    </member>
    <member name="T:Castle.MicroKernel.ComponentRegistrationException">
      <summary>
              Exception threw when there is a problem
              registering a component
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ComponentRegistrationException.#ctor(System.String)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentRegistrationException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Castle.MicroKernel.ComponentRegistrationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.ComponentRegistrationException" /> class.
            </summary>
      <param name="info">The object that holds the serialized object data.</param>
      <param name="context">The contextual information about the source or destination.</param>
    </member>
    <member name="T:Castle.MicroKernel.IHandlersFilter">
      <summary>
              Implementation of this interface allows for extension of the way
              the container looks up multiple handlers. It provides the necessary
              hook to allow for business logic to prioritize, filter, and sort
              handlers when resolving multiple handlers.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.IHandlersFilter.HasOpinionAbout(System.Type)">
      <summary>
              Whatever the selector has an opinion about resolving a component with the 
              specified service and key.
            </summary>
      <param name="service">The service interface that we want to resolve</param>
    </member>
    <member name="M:Castle.MicroKernel.IHandlersFilter.SelectHandlers(System.Type,Castle.MicroKernel.IHandler[])">
      <summary>
              Select the appropriate handlers (if any) from the list of defined handlers,
              returning them in the order they should be executed.
              The returned handlers should members from the <paramref name="handlers" /> array.
            </summary>
      <param name="service">The service interface that we want to resolve</param>
      <param name="handlers">The defined handlers</param>
      <returns>The selected handlers, or an empty array, or null</returns>
    </member>
    <member name="T:Castle.MicroKernel.KernelException">
      <summary>
              Exception threw by Kernel operations that failed
              for some reason.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.KernelException.#ctor(System.String)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.KernelException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Castle.MicroKernel.KernelException.#ctor(System.String,System.Exception)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.KernelException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="M:Castle.MicroKernel.KernelException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.KernelException" /> class.
            </summary>
      <param name="info">The object that holds the serialized object data.</param>
      <param name="context">The contextual information about the source or destination.</param>
    </member>
    <member name="T:Castle.MicroKernel.Facilities.FacilityException">
      <summary>
              Base exception to be used by facilities.
            </summary>
    </member>
    <member name="M:Castle.Facilities.Startable.StartableFacilityRegistrationExtensions.StartUsingMethod``1(Castle.MicroKernel.Registration.ComponentRegistration{``0},System.String)">
      <summary>
              Assigns the start method for the startable.
            </summary>
      <param name="registration">
      </param>
      <param name="startMethod">The start method.</param>
      <returns>
      </returns>
      <remarks>
              Be sure that you first added the <see cref="T:Castle.Facilities.Startable.StartableFacility" /> 
              to the kernel, before registering this component.
            </remarks>
    </member>
    <member name="M:Castle.Facilities.Startable.StartableFacilityRegistrationExtensions.StartUsingMethod``1(Castle.MicroKernel.Registration.ComponentRegistration{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Action}})">
      <summary>
              Assigns the start method for the startable.
            </summary>
      <param name="registration">
      </param>
      <param name="methodToUse">Method to use. something like: StartUsingMethod(s =&gt; s.Start)</param>
      <returns>
      </returns>
      <remarks>
              Be sure that you first added the <see cref="T:Castle.Facilities.Startable.StartableFacility" /> 
              to the kernel, before registering this component.
            </remarks>
    </member>
    <member name="M:Castle.Facilities.Startable.StartableFacilityRegistrationExtensions.StopUsingMethod``1(Castle.MicroKernel.Registration.ComponentRegistration{``0},System.String)">
      <summary>
              Assigns the stop method for the startable.
            </summary>
      <param name="registration">
      </param>
      <param name="stopMethod">The stop method.</param>
      <returns>
      </returns>
      <remarks>
              Be sure that you first added the <see cref="T:Castle.Facilities.Startable.StartableFacility" /> 
              to the kernel, before registering this component.
            </remarks>
    </member>
    <member name="M:Castle.Facilities.Startable.StartableFacilityRegistrationExtensions.StopUsingMethod``1(Castle.MicroKernel.Registration.ComponentRegistration{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Action}})">
      <summary>
              Assigns the stop method for the startable.
            </summary>
      <param name="registration">
      </param>
      <param name="methodToUse">Method to use. something like: StartUsingMethod(s =&gt; s.Start)</param>
      <returns>
      </returns>
      <remarks>
              Be sure that you first added the <see cref="T:Castle.Facilities.Startable.StartableFacility" /> 
              to the kernel, before registering this component.
            </remarks>
    </member>
    <member name="T:Castle.Facilities.TypedFactory.FactoryEntry">
      <summary>
              Legacy class from old impl. of the facility. Do not use it.
            </summary>
    </member>
    <member name="T:Castle.Core.Interceptor.IOnBehalfAware">
      <summary>
              Interceptors might implement this to receive the
              ComponentModel on behalf of the component where the
              interceptor is acting.
            </summary>
    </member>
    <member name="T:Castle.Facilities.TypedFactory.Internal.FactoryInterceptor">
      <summary>
              Legacy interceptor for old impl. of the facility.
            </summary>
    </member>
    <member name="T:Castle.Facilities.TypedFactory.TypedFactoryComponentResolver">
      <summary>
              Represents a single component to be resolved via Typed Factory
            </summary>
    </member>
    <member name="M:Castle.Facilities.TypedFactory.TypedFactoryComponentResolver.Resolve(Castle.MicroKernel.IKernelInternal,Castle.MicroKernel.IReleasePolicy)">
      <summary>
              Resolves the component(s) from given kernel.
            </summary>
      <param name="kernel">
      </param>
      <param name="scope">
      </param>
      <returns>Resolved component(s).</returns>
    </member>
    <member name="T:Castle.Facilities.TypedFactory.TypedFactoryFacility">
      <summary>
              Provides automatically generated factories on top of interfaces or delegates that
              you can use to pull components out of the container without ever referencing it 
              explicitly.
            </summary>
    </member>
    <member name="M:Castle.Facilities.TypedFactory.TypedFactoryRegistrationExtensions.AsFactory``1(Castle.MicroKernel.Registration.ComponentRegistration{``0})">
      <summary>
              Marks the component as typed factory.
            </summary>
      <typeparam name="TFactoryInterface">
      </typeparam>
      <param name="registration">
      </param>
      <returns>
      </returns>
      <remarks>
              Only interfaces and delegates are legal to use as typed factories. Methods with out parameters are not allowed.
              When registering component as typed factory no implementation should be provided (in case there is any it will be ignored).
              Typed factories rely on <see cref="T:Castle.DynamicProxy.IInterceptorSelector" /> set internally, so users should not set interceptor selectors explicitly;
              otherwise the factory will not function correctly.
            </remarks>
    </member>
    <member name="M:Castle.Facilities.TypedFactory.TypedFactoryRegistrationExtensions.AsFactory``1(Castle.MicroKernel.Registration.ComponentRegistration{``0},System.String)">
      <summary>
              Marks the component as typed factory.
            </summary>
      <typeparam name="TFactoryInterface">
      </typeparam>
      <param name="registration">
      </param>
      <param name="selectorComponentName">Name of the <see cref="T:Castle.Facilities.TypedFactory.ITypedFactoryComponentSelector" /> component to be used for this factory</param>
      <returns>
      </returns>
      <remarks>
              Only interfaces and delegates are legal to use as typed factories. Methods with out parameters are not allowed.
              When registering component as typed factory no implementation should be provided (in case there is any it will be ignored).
              Typed factories rely on <see cref="T:Castle.DynamicProxy.IInterceptorSelector" /> set internally, so users should not set interceptor selectors explicitly;
              otherwise the factory will not function correctly.
            </remarks>
    </member>
    <member name="M:Castle.Facilities.TypedFactory.TypedFactoryRegistrationExtensions.AsFactory``1(Castle.MicroKernel.Registration.ComponentRegistration{``0},System.Type)">
      <summary>
              Marks the component as typed factory.
            </summary>
      <typeparam name="TFactoryInterface">
      </typeparam>
      <param name="registration">
      </param>
      <param name="selectorComponentType">Type of the <see cref="T:Castle.Facilities.TypedFactory.ITypedFactoryComponentSelector" /> component to be used for this factory</param>
      <returns>
      </returns>
      <remarks>
              Only interfaces and delegates are legal to use as typed factories. Methods with out parameters are not allowed.
              When registering component as typed factory no implementation should be provided (in case there is any it will be ignored).
              Typed factories rely on <see cref="T:Castle.DynamicProxy.IInterceptorSelector" /> set internally, so users should not set interceptor selectors explicitly;
              otherwise the factory will not function correctly.
            </remarks>
    </member>
    <member name="M:Castle.Facilities.TypedFactory.TypedFactoryRegistrationExtensions.AsFactory``1(Castle.MicroKernel.Registration.ComponentRegistration{``0},Castle.Facilities.TypedFactory.ITypedFactoryComponentSelector)">
      <summary>
              Marks the component as typed factory.
            </summary>
      <typeparam name="TFactoryInterface">
      </typeparam>
      <param name="registration">
      </param>
      <param name="selector">The <see cref="T:Castle.Facilities.TypedFactory.ITypedFactoryComponentSelector" /> instance to be used for this factory</param>
      <returns>
      </returns>
      <remarks>
              Only interfaces and delegates are legal to use as typed factories. Methods with out parameters are not allowed.
              When registering component as typed factory no implementation should be provided (in case there is any it will be ignored).
              Typed factories rely on <see cref="T:Castle.DynamicProxy.IInterceptorSelector" /> set internally, so users should not set interceptor selectors explicitly;
              otherwise the factory will not function correctly.
            </remarks>
    </member>
    <member name="M:Castle.Facilities.TypedFactory.TypedFactoryRegistrationExtensions.AsFactory``1(Castle.MicroKernel.Registration.ComponentRegistration{``0},System.Action{Castle.Facilities.TypedFactory.TypedFactoryConfiguration})">
      <summary>
              Marks the component as typed factory.
            </summary>
      <typeparam name="TFactoryInterface">
      </typeparam>
      <param name="registration">
      </param>
      <param name="configuration">
      </param>
      <returns>
      </returns>
      <remarks>
              Only interfaces and delegates are legal to use as typed factories. Methods with out parameters are not allowed.
              When registering component as typed factory no implementation should be provided (in case there is any it will be ignored).
              Typed factories rely on <see cref="T:Castle.DynamicProxy.IInterceptorSelector" /> set internally, so users should not set interceptor selectors explicitly;
              otherwise the factory will not function correctly.
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.ParentHandlerWrapper.#ctor(Castle.MicroKernel.IHandler,Castle.MicroKernel.ISubDependencyResolver,Castle.MicroKernel.IReleasePolicy)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Handlers.ParentHandlerWrapper" /> class.
            </summary>
      <param name="parentHandler">The parent handler.</param>
      <param name="childResolver">The child resolver.</param>
      <param name="parentReleasePolicy">Release policy of the parent container.</param>
    </member>
    <member name="M:Castle.MicroKernel.Handlers.DefaultGenericHandler.CloneParentProperties(Castle.Core.ComponentModel)">
      <summary>
              Clone some of the parent componentmodel properties to the generic subhandler.
            </summary>
      <remarks>
              The following properties are copied: <list type="bullet"><item><description>
                                                         The
                                                         <see cref="T:Castle.Core.LifestyleType" /></description></item><item><description>
                                                         The
                                                         <see cref="P:Castle.Core.ComponentModel.Interceptors" /></description></item></list></remarks>
      <param name="newModel"> the subhandler </param>
    </member>
    <member name="T:Castle.MicroKernel.IHandlerFactory">
      <summary>
                Extension point to allow the developer to use his implementation of <see cref="T:Castle.MicroKernel.IHandler" /></summary>
    </member>
    <member name="T:Castle.MicroKernel.ComponentDataDelegate">
      <summary>
              Represents a delegate which holds basic information about a component.
            </summary>
      <param name="key">Key which identifies the component</param>
      <param name="handler">handler that holds this component and is capable of 
              creating an instance of it.
            </param>
    </member>
    <member name="T:Castle.MicroKernel.ComponentInstanceDelegate">
      <summary>
              Represents a delegate which holds basic information about a component
              and its instance.
            </summary>
      <param name="model">Component meta information</param>
      <param name="instance">Component instance</param>
    </member>
    <member name="T:Castle.MicroKernel.ComponentModelDelegate">
      <summary>
              Represents a delegate which holds the information about the 
              component
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.ServiceDelegate">
      <summary>
              Represents a delegate which holds the information about a service.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.HandlerDelegate">
      <summary>
              Represents a delegate which holds a handler
            </summary>
      <param name="handler">handler that holds a component and is capable of 
              creating an instance of it.
            </param>
      <param name="stateChanged">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.DependencyDelegate">
      <summary>
              Represents a delegate which holds dependency
              resolving information.
            </summary>
    </member>
    <member name="T:Castle.Core.Internal.IVertex">
      <summary>
              Abstract representation of a vertex.
            </summary>
    </member>
    <member name="P:Castle.Core.Internal.GraphNode.Dependents">
      <summary>The nodes that this node depends on</summary>
    </member>
    <member name="F:Castle.Core.Internal.VertexColor.White">
      <summary>
              The node has not been visited yet
            </summary>
    </member>
    <member name="F:Castle.Core.Internal.VertexColor.Gray">
      <summary>
              This node is in the process of being visited
            </summary>
    </member>
    <member name="F:Castle.Core.Internal.VertexColor.Black">
      <summary>
              This now was visited
            </summary>
    </member>
    <member name="T:Castle.Core.Internal.ColorsSet">
      <summary>
              Represents a collection of objects
              which are guaranteed to be unique 
              and holds a color for them
            </summary>
    </member>
    <member name="T:Castle.Core.Internal.TimestampSet">
      <summary>
              Holds a timestamp (integer) 
              for a given item
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.LifecycleConcerns.DisposalConcern">
      <summary>
            Summary description for DisposalConcern.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.LifecycleConcerns.InitializationConcern">
      <summary>
            Summary description for InitializationConcern.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.LifecycleConcerns.LateBoundConcerns`1">
      <summary>
              Lifetime concern that works for components that don't have their actual type determined upfront
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.LifecycleConcerns.LateBoundCommissionConcerns">
      <summary>
              Lifetime concern that works for components that don't have their actual type determined upfront
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.LifecycleConcerns.LateBoundDecommissionConcerns">
      <summary>
              Lifetime concern that works for components that don't have their actual type determined upfront
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.LifecycleConcerns.SupportInitializeConcern">
      <summary>
              Summary description for SupportInitializeConcern.
            </summary>
    </member>
    <member name="T:Castle.Core.IRecyclable">
      <summary>
              Only called for components that 
              belongs to a pool when the component
              comes back to the pool.
            </summary>
    </member>
    <member name="M:Castle.Core.IRecyclable.Recycle">
      <summary>
              Implementors should perform any 
              initialization/clean up.
            </summary>
    </member>
    <member name="T:Castle.Core.IStartable">
      <summary>
              Interface for components that wish to be started and stopped by the container
            </summary>
    </member>
    <member name="M:Castle.Core.IStartable.Start">
      <summary>
              Starts this instance.
            </summary>
    </member>
    <member name="M:Castle.Core.IStartable.Stop">
      <summary>
              Stops this instance.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.ILifestyleManager">
      <summary>
              The <c>ILifestyleManager</c> implements 
              a strategy for a given lifestyle, like singleton, per-thread
              and transient.
            </summary>
      <remarks>
              The responsibility of <c>ILifestyleManager</c>
              is only the management of lifestyle. It should rely on
              <see cref="T:Castle.MicroKernel.IComponentActivator" /> to obtain a new component instance
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.ILifestyleManager.Init(Castle.MicroKernel.IComponentActivator,Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
              Initializes the <c>ILifestyleManager</c> with the 
              <see cref="T:Castle.MicroKernel.IComponentActivator" /></summary>
      <param name="componentActivator">
      </param>
      <param name="kernel">
      </param>
      <param name="model">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.ILifestyleManager.Release(System.Object)">
      <summary>
              Implementors should release the component instance based
              on the lifestyle semantic, for example, singleton components
              should not be released on a call for release, instead they should
              release them when disposed is invoked.
            </summary>
      <param name="instance">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.ILifestyleManager.Resolve(Castle.MicroKernel.Context.CreationContext,Castle.MicroKernel.IReleasePolicy)">
      <summary>
              Implementors should return the component instance based on the lifestyle semantic.
              Also the instance should be set to <see cref="M:Castle.MicroKernel.Burden.SetRootInstance(System.Object)" />, <see cref="P:Castle.MicroKernel.Burden.RequiresPolicyRelease" /> should be also set if needed
              and if a new instance was created it should be passed on to <see cref="M:Castle.MicroKernel.IReleasePolicy.Track(System.Object,Castle.MicroKernel.Burden)" /> of <paramref name="releasePolicy" />.
            </summary>
      <param name="context" />
      <param name="releasePolicy" />
      <returns>
      </returns>
    </member>
    <member name="T:Castle.MicroKernel.Lifestyle.AbstractLifestyleManager">
      <summary>
              Base implementation of <see cref="T:Castle.MicroKernel.ILifestyleManager" /></summary>
    </member>
    <member name="M:Castle.MicroKernel.Lifestyle.AbstractLifestyleManager.Dispose">
      <summary>
              Invoked when the container gets disposed. The container will not call it multiple times in multithreaded environments.
              However it may be called at the same time when some out of band release mechanism is in progress. Resolving those potential
              issues is the task of implementors
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Lifestyle.Scoped.IScopeAccessor">
      <summary>
              Provides access to <see cref="T:Castle.MicroKernel.Lifestyle.Scoped.IScopeCache" /> held in whatever is appropriate for given scope.
            </summary>
      <remarks>
              Implementors should also ensure proper initialization of <see cref="T:Castle.MicroKernel.Lifestyle.Scoped.IScopeCache" /> when accessed for the first time and ensure a thread safe implementation is used when scope or cache access can cause threading issues if non thread safe cache is used.
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.Lifestyle.Scoped.IScopeAccessor.GetScope(Castle.MicroKernel.Context.CreationContext)">
      <summary>
              Provides access to <see cref="T:Castle.MicroKernel.Lifestyle.Scoped.IScopeCache" /> for currently resolved component.
            </summary>
      <param name="context">Current creation context</param>
      <exception cref="T:System.InvalidOperationException"> Thrown when scope cache could not be accessed.</exception>
    </member>
    <member name="M:Castle.MicroKernel.Lifestyle.PerWebRequestLifestyleModule.YieldScope">
      <summary>
              Returns current request's scope and detaches it from the request context.
              Does not throw if scope or context not present. To be used for disposing of the context.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.MicroKernel.Lifestyle.PoolableLifestyleManager">
      <summary>
              Manages a pool of objects.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Lifestyle.Pool.IPool">
      <summary>
              Pool implementation contract.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Lifestyle.Pool.IPool.Release(System.Object)">
      <summary>
              Implementors should release the instance or put it
              on the pool
            </summary>
      <param name="instance">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.Lifestyle.Scoped.IScopeCache">
      <summary>Represents persistence mechanism for instances of components that are supposed to be reused within scope managing the cache.</summary>
    </member>
    <member name="P:Castle.MicroKernel.Lifestyle.Scoped.IScopeCache.Item(System.Object)">
      <summary>
                Saves or retrieves a <see cref="T:Castle.MicroKernel.Burden" /> stored in the cache associated with the given <paramref name="id" />.
            </summary>
      <exception cref="T:System.ArgumentNullException">
                Thrown when <paramref name="id" /> is null.
            </exception>
      <exception cref="T:System.ArgumentException">
                Thrown when there is already a <see cref="T:Castle.MicroKernel.Burden" /> associated with given
                <paramref name="id" />
                value in the cache.
            </exception>
      <remarks>The interface gives no thread safety guarantees. When the scope can be accessed from multiple threads the implementor should ensure thread safety.</remarks>
    </member>
    <member name="T:Castle.MicroKernel.Lifestyle.Scoped.CallContextLifetimeScope">
      <summary>
              Provides explicit lifetime scoping within logical path of execution. Used for types with <see cref="F:Castle.Core.LifestyleType.Scoped" /> .
            </summary>
      <remarks>
              The scope is passed on to child threads, including ThreadPool threads. The capability is limited to single <see cref="T:System.AppDomain" /> and should be used cautiously as call to <see cref="M:Castle.MicroKernel.Lifestyle.Scoped.CallContextLifetimeScope.Dispose" /> may occur while the child thread is still executing, what in turn may lead to subtle threading bugs.
            </remarks>
    </member>
    <member name="T:Castle.MicroKernel.Lifestyle.Scoped.ScopedInstanceActivationCallback">
      <summary>
              Delegate used by <see cref="T:Castle.MicroKernel.Lifestyle.Scoped.ILifetimeScope" /> to request a new instance to be created (that would be the first instance in that scope, subsequently reused).
            </summary>
      <param name="afterCreated">Callback which should be invoken by provided delegate right after isntance gets created and before it burden gets tracked.
              The purpose if this callback is to include scope in decisions regarding tracking of the instance by <see cref="T:Castle.MicroKernel.IReleasePolicy" />.
              Depending on the scope implementation it may or may not provide its own end of lifetime detection mechanism.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.IComponentModelDescriptor.BuildComponentModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
            	Contribute to component model before standard <see cref="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction" /> run.
            </summary>
      <param name="kernel">
      </param>
      <param name="model">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.IComponentModelDescriptor.ConfigureComponentModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
            	Contribute to component model after standard <see cref="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction" /> run.
            </summary>
      <param name="kernel">
      </param>
      <param name="model">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.IMetaComponentModelDescriptor.ConfigureComponentModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
            	Contribute to component model after standard <see cref="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction" /> run.
            </summary>
      <param name="kernel">
      </param>
      <param name="model">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.Registration.Classes">
      <summary>
                Entry point to fluent way to register, by convention, multiple concrete (non-abstract) classes (that include also delegate types). Use static methods on the class to fluently build
                registration.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Classes.From(System.Collections.Generic.IEnumerable{System.Type})">
      <summary>Prepares to register types from a list of types.</summary>
      <param name="types"> The list of types. </param>
      <returns>
                The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Classes.From(System.Type[])">
      <summary>Prepares to register types from a list of types.</summary>
      <param name="types"> The list of types. </param>
      <returns>
                The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Classes.FromAssembly(System.Reflection.Assembly)">
      <summary>Prepares to register types from an assembly.</summary>
      <param name="assembly"> The assembly. </param>
      <returns>
                The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Classes.FromAssemblyContaining(System.Type)">
      <summary>Prepares to register types from an assembly containing the type.</summary>
      <param name="type"> The type belonging to the assembly. </param>
      <returns>
                The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Classes.FromAssemblyContaining``1">
      <summary>Prepares to register types from an assembly containing the type.</summary>
      <typeparam name="T"> The type belonging to the assembly. </typeparam>
      <returns>
                The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Classes.FromAssemblyInDirectory(Castle.MicroKernel.Registration.AssemblyFilter)">
      <summary>Prepares to register types from assemblies found in a given directory that meet additional optional restrictions.</summary>
      <param name="filter">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Classes.FromAssemblyInThisApplication">
      <summary>Scans current assembly and all refernced assemblies with the same first part of the name.</summary>
      <returns>
      </returns>
      <remarks>
                Assemblies are considered to belong to the same application based on the first part of the name. For example if the method is called from within <c>MyApp.exe</c> and <c>MyApp.exe</c> references
                <c>MyApp.SuperFeatures.dll</c>, <c>mscorlib.dll</c> and <c>ThirdPartyCompany.UberControls.dll</c> the <c>MyApp.exe</c> and <c>MyApp.SuperFeatures.dll</c> will be scanned for components, and other
                assemblies will be ignored.
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Classes.FromAssemblyNamed(System.String)">
      <summary>Prepares to register types from an assembly.</summary>
      <param name="assemblyName"> The assembly name. </param>
      <returns>
                The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Classes.FromThisAssembly">
      <summary>Prepares to register types from the assembly containing the code invoking this method.</summary>
      <returns>
                The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor" /></returns>
    </member>
    <member name="T:Castle.MicroKernel.Registration.Types">
      <summary>
                Entry point to fluent way to register, by convention, multiple types. No upfront filtering is done so literally every type will be considered. That means that usually some filtering done by user
                will be required. For a most common case where non-abstract classes only are to be considered use <see cref="T:Castle.MicroKernel.Registration.Classes" /> class instead. Use static methods on the class to fluently build
                registration.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Types.From(System.Collections.Generic.IEnumerable{System.Type})">
      <summary>Prepares to register types from a list of types.</summary>
      <param name="types"> The list of types. </param>
      <returns>
                The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Types.From(System.Type[])">
      <summary>Prepares to register types from a list of types.</summary>
      <param name="types"> The list of types. </param>
      <returns>
                The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Types.FromAssembly(System.Reflection.Assembly)">
      <summary>Prepares to register types from an assembly.</summary>
      <param name="assembly"> The assembly. </param>
      <returns>
                The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Types.FromAssemblyContaining(System.Type)">
      <summary>Prepares to register types from an assembly containing the type.</summary>
      <param name="type"> The type belonging to the assembly. </param>
      <returns>
                The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Types.FromAssemblyContaining``1">
      <summary>Prepares to register types from an assembly containing the type.</summary>
      <typeparam name="T"> The type belonging to the assembly. </typeparam>
      <returns>
                The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Types.FromAssemblyInDirectory(Castle.MicroKernel.Registration.AssemblyFilter)">
      <summary>Prepares to register types from assemblies found in a given directory that meet additional optional restrictions.</summary>
      <param name="filter">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Types.FromAssemblyInThisApplication">
      <summary>Scans current assembly and all refernced assemblies with the same first part of the name.</summary>
      <returns>
      </returns>
      <remarks>
                Assemblies are considered to belong to the same application based on the first part of the name. For example if the method is called from within <c>MyApp.exe</c> and <c>MyApp.exe</c> references
                <c>MyApp.SuperFeatures.dll</c>, <c>mscorlib.dll</c> and <c>ThirdPartyCompany.UberControls.dll</c> the <c>MyApp.exe</c> and <c>MyApp.SuperFeatures.dll</c> will be scanned for components, and other
                assemblies will be ignored.
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Types.FromAssemblyNamed(System.String)">
      <summary>Prepares to register types from an assembly.</summary>
      <param name="assemblyName"> The assembly name. </param>
      <returns>
                The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Types.FromThisAssembly">
      <summary>Prepares to register types from the assembly containing the code invoking this method.</summary>
      <returns>
                The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor" /></returns>
    </member>
    <member name="T:Castle.MicroKernel.Lifestyle.SingletonLifestyleManager">
      <summary>
              Only one instance is created first time an instance of the component is requested, and it is then reused for all subseque.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Lifestyle.TransientLifestyleManager">
      <summary>
              Transient components are never reused. Since their lifetime does not have any externally constrained end, they have to be manually released if resolved explicitly, to ensure proper decomission.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.IComponentModelBuilder">
      <summary>
              Implementors must construct a populated
              instance of ComponentModel by inspecting the component
              and|or the configuration.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.IComponentModelBuilder.AddContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
      <summary>
              "To give or supply in common with others; give to a 
              common fund or for a common purpose". The contributor
              should inspect the component, or even the configuration
              associated with the component, to add or change information
              in the model that can be used later.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.IComponentModelBuilder.BuildModel(Castle.Core.ComponentName,System.Type[],System.Type,System.Collections.IDictionary)">
      <summary>
              Constructs a new ComponentModel by invoking
              the registered contributors.
            </summary>
      <param name="name">
      </param>
      <param name="services">
      </param>
      <param name="classType">
      </param>
      <param name="extendedProperties">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IComponentModelBuilder.RemoveContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
      <summary>
              Removes the specified contributor
            </summary>
      <param name="contributor">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder">
      <summary>
              Summary description for DefaultComponentModelBuilder.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.#ctor(Castle.MicroKernel.IKernel)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder" /> class.
            </summary>
      <param name="kernel">The kernel.</param>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.AddContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
      <summary>
              "To give or supply in common with others; give to a
              common fund or for a common purpose". The contributor
              should inspect the component, or even the configuration
              associated with the component, to add or change information
              in the model that can be used later.
            </summary>
      <param name="contributor">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.BuildModel(Castle.Core.ComponentName,System.Type[],System.Type,System.Collections.IDictionary)">
      <summary>
              Constructs a new ComponentModel by invoking
              the registered contributors.
            </summary>
      <param name="name">
      </param>
      <param name="services">
      </param>
      <param name="classType">
      </param>
      <param name="extendedProperties">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.RemoveContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
      <summary>
              Removes the specified contributor
            </summary>
      <param name="contributor">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.InitializeContributors">
      <summary>
              Initializes the default contributors.
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder.Contributors">
      <summary>
              Gets the contributors.
            </summary>
      <value>The contributors.</value>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector">
      <summary>
              Inspects the component configuration and the type looking for a
              definition of component activator type. The configuration preceeds whatever
              is defined in the component.
            </summary>
      <remarks>
              This inspector is not guarantee to always set up an component activator type. 
              If nothing could be found it wont touch the model. In this case is up to
              the kernel to establish a default component activator for components.
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
              Searches for the component activator in the configuration and, if unsuccessful
              look for the component activator attribute in the implementation type.
            </summary>
      <param name="kernel">The kernel instance</param>
      <param name="model">The model instance</param>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector.ReadComponentActivatorFromConfiguration(Castle.Core.ComponentModel)">
      <summary>
              Reads the attribute "componentActivatorType" associated with the 
              component configuration and verifies it implements the <see cref="T:Castle.MicroKernel.IComponentActivator" /> 
              interface.
            </summary>
      <exception cref="T:System.Exception">
              If the type does not implement the proper interface
            </exception>
      <param name="model">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector.ReadComponentActivatorFromType(Castle.Core.ComponentModel)">
      <summary>
              Check if the type expose one of the component activator attributes
              defined in Castle.Core namespace.
            </summary>
      <param name="model">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentActivatorInspector.ValidateComponentActivator(System.Type)">
      <summary>
              Validates that the provide type implements IComponentActivator
            </summary>
      <param name="customComponentActivator">The custom component activator.</param>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentProxyInspector">
      <summary>
              Inspects the component configuration and type looking for information
              that can influence the generation of a proxy for that component.
              <para>
                We specifically look for <c>additionalInterfaces</c> and <c>marshalByRefProxy</c> 
                on the component configuration or the <see cref="T:Castle.Core.ComponentProxyBehaviorAttribute" /> 
                attribute.
              </para></summary>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentProxyInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
              Searches for proxy behavior in the configuration and, if unsuccessful
              look for the <see cref="T:Castle.Core.ComponentProxyBehaviorAttribute" /> attribute in 
              the implementation type.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentProxyInspector.ReadProxyBehaviorFromType(System.Type)">
      <summary>
              Returns a <see cref="T:Castle.Core.ComponentProxyBehaviorAttribute" /> instance if the type
              uses the attribute. Otherwise returns null.
            </summary>
      <param name="implementation">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ComponentProxyInspector.ReadProxyBehavior(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
              Reads the proxy behavior associated with the 
              component configuration/type and applies it to the model.
            </summary>
      <exception cref="T:System.Exception">
              If the conversion fails
            </exception>
      <param name="kernel">
      </param>
      <param name="model">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationModelInspector">
      <summary>
              Uses the ConfigurationStore registered in the kernel to obtain
              an <see cref="T:Castle.Core.Configuration.IConfiguration" /> associated with the component.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
              Queries the kernel's ConfigurationStore for a configuration
              associated with the component name.
            </summary>
      <param name="kernel">
      </param>
      <param name="model">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationParametersInspector">
      <summary>
              Check for a node 'parameters' within the component 
              configuration. For each child it, a ParameterModel is created
              and added to ComponentModel's Parameters collection
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationParametersInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
              Inspect the configuration associated with the component
              and populates the parameter model collection accordingly
            </summary>
      <param name="kernel">
      </param>
      <param name="model">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ConstructorDependenciesModelInspector">
      <summary>
              This implementation of <see cref="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction" />
              collects all available constructors and populates them in the model
              as candidates. The Kernel will pick up one of the candidates
              according to a heuristic.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ExtendedPropertiesConstants">
      <summary>
              Only to hold internal constants and get rid of 
              magic numbers and hardcode names.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.InterceptorInspector">
      <summary>
              Inspect the component for <c>InterceptorAttribute</c> and
              the configuration for the interceptors node
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.LifecycleModelInspector">
      <summary>
              Inspects the type looking for interfaces that constitutes
              lifecycle interfaces, defined in the Castle.Model namespace.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifecycleModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
              Checks if the type implements <see cref="T:Castle.Core.IInitializable" /> and or
              <see cref="T:System.IDisposable" /> interfaces.
            </summary>
      <param name="kernel">
      </param>
      <param name="model">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector">
      <summary>Inspects the component configuration and the type looking for a definition of lifestyle type. The configuration preceeds whatever is defined in the component.</summary>
      <remarks>
                This inspector is not guarantee to always set up an lifestyle type. If nothing could be found it wont touch the model. In this case is up to the kernel to establish a default lifestyle for
                components.
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>Searches for the lifestyle in the configuration and, if unsuccessful look for the lifestyle attribute in the implementation type.</summary>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector.ReadLifestyleFromConfiguration(Castle.Core.ComponentModel)">
      <summary>
                Reads the attribute "lifestyle" associated with the component configuration and tries to convert to <see cref="T:Castle.Core.LifestyleType" />
                enum type.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector.ReadLifestyleFromType(Castle.Core.ComponentModel)">
      <summary>Check if the type expose one of the lifestyle attributes defined in Castle.Model namespace.</summary>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.MethodMetaInspector">
      <summary>
              Base for inspectors that want configuration associated with methods.
              For each child a <see cref="T:Castle.Core.MethodMetaModel" /> is created
              and added to ComponentModel's methods collection
            </summary>
      <remarks>
              Implementors should override the <see cref="M:Castle.MicroKernel.ModelBuilder.Inspectors.MethodMetaInspector.ObtainNodeName" /> return
              the name of the node to be inspected. For example:
              <code><![CDATA[
              <transactions>
                <method name="Save" transaction="requires" />
              </transactions>
            ]]></code></remarks>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.PropertiesDependenciesModelInspector">
      <summary>
              This implementation of <see cref="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction" />
              collects all potential writable public properties exposed by the component 
              implementation and populates the model with them.
              The Kernel might be able to set some of these properties when the component 
              is requested.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.PropertiesDependenciesModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
              Adds the properties as optional dependencies of this component.
            </summary>
      <param name="kernel">
      </param>
      <param name="model">
      </param>
    </member>
    <member name="T:Castle.Core.ComponentModel">
      <summary>
              Represents the collection of information and meta information collected about a component.
            </summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.dependencies">
      <summary>
              Dependencies the kernel must resolve
            </summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.interceptors">
      <summary>
              Interceptors associated
            </summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.parameters">
      <summary>
              External parameters
            </summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.properties">
      <summary>
              All potential properties that can be setted by the kernel
            </summary>
    </member>
    <member name="M:Castle.Core.ComponentModel.#ctor(Castle.Core.ComponentName,System.Collections.Generic.ICollection{System.Type},System.Type,System.Collections.IDictionary)">
      <summary>
              Constructs a ComponentModel
            </summary>
    </member>
    <member name="M:Castle.Core.ComponentModel.AddConstructor(Castle.Core.ConstructorCandidate)">
      <summary>
              Adds constructor dependency to this <see cref="T:Castle.Core.ComponentModel" /></summary>
      <param name="constructor">
      </param>
    </member>
    <member name="M:Castle.Core.ComponentModel.AddProperty(Castle.Core.PropertySet)">
      <summary>
              Adds property dependency to this <see cref="T:Castle.Core.ComponentModel" /></summary>
      <param name="property">
      </param>
    </member>
    <member name="M:Castle.Core.ComponentModel.AddService(System.Type)">
      <summary>
              Add service to be exposed by this <see cref="T:Castle.Core.ComponentModel" /></summary>
      <param name="type">
      </param>
    </member>
    <member name="M:Castle.Core.ComponentModel.Requires(System.Predicate{Castle.Core.PropertySet}[])">
      <summary>
              Requires the selected property dependencies.
            </summary>
      <param name="selectors"> The property selector. </param>
    </member>
    <member name="M:Castle.Core.ComponentModel.Requires``1">
      <summary>
              Requires the property dependencies of type <typeparamref name="D" /> .
            </summary>
      <typeparam name="D"> The dependency type. </typeparam>
    </member>
    <member name="P:Castle.Core.ComponentModel.Configuration">
      <summary>
              Gets or sets the configuration.
            </summary>
      <value> The configuration. </value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Constructors">
      <summary>
              Gets the constructors candidates.
            </summary>
      <value> The constructors. </value>
    </member>
    <member name="P:Castle.Core.ComponentModel.CustomComponentActivator">
      <summary>
              Gets or sets the custom component activator.
            </summary>
      <value> The custom component activator. </value>
    </member>
    <member name="P:Castle.Core.ComponentModel.CustomDependencies">
      <summary>
              Gets the custom dependencies.
            </summary>
      <value> The custom dependencies. </value>
    </member>
    <member name="P:Castle.Core.ComponentModel.CustomLifestyle">
      <summary>
              Gets or sets the custom lifestyle.
            </summary>
      <value> The custom lifestyle. </value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Dependencies">
      <summary>
              Dependencies are kept within constructors and properties. Others dependencies must be registered here, so the kernel (as a matter of fact the handler) can check them
            </summary>
    </member>
    <member name="P:Castle.Core.ComponentModel.ExtendedProperties">
      <summary>
              Gets or sets the extended properties.
            </summary>
      <value> The extended properties. </value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Implementation">
      <summary>
              Gets or sets the component implementation.
            </summary>
      <value> The implementation. </value>
    </member>
    <member name="P:Castle.Core.ComponentModel.InspectionBehavior">
      <summary>
              Gets or sets the strategy for inspecting public properties on the components
            </summary>
    </member>
    <member name="P:Castle.Core.ComponentModel.Interceptors">
      <summary>
              Gets the interceptors.
            </summary>
      <value> The interceptors. </value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Lifecycle">
      <summary>
              Gets the lifecycle steps.
            </summary>
      <value> The lifecycle steps. </value>
    </member>
    <member name="P:Castle.Core.ComponentModel.LifestyleType">
      <summary>
              Gets or sets the lifestyle type.
            </summary>
      <value> The type of the lifestyle. </value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Name">
      <summary>
              Sets or returns the component key
            </summary>
    </member>
    <member name="P:Castle.Core.ComponentModel.Parameters">
      <summary>
              Gets the parameter collection.
            </summary>
      <value> The parameters. </value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Properties">
      <summary>
              Gets the properties set.
            </summary>
      <value> The properties. </value>
    </member>
    <member name="P:Castle.Core.ComponentModel.RequiresGenericArguments">
      <summary>
              Gets or sets a value indicating whether the component requires generic arguments.
            </summary>
      <value>
        <c>true</c> if generic arguments are required; otherwise, <c>false</c> . </value>
    </member>
    <member name="T:Castle.Core.ConstructorCandidate">
      <summary>
              Represents a constructor of the component 
              that the container can use to initialize it properly.
            </summary>
    </member>
    <member name="M:Castle.Core.ConstructorCandidate.#ctor(System.Reflection.ConstructorInfo,Castle.Core.ConstructorDependencyModel[])">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.ConstructorCandidate" /> class.
            </summary>
      <param name="constructorInfo">The constructor info.</param>
      <param name="dependencies">The dependencies.</param>
    </member>
    <member name="P:Castle.Core.ConstructorCandidate.Constructor">
      <summary>
              Gets the ConstructorInfo (from reflection).
            </summary>
      <value>The constructor.</value>
    </member>
    <member name="P:Castle.Core.ConstructorCandidate.Dependencies">
      <summary>
              Gets the dependencies this constructor candidate exposes.
            </summary>
      <value>The dependencies.</value>
    </member>
    <member name="T:Castle.Core.ConstructorCandidateCollection">
      <summary>
                Collection of <see cref="T:Castle.Core.ConstructorCandidate" /></summary>
    </member>
    <member name="T:Castle.Core.DependencyModelCollection">
      <summary>
                Collection of <see cref="T:Castle.Core.DependencyModel" />.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.IReference`1">
      <summary>
              Represents obtained just in time object.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Castle.MicroKernel.IReference`1.Attach(Castle.Core.ComponentModel)">
      <summary>
              If the reference introduces dependency on a component, should return <see cref="T:Castle.Core.DependencyModel" /> for that dependency, otherwise <c>null</c>.
            </summary>
      <param name="component">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IReference`1.Resolve(Castle.MicroKernel.IKernel,Castle.MicroKernel.Context.CreationContext)">
      <summary>
              Resolves object referenced by this reference, optionally using provided <paramref name="kernel" />.
              If object is resolved from the kernel, the <paramref name="context" /> should be used to guard
              against against cyclic dependencies.
            </summary>
      <param name="kernel">
      </param>
      <param name="context">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.InterceptorReference">
      <summary>
              Represents an reference to a Interceptor component.
            </summary>
    </member>
    <member name="M:Castle.Core.InterceptorReference.#ctor(System.String)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.InterceptorReference" /> class.
            </summary>
      <param name="referencedComponentName">The component key.</param>
    </member>
    <member name="M:Castle.Core.InterceptorReference.#ctor(System.Type)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.InterceptorReference" /> class.
            </summary>
      <param name="componentType">Type of the interceptor to use. This will reference the default component (ie. one with no explicitly assigned name) implemented by given type.</param>
    </member>
    <member name="M:Castle.Core.InterceptorReference.ForKey(System.String)">
      <summary>
              Gets an <see cref="T:Castle.Core.InterceptorReference" /> for the component key.
            </summary>
      <param name="key">The component key.</param>
      <returns>The <see cref="T:Castle.Core.InterceptorReference" /></returns>
    </member>
    <member name="M:Castle.Core.InterceptorReference.ForType(System.Type)">
      <summary>
              Gets an <see cref="T:Castle.Core.InterceptorReference" /> for the service.
            </summary>
      <param name="service">The service.</param>
      <returns>The <see cref="T:Castle.Core.InterceptorReference" /></returns>
    </member>
    <member name="M:Castle.Core.InterceptorReference.ForType``1">
      <summary>
              Gets an <see cref="T:Castle.Core.InterceptorReference" /> for the service.
            </summary>
      <typeparam name="T">The service type.</typeparam>
      <returns>The <see cref="T:Castle.Core.InterceptorReference" /></returns>
    </member>
    <member name="T:Castle.Core.InterceptorReferenceCollection">
      <summary>
                Collection of <see cref="T:Castle.Core.InterceptorReference" /></summary>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.AddFirst(Castle.Core.InterceptorReference)">
      <summary>Adds the specified interceptor as the first.</summary>
      <param name="item">The interceptor.</param>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.AddIfNotInCollection(Castle.Core.InterceptorReference)">
      <summary>Adds the interceptor to the end of the interceptors list if it does not exist already.</summary>
      <param name="interceptorReference">The interceptor reference.</param>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.AddLast(Castle.Core.InterceptorReference)">
      <summary>Adds the specified interceptor as the last.</summary>
      <param name="item">The interceptor.</param>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.Insert(System.Int32,Castle.Core.InterceptorReference)">
      <summary>Inserts the specified interceptor at the specified index.</summary>
      <param name="index">The index.</param>
      <param name="item">The interceptor.</param>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.GetEnumerator">
      <summary>Returns an enumerator that can iterate through a collection.</summary>
      <returns>
                An <see cref="T:System.Collections.IEnumerator" />
                that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.Add(Castle.Core.InterceptorReference)">
      <summary>Adds the specified item.</summary>
      <param name="item">The interceptor.</param>
    </member>
    <member name="P:Castle.Core.InterceptorReferenceCollection.HasInterceptors">
      <summary>Gets a value indicating whether this instance has interceptors.</summary>
      <value>
        <c>true</c> if this instance has interceptors; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Castle.Core.LifecycleConcernsCollection">
      <summary>
              Represents a collection of ordered lifecycle concerns.
            </summary>
    </member>
    <member name="P:Castle.Core.LifecycleConcernsCollection.CommissionConcerns">
      <summary>
              Returns all concerns for the commission phase
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Core.LifecycleConcernsCollection.DecommissionConcerns">
      <summary>
              Returns all concerns for the decommission phase
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Core.LifecycleConcernsCollection.HasCommissionConcerns">
      <summary>
              Gets a value indicating whether this instance has commission steps.
            </summary>
      <value>
        <c>true</c> if this instance has commission steps; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.Core.LifecycleConcernsCollection.HasDecommissionConcerns">
      <summary>
              Gets a value indicating whether this instance has decommission steps.
            </summary>
      <value>
        <c>true</c> if this instance has decommission steps; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Castle.Core.MethodMetaModel">
      <summary>
              Represents meta information associated with a method
              (not yet defined)
            </summary>
    </member>
    <member name="M:Castle.Core.MethodMetaModel.#ctor(Castle.Core.Configuration.IConfiguration)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.MethodMetaModel" /> class.
            </summary>
      <param name="configNode">The config node.</param>
    </member>
    <member name="P:Castle.Core.MethodMetaModel.ConfigNode">
      <summary>
              Gets the config node.
            </summary>
      <value>The config node.</value>
    </member>
    <member name="T:Castle.Core.MethodMetaModelCollection">
      <summary>
              Collection of <see cref="T:Castle.Core.MethodMetaModel" /></summary>
    </member>
    <member name="P:Castle.Core.MethodMetaModelCollection.MethodInfo2Model">
      <summary>
              Gets the method info2 model.
            </summary>
      <value>The method info2 model.</value>
    </member>
    <member name="T:Castle.Core.ParameterModel">
      <summary>
              Represents a parameter. Usually the parameter
              comes from the external world, ie, an external configuration.
            </summary>
    </member>
    <member name="M:Castle.Core.ParameterModel.#ctor(System.String,System.String)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.ParameterModel" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Castle.Core.ParameterModel.#ctor(System.String,Castle.Core.Configuration.IConfiguration)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.ParameterModel" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="value">The value.</param>
    </member>
    <member name="P:Castle.Core.ParameterModel.ConfigValue">
      <summary>
              Gets the config value.
            </summary>
      <value>The config value.</value>
    </member>
    <member name="P:Castle.Core.ParameterModel.Name">
      <summary>
              Gets the name.
            </summary>
      <value>The name.</value>
    </member>
    <member name="P:Castle.Core.ParameterModel.Value">
      <summary>
              Gets the value.
            </summary>
      <value>The value.</value>
    </member>
    <member name="T:Castle.Core.ParameterModelCollection">
      <summary>
              Collection of <see cref="T:Castle.Core.ParameterModel" /></summary>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.Add(System.String,System.String)">
      <summary>
              Adds the specified name.
            </summary>
      <param name="name">The name.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.Add(System.String,Castle.Core.Configuration.IConfiguration)">
      <summary>
              Adds the specified name.
            </summary>
      <param name="name">The name.</param>
      <param name="configNode">The config node.</param>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.Add(System.String,Castle.Core.ParameterModel)">
      <summary>
              Adds the specified key.
            </summary>
      <remarks>
              Not implemented
            </remarks>
      <param name="key">The key.</param>
      <param name="value">The value.</param>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.Count">
      <summary>
              Gets the count.
            </summary>
      <value>The count.</value>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.Item(System.String)">
      <summary>
              Gets the <see cref="T:Castle.Core.ParameterModel" /> with the specified key.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Castle.Core.PropertySet">
      <summary>
            	Represents a property and the respective dependency.
            </summary>
            TODO: remove this class and instead create PropertyDependencyModel like we do for constructors
        </member>
    <member name="M:Castle.Core.PropertySet.#ctor(System.Reflection.PropertyInfo,Castle.Core.DependencyModel)">
      <summary>
            	Initializes a new instance of the <see cref="T:Castle.Core.PropertySet" /> class.
            </summary>
      <param name="propertyInfo"> The property info. </param>
      <param name="dependency"> The dependency. </param>
    </member>
    <member name="P:Castle.Core.PropertySet.Dependency">
      <summary>
            	Gets the dependency.
            </summary>
      <value> The dependency. </value>
    </member>
    <member name="P:Castle.Core.PropertySet.Property">
      <summary>
            	Gets the property.
            </summary>
      <value> The property. </value>
    </member>
    <member name="T:Castle.Core.PropertySetCollection">
      <summary>
                Collection of <see cref="T:Castle.Core.PropertySet" /></summary>
    </member>
    <member name="M:Castle.Core.PropertySetCollection.FindByPropertyInfo(System.Reflection.PropertyInfo)">
      <summary>Finds a PropertySet the by PropertyInfo.</summary>
      <param name="info">The info.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.MicroKernel.ComponentReference`1">
      <summary>
              Reference to component obtained from the container.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Castle.MicroKernel.ComponentReference`1.#ctor(System.Type)">
      <summary>
              Creates a new instance of <see cref="T:Castle.MicroKernel.ComponentReference`1" /> referencing default component implemented by <paramref name="componentType" /></summary>
      <param name="componentType">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.ComponentReference`1.#ctor(System.String)">
      <summary>
              Creates a new instance of <see cref="T:Castle.MicroKernel.ComponentReference`1" /> referencing component <paramref name="referencedComponentName" /></summary>
      <param name="referencedComponentName">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.Proxy.IModelInterceptorsSelector">
      <summary>
              Select the appropriate interceptors based on the application specific
              business logic
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Proxy.IModelInterceptorsSelector.HasInterceptors(Castle.Core.ComponentModel)">
      <summary>
              Determine whatever the specified has interceptors.
              The selector should only return true from this method if it has determined that is
              a model that it would likely add interceptors to.
            </summary>
      <param name="model">The model</param>
      <returns>Whatever this selector is likely to add interceptors to the specified model</returns>
    </member>
    <member name="M:Castle.MicroKernel.Proxy.IModelInterceptorsSelector.SelectInterceptors(Castle.Core.ComponentModel,Castle.Core.InterceptorReference[])">
      <summary>
              Select the appropriate interceptor references.
              The interceptor references aren't necessarily registered in the model.Intereceptors
            </summary>
      <param name="model">The model to select the interceptors for</param>
      <param name="interceptors">The interceptors selected by previous selectors in the pipeline or <see cref="P:Castle.Core.ComponentModel.Interceptors" /> if this is the first interceptor in the pipeline.</param>
      <returns>The interceptor for this model (in the current context) or a null reference</returns>
      <remarks>
              If the selector is not interested in modifying the interceptors for this model, it 
              should return <paramref name="interceptors" /> and the next selector in line would be executed.
              If the selector wants no interceptors to be used it can either return <c>null</c> or empty array.
              However next interceptor in line is free to override this choice.
            </remarks>
    </member>
    <member name="T:Castle.MicroKernel.InstanceReference`1">
      <summary>
              Represents a reference to an existing object.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Castle.MicroKernel.IProxyFactory">
      <summary>
              Defines the contract used by the kernel 
              to obtain proxies for components. The implementor
              must return a proxied instance that dispatch 
              the invocation to the registered interceptors in the model
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.IProxyFactory.AddInterceptorSelector(Castle.MicroKernel.Proxy.IModelInterceptorsSelector)">
      <summary>
              Add the selector to the list of selectors that can affect interceptor's decisions
              in the container.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.IProxyFactory.Create(Castle.MicroKernel.IKernel,System.Object,Castle.Core.ComponentModel,Castle.MicroKernel.Context.CreationContext,System.Object[])">
      <summary>
              Implementors must create a proxy based on 
              the information exposed by ComponentModel
            </summary>
      <param name="kernel">The kernel instance</param>
      <param name="model">The component model</param>
      <param name="instance">The component instance to be proxy (only required in some cases)</param>
      <param name="constructorArguments">array of parameters to the constructor (if any)</param>
      <param name="context">The creation context</param>
      <returns>proxy instance</returns>
    </member>
    <member name="M:Castle.MicroKernel.IProxyFactory.RequiresTargetInstance(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
              Implementor should check the component model
              and determine if the caller must pass on the component 
              instance to the proxy
            </summary>
      <param name="kernel">The kernel instance</param>
      <param name="model">The component model</param>
      <returns>
        <c>true</c> if an instance must be passed to <see cref="M:Castle.MicroKernel.IProxyFactory.Create(Castle.MicroKernel.IKernel,System.Object,Castle.Core.ComponentModel,Castle.MicroKernel.Context.CreationContext,System.Object[])" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.IProxyFactory.ShouldCreateProxy(Castle.Core.ComponentModel)">
      <summary>
              Determines whatever we need to create a proxy for this model
            </summary>
      <param name="model">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.MicroKernel.Proxy.NotSupportedProxyFactory">
      <summary>
              This is a placeholder implementation of <see cref="T:Castle.MicroKernel.IProxyFactory" />.
            </summary>
      <remarks>
              The decision to supply no implementation for <see cref="T:Castle.MicroKernel.IProxyFactory" />
              is supported by the fact that the MicroKernel should be a thin
              assembly with the minimal set of features, although extensible.
              Providing the support for this interface would obligate 
              the user to import another assembly, even if the large majority of
              simple cases, no use use of interceptors will take place.
              If you want to use however, see the Windsor container.
            </remarks>
    </member>
    <member name="T:Castle.MicroKernel.Proxy.ProxyConstants">
      <summary>
              Holds the keys used by the proxy factories.
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.Proxy.ProxyConstants.ProxyOptionsKey">
      <summary>
              Key used to supply custom proxy options.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Proxy.ProxyOptions">
      <summary>
            	Represents options to configure proxies.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Proxy.ProxyOptions.#ctor(Castle.Core.ComponentModel)">
      <summary>
            	Initializes a new instance of the <see cref="T:Castle.MicroKernel.Proxy.ProxyOptions" /> class.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Proxy.ProxyOptions.AddAdditionalInterfaces(System.Type[])">
      <summary>
            	Adds the additional interfaces to proxy.
            </summary>
      <param name="interfaces"> The interfaces. </param>
    </member>
    <member name="M:Castle.MicroKernel.Proxy.ProxyOptions.AddMixIns(System.Object[])">
      <summary>
            	Adds the additional mix ins to integrate.
            </summary>
      <param name="mixIns"> The mix ins. </param>
    </member>
    <member name="M:Castle.MicroKernel.Proxy.ProxyOptions.AddMixinReference(Castle.MicroKernel.IReference{System.Object})">
      <summary>
            	Adds the additional mix in to integrate.
            </summary>
      <param name="mixIn"> The mix in. </param>
    </member>
    <member name="M:Castle.MicroKernel.Proxy.ProxyOptions.Equals(System.Object)">
      <summary>
            	Equals the specified obj.
            </summary>
      <param name="obj"> The obj. </param>
      <returns> true if equal. </returns>
    </member>
    <member name="M:Castle.MicroKernel.Proxy.ProxyOptions.GetHashCode">
      <summary>
            	Gets the hash code.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.AdditionalInterfaces">
      <summary>
            	Gets the additional interfaces to proxy.
            </summary>
      <value> The interfaces. </value>
    </member>
    <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.AllowChangeTarget">
      <summary>
            	Determines if the proxied component can change targets.
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.UseMarshalByRefAsBaseClass">
      <summary>
            	Determines if the interface proxied component should inherit 
            	from <see cref="T:System.MarshalByRefObject" /></summary>
    </member>
    <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.Hook">
      <summary>
            	Gets or sets the proxy hook.
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.MixIns">
      <summary>
            	Gets the mix ins to integrate.
            </summary>
      <value> The interfaces. </value>
    </member>
    <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.OmitTarget">
      <summary>
            	Determines if the proxied component uses a target.
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.Proxy.ProxyOptions.Selector">
      <summary>
            	Gets or sets the interceptor selector.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Proxy.ProxyOptionsUtil">
      <summary>
              Helper support for proxy configuration.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Proxy.ProxyOptionsUtil.ObtainProxyOptions(Castle.Core.ComponentModel,System.Boolean)">
      <summary>
              Obtains the <see cref="T:Castle.MicroKernel.Proxy.ProxyOptions" /> associated with the <see cref="T:Castle.Core.ComponentModel" />.
            </summary>
      <param name="model">The component model.</param>
      <param name="createOnDemand">true if the options should be created if not present.</param>
      <returns>The associated proxy options for the component model.</returns>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Descriptors.AttributeDescriptor`1.#ctor(System.String,System.String)">
      <summary>
              Constructs the <see cref="T:Castle.MicroKernel.ModelBuilder.Descriptors.AttributeDescriptor`1" /> descriptor with name and value.
            </summary>
      <param name="name">The attribute name.</param>
      <param name="value">The attribute value.</param>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Descriptors.AttributeKeyDescriptor`1.#ctor(Castle.MicroKernel.Registration.ComponentRegistration{`0},System.String)">
      <summary>
              Constructs the <see cref="T:Castle.MicroKernel.ModelBuilder.Descriptors.AttributeKeyDescriptor`1" /> descriptor with name.
            </summary>
      <param name="component">The component.</param>
      <param name="name">The attribute name.</param>
    </member>
    <member name="M:Castle.MicroKernel.ModelBuilder.Descriptors.AttributeKeyDescriptor`1.Eq(System.Object)">
      <summary>
              Builds the <see cref="T:Castle.MicroKernel.ModelBuilder.Descriptors.AttributeKeyDescriptor`1" /> with value.
            </summary>
      <param name="value">The attribute value.</param>
      <returns>The <see cref="T:Castle.MicroKernel.Registration.ComponentRegistration`1" /></returns>
    </member>
    <member name="T:Castle.MicroKernel.Registration.Component">
      <summary>
              Factory for creating <see cref="T:Castle.MicroKernel.Registration.ComponentRegistration" /> objects. Use static methods on the class to fluently build registration.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Component.For(System.Type)">
      <summary>
              Creates a component registration for the <paramref name="serviceType" /></summary>
      <param name="serviceType">Type of the service.</param>
      <returns>The component registration.</returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Component.For(System.Type[])">
      <summary>
              Creates a component registration for the <paramref name="serviceTypes" /></summary>
      <param name="serviceTypes">Types of the service.</param>
      <returns>The component registration.</returns>
            B
        </member>
    <member name="M:Castle.MicroKernel.Registration.Component.For(System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
              Creates a component registration for the <paramref name="serviceTypes" /></summary>
      <param name="serviceTypes">Types of the service.</param>
      <returns>The component registration.</returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Component.For``1">
      <summary>
              Creates a component registration for the service type.
            </summary>
      <typeparam name="TService">The service type.</typeparam>
      <returns>The component registration.</returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Component.For``2">
      <summary>
              Creates a component registration for the service types.
            </summary>
      <typeparam name="TService1">The primary service type.</typeparam>
      <typeparam name="TService2">The forwarded type.</typeparam>
      <returns>The component registration.</returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Component.For``3">
      <summary>
              Creates a component registration for the service types.
            </summary>
      <typeparam name="TService1">The primary service type.</typeparam>
      <typeparam name="TService2">The first forwarded type.</typeparam>
      <typeparam name="TService3">The second forwarded type.</typeparam>
      <returns>The component registration.</returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Component.For``4">
      <summary>
              Creates a component registration for the service types.
            </summary>
      <typeparam name="TService1">The primary service type.</typeparam>
      <typeparam name="TService2">The first forwarded type.</typeparam>
      <typeparam name="TService3">The second forwarded type.</typeparam>
      <typeparam name="TService4">The third forwarded type.</typeparam>
      <returns>The component registration.</returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Component.For``5">
      <summary>
              Creates a component registration for the service types.
            </summary>
      <typeparam name="TService1">The primary service type.</typeparam>
      <typeparam name="TService2">The first forwarded type.</typeparam>
      <typeparam name="TService3">The second forwarded type.</typeparam>
      <typeparam name="TService4">The third forwarded type.</typeparam>
      <typeparam name="TService5">The fourth forwarded type.</typeparam>
      <returns>The component registration.</returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Component.HasAttribute``1(System.Type)">
      <summary>
              Helper method for filtering components based on presence of an Attribute.
            </summary>
      <typeparam name="TAttribute">
      </typeparam>
      <param name="type">
      </param>
      <returns>
      </returns>
      <example>
              container.Register(
              Classes.FromThisAssembly()
              .Where(Component.HasAttribute&lt;UserAttribute&gt;) );
            </example>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Component.HasAttribute``1(System.Predicate{``0})">
      <summary>
              Helper method for filtering components based on presence of an Attribute and value of predicate on that attribute.
            </summary>
      <typeparam name="TAttribute">
      </typeparam>
      <param name="filter">
      </param>
      <returns>
      </returns>
      <example>
              container.Register(
              Classes.FromThisAssembly()
              .Where(Component.HasAttribute&lt;UserAttribute&gt;(u =&gt; u.SomeFlag)) );
            </example>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Component.IsCastleComponent(System.Type)">
      <summary>
              Determines if the component is a Castle component, that is - if it has a <see cref="T:Castle.Core.CastleComponentAttribute" />.
            </summary>
      <returns>true if the service is a Castle Component.</returns>
      <remarks>
              This method is usually used as argument for <see cref="M:Castle.MicroKernel.Registration.BasedOnDescriptor.If(System.Predicate{System.Type})" /> method.
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Component.IsInNamespace(System.String)">
      <summary>
              Creates a predicate to check if a component is in a namespace.
            </summary>
      <param name="namespace">The namespace.</param>
      <returns>true if the component type is in the namespace.</returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Component.IsInNamespace(System.String,System.Boolean)">
      <summary>
              Creates a predicate to check if a component is in a namespace.
            </summary>
      <param name="namespace">The namespace.</param>
      <param name="includeSubnamespaces">If set to true, will also include types from subnamespaces.</param>
      <returns>true if the component type is in the namespace.</returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Component.IsInSameNamespaceAs(System.Type)">
      <summary>
              Creates a predicate to check if a component shares a namespace with another.
            </summary>
      <param name="type">The component type to test namespace against.</param>
      <returns>true if the component is in the same namespace.</returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Component.IsInSameNamespaceAs(System.Type,System.Boolean)">
      <summary>
              Creates a predicate to check if a component shares a namespace with another.
            </summary>
      <param name="type">The component type to test namespace against.</param>
      <param name="includeSubnamespaces">If set to true, will also include types from subnamespaces.</param>
      <returns>true if the component is in the same namespace.</returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Component.IsInSameNamespaceAs``1">
      <summary>
              Creates a predicate to check if a component shares a namespace with another.
            </summary>
      <typeparam name="T">The component type to test namespace against.</typeparam>
      <returns>true if the component is in the same namespace.</returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Component.IsInSameNamespaceAs``1(System.Boolean)">
      <summary>
              Creates a predicate to check if a component shares a namespace with another.
            </summary>
      <typeparam name="T">The component type to test namespace against.</typeparam>
      <param name="includeSubnamespaces">If set to true, will also include types from subnamespaces.</param>
      <returns>true if the component is in the same namespace.</returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentDependencyRegistrationExtensions.Insert(System.Collections.IDictionary,System.String,System.Object)">
      <summary>
              Inserts a new named argument with given key. If an argument for this name already exists, it will be overwritten.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentDependencyRegistrationExtensions.Insert(System.Collections.IDictionary,System.Type,System.Object)">
      <summary>
              Inserts a new typed argument with given type. If an argument for this type already exists, it will be overwritten.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentDependencyRegistrationExtensions.InsertAnonymous(System.Collections.IDictionary,System.Object)">
      <summary>
              Inserts a set of typed arguments. Property names of the anonymous type will be used as key.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentDependencyRegistrationExtensions.InsertTyped``1(System.Collections.IDictionary,``0)">
      <summary>
              Inserts a new typed argument with given type. If an argument for this type already exists, it will be overwritten.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentDependencyRegistrationExtensions.InsertTypedCollection(System.Collections.IDictionary,System.Object[])">
      <summary>
              Inserts a set of typed arguments. Actual type of the arguments will be used as key.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Registration.IRegistration">
      <summary>
              The contract for all registrations with the kernel.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.IRegistration.Register(Castle.MicroKernel.IKernelInternal)">
      <summary>
              Performs the registration in the <see cref="T:Castle.MicroKernel.IKernel" />.
            </summary>
      <param name="kernel">The kernel.</param>
    </member>
    <member name="T:Castle.MicroKernel.Registration.ComponentRegistration`1">
      <summary>
            Registration for a single type as a component with the kernel.
                <para />
            You can create a new registration with the <see cref="T:Castle.MicroKernel.Registration.Component" /> factory.
            </summary>
      <typeparam name="TService"> The service type </typeparam>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Registration.ComponentRegistration`1" /> class.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.#ctor(System.Type[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.MicroKernel.Registration.ComponentRegistration`1" /> class.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ActAs(System.Object[])">
      <summary>
            Marks the components with one or more actors.
            </summary>
      <param name="actors"> The component actors. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Activator``1">
      <summary>
            Set a custom <see cref="T:Castle.MicroKernel.IComponentActivator" /> which creates and destroys the component.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.AddAttributeDescriptor(System.String,System.String)">
      <summary>
            Adds the attribute descriptor.
            </summary>
      <param name="key"> The key. </param>
      <param name="value"> The value. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.AddDescriptor(Castle.MicroKernel.ModelBuilder.IComponentModelDescriptor)">
      <summary>
            Adds the descriptor.
            </summary>
      <param name="descriptor"> The descriptor. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Attribute(System.String)">
      <summary>
            Creates an attribute descriptor.
            </summary>
      <param name="key"> The attribute key. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Configuration(Castle.MicroKernel.Registration.Node[])">
      <summary>
            Apply more complex configuration to this component registration.
            </summary>
      <param name="configNodes"> The config nodes. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Configuration(Castle.Core.Configuration.IConfiguration)">
      <summary>
            Apply more complex configuration to this component registration.
            </summary>
      <param name="configuration"> The configuration <see cref="T:Castle.Core.Configuration.MutableConfiguration" /> . </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(Castle.MicroKernel.Registration.Dependency)">
      <summary>
            Defines additional dependencies for the component. Those can be any of <see cref="T:Castle.MicroKernel.Registration.ServiceOverride" />, <see cref="T:Castle.MicroKernel.Registration.Property" /> and <see cref="T:Castle.MicroKernel.Registration.Parameter" />. Use the static methods on
                <see cref="T:Castle.MicroKernel.Registration.Dependency" /> class to define the dependencies. See the example attached.
            </summary>
      <param name="dependency"> The dependency. </param>
      <returns>
      </returns>
      <example>
            Artificial example showing how to specify a service override. See other methods on <see cref="T:Castle.MicroKernel.Registration.Dependency" /> class for more options.
                <code>DependsOn(Dependency.OnComponent(typeof(IRepository), typeof(IntranetRepository)));</code></example>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(Castle.MicroKernel.Registration.Dependency[])">
      <summary>
            Defines additional dependencies for the component. Those can be any combibation of <see cref="T:Castle.MicroKernel.Registration.ServiceOverride" />, <see cref="T:Castle.MicroKernel.Registration.Property" /> and <see cref="T:Castle.MicroKernel.Registration.Parameter" />. Use the static methods
            on <see cref="T:Castle.MicroKernel.Registration.Dependency" /> class to define the dependencies. See the example attached.
            </summary>
      <param name="dependencies"> The dependencies. </param>
      <returns>
      </returns>
      <example>
            Artificial example showing how to specify three different dependencies. If any of the methods shown is not self explanatory consult its documentation.
                <code>DependsOn(Dependency.OnAppSettingsValue("connectionString", "intranet-connection-string"),
            		Dependency.OnComponent(typeof(IRepository), typeof(IntranetRepository)),
            		Dependency.OnValue("applicationName", "My Application"));</code></example>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(System.Collections.IDictionary)">
      <summary>
            Uses a dictionary of key/value pairs, to specify custom dependencies.
                <para /></summary>
      <param name="dependencies"> The dependencies. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(System.Object)">
      <summary>
            Uses an (anonymous) object as a dictionary, to specify custom dependencies.
                <para /></summary>
      <param name="dependenciesAsAnonymousType"> The dependencies. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(Castle.MicroKernel.Registration.DynamicParametersDelegate)">
      <summary>
            Allows custom dependencies to by defined dyncamically. Calling this overload is synonymous to using <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DynamicParameters(Castle.MicroKernel.Registration.DynamicParametersDelegate)" /></summary>
      <param name="resolve"> The delegate used for providing dynamic parameters. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(Castle.MicroKernel.Registration.DynamicParametersResolveDelegate)">
      <summary>
            Allows custom dependencies to by defined dynamically with releasing capability. Calling this overload is synonymous to using
                <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DynamicParameters(Castle.MicroKernel.Registration.DynamicParametersResolveDelegate)" /></summary>
      <param name="resolve"> The delegate used for providing dynamic parameters. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(Castle.MicroKernel.Registration.DynamicParametersWithContextResolveDelegate)">
      <summary>
            Allows custom dependencies to by defined dynamically with releasing capability. Calling this overload is synonymous to using
                <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DynamicParameters(Castle.MicroKernel.Registration.DynamicParametersWithContextResolveDelegate)" /></summary>
      <param name="resolve"> The delegate used for providing dynamic parameters. </param>
      <returns>
      </returns>
      <remarks>
            Use <see cref="T:Castle.MicroKernel.Context.CreationContext" /> when resolving components from <see cref="T:Castle.MicroKernel.IKernel" /> in order to detect cycles.
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DynamicParameters(Castle.MicroKernel.Registration.DynamicParametersDelegate)">
      <summary>
            Allows custom dependencies to by defined dyncamically.
            </summary>
      <param name="resolve"> The delegate used for providing dynamic parameters. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DynamicParameters(Castle.MicroKernel.Registration.DynamicParametersResolveDelegate)">
      <summary>
            Allows custom dependencies to by defined dynamically with releasing capability.
            </summary>
      <param name="resolve"> The delegate used for providing dynamic parameters. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DynamicParameters(Castle.MicroKernel.Registration.DynamicParametersWithContextResolveDelegate)">
      <summary>
            Allows custom dependencies to by defined dynamically with releasing capability.
            </summary>
      <param name="resolve"> The delegate used for providing dynamic parameters. </param>
      <returns>
      </returns>
      <remarks>
            Use <see cref="T:Castle.MicroKernel.Context.CreationContext" /> when resolving components from <see cref="T:Castle.MicroKernel.IKernel" /> in order to detect cycles.
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ExtendedProperties(Castle.MicroKernel.Registration.Property[])">
      <summary>
            Sets <see cref="P:Castle.Core.ComponentModel.ExtendedProperties" /> for this component.
            </summary>
      <param name="properties"> The extended properties. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ExtendedProperties(Castle.MicroKernel.Registration.Property)">
      <summary>
            Sets <see cref="P:Castle.Core.ComponentModel.ExtendedProperties" /> for this component.
            </summary>
      <param name="property"> The extended properties. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ExtendedProperties(System.Object)">
      <summary>
            Sets <see cref="P:Castle.Core.ComponentModel.ExtendedProperties" /> for this component.
            </summary>
      <param name="anonymous"> The extendend properties as key/value pairs. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward(System.Type[])">
      <summary>
            Adds <paramref name="types" /> as additional services to be exposed by this component.
            </summary>
      <param name="types"> The types to forward. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward``1">
      <summary>
            Adds <typeparamref name="TService2" /> as additional service to be exposed by this component.
            </summary>
      <typeparam name="TService2"> The forwarded type. </typeparam>
      <returns> The component registration. </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward``2">
      <summary>
            Adds <typeparamref name="TService2" /> and <typeparamref name="TService3" /> as additional services to be exposed by this component.
            </summary>
      <typeparam name="TService2"> The first forwarded type. </typeparam>
      <typeparam name="TService3"> The second forwarded type. </typeparam>
      <returns> The component registration. </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward``3">
      <summary>
            Adds <typeparamref name="TService2" /> , <typeparamref name="TService3" /> and <typeparamref name="TService4" /> as additional services to be exposed by this component.
            </summary>
      <typeparam name="TService2"> The first forwarded type. </typeparam>
      <typeparam name="TService3"> The second forwarded type. </typeparam>
      <typeparam name="TService4"> The third forwarded type. </typeparam>
      <returns> The component registration. </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward``4">
      <summary>
            Adds <typeparamref name="TService2" /> , <typeparamref name="TService3" /> , <typeparamref name="TService4" /> and <typeparamref name="TService5" /> as additional services to be exposed by
            this component.
            </summary>
      <typeparam name="TService2"> The first forwarded type. </typeparam>
      <typeparam name="TService3"> The second forwarded type. </typeparam>
      <typeparam name="TService4"> The third forwarded type. </typeparam>
      <typeparam name="TService5"> The fourth forwarded type. </typeparam>
      <returns> The component registration. </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Forward(System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Adds <paramref name="types" /> as additional services to be exposed by this component.
            </summary>
      <param name="types"> The types to forward. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ImplementedBy``1">
      <summary>
            Sets the concrete type that implements the service to <typeparamref name="TImpl" /> .
                <para />
            If not set, the class service type or first registered interface will be used as the implementation for this component.
            </summary>
      <typeparam name="TImpl"> The type that is the implementation for the service. </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ImplementedBy(System.Type)">
      <summary>
            Sets the concrete type that implements the service to <paramref name="type" /> .
                <para />
            If not set, the class service type or first registered interface will be used as the implementation for this component.
            </summary>
      <param name="type"> The type that is the implementation for the service. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ImplementedBy(System.Type,Castle.MicroKernel.Handlers.IGenericImplementationMatchingStrategy)">
      <summary>
            Sets the concrete type that implements the service to <paramref name="type" /> .
                <para />
            If not set, the class service type or first registered interface will be used as the implementation for this component.
            </summary>
      <param name="type"> The type that is the implementation for the service. </param>
      <param name="genericImplementationMatchingStrategy"> Provides ability to close open generic service. Ignored when registering closed or non-generic component. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ImplementedBy(System.Type,Castle.MicroKernel.Handlers.IGenericServiceStrategy)">
      <summary>
            Sets the concrete type that implements the service to <paramref name="type" /> .
                <para />
            If not set, the class service type or first registered interface will be used as the implementation for this component.
            </summary>
      <param name="type"> The type that is the implementation for the service. </param>
      <param name="genericServiceStrategy"> Provides ability to select if open generic component supports particular closed version of a service. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ImplementedBy(System.Type,Castle.MicroKernel.Handlers.IGenericImplementationMatchingStrategy,Castle.MicroKernel.Handlers.IGenericServiceStrategy)">
      <summary>
            Sets the concrete type that implements the service to <paramref name="type" /> .
                <para />
            If not set, the class service type or first registered interface will be used as the implementation for this component.
            </summary>
      <param name="type"> The type that is the implementation for the service. </param>
      <param name="genericImplementationMatchingStrategy"> Provides ability to close open generic service. Ignored when registering closed or non-generic component. </param>
      <param name="genericServiceStrategy"> Provides ability to select if open generic component supports particular closed version of a service. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Instance(`0)">
      <summary>
            Assigns an existing instance as the component for this registration.
            </summary>
      <param name="instance"> The component instance. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Interceptors(Castle.Core.InterceptorReference[])">
      <summary>
            Set the interceptors for this component.
            </summary>
      <param name="interceptors"> The interceptors. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Interceptors(System.Type[])">
      <summary>
            Set the interceptors for this component.
            </summary>
      <param name="interceptors"> The interceptors. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Interceptors``1">
      <summary>
            Set the interceptor for this component.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Interceptors``2">
      <summary>
            Set the interceptor for this component.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Interceptors(System.String[])">
      <summary>
            Set the interceptor for this component.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.LifestyleCustom(System.Type)">
      <summary>
            Sets component lifestyle to specified one.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.LifestyleCustom``1">
      <summary>
            Sets component lifestyle to specified one.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.LifestylePerThread">
      <summary>
            Sets component lifestyle to per thread.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.LifestyleScoped(System.Type)">
      <summary>
            Sets component lifestyle to scoped per explicit scope. If <paramref name="scopeAccessorType" /> is provided, it will be used to access scope for the component. Otherwise the default scope accessor
            will be used.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.LifestyleScoped``1">
      <summary>
            Sets component lifestyle to scoped per explicit scope.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.LifestyleBoundTo``1">
      <summary>
            Sets component lifestyle to scoped per farthest component on the resolution stack where implementation type is assignable to <typeparamref name="TBaseForRoot" /> .
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.LifestyleBoundToNearest``1">
      <summary>
            Sets component lifestyle to scoped per nearest component on the resolution stack where implementation type is assignable to <typeparamref name="TBaseForRoot" /> .
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.LifestyleBoundTo(System.Func{Castle.MicroKernel.IHandler[],Castle.MicroKernel.IHandler})">
      <summary>
            Sets component lifestyle to scoped per scope determined by <paramref name="scopeRootBinder" /></summary>
      <param name="scopeRootBinder"> Custom algorithm for selection which component higher up the resolution stack should be the root of the lifetime scope for current component's instances. The delegate
            will be invoked when current component is about to be resolved and will be passed set of handlers to components higher up the resolution stack. It ought to return one which it designages as the root
            which shall scope the lifetime of current component's instance, or <c>null</c></param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.LifestylePerWebRequest">
      <summary>
            Sets component lifestyle to instance per web request.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.LifestylePooled(System.Nullable{System.Int32},System.Nullable{System.Int32})">
      <summary>
            Sets component lifestyle to pooled. If <paramref name="initialSize" /> or <paramref name="maxSize" /> are not set default values will be used.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.LifestyleSingleton">
      <summary>
            Sets component lifestyle to singleton.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.LifestyleTransient">
      <summary>
            Sets component lifestyle to transient.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Named(System.String)">
      <summary>
            Set a name of this registration. This is required if you have multiple components for a given service and want to be able to resolve some specific ones. Then you'd provide the name so that Windsor
            knows which one of the bunch you know. Otherwise don't bother setting the name.
                <para />
            If not set, the <see cref="P:System.Type.FullName" /> of the <see cref="P:Castle.MicroKernel.Registration.ComponentRegistration`1.Implementation" /> will be used as the key to register the component.
            </summary>
      <param name="name"> The name of this registration. </param>
      <returns>
      </returns>
      <remarks>
            Names have to be globally unique in the scope of the container.
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.NamedAutomatically(System.String)">
      <summary>
            This method as opposed to <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Named(System.String)" /> should be used by tools like facilities when the name is not provided by the user, but autogenerated and user has no interest in seing this name, for
            example in diagnostics reports. Set a name of this registration. This is required if you have multiple components for a given service and want to be able to resolve some specific ones. Then you'd
            provide the name so that Windsor knows which one of the bunch you know. Otherwise don't bother setting the name.
                <para />
            If not set, the <see cref="P:System.Type.FullName" /> of the <see cref="P:Castle.MicroKernel.Registration.ComponentRegistration`1.Implementation" /> will be used as the key to register the component.
            </summary>
      <param name="name"> The name of this registration. </param>
      <returns>
      </returns>
      <remarks>
            Names have to be globally unique in the scope of the container.
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.OnCreate(System.Action{`0}[])">
      <summary>
            Stores a set of <see cref="T:Castle.MicroKernel.LifecycleConcerns.LifecycleActionDelegate`1" /> which will be invoked when the component is created and before it's returned from the container.
            </summary>
      <param name="actions"> A set of actions to be executed right after the component is created and before it's returned from the container. </param>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.OnCreate(Castle.MicroKernel.LifecycleConcerns.LifecycleActionDelegate{`0}[])">
      <summary>
            Stores a set of <see cref="T:Castle.MicroKernel.LifecycleConcerns.LifecycleActionDelegate`1" /> which will be invoked when the component is created and before it's returned from the container.
            </summary>
      <param name="actions"> A set of actions to be executed right after the component is created and before it's returned from the container. </param>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.OnDestroy(System.Action{`0}[])">
      <summary>
            Stores a set of <see cref="T:Castle.MicroKernel.LifecycleConcerns.LifecycleActionDelegate`1" /> which will be invoked when the component is created and before it's returned from the container.
            </summary>
      <param name="actions"> A set of actions to be executed right after the component is created and before it's returned from the container. </param>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.OnDestroy(Castle.MicroKernel.LifecycleConcerns.LifecycleActionDelegate{`0}[])">
      <summary>
            Stores a set of <see cref="T:Castle.MicroKernel.LifecycleConcerns.LifecycleActionDelegate`1" /> which will be invoked when the component is destroyed which means when it's released or it's lifetime scope ends. Notice that usage of this
            method will cause instsances of the component to be tracked, even if they wouldn't be otherwise.
            </summary>
      <param name="actions"> A set of actions to be executed when the component is destroyed. </param>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.OnlyNewServices">
      <summary>
            Services that are already present in the container will be skipped. If no new service is left the registration will not happen at all.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.OverWrite">
      <summary>
            With the overwrite.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Parameters(Castle.MicroKernel.Registration.Parameter[])">
      <summary>
            Set configuration parameters with string or <see cref="T:Castle.Core.Configuration.IConfiguration" /> values.
            </summary>
      <param name="parameters"> The parameters. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.SelectInterceptorsWith(Castle.DynamicProxy.IInterceptorSelector)">
      <summary>
            Sets the interceptor selector for this component.
            </summary>
      <param name="selector">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.SelectInterceptorsWith(System.Action{Castle.MicroKernel.Registration.Proxy.ItemRegistration{Castle.DynamicProxy.IInterceptorSelector}})">
      <summary>
            Sets the interceptor selector for this component.
            </summary>
      <param name="selector">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ServiceOverrides(Castle.MicroKernel.Registration.ServiceOverride[])">
      <summary>
            Override (some of) the services that this component needs. Use <see cref="M:Castle.MicroKernel.Registration.ServiceOverride.ForKey(System.String)" /> to create an override.
                <para />
            Each key represents the service dependency of this component, for example the name of a constructor argument or a property. The corresponding value is the key of an other component registered to the
            kernel, and is used to resolve the dependency.
                <para />
            To specify dependencies which are not services, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(Castle.MicroKernel.Registration.Dependency[])" /></summary>
      <param name="overrides"> The service overrides. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ServiceOverrides(System.Collections.IDictionary)">
      <summary>
            Override (some of) the services that this component needs, using a dictionary.
                <para />
            Each key represents the service dependency of this component, for example the name of a constructor argument or a property. The corresponding value is the key of an other component registered to the
            kernel, and is used to resolve the dependency.
                <para />
            To specify dependencies which are not services, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(System.Collections.IDictionary)" /></summary>
      <param name="overrides"> The service overrides. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ServiceOverrides(System.Object)">
      <summary>
            Override (some of) the services that this component needs, using an (anonymous) object as a dictionary.
                <para />
            Each key represents the service dependency of this component, for example the name of a constructor argument or a property. The corresponding value is the key of an other component registered to the
            kernel, and is used to resolve the dependency.
                <para />
            To specify dependencies which are not services, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.DependsOn(System.Object)" /></summary>
      <param name="anonymous"> The service overrides. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.UsingFactory``2(System.Converter{``0,``1})">
      <summary>
            Uses a factory to instantiate the component
            </summary>
      <typeparam name="TFactory"> Factory type. This factory has to be registered in the kernel. </typeparam>
      <typeparam name="TServiceImpl"> Implementation type. </typeparam>
      <param name="factory"> Factory invocation </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.UsingFactoryMethod``1(System.Func{``0},System.Boolean)">
      <summary>
            Uses a factory method to instantiate the component.
            </summary>
      <typeparam name="TImpl"> Implementation type </typeparam>
      <param name="factoryMethod"> Factory method </param>
      <param name="managedExternally"> When set to <c>true</c> container will not assume ownership of this component, will not track it not apply and lifecycle concerns to it. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.UsingFactoryMethod``1(System.Converter{Castle.MicroKernel.IKernel,``0},System.Boolean)">
      <summary>
            Uses a factory method to instantiate the component.
            </summary>
      <typeparam name="TImpl"> Implementation type </typeparam>
      <param name="factoryMethod"> Factory method </param>
      <param name="managedExternally"> When set to <c>true</c> container will not assume ownership of this component, will not track it not apply and lifecycle concerns to it. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.UsingFactoryMethod``1(System.Func{Castle.MicroKernel.IKernel,Castle.Core.ComponentModel,Castle.MicroKernel.Context.CreationContext,``0},System.Boolean)">
      <summary>
            Uses a factory method to instantiate the component.
            </summary>
      <typeparam name="TImpl"> Implementation type </typeparam>
      <param name="factoryMethod"> Factory method </param>
      <param name="managedExternally"> When set to <c>true</c> container will not assume ownership of this component, will not track it not apply and lifecycle concerns to it. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.UsingFactoryMethod``1(System.Func{Castle.MicroKernel.IKernel,Castle.MicroKernel.Context.CreationContext,``0})">
      <summary>
            Uses a factory method to instantiate the component.
            </summary>
      <typeparam name="TImpl"> Implementation type </typeparam>
      <param name="factoryMethod"> Factory method </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.IsDefault(System.Predicate{System.Type})">
      <summary>
            Overrides default behavior by making the current component the default for every service it exposes. The <paramref name="serviceFilter" /> allows user to narrow down the number of services which
            should be make defaults.
            </summary>
      <param name="serviceFilter"> Invoked for each service exposed by given component if returns <c>true</c> this component will be the default for that service. </param>
      <returns>
      </returns>
      <remarks>
            When specified for multiple components for any given service the one registered after will override the one selected before.
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.IsDefault">
      <summary>
            Overrides default behavior by making the current component the default for every service it exposes.
            </summary>
      <returns>
      </returns>
      <remarks>
            When specified for multiple components for any given service the one registered after will override the one selected before.
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.IsFallback(System.Predicate{System.Type})">
      <summary>
            Overrides default behavior by making the current component the fallback for every service it exposes that <paramref name="serviceFilter" /> returns <c>true</c> for. That is if another,
            non-fallback, component will be registered exposing any of these same services as this component, that other component will take precedence over this one, regardless of order in which they are
            registered.
            </summary>
      <param name="serviceFilter"> Invoked for each service exposed by given component if returns <c>true</c> this component will be the fallback for that service. </param>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.IsFallback">
      <summary>
            Overrides default behavior by making the current component the fallback for every service it exposes. That is if another, non-fallback, component will be registered exposing any of the same services
            as this component, that other component will take precedence over this one, regardless of order in which they are registered
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Properties(System.Predicate{System.Reflection.PropertyInfo})">
      <summary>
            Filters (settable) properties of the component's implementation type to expose in the container.
            </summary>
      <param name="filter"> Predicate deciding whether a property is settable or not. If it returns <c>false</c> the property will not be added to <see cref="P:Castle.Core.ComponentModel.Properties" /> collection
            and Windsor will never try to set it. </param>
      <returns>
      </returns>
      <remarks>
            Matched properties will be considered optional. Windsor will resolve the component even if it cannot provide value for those properties. If you want to make them mandatory use a different overload.
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Properties(System.Predicate{System.Reflection.PropertyInfo},System.Boolean)">
      <summary>
            Filters (settable) properties of the component's implementation type to expose in the container and specifies if matched properties are considered mandatory.
            </summary>
      <param name="filter"> Predicate deciding whether a property is settable or not. If it returns <c>false</c> the property will not be added to <see cref="P:Castle.Core.ComponentModel.Properties" /> collection
            and Windsor will never try to set it. </param>
      <param name="isRequired"> if <c>true</c> the properties matched by <paramref name="filter" /> will be considered mandatory dependencies. Windsor will only successfully resole the component if it
            can provide value for all of these properties. If <c>false</c> Windsor will still try to provide values for these properties, but if it can't it will not stop the component from being successfully
            resolved. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Properties(System.Func{Castle.Core.ComponentModel,System.Reflection.PropertyInfo,System.Boolean},System.Boolean)">
      <summary>
            Filters (settable) properties of the component's implementation type to expose in the container and specifies if matched properties are considered mandatory.
            </summary>
      <param name="filter"> Predicate deciding whether a property is settable or not. If it returns <c>false</c> the property will not be added to <see cref="P:Castle.Core.ComponentModel.Properties" /> collection
            and Windsor will never try to set it. </param>
      <param name="isRequired"> if <c>true</c> the properties matched by <paramref name="filter" /> will be considered mandatory dependencies. Windsor will only successfully resole the component if it
            can provide value for all of these properties. If <c>false</c> Windsor will still try to provide values for these properties, but if it can't it will not stop the component from being successfully
            resolved. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.PropertiesIgnore(System.Func{System.Reflection.PropertyInfo,System.Boolean})">
      <summary>
            Filters (settable) properties of the component's implementation type to ignore.
            </summary>
      <param name="propertySelector"> Predicate finding properties to ignore. If it returns <c>true</c> the property will not be added to <see cref="P:Castle.Core.ComponentModel.Properties" /> collection and Windsor
            will never try to set it. </param>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.PropertiesRequire(System.Func{System.Reflection.PropertyInfo,System.Boolean})">
      <summary>
            Filters (settable) properties of the component's implementation type to expose in the container as mandatory dependencies
            </summary>
      <param name="propertySelector"> Predicate finding properties. If it returns <c>true</c> the property will be added to <see cref="P:Castle.Core.ComponentModel.Properties" /> collection and Windsor will make it
            a mandatory dependency. </param>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.PropertiesIgnore(System.Func{Castle.Core.ComponentModel,System.Reflection.PropertyInfo,System.Boolean})">
      <summary>
            Filters (settable) properties of the component's implementation type to ignore.
            </summary>
      <param name="propertySelector"> Predicate finding properties to ignore. If it returns <c>true</c> the property will not be added to <see cref="P:Castle.Core.ComponentModel.Properties" /> collection and Windsor
            will never try to set it. </param>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.PropertiesRequire(System.Func{Castle.Core.ComponentModel,System.Reflection.PropertyInfo,System.Boolean})">
      <summary>
            Filters (settable) properties of the component's implementation type to expose in the container as mandatory dependencies
            </summary>
      <param name="propertySelector"> Predicate finding properties. If it returns <c>true</c> the property will be added to <see cref="P:Castle.Core.ComponentModel.Properties" /> collection and Windsor will make it
            a mandatory dependency. </param>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Properties(Castle.Core.PropertyFilter)">
      <summary>
            Filters (settable) properties of the component's implementation type to expose in the container and specifies if matched properties are considered mandatory.
            </summary>
      <param name="filter"> Rules for deciding whether given properties are exposed in the container or ignored and if they are mandatory, that is Windsor will only successfully resole the component if
            it can provide value for all of these properties. </param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.MicroKernel.Registration.ComponentRegistration`1.Implementation">
      <summary>
            The concrete type that implements the service.
                <para />
            To set the implementation, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.ImplementedBy(System.Type)" /> .
            </summary>
      <value> The implementation of the service. </value>
    </member>
    <member name="P:Castle.MicroKernel.Registration.ComponentRegistration`1.LifeStyle">
      <summary>
            Set the lifestyle of this component. For example singleton and transient (also known as 'factory').
            </summary>
      <value> The with lifestyle. </value>
    </member>
    <member name="P:Castle.MicroKernel.Registration.ComponentRegistration`1.Name">
      <summary>
            The name of the component. Will become the key for the component in the kernel.
                <para />
            To set the name, use <see cref="M:Castle.MicroKernel.Registration.ComponentRegistration`1.Named(System.String)" /> .
                <para />
            If not set, the <see cref="P:System.Type.FullName" /> of the <see cref="P:Castle.MicroKernel.Registration.ComponentRegistration`1.Implementation" /> will be used as the key to register the component.
            </summary>
      <value> The name. </value>
    </member>
    <member name="P:Castle.MicroKernel.Registration.ComponentRegistration`1.Proxy">
      <summary>
            Set proxy for this component.
            </summary>
      <value> The proxy. </value>
    </member>
    <member name="T:Castle.MicroKernel.Registration.ComponentRegistration">
      <summary>
              A non-generic <see cref="T:Castle.MicroKernel.Registration.ComponentRegistration`1" />.
              <para />
              You can create a new registration with the <see cref="T:Castle.MicroKernel.Registration.Component" /> factory.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Registration.Node">
      <summary>
              Represents a configuration child.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Node.ApplyTo(Castle.Core.Configuration.IConfiguration)">
      <summary>
              Applies the configuration node.
            </summary>
      <param name="configuration">The configuration.</param>
    </member>
    <member name="T:Castle.MicroKernel.Registration.Attrib">
      <summary>
              Represents a configuration attribute.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Attrib.ApplyTo(Castle.Core.Configuration.IConfiguration)">
      <summary>
              Applies the configuration node.
            </summary>
      <param name="configuration">The configuration.</param>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Attrib.ForName(System.String)">
      <summary>
              Create a <see cref="T:Castle.MicroKernel.Registration.NamedAttribute" /> with name.
            </summary>
      <param name="name">The attribute name.</param>
      <returns>The new <see cref="T:Castle.MicroKernel.Registration.NamedAttribute" /></returns>
    </member>
    <member name="T:Castle.MicroKernel.Registration.NamedAttribute">
      <summary>
              Represents a named attribute.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.NamedAttribute.Eq(System.String)">
      <summary>
              Builds the <see cref="T:System.Attribute" /> with name/value.
            </summary>
      <param name="value">The attribute value.</param>
      <returns>The new <see cref="T:Castle.MicroKernel.Registration.SimpleChild" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.NamedAttribute.Eq(System.Object)">
      <summary>
              Builds the <see cref="T:System.Attribute" /> with name/value.
            </summary>
      <param name="value">The attribute value.</param>
      <returns>The new <see cref="T:Castle.MicroKernel.Registration.SimpleChild" /></returns>
    </member>
    <member name="T:Castle.MicroKernel.Registration.Child">
      <summary>
              Represents a configuration child.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Child.ForName(System.String)">
      <summary>
              Create a <see cref="T:Castle.MicroKernel.Registration.NamedChild" /> with name.
            </summary>
      <param name="name">The child name.</param>
      <returns>The new <see cref="T:Castle.MicroKernel.Registration.NamedChild" /></returns>
    </member>
    <member name="T:Castle.MicroKernel.Registration.NamedChild">
      <summary>
              Represents a named child.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.NamedChild.ApplyTo(Castle.Core.Configuration.IConfiguration)">
      <summary>
              Applies the configuration node.
            </summary>
      <param name="configuration">The configuration.</param>
    </member>
    <member name="M:Castle.MicroKernel.Registration.NamedChild.Eq(System.String)">
      <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.SimpleChild" /> with name/value.
            </summary>
      <param name="value">The child value.</param>
      <returns>The new <see cref="T:Castle.MicroKernel.Registration.SimpleChild" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.NamedChild.Eq(System.Object)">
      <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.SimpleChild" /> with name/value.
            </summary>
      <param name="value">The child value.</param>
      <returns>The new <see cref="T:Castle.MicroKernel.Registration.SimpleChild" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.NamedChild.Eq(Castle.Core.Configuration.IConfiguration)">
      <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.ComplexChild" /> with name/config.
            </summary>
      <param name="configNode">The child configuration.</param>
      <returns>The new <see cref="T:Castle.MicroKernel.Registration.ComplexChild" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.NamedChild.Eq(Castle.MicroKernel.Registration.Node[])">
      <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.Child" /> with name/config.
            </summary>
      <param name="childNodes">The child nodes.</param>
      <returns>The new <see cref="T:Castle.MicroKernel.Registration.CompoundChild" /></returns>
    </member>
    <member name="T:Castle.MicroKernel.Registration.SimpleChild">
      <summary>
              Represents a simple child node.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.SimpleChild.ApplyTo(Castle.Core.Configuration.IConfiguration)">
      <summary>
              Applies the configuration node.
            </summary>
      <param name="configuration">The configuration.</param>
    </member>
    <member name="T:Castle.MicroKernel.Registration.ComplexChild">
      <summary>
              Represents a complex child node.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ComplexChild.ApplyTo(Castle.Core.Configuration.IConfiguration)">
      <summary>
              Applies the configuration node.
            </summary>
      <param name="configuration">The configuration.</param>
    </member>
    <member name="T:Castle.MicroKernel.Registration.CompoundChild">
      <summary>
              Represents a compound child node.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.CompoundChild.ApplyTo(Castle.Core.Configuration.IConfiguration)">
      <summary>
              Applies the configuration node.
            </summary>
      <param name="configuration">The configuration.</param>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Dependency.OnConfigValue(System.String,System.String)">
      <summary>
            Specifies that value <paramref name="valueAsString" /> should be used to satisfy dependencies matched by <paramref name="dependencyName" />. The value is provided as a string and will be
            converted to appropriate type when resolving.
            </summary>
      <param name="dependencyName">
      </param>
      <param name="valueAsString">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Dependency.OnConfigValue(System.String,Castle.Core.Configuration.IConfiguration)">
      <summary>
            Specifies that value <paramref name="value" /> should be used to satisfy dependencies matched by <paramref name="dependencyName" />. The value is provided as a string and will be converted to
            appropriate type when resolving.
            </summary>
      <param name="dependencyName">
      </param>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Dependency.OnAppSettingsValue(System.String,System.String)">
      <summary>
            Specifies that value from application configuration file's appSettings section named <paramref name="settingName" /> should be used to satisfy dependencies matched by
                <paramref name="dependencyName" />. The value is provided as a string and will be converted to appropriate type when resolving.
            </summary>
      <param name="dependencyName">
      </param>
      <param name="settingName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Dependency.OnAppSettingsValue(System.String)">
      <summary>
            Specifies that value from application configuration file's appSettings section named <paramref name="name" /> should be used to satisfy dependencies matched by <paramref name="name" />. The value
            is provided as a string and will be converted to appropriate type when resolving.
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Dependency.OnComponent(System.String,System.String)">
      <summary>
            Specifies that component registered with <paramref name="componentName" /> should be used to satisfy dependencies matched by <paramref name="dependencyName" /></summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Dependency.OnComponent(System.Type,System.String)">
      <summary>
            Specifies that component registered with <paramref name="componentName" /> should be used to satisfy dependencies matched by <paramref name="dependencyType" /></summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Dependency.OnComponent(System.String,System.Type)">
      <summary>
            Specifies that component registered with <paramref name="componentType" /> should be used to satisfy dependencies matched by <paramref name="dependencyName" /></summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Dependency.OnComponent(System.Type,System.Type)">
      <summary>
            Specifies that component registered with <paramref name="componentType" /> should be used to satisfy dependencies matched by <paramref name="dependencyType" /></summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Dependency.OnComponent``2">
      <summary>
            Specifies that component registered with <typeparamref name="TComponentType" /> should be used to satisfy dependencies matched by <typeparamref name="TDependencyType" /></summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Dependency.OnComponentCollection(System.String,System.String[])">
      <summary>
            Specifies that components registered with <paramref name="componentNames" /> should be used to satisfy collection dependencies matched by <paramref name="collectionDependencyName" /></summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Dependency.OnComponentCollection(System.Type,System.String[])">
      <summary>
            Specifies that components registered with <paramref name="componentNames" /> should be used to satisfy collection dependencies matched by <paramref name="collectionDependencyType" /></summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Dependency.OnComponentCollection``1(System.String[])">
      <summary>
            Specifies that components registered with <paramref name="componentNames" /> should be used to satisfy collection dependencies matched by <typeparamref name="TCollectionDependencyType" /></summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Dependency.OnComponentCollection(System.String,System.Type[])">
      <summary>
            Specifies that components registered with <paramref name="componentTypes" /> should be used to satisfy collection dependencies matched by <paramref name="collectionDependencyName" /></summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Dependency.OnComponentCollection(System.Type,System.Type[])">
      <summary>
            Specifies that components registered with <paramref name="componentTypes" /> should be used to satisfy collection dependencies matched by <paramref name="collectionDependencyType" /></summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Dependency.OnComponentCollection``1(System.Type[])">
      <summary>
            Specifies that components registered with <paramref name="componentTypes" /> should be used to satisfy collection dependencies matched by <typeparamref name="TCollectionDependencyType" /></summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Dependency.OnValue(System.String,System.Object)">
      <summary>
            Specifies that value <paramref name="value" /> should be used to satisfy dependencies matched by <paramref name="dependencyName" /></summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Dependency.OnValue(System.Type,System.Object)">
      <summary>
            Specifies that value <paramref name="value" /> should be used to satisfy dependencies matched by <paramref name="dependencyType" /></summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Dependency.OnValue``1(System.Object)">
      <summary>
            Specifies that value <paramref name="value" /> should be used to satisfy dependencies matched by <typeparamref name="TDependencyType" /></summary>
    </member>
    <member name="T:Castle.MicroKernel.Registration.IWindsorInstaller">
      <summary>
              The contract to install components in the container.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.IWindsorInstaller.Install(Castle.Windsor.IWindsorContainer,Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore)">
      <summary>
              Performs the installation in the <see cref="T:Castle.Windsor.IWindsorContainer" />.
            </summary>
      <param name="container">The container.</param>
      <param name="store">The configuration store.</param>
    </member>
    <member name="T:Castle.MicroKernel.ModelBuilder.Descriptors.OnCreateComponentDescriptor`1">
      <summary>
              Adds the actions to ExtendedProperties.
            </summary>
      <typeparam name="S">
      </typeparam>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Lifestyle.LifestyleGroup`1.Is(Castle.Core.LifestyleType)">
      <summary>
              Sets the lifestyle to the specified
              <paramref name="type" />
              .
            </summary>
      <param name="type"> The type. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Lifestyle.LifestyleGroup`1.Scoped``1">
      <summary>
              Assigns scoped lifestyle with scope accessed via
              <typeparamref name="TScopeAccessor" />
              instances.
            </summary>
      <typeparam name="TScopeAccessor">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Lifestyle.LifestyleGroup`1.Scoped(System.Type)">
      <summary>
              Assigns scoped lifestyle with scope accessed via
              <paramref name="scopeAccessorType" />
              instances if provided, or default accessor otherwise.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Lifestyle.LifestyleGroup`1.Scoped">
      <summary>
              Assigns scoped lifestyle with scope accessed via default accessor.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Lifestyle.LifestyleGroup`1.Custom(System.Type)">
      <summary>
              Assign a custom lifestyle type, that implements
              <see cref="T:Castle.MicroKernel.ILifestyleManager" />
              .
            </summary>
      <param name="customLifestyleType"> Type of the custom lifestyle. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Lifestyle.LifestyleGroup`1.Custom``1">
      <summary>
              Assign a custom lifestyle type, that implements
              <see cref="T:Castle.MicroKernel.ILifestyleManager" />
              .
            </summary>
      <typeparam name="TLifestyleManager"> The type of the custom lifestyle </typeparam>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.MicroKernel.Registration.Parameter">
      <summary>
              Represents a configuration parameter.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Parameter.ForKey(System.String)">
      <summary>
              Create a <see cref="T:Castle.MicroKernel.Registration.ParameterKey" /> with key.
            </summary>
      <param name="key">The parameter key.</param>
      <returns>The new <see cref="T:Castle.MicroKernel.Registration.ParameterKey" /></returns>
    </member>
    <member name="P:Castle.MicroKernel.Registration.Parameter.ConfigNode">
      <summary>
              Gets the parameter configuration.
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.Registration.Parameter.Key">
      <summary>
              Gets the parameter key.
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.Registration.Parameter.Value">
      <summary>
              Gets the parameter value.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Registration.ParameterKey">
      <summary>
              Represents a parameter key.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ParameterKey.Eq(System.String)">
      <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.Parameter" /> with key/value.
            </summary>
      <param name="value">The parameter value.</param>
      <returns>The new <see cref="T:Castle.MicroKernel.Registration.Parameter" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ParameterKey.Eq(Castle.Core.Configuration.IConfiguration)">
      <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.Parameter" /> with key/config.
            </summary>
      <param name="configNode">The parameter configuration.</param>
      <returns>The new <see cref="T:Castle.MicroKernel.Registration.Parameter" /></returns>
    </member>
    <member name="P:Castle.MicroKernel.Registration.ParameterKey.Name">
      <summary>
              The parameter key name.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Registration.Property">
      <summary>
              Represents a key/value pair.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Property.ForKey(System.String)">
      <summary>
              Create a <see cref="T:Castle.MicroKernel.Registration.PropertyKey" /> with key.
            </summary>
      <param name="key">The property key.</param>
      <returns>The new <see cref="T:Castle.MicroKernel.Registration.PropertyKey" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Property.ForKey(System.Type)">
      <summary>
              Create a <see cref="T:Castle.MicroKernel.Registration.PropertyKey" /> with key.
            </summary>
      <param name="key">The property key.</param>
      <returns>The new <see cref="T:Castle.MicroKernel.Registration.PropertyKey" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.Property.ForKey``1">
      <summary>
              Create a <see cref="T:Castle.MicroKernel.Registration.PropertyKey" /> with key.
            </summary>
      <param key="key">The property key.</param>
      <returns>The new <see cref="T:Castle.MicroKernel.Registration.PropertyKey" /></returns>
    </member>
    <member name="P:Castle.MicroKernel.Registration.Property.Key">
      <summary>
              Gets the property key.
            </summary>
    </member>
    <member name="P:Castle.MicroKernel.Registration.Property.Value">
      <summary>
              Gets the property value.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Registration.PropertyKey">
      <summary>
              Represents a property key.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.PropertyKey.Eq(System.Object)">
      <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.Property" /> with key/value.
            </summary>
      <param name="value">The property value.</param>
      <returns>The new <see cref="T:Castle.MicroKernel.Registration.Property" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.PropertyKey.Is(System.String)">
      <summary>
              Builds a service override using other component registered with given <paramref name="componentName" /> as value for dependency with given <see cref="P:Castle.MicroKernel.Registration.PropertyKey.Key" />.
            </summary>
      <param name="componentName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.PropertyKey.Is(System.Type)">
      <summary>
              Builds a service override using other component registered with given <paramref name="componentImplementation" /> and no explicit name, as value for dependency with given <see cref="P:Castle.MicroKernel.Registration.PropertyKey.Key" />.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.PropertyKey.Is``1">
      <summary>
              Builds a service override using other component registered with given <typeparam name="TComponentImplementation" /> and no explicit name, as value for dependency with given <see cref="P:Castle.MicroKernel.Registration.PropertyKey.Key" />.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.MicroKernel.Registration.PropertyKey.Key">
      <summary>
              The property key key.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Registration.ServiceOverride">
      <summary>
              Represents a service override.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ServiceOverride.ForKey(System.String)">
      <summary>
              Creates a <see cref="T:Castle.MicroKernel.Registration.ServiceOverrideKey" /> with key.
            </summary>
      <param name="key">The service override key.</param>
      <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverrideKey" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ServiceOverride.ForKey(System.Type)">
      <summary>
              Creates a <see cref="T:Castle.MicroKernel.Registration.ServiceOverrideKey" /> with key.
            </summary>
      <param name="key">The service override key.</param>
      <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverrideKey" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ServiceOverride.ForKey``1">
      <summary>
              Creates a <see cref="T:Castle.MicroKernel.Registration.ServiceOverrideKey" /> with key.
            </summary>
      <typeparam name="TKey">The service override key.</typeparam>
      <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverrideKey" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ServiceOverride.op_Implicit(Castle.MicroKernel.Registration.ServiceOverride)~Castle.MicroKernel.Registration.Dependency">
      <summary>
              Implicitly converts service override to dependency. This is a API trick to keep the API clean and focused.
            </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.MicroKernel.Registration.ServiceOverride.Type">
      <summary>
              Gets the optional value type specifier.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Registration.ServiceOverrideKey">
      <summary>
              Represents a service override key.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ServiceOverrideKey.Eq(System.String)">
      <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.ServiceOverride" /> with key/value.
            </summary>
      <param name="value">The service override value.</param>
      <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverride" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ServiceOverrideKey.Eq(System.String[])">
      <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.ServiceOverride" /> with key/values.
            </summary>
      <param name="value">The service override values.</param>
      <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverride" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ServiceOverrideKey.Eq``1(System.String[])">
      <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.ServiceOverride" /> with key/values.
            </summary>
      <param name="value">The service override values.</param>
      <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverride" /></returns>
      <typeparam name="V">The value type.</typeparam>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ServiceOverrideKey.Eq(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.ServiceOverride" /> with key/values.
            </summary>
      <param name="value">The service override values.</param>
      <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverride" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ServiceOverrideKey.Eq``1(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
              Builds the <see cref="T:Castle.MicroKernel.Registration.ServiceOverride" /> with key/values.
            </summary>
      <param name="value">The service override values.</param>
      <returns>The new <see cref="T:Castle.MicroKernel.Registration.ServiceOverride" /></returns>
      <typeparam name="V">The value type.</typeparam>
    </member>
    <member name="T:Castle.MicroKernel.Registration.AllTypes">
      <summary>
              Describes a set of components to register in the kernel. Use static methods on the class to fluently build registration.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.AllTypes.From(System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
              Prepares to register types from a list of types.
            </summary>
      <param name="types">The list of types.</param>
      <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.AllTypes.From(System.Type[])">
      <summary>
              Prepares to register types from a list of types.
            </summary>
      <param name="types">The list of types.</param>
      <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.AllTypes.FromAssembly(System.Reflection.Assembly)">
      <summary>
              Prepares to register types from an assembly.
            </summary>
      <param name="assembly">The assembly.</param>
      <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.AllTypes.FromAssemblyContaining(System.Type)">
      <summary>
              Prepares to register types from an assembly containing the type.
            </summary>
      <param name="type">The type belonging to the assembly.</param>
      <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.AllTypes.FromAssemblyContaining``1">
      <summary>
              Prepares to register types from an assembly containing the type.
            </summary>
      <typeparam name="T">The type belonging to the assembly.</typeparam>
      <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.AllTypes.FromAssemblyInDirectory(Castle.MicroKernel.Registration.AssemblyFilter)">
      <summary>
              Prepares to register types from assemblies found in a given directory that meet additional optional restrictions.
            </summary>
      <param name="filter">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.AllTypes.FromAssemblyNamed(System.String)">
      <summary>
              Prepares to register types from an assembly.
            </summary>
      <param name="assemblyName">The assembly name.</param>
      <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.AllTypes.FromThisAssembly">
      <summary>
              Prepares to register types from the assembly containing the code invoking this method.
            </summary>
      <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.AllTypes.Of(System.Type)">
      <summary>
              Describes all the types based on <c>basedOn</c>.
            </summary>
      <param name="basedOn">The base type.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.AllTypes.Of``1">
      <summary>
              Describes all the types based on type T.
            </summary>
      <typeparam name="T">The base type.</typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.AllTypes.Pick">
      <summary>
              Describes any types that are supplied.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.AllTypes.Pick(System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
              Prepares to register types from a list of types.
            </summary>
      <param name="types">The list of types.</param>
      <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.FromDescriptor" /></returns>
    </member>
    <member name="T:Castle.MicroKernel.Registration.AllTypesOf">
      <summary>
              Describes a related group of components to register in the kernel.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.AllTypesOf.From(System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
              Prepares to register types from a list of types.
            </summary>
      <param name="types">The list of types.</param>
      <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.AllTypesOf.From(System.Type[])">
      <summary>
              Prepares to register types from a list of types.
            </summary>
      <param name="types">The list of types.</param>
      <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.AllTypesOf.FromAssembly(System.Reflection.Assembly)">
      <summary>
              Prepares to register types from an assembly.
            </summary>
      <param name="assembly">The assembly.</param>
      <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.AllTypesOf.FromAssemblyNamed(System.String)">
      <summary>
              Prepares to register types from an assembly.
            </summary>
      <param name="assemblyName">The assembly name.</param>
      <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor" /></returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.AllTypesOf.Pick(System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
              Prepares to register types from a list of types.
            </summary>
      <param name="types">The list of types.</param>
      <returns>The corresponding <see cref="T:Castle.MicroKernel.Registration.BasedOnDescriptor" /></returns>
    </member>
    <member name="T:Castle.MicroKernel.Registration.FromDescriptor">
      <summary>
              Describes the source of types to register.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.FromDescriptor.AllowMultipleMatches">
      <summary>
              Allows a type to be registered multiple times.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.FromDescriptor.BasedOn``1">
      <summary>
              Returns the descriptor for accepting a type.
            </summary>
      <typeparam name="T"> The base type. </typeparam>
      <returns> The descriptor for the type. </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.FromDescriptor.BasedOn(System.Type)">
      <summary>
              Returns the descriptor for accepting a type.
            </summary>
      <param name="basedOn"> The base type. </param>
      <returns> The descriptor for the type. </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.FromDescriptor.BasedOn(System.Type[])">
      <summary>
              Returns the descriptor for accepting a type.
            </summary>
      <param name="basedOn"> One or more base types. To be accepted a type must implement at least one of the given base types. </param>
      <returns> The descriptor for the type. </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.FromDescriptor.BasedOn(System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
              Returns the descriptor for accepting a type.
            </summary>
      <param name="basedOn"> One or more base types. To be accepted a type must implement at least one of the given base types. </param>
      <returns> The descriptor for the type. </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.FromDescriptor.InNamespace(System.String)">
      <summary>
              Creates a predicate to check if a component is in a namespace.
            </summary>
      <param name="namespace"> The namespace. </param>
      <returns> true if the component type is in the namespace. </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.FromDescriptor.InNamespace(System.String,System.Boolean)">
      <summary>
              Creates a predicate to check if a component is in a namespace.
            </summary>
      <param name="namespace"> The namespace. </param>
      <param name="includeSubnamespaces"> If set to true, will also include types from subnamespaces. </param>
      <returns> true if the component type is in the namespace. </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.FromDescriptor.InSameNamespaceAs(System.Type)">
      <summary>
              Creates a predicate to check if a component shares a namespace with another.
            </summary>
      <param name="type"> The component type to test namespace against. </param>
      <returns> true if the component is in the same namespace. </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.FromDescriptor.InSameNamespaceAs(System.Type,System.Boolean)">
      <summary>
              Creates a predicate to check if a component shares a namespace with another.
            </summary>
      <param name="type"> The component type to test namespace against. </param>
      <param name="includeSubnamespaces"> If set to true, will also include types from subnamespaces. </param>
      <returns> true if the component is in the same namespace. </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.FromDescriptor.InSameNamespaceAs``1">
      <summary>
              Creates a predicate to check if a component shares a namespace with another.
            </summary>
      <typeparam name="T"> The component type to test namespace against. </typeparam>
      <returns> true if the component is in the same namespace. </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.FromDescriptor.InSameNamespaceAs``1(System.Boolean)">
      <summary>
              Creates a predicate to check if a component shares a namespace with another.
            </summary>
      <typeparam name="T"> The component type to test namespace against. </typeparam>
      <param name="includeSubnamespaces"> If set to true, will also include types from subnamespaces. </param>
      <returns> true if the component is in the same namespace. </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.FromDescriptor.Pick">
      <summary>
              Returns the descriptor for accepting any type from given solutions.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.FromDescriptor.Where(System.Predicate{System.Type})">
      <summary>
              Returns the descriptor for accepting a type based on a condition.
            </summary>
      <param name="accepted"> The accepting condition. </param>
      <returns> The descriptor for the type. </returns>
    </member>
    <member name="T:Castle.MicroKernel.Registration.FromAssemblyDescriptor">
      <summary>
              Selects a set of types from an assembly.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.FromAssemblyDescriptor.IncludeNonPublicTypes">
      <summary>
              When called also non-public types will be scanned.
            </summary>
      <remarks>
              Usually it is not recommended to register non-public types in the container so think twice before using this option.
            </remarks>
    </member>
    <member name="T:Castle.MicroKernel.Registration.FromTypesDescriptor">
      <summary>
              Selects an existing set of types to register.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Registration.ServiceDescriptor">
      <summary>
              Describes how to select a types service.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.AllInterfaces">
      <summary>
              Uses all interfaces implemented by the type (or its base types) as well as their base interfaces.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.Base">
      <summary>
              Uses the base type matched on.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.DefaultInterfaces">
      <summary>
              Uses all interfaces that have names matched by implementation type name.
              Matches Foo to IFoo, SuperFooExtended to IFoo and IFooExtended etc
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.FirstInterface">
      <summary>
              Uses the first interface of a type. This method has non-deterministic behavior when type implements more than one interface!
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.FromInterface(System.Type)">
      <summary>
              Uses <paramref name="implements" /> to lookup the sub interface.
              For example: if you have IService and 
              IProductService : ISomeInterface, IService, ISomeOtherInterface.
              When you call FromInterface(typeof(IService)) then IProductService
              will be used. Useful when you want to register _all_ your services
              and but not want to specify all of them.
            </summary>
      <param name="implements">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.FromInterface">
      <summary>
              Uses base type to lookup the sub interface.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.Select(Castle.MicroKernel.Registration.ServiceDescriptor.ServiceSelector)">
      <summary>
              Assigns a custom service selection strategy.
            </summary>
      <param name="selector">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.Select(System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
              Assigns the supplied service types.
            </summary>
      <param name="types">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.Self">
      <summary>
              Uses the type itself.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.ServiceDescriptor.WorkaroundCLRBug(System.Type)">
      <summary>
              This is a workaround for a CLR bug in
              which GetInterfaces() returns interfaces
              with no implementations.
            </summary>
      <param name="serviceType">Type of the service.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.MicroKernel.Registration.BasedOnDescriptor">
      <summary>
              Describes how to register a group of related types.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.#ctor(System.Collections.Generic.IEnumerable{System.Type},Castle.MicroKernel.Registration.FromDescriptor,System.Predicate{System.Type})">
      <summary>
              Initializes a new instance of the BasedOnDescriptor.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.AllowMultipleMatches">
      <summary>
              Allows a type to be registered multiple times.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.BasedOn``1">
      <summary>
              Returns the descriptor for accepting a new type.
            </summary>
      <typeparam name="T"> The base type. </typeparam>
      <returns> The descriptor for the type. </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.BasedOn(System.Type)">
      <summary>
              Returns the descriptor for accepting a new type.
            </summary>
      <param name="basedOn"> The base type. </param>
      <returns> The descriptor for the type. </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.OrBasedOn(System.Type)">
      <summary>
              Adds another type to be accepted as base.
            </summary>
      <param name="basedOn"> The base type. </param>
      <returns> The descriptor for the type. </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.Configure(System.Action{Castle.MicroKernel.Registration.ComponentRegistration})">
      <summary>
              Allows customized configurations of each matching type.
            </summary>
      <param name="configurer"> The configuration action. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.ConfigureFor``1(System.Action{Castle.MicroKernel.Registration.ComponentRegistration})">
      <summary>
              Allows customized configurations of each matching component with implementation type that is 
              assignable to
              <typeparamref name="TComponentImplementationType" />
              .
            </summary>
      <typeparam name="TComponentImplementationType"> The type assignable from. </typeparam>
      <param name="configurer"> The configuration action. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.ConfigureIf(System.Predicate{Castle.MicroKernel.Registration.ComponentRegistration},System.Action{Castle.MicroKernel.Registration.ComponentRegistration})">
      <summary>
              Allows customized configurations of each matching component that satisfies supplied <paramref name="condition" />.
            </summary>
      <param name="condition"> Condition to satisfy </param>
      <param name="configurer"> The configuration action, executed only for components for which <paramref name="condition" /> evaluates to <c>true</c> . </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.ConfigureIf(System.Predicate{Castle.MicroKernel.Registration.ComponentRegistration},System.Action{Castle.MicroKernel.Registration.ComponentRegistration},System.Action{Castle.MicroKernel.Registration.ComponentRegistration})">
      <summary>
              Allows customized configurations of each matching component that satisfies supplied <paramref name="condition" /> and alternative configuration for the rest of components.
            </summary>
      <param name="condition"> Condition to satisfy </param>
      <param name="configurerWhenTrue"> The configuration action, executed only for components for which <paramref name="condition" /> evaluates to <c>true</c> . </param>
      <param name="configurerWhenFalse"> The configuration action, executed only for components for which <paramref name="condition" /> evaluates to <c>false</c> . </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.If(System.Predicate{System.Type})">
      <summary>
              Assigns a conditional predication which must be satisfied.
            </summary>
      <param name="ifFilter"> The predicate to satisfy. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.Unless(System.Predicate{System.Type})">
      <summary>
              Assigns a conditional predication which must not be satisfied.
            </summary>
      <param name="unlessFilter"> The predicate not to satisify. </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.Where(System.Predicate{System.Type})">
      <summary>
              Returns the descriptor for accepting a type based on a condition.
            </summary>
      <param name="accepted"> The accepting condition. </param>
      <returns> The descriptor for the type. </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.WithServiceAllInterfaces">
      <summary>
              Uses all interfaces implemented by the type (or its base types) as well as their base interfaces.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.WithServiceBase">
      <summary>
              Uses the base type matched on.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.WithServiceDefaultInterfaces">
      <summary>
              Uses all interfaces that have names matched by implementation type name.
              Matches Foo to IFoo, SuperFooExtended to IFoo and IFooExtended etc
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.WithServiceFirstInterface">
      <summary>
              Uses the first interface of a type. This method has non-deterministic behavior when type implements more than one interface!
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.WithServiceFromInterface(System.Type)">
      <summary>
              Uses <paramref name="implements" /> to lookup the sub interface.
              For example: if you have IService and 
              IProductService : ISomeInterface, IService, ISomeOtherInterface.
              When you call FromInterface(typeof(IService)) then IProductService
              will be used. Useful when you want to register _all_ your services
              and but not want to specify all of them.
            </summary>
      <param name="implements">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.WithServiceFromInterface">
      <summary>
              Uses base type to lookup the sub interface.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.WithServiceSelect(Castle.MicroKernel.Registration.ServiceDescriptor.ServiceSelector)">
      <summary>
              Assigns a custom service selection strategy.
            </summary>
      <param name="selector">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.WithServiceSelf">
      <summary>
              Uses the type itself.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.LifestyleCustom(System.Type)">
      <summary>
              Sets component lifestyle to specified one.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.LifestyleCustom``1">
      <summary>
              Sets component lifestyle to specified one.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.LifestylePerThread">
      <summary>
              Sets component lifestyle to per thread.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.LifestyleScoped">
      <summary>
              Sets component lifestyle to scoped per explicit scope.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.LifestyleScoped(System.Type)">
      <summary>
              Sets component lifestyle to scoped per explicit scope.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.LifestyleScoped``1">
      <summary>
              Sets component lifestyle to scoped per explicit scope.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.LifestyleBoundTo``1">
      <summary>
              Sets component lifestyle to scoped per component <typeparamref name="TBaseForRoot" />.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.LifestyleBoundToNearest``1">
      <summary>
              Sets component lifestyle to scoped per nearest component on the resolution stack where implementation type is assignable to <typeparamref name="TBaseForRoot" /> .
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.LifestylePerWebRequest">
      <summary>
              Sets component lifestyle to instance per web request.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.LifestylePooled(System.Nullable{System.Int32},System.Nullable{System.Int32})">
      <summary>
              Sets component lifestyle to pooled. If <paramref name="initialSize" /> or <paramref name="maxSize" /> are not set default values will be used.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.LifestyleSingleton">
      <summary>
              Sets component lifestyle to singleton.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.LifestyleTransient">
      <summary>
              Sets component lifestyle to transient.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.WithServices(System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
              Assigns the supplied service types.
            </summary>
      <param name="types">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Registration.BasedOnDescriptor.WithServices(System.Type[])">
      <summary>
              Assigns the supplied service types.
            </summary>
      <param name="types">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.MicroKernel.Registration.BasedOnDescriptor.WithService">
      <summary>
              Gets the service descriptor.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.IReleasePolicy">
      <summary>
              Policy managing lifetime of components, and in particular their release process.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.IReleasePolicy.CreateSubPolicy">
      <summary>
              Creates nested policy for scoped object tracking.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IReleasePolicy.HasTrack(System.Object)">
      <summary>
              Returns <c>true</c> if <paramref name="instance" /> is being tracked by this release policy, <c>false</c> otherwise.
            </summary>
      <param name="instance">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.IReleasePolicy.Release(System.Object)">
      <summary>
              Releases <paramref name="instance" /> if it's being tracked by this release policy, invoking its <see cref="T:Castle.Core.IDecommissionConcern" />s and stops tracking it so that it can be claimed by the Garbage Collector.
            </summary>
      <param name="instance">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.IReleasePolicy.Track(System.Object,Castle.MicroKernel.Burden)">
      <summary>
              Asks the policy to track given object. The object will be released when a call to <see cref="M:Castle.MicroKernel.IReleasePolicy.Release(System.Object)" /> is made.
            </summary>
      <param name="instance">
      </param>
      <param name="burden">
      </param>
      <exception cref="T:System.ArgumentException">Thrown when <paramref name="burden" /> does NOT have its <see cref="P:Castle.MicroKernel.Burden.RequiresPolicyRelease" /> flag set.</exception>
    </member>
    <member name="T:Castle.MicroKernel.Releasers.LifecycledComponentsReleasePolicy">
      <summary>
                Tracks all components requiring decomission (<see cref="P:Castle.MicroKernel.Burden.RequiresPolicyRelease" />)
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.Releasers.LifecycledComponentsReleasePolicy.#ctor(Castle.MicroKernel.IKernel)">
      <param name="kernel">
                Used to obtain <see cref="T:Castle.Windsor.Diagnostics.ITrackedComponentsDiagnostic" /> if present.
            </param>
    </member>
    <member name="M:Castle.MicroKernel.Releasers.LifecycledComponentsReleasePolicy.#ctor(Castle.Windsor.Diagnostics.ITrackedComponentsDiagnostic,Castle.Windsor.Diagnostics.ITrackedComponentsPerformanceCounter)">
      <summary>
                Creates new policy which publishes its tracking components count to
                <paramref name="trackedComponentsPerformanceCounter" />
                and exposes diagnostics into
                <paramref name="trackedComponentsDiagnostic" />
                .
            </summary>
      <param name="trackedComponentsDiagnostic">
      </param>
      <param name="trackedComponentsPerformanceCounter">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.Releasers.LifecycledComponentsReleasePolicy.GetTrackedComponentsDiagnostic(Castle.MicroKernel.IKernel)">
      <summary>
                Obtains <see cref="T:Castle.Windsor.Diagnostics.ITrackedComponentsDiagnostic" /> from given <see cref="T:Castle.MicroKernel.IKernel" /> if present.
            </summary>
      <param name="kernel">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.Releasers.LifecycledComponentsReleasePolicy.GetTrackedComponentsPerformanceCounter(Castle.Windsor.Diagnostics.IPerformanceMetricsFactory)">
      <summary>
                Creates new <see cref="T:Castle.Windsor.Diagnostics.ITrackedComponentsPerformanceCounter" /> from given <see cref="T:Castle.Windsor.Diagnostics.IPerformanceMetricsFactory" />.
            </summary>
      <param name="perfMetricsFactory">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.MicroKernel.Releasers.NoTrackingReleasePolicy">
      <summary>
              No tracking of component instances are made.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.IDependencyResolver">
      <summary>
              Implementors should use a strategy to obtain 
              valid references to properties and/or services 
              requested in the dependency model.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.IDependencyResolver.AddSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
      <summary>
              Registers a sub resolver instance
            </summary>
      <param name="subResolver">The subresolver instance</param>
    </member>
    <member name="M:Castle.MicroKernel.IDependencyResolver.Initialize(Castle.MicroKernel.IKernelInternal,Castle.MicroKernel.DependencyDelegate)">
      <summary>
              This method is called with a delegate for firing the
              IKernelEvents.DependencyResolving event.
            </summary>
      <param name="kernel">kernel</param>
      <param name="resolving">The delegate used to fire the event</param>
    </member>
    <member name="M:Castle.MicroKernel.IDependencyResolver.RemoveSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
      <summary>
              Unregisters a sub resolver instance previously registered
            </summary>
      <param name="subResolver">The subresolver instance</param>
    </member>
    <member name="T:Castle.MicroKernel.Resolvers.DefaultDependencyResolver">
      <summary>Default implementation for <see cref="T:Castle.MicroKernel.IDependencyResolver" />. This implementation is quite simple, but still should be useful for 99% of situations.</summary>
    </member>
    <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.AddSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
      <summary>Registers a sub resolver instance</summary>
      <param name="subResolver">The subresolver instance</param>
    </member>
    <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.Initialize(Castle.MicroKernel.IKernelInternal,Castle.MicroKernel.DependencyDelegate)">
      <summary>Initializes this instance with the specified dependency delegate.</summary>
      <param name="kernel">kernel</param>
      <param name="dependencyDelegate">The dependency delegate.</param>
    </member>
    <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.RemoveSubResolver(Castle.MicroKernel.ISubDependencyResolver)">
      <summary>Unregisters a sub resolver instance previously registered</summary>
      <param name="subResolver">The subresolver instance</param>
    </member>
    <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.CanResolve(Castle.MicroKernel.Context.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
      <summary>Returns true if the resolver is able to satisfy the specified dependency.</summary>
      <param name="context">Creation context, which is a resolver itself</param>
      <param name="contextHandlerResolver">Parent resolver</param>
      <param name="model">Model of the component that is requesting the dependency</param>
      <param name="dependency">The dependency model</param>
      <returns>
        <c>true</c>
                if the dependency can be satisfied
            </returns>
    </member>
    <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.Resolve(Castle.MicroKernel.Context.CreationContext,Castle.MicroKernel.ISubDependencyResolver,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
      <summary>Try to resolve the dependency by checking the parameters in the model or checking the Kernel for the requested service.</summary>
      <remarks>
                The dependency resolver has the following precedence order:
                <list type="bullet"><item><description>The dependency is checked within the
                            <see cref="T:Castle.MicroKernel.Context.CreationContext" /></description></item><item><description>The dependency is checked within the
                            <see cref="T:Castle.MicroKernel.IHandler" />
                            instance for the component</description></item><item><description>The dependency is checked within the registered
                            <see cref="T:Castle.MicroKernel.ISubDependencyResolver" />
                            s</description></item><item><description>Finally the resolver tries the normal flow which is using the configuration or other component to satisfy the dependency</description></item></list></remarks>
      <param name="context">Creation context, which is a resolver itself</param>
      <param name="contextHandlerResolver">Parent resolver</param>
      <param name="model">Model of the component that is requesting the dependency</param>
      <param name="dependency">The dependency model</param>
      <returns>The dependency resolved value or null</returns>
    </member>
    <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.RebuildContextForParameter(Castle.MicroKernel.Context.CreationContext,System.Type)">
      <summary>This method rebuild the context for the parameter type. Naive implementation.</summary>
    </member>
    <member name="M:Castle.MicroKernel.Resolvers.DependencyResolverException.#ctor(System.String,System.Exception)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Resolvers.DependencyResolverException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="M:Castle.MicroKernel.Resolvers.DependencyResolverException.#ctor(System.String)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Resolvers.DependencyResolverException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Castle.MicroKernel.Resolvers.DependencyResolverException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.Resolvers.DependencyResolverException" /> class.
            </summary>
      <param name="info">The object that holds the serialized object data.</param>
      <param name="context">The contextual information about the source or destination.</param>
    </member>
    <member name="T:Castle.MicroKernel.Resolvers.LazyOfTComponentLoader">
      <summary>
              Lazily adds component for <see cref="T:System.Lazy`1" />.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.Resolvers.SpecializedResolvers.CollectionResolver">
      <summary>
              More generic alternative to <see cref="T:Castle.MicroKernel.Resolvers.SpecializedResolvers.ArrayResolver" /> and <see cref="T:Castle.MicroKernel.Resolvers.SpecializedResolvers.ListResolver" />.
              It supports arrays as well as any generic interface type assignable from arrays.
            </summary>
      <remarks>
              The collection instance that is provided is read only, even for interfaces like <see cref="T:System.Collections.Generic.IList`1" /></remarks>
    </member>
    <member name="T:Castle.MicroKernel.Resolvers.SpecializedResolvers.ArrayResolver">
      <summary>
              Handle dependencies of services in the format of typed arrays.
            </summary>
      <remarks>
              This is a complimentary <see cref="T:Castle.MicroKernel.ISubDependencyResolver" /> implementation 
              that is capable of satisfying dependencies of services as typed arrays.
              <para>
                Note that it will take precedence over service override for arrays defined 
                on the configuration.
              </para></remarks>
      <example>
              In order to install the resolver:
              <code>
                var kernel = new DefaultKernel();
                kernel.Resolver.AddSubResolver(new ArrayResolver(kernel));
              </code><para>
                To use it, assuming that IService is on the container:
              </para><code>
                public class Component
                {
                public Component(IService[] services)
                {
                }
                }
              </code></example>
    </member>
    <member name="T:Castle.MicroKernel.Resolvers.SpecializedResolvers.ListResolver">
      <summary>
              Handle dependencies of services in the format of generic IList.
            </summary>
      <remarks>
              This is a complimentary <see cref="T:Castle.MicroKernel.ISubDependencyResolver" /> implementation 
              that is capable of satisfying dependencies of services generic IList.
              <para>
                Note that it will take precedence over service override for lists defined 
                on the configuration.
              </para></remarks>
      <example>
              In order to install the resolver:
              <code>
                var kernel = new DefaultKernel();
                kernel.Resolver.AddSubResolver(new ListResolver(kernel));
              </code><para>
                To use it, assuming that IService is on the container:
              </para><code>
                public class Component
                {
                public Component(IList&lt;IService&gt; services)
                {
                }
                }
              </code></example>
    </member>
    <member name="T:Castle.MicroKernel.ISubSystem">
      <summary>
              A subsystem is used by the MicroKernel to deal 
              with a specific concern.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.ISubSystem.Init(Castle.MicroKernel.IKernelInternal)">
      <summary>
              Initializes the subsystem
            </summary>
      <param name="kernel">
      </param>
    </member>
    <member name="M:Castle.MicroKernel.ISubSystem.Terminate">
      <summary>
              Should perform the termination
              of the subsystem instance.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore">
      <summary>
              The contract used by the kernel to obtain
              external configuration for the components and
              facilities.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.AddChildContainerConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
      <summary>
              Adds the child container configuration.
            </summary>
      <param name="name">The container's name.</param>
      <param name="config">The config.</param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.AddComponentConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
      <summary>
              Associates a configuration node with a component key
            </summary>
      <param name="key">item key</param>
      <param name="config">Configuration node</param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.AddFacilityConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
      <summary>
              Associates a configuration node with a facility key
            </summary>
      <param name="key">item key</param>
      <param name="config">Configuration node</param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetChildContainerConfiguration(System.String)">
      <summary>
              Returns the configuration node associated with 
              the specified child container key. Should return null
              if no association exists.
            </summary>
      <param name="key">item key</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetComponentConfiguration(System.String)">
      <summary>
              Returns the configuration node associated with 
              the specified component key. Should return null
              if no association exists.
            </summary>
      <param name="key">item key</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetComponents">
      <summary>
              Returns all configuration nodes for components
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetConfigurationForChildContainers">
      <summary>
              Gets the child containers configuration nodes.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetFacilities">
      <summary>
              Returns all configuration nodes for facilities
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetFacilityConfiguration(System.String)">
      <summary>
              Returns the configuration node associated with 
              the specified facility key. Should return null
              if no association exists.
            </summary>
      <param name="key">item key</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetInstallers">
      <summary>
              Returns all configuration nodes for installers
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore.GetResource(System.String,Castle.Core.Resource.IResource)">
      <summary>
      </summary>
      <param name="resourceUri">
      </param>
      <param name="resource">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore">
      <summary>
              This implementation of <see cref="T:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore" />
              does not try to obtain an external configuration by any means.
              Its only purpose is to serve as a base class for subclasses
              that might obtain the configuration node from anywhere.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.AddChildContainerConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
      <summary>
              Adds the child container configuration.
            </summary>
      <param name="key">The key.</param>
      <param name="config">The config.</param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.AddComponentConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
      <summary>
              Associates a configuration node with a component key
            </summary>
      <param name="key">item key</param>
      <param name="config">Configuration node</param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.AddFacilityConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
      <summary>
              Associates a configuration node with a facility key
            </summary>
      <param name="key">item key</param>
      <param name="config">Configuration node</param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetChildContainerConfiguration(System.String)">
      <summary>
              Returns the configuration node associated with
              the specified child container key. Should return null
              if no association exists.
            </summary>
      <param name="key">item key</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetComponentConfiguration(System.String)">
      <summary>
              Returns the configuration node associated with
              the specified component key. Should return null
              if no association exists.
            </summary>
      <param name="key">item key</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetComponents">
      <summary>
              Returns all configuration nodes for components
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetConfigurationForChildContainers">
      <summary>
              Returns all configuration nodes for child containers
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetFacilities">
      <summary>
              Returns all configuration nodes for facilities
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore.GetFacilityConfiguration(System.String)">
      <summary>
              Returns the configuration node associated with
              the specified facility key. Should return null
              if no association exists.
            </summary>
      <param name="key">item key</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter">
      <summary>
              Implements a conversion logic to a type of a
              set of types.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.CanHandleType(System.Type)">
      <summary>
              Returns true if this instance of <c>ITypeConverter</c>
              is able to handle the specified type.
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.CanHandleType(System.Type,Castle.Core.Configuration.IConfiguration)">
      <summary>
              Returns true if this instance of <c>ITypeConverter</c>
              is able to handle the specified type with the specified 
              configuration
            </summary>
      <param name="type">
      </param>
      <param name="configuration">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.PerformConversion(System.String,System.Type)">
      <summary>
              Should perform the conversion from the
              string representation specified to the type
              specified.
            </summary>
      <param name="value">
      </param>
      <param name="targetType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.PerformConversion(Castle.Core.Configuration.IConfiguration,System.Type)">
      <summary>
              Should perform the conversion from the
              configuration node specified to the type
              specified.
            </summary>
      <param name="configuration">
      </param>
      <param name="targetType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.AbstractTypeConverter">
      <summary>
              Base implementation of <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter" /></summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.AbstractTypeConverter.CanHandleType(System.Type,Castle.Core.Configuration.IConfiguration)">
      <summary>
              Returns true if this instance of <c>ITypeConverter</c>
              is able to handle the specified type with the specified
              configuration
            </summary>
      <param name="type">
      </param>
      <param name="configuration">
      </param>
      <returns>
      </returns>
      <remarks>
              The default behavior is to just pass it to the normal CanHadnleType
              peeking into the configuration is used for some advanced functionality
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConverterException.#ctor(System.String)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ConverterException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConverterException.#ctor(System.String,System.Exception)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ConverterException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConverterException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ConverterException" /> class.
            </summary>
      <param name="info">The object that holds the serialized object data.</param>
      <param name="context">The contextual information about the source or destination.</param>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.AttributeAwareConverter">
      <summary>
              Looks for a <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ConvertibleAttribute" /> on the type to be converted. 
              If found, the TypeConverter defined by the attribute is used to perform the conversion.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.IKernelDependentConverter">
      <summary>
              Marker interface that signals that a converter
              depends on IKernel to be able to perform 
              the conversion.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.ComponentModelConverter">
      <summary>
            Attempts to utilize an existing <see cref="T:System.ComponentModel.TypeConverter" /> for conversion
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.CreateInstance(System.Type,Castle.Core.Configuration.IConfiguration)">
      <summary>
              Creates the target type instance.
            </summary>
      <param name="type">The type.</param>
      <param name="configuration">The configuration.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.ChooseConstructor(System.Type)">
      <summary>
              Chooses the first non default constructor. Throws an exception if more than 
              one non default constructor is found
            </summary>
      <param name="type">
      </param>
      <returns>The chosen constructor, or <c>null</c> if none was found</returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.ConvertConstructorParameters(System.Reflection.ConstructorInfo,Castle.Core.Configuration.IConfiguration)">
      <summary>
              Converts the constructor parameters.
            </summary>
      <param name="constructor">The constructor.</param>
      <param name="configuration">The configuration.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.ConvertPropertyValues(System.Object,System.Type,Castle.Core.Configuration.IConfiguration)">
      <summary>
              Converts the property values.
            </summary>
      <param name="instance">The instance.</param>
      <param name="type">The type.</param>
      <param name="configuration">The configuration.</param>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.FindChildIgnoreCase(Castle.Core.Configuration.IConfiguration,System.String)">
      <summary>
              Finds the child (case insensitive).
            </summary>
      <param name="config">The config.</param>
      <param name="name">The name.</param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter.ConversionManager">
      <summary>
              Gets the conversion manager.
            </summary>
      <value>The conversion manager.</value>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.EnumConverter">
      <summary>
              Converts a string representation to an enum value
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.IGenericCollectionConverterHelper">
      <summary>
              This interface is needed because we want to isolate ourself from
              the generic parameters, so we can work type safe inside the implementations,
              and still call from non generic types outside.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.PrimitiveConverter">
      <summary>
              Implements all standard conversions.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.TypeNameConverter">
      <summary>
              Convert a type name to a Type instance.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.ConvertibleAttribute">
      <summary>
              Declares a type as being convertible by a <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter" /> and optionally defines the converter to be used
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConvertibleAttribute.#ctor">
      <summary>
              Defines the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.DefaultComplexConverter" /> to be used to convert the type
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.ConvertibleAttribute.#ctor(System.Type)">
      <summary>
              Defines the <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter" /> to be used to convert the type
            </summary>
      <param name="converterType">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.IConversionManager">
      <summary>
              Establish a composition interface and a subsystem.
              Implementors should delegate the conversion to 
              a instance of a type converter.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Conversion.IConversionManager.Add(Castle.MicroKernel.SubSystems.Conversion.ITypeConverter)">
      <summary>
              Register a type converter instance.
            </summary>
      <param name="converter">
      </param>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Conversion.DefaultConversionManager">
      <summary>
              Composition of all available conversion managers
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem">
      <summary>
              Contract for SubSystem that wishes to keep and coordinate
              component registration.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.AddHandlerSelector(Castle.MicroKernel.IHandlerSelector)">
      <summary>
              Register a new component resolver that can take part in the decision
              making about which handler to resolve
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.AddHandlersFilter(Castle.MicroKernel.IHandlersFilter)">
      <summary>
              Register a new component resolver that can take part in the decision
              making about which handler(s) to resolve and in which order
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.Contains(System.String)">
      <summary>
              Returns true if there is a component registered 
              for the specified name
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.Contains(System.Type)">
      <summary>
              Returns true if there is a component registered 
              for the specified service
            </summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.GetAllHandlers">
      <summary>
              Returns all <see cref="T:Castle.MicroKernel.IHandler" /> registered.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.GetAssignableHandlers(System.Type)">
      <summary>
              Return <see cref="T:Castle.MicroKernel.IHandler" />s where components are compatible
              with the specified service.
            </summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.GetHandler(System.String)">
      <summary>
              Returns the <see cref="T:Castle.MicroKernel.IHandler" /> associated with
              the specified name.
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.GetHandler(System.Type)">
      <summary>
              Returns the <see cref="T:Castle.MicroKernel.IHandler" /> associated with
              the specified service.
            </summary>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.GetHandlers(System.Type)">
      <summary>
              Returns an array of <see cref="T:Castle.MicroKernel.IHandler" /> associated with
              the specified service.
            </summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.Register(Castle.MicroKernel.IHandler)">
      <summary>
              Implementors should register the <see cref="T:Castle.MicroKernel.IHandler" /> with all <see cref="P:Castle.Core.ComponentModel.Services" /> its <see cref="P:Castle.MicroKernel.IHandler.ComponentModel" /> exposes.
              The handler should also be accessible via unique <see cref="P:Castle.Core.ComponentModel.Name" /> of its <see cref="P:Castle.MicroKernel.IHandler.ComponentModel" />.
            </summary>
      <param name="handler">
      </param>
      <exception cref="T:Castle.MicroKernel.ComponentRegistrationException">Thrown if the <see cref="P:Castle.Core.ComponentModel.Name" /> of <paramref name="handler" />'s <see cref="P:Castle.MicroKernel.IHandler.ComponentModel" /> is not unique and a handler with the same name has already been registered.</exception>
    </member>
    <member name="P:Castle.MicroKernel.SubSystems.Naming.INamingSubSystem.ComponentCount">
      <summary>
              Returns the number of components registered.
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem.name2Handler">
      <summary>
              Map(String, IHandler) to map component names to <see cref="T:Castle.MicroKernel.IHandler" /> Items in this dictionary are sorted in insertion order.
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem.service2Handler">
      <summary>
              Map(Type, IHandler) to map a service to <see cref="T:Castle.MicroKernel.IHandler" /> . If there is more than a single service of the type, only the first registered services is stored in this dictionary. It serve as a fast lookup for the common case of having a single handler for a type.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.IHandlerSelector">
      <summary>
              Implementors of this interface allow to extend the way the container perform
              component resolution based on some application specific business logic.
            </summary>
      <remarks>
              This is the sibling interface to <seealso cref="T:Castle.MicroKernel.ISubDependencyResolver" />.
              This is dealing strictly with root components, while the <seealso cref="T:Castle.MicroKernel.ISubDependencyResolver" /> is dealing with
              dependent components.
            </remarks>
    </member>
    <member name="M:Castle.MicroKernel.IHandlerSelector.HasOpinionAbout(System.String,System.Type)">
      <summary>
              Whatever the selector has an opinion about resolving a component with the 
              specified service and key.
            </summary>
      <param name="key">The service key - can be null</param>
      <param name="service">The service interface that we want to resolve</param>
    </member>
    <member name="M:Castle.MicroKernel.IHandlerSelector.SelectHandler(System.String,System.Type,Castle.MicroKernel.IHandler[])">
      <summary>
              Select the appropriate handler from the list of defined handlers.
              The returned handler should be a member from the <paramref name="handlers" /> array.
            </summary>
      <param name="key">The service key - can be null</param>
      <param name="service">The service interface that we want to resolve</param>
      <param name="handlers">The defined handlers</param>
      <returns>The selected handler, or null</returns>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Resource.IResourceSubSystem">
      <summary>
              An implementation of <c>a</c> should 
              be able to return instances of <see cref="T:Castle.Core.Resource.IResource" />
              for a given resource identifier.
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.SubSystems.Resource.DefaultResourceSubSystem">
      <summary>
              Pendent
            </summary>
    </member>
    <member name="T:Castle.MicroKernel.SubSystemConstants">
      <summary>
              Holds the keys used by Kernel to register/request 
              a subsystem.
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.SubSystemConstants.ConfigurationStoreKey">
      <summary>
              Key used for the configuration store subsystem
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.SubSystemConstants.ConversionManagerKey">
      <summary>
              Key used for the conversion manager
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.SubSystemConstants.DiagnosticsKey">
      <summary>
              Key used for the diagnostics subsystem
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.SubSystemConstants.NamingKey">
      <summary>
              Key used for the naming subsystem
            </summary>
    </member>
    <member name="F:Castle.MicroKernel.SubSystemConstants.ResourceKey">
      <summary>
              Key used for the resource subsystem
            </summary>
    </member>
    <member name="T:Castle.Windsor.Configuration.AppDomain.CastleSectionHandler">
      <summary>
              Implementation of <see cref="T:System.Configuration.IConfigurationSectionHandler" />.
              Do not support configuration inheritance.
            </summary>
    </member>
    <member name="T:Castle.Windsor.Configuration.IConfigurationInterpreter">
      <summary>
              Interpreter of a specific language to describe 
              configuration nodes in a hierarchical manner.
            </summary>
    </member>
    <member name="M:Castle.Windsor.Configuration.IConfigurationInterpreter.ProcessResource(Castle.Core.Resource.IResource,Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore,Castle.MicroKernel.IKernel)">
      <summary>
              Should obtain the contents from the resource,
              interpret it and populate the <see cref="T:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore" />
              accordingly.
            </summary>
      <param name="resource">
      </param>
      <param name="store">
      </param>
      <param name="kernel">
      </param>
    </member>
    <member name="P:Castle.Windsor.Configuration.IConfigurationInterpreter.EnvironmentName">
      <summary>
              Gets or sets the name of the environment.
            </summary>
      <value>The name of the environment.</value>
    </member>
    <member name="P:Castle.Windsor.Configuration.IConfigurationInterpreter.Source">
      <summary>
              Exposes the reference to <see cref="T:Castle.Core.Resource.IResource" />
              which the interpreter is likely to hold
            </summary>
    </member>
    <member name="T:Castle.Windsor.Configuration.Interpreters.AbstractInterpreter">
      <summary>
              Provides common methods for those who wants 
              to implement <see cref="T:Castle.Windsor.Configuration.IConfigurationInterpreter" /></summary>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.AbstractInterpreter.ProcessResource(Castle.Core.Resource.IResource,Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore,Castle.MicroKernel.IKernel)">
      <summary>
              Should obtain the contents from the resource,
              interpret it and populate the <see cref="T:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore" />
              accordingly.
            </summary>
      <param name="resource">
      </param>
      <param name="store">
      </param>
      <param name="kernel">
      </param>
    </member>
    <member name="P:Castle.Windsor.Configuration.Interpreters.AbstractInterpreter.Source">
      <summary>
              Exposes the reference to <see cref="T:Castle.Core.Resource.IResource" />
              which the interpreter is likely to hold
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Windsor.Configuration.Interpreters.AbstractInterpreter.EnvironmentName">
      <summary>
              Gets or sets the name of the environment.
            </summary>
      <value>The name of the environment.</value>
    </member>
    <member name="T:Castle.Windsor.Configuration.Interpreters.XmlInterpreter">
      <summary>
              Reads the configuration from a XmlFile. Sample structure:
              <code>
                &lt;configuration&gt;
                &lt;facilities&gt;
                &lt;facility id="myfacility"&gt;
                
                &lt;/facility&gt;
                &lt;/facilities&gt;
              
                &lt;components&gt;
                &lt;component id="component1"&gt;
                
                &lt;/component&gt;
                &lt;/components&gt;
                &lt;/configuration&gt;
              </code></summary>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlInterpreter.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlInterpreter" /> class.
            </summary>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlInterpreter.#ctor(System.String)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlInterpreter" /> class.
            </summary>
      <param name="filename">The filename.</param>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlInterpreter.#ctor(Castle.Core.Resource.IResource)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlInterpreter" /> class.
            </summary>
      <param name="source">The source.</param>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine.#ctor(System.String)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine" /> class.
            </summary>
      <param name="environmentName">Name of the environment.</param>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine.#ctor(System.String,Castle.MicroKernel.SubSystems.Resource.IResourceSubSystem)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine" /> class.
            </summary>
      <param name="environmentName">Name of the environment.</param>
      <param name="resourceSubSystem">The resource sub system.</param>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine.DispatchProcessAll(Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorNodeList)">
      <summary>
              Processes the element.
            </summary>
      <param name="nodeList">The element.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorEngine.DispatchProcessCurrent(Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorNodeList)">
      <summary>
              Processes the element.
            </summary>
      <param name="nodeList">The element.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.DefaultXmlProcessorNodeList.CloneNodeList(System.Xml.XmlNodeList)">
      <summary>
              Make a shallow copy of the nodeList.
            </summary>
      <param name="nodeList">The nodeList to be copied.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.AbstractXmlNodeProcessor.Accept(System.Xml.XmlNode)">
      <summary>
              Accepts the specified node.
              Check if node has the same name as the processor and the node.NodeType
              is in the AcceptNodeTypes List
            </summary>
      <param name="node">The node.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.AbstractXmlNodeProcessor.GetNodeAsElement(System.Xml.XmlElement,System.Xml.XmlNode)">
      <summary>
              Convert and return child parameter into an XmlElement
              An exception will be throw in case the child node cannot be converted
            </summary>
      <param name="element">Parent node</param>
      <param name="child">Node to be converted</param>
      <returns>child node as XmlElement</returns>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.AttributesElementProcessor.Process(Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorNodeList,Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorEngine)">
      <summary>
      </summary>
      <param name="nodeList">
      </param>
      <param name="engine">
      </param>
      <example>
        <code>
          <properties>
            <attributes>
              <myAttribute>attributeValue</myAttribute>
            </attributes>
            <myProperty>propertyValue</myProperty>
          </properties>
        </code>
      </example>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.DefaultElementProcessor.Process(Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorNodeList,Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorEngine)">
      <summary>
              Processes the specified node list.
            </summary>
      <param name="nodeList">The node list.</param>
      <param name="engine">The engine.</param>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.DefaultElementProcessor.ProcessAttributes(System.Xml.XmlElement,Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorEngine)">
      <summary>
              Processes element attributes.
              if the attribute is include will append to the element
              all contents from the file.
              if the attribute has a property reference the reference will be
              expanded
            </summary>
      <param name="element">The element.</param>
      <param name="engine">
      </param>
    </member>
    <member name="F:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.DefaultTextNodeProcessor.PropertyValidationRegExp">
      <summary>
              Properties names can contain a-zA-Z0-9_. 
              i.e. #!{ my_node_name } || #{ my.node.name }
              spaces are trimmed
            </summary>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.DefaultTextNodeProcessor.ProcessString(System.Xml.XmlNode,System.String,Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorEngine)">
      <summary>
              Processes the string.
            </summary>
      <param name="node">The node.</param>
      <param name="value">The value.</param>
      <param name="engine">The context.</param>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.IncludeElementProcessor.Accept(System.Xml.XmlNode)">
      <summary>
              Accepts the specified node.
              Check if node has the same name as the processor and the node.NodeType
              is in the AcceptNodeTypes List
              NOTE: since the BatchRegistrationFacility already uses an include
              element we will distinguish between both by looking for the presence of an uri attribute
              we should revisit this later by using xml-namespaces
            </summary>
      <param name="node">The node.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.ElementProcessors.PropertiesElementProcessor.Process(Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorNodeList,Castle.Windsor.Configuration.Interpreters.XmlProcessor.IXmlProcessorEngine)">
      <summary>
      </summary>
      <param name="nodeList">
      </param>
      <param name="engine">
      </param>
      <example>
        <code>
          <properties>
            <attributes>
              <myAttribute>attributeValue</myAttribute>
            </attributes>
            <myProperty>propertyValue</myProperty>
          </properties>
        </code>
      </example>
    </member>
    <member name="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor">
      <summary>
              Pendent
            </summary>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor" /> class.
            </summary>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor.#ctor(System.String,Castle.MicroKernel.SubSystems.Resource.IResourceSubSystem)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor" /> class.
            </summary>
      <param name="environmentName">Name of the environment.</param>
      <param name="resourceSubSystem">The resource sub system.</param>
    </member>
    <member name="M:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor.#ctor(System.String)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.Configuration.Interpreters.XmlProcessor.XmlProcessor" /> class.
            </summary>
    </member>
    <member name="T:Castle.Windsor.Diagnostics.IDiagnostic`1">
      <summary>
            	Base inteface for exposing diagnostic information about container, its components and extensions
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Castle.Windsor.Diagnostics.IDiagnostic`1.Inspect">
      <summary>
            	Collects specified diagnostic information.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Windsor.Diagnostics.IAllComponentsDiagnostic">
      <summary>
              Collects all handlers for components in hosting container.
            </summary>
    </member>
    <member name="T:Castle.Windsor.Diagnostics.IAllServicesDiagnostic">
      <summary>
            	Collects all handlers for components in hosting container grouped by services they expose.
            	Within the service group, first one would be the default (the one obtained when callling <see cref="M:Castle.MicroKernel.IKernel.Resolve(System.Type)" /> for the service type)
            </summary>
    </member>
    <member name="T:Castle.Windsor.Diagnostics.IDiagnosticsHost">
      <summary>
              Hosts different diagnostics available in the container.
            </summary>
    </member>
    <member name="M:Castle.Windsor.Diagnostics.IDiagnosticsHost.AddDiagnostic``1(``0)">
      <summary>
              Adds <paramref name="diagnostic" /> and makes it available as <typeparamref name="TDiagnostic" />.
            </summary>
      <exception cref="T:System.ArgumentException">
              Thrown when a diagnostic for
              <typeparamref name="TDiagnostic" />
              has already been added.
            </exception>
    </member>
    <member name="M:Castle.Windsor.Diagnostics.IDiagnosticsHost.GetDiagnostic``1">
      <summary>
              Returns diagnostic registered with <typeparamref name="TDiagnostic" /> or <c>null</c> if not present.
            </summary>
      <typeparam name="TDiagnostic">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Windsor.Diagnostics.DebuggerViews.MasterDetailsDebuggerViewItem.AMaster">
      <summary>
              Stupid name, but debugger views in Visual Studio display items in alphabetical order so if we want
              to have that item on top its name must be alphabetically before <see cref="P:Castle.Windsor.Diagnostics.DebuggerViews.MasterDetailsDebuggerViewItem.Details" /></summary>
    </member>
    <member name="T:Castle.Windsor.Diagnostics.IDuplicatedDependenciesDiagnostic">
      <summary>
              Collects dependencies that are duplicated between constructors and properties.
            </summary>
    </member>
    <member name="T:Castle.Windsor.Diagnostics.IUsingContainerAsServiceLocatorDiagnostic">
      <summary>
              Detects components that are not extending Windsor's infrastructure yet depend on the container which usually means they use the container as service locator
              which is a bad practice and should be avoided. Consult the documentation for more details: http://j.mp/WindsorSL
            </summary>
    </member>
    <member name="T:Castle.Windsor.Diagnostics.IExposeDiagnostics`1">
      <summary>
              Exposes diagnostics about itself to the <see cref="T:Castle.Windsor.Diagnostics.IDiagnosticsInspector`2" />.
            </summary>
      <typeparam name="TData">Usually simple type containing information provided to the <see cref="T:Castle.Windsor.Diagnostics.IDiagnosticsInspector`2" />.</typeparam>
      <remarks>
              Can be implemented by any type constituting part of container infrastructure. Should have a matching <see cref="T:Castle.Windsor.Diagnostics.IDiagnosticsInspector`2" /> registred in the container that knows
              how to find it and that prepares information from it for consumption.
            </remarks>
    </member>
    <member name="M:Castle.Windsor.Diagnostics.IExposeDiagnostics`1.Visit``1(Castle.Windsor.Diagnostics.IDiagnosticsInspector{`0,``0},``0)">
      <summary>
              Collects <typeparamref name="TData" /> for the <paramref name="inspector" /> and calls <see cref="M:Castle.Windsor.Diagnostics.IDiagnosticsInspector`2.Inspect(`0,`1)" /> if any data available.
            </summary>
      <param name="inspector">
      </param>
      <param name="context">pass-through context. Used by the inspector.</param>
    </member>
    <member name="T:Castle.Windsor.IEnvironmentInfo">
      <summary>
              Gets the environment information (name). Implementors should 
              use to define their environments and how those affect the configuration.
            </summary>
    </member>
    <member name="M:Castle.Windsor.IEnvironmentInfo.GetEnvironmentName">
      <summary>
              Gets the name of the environment.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Installer.Configuration.FromAppConfig">
      <summary>
              Installs all the components from the App.Config file.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Installer.Configuration.FromXml(Castle.Core.Resource.IResource)">
      <summary>
              Installs all the component from the xml configuration.
            </summary>
      <param name="resource">The xml configuration resource.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Installer.Configuration.FromXmlFile(System.String)">
      <summary>
              Installs all the component from the xml configuration file.
            </summary>
      <param name="file">The xml configuration file.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Windsor.Installer.EnvironmentDelegate">
      <summary>
              Delegate to provide environment name.
            </summary>
      <returns>The environment name.</returns>
    </member>
    <member name="M:Castle.Windsor.Installer.ConfigurationInstaller.#ctor(Castle.Windsor.Configuration.IConfigurationInterpreter)">
      <summary>
              Initializes a new instance of the ConfigurationInstaller class.
            </summary>
    </member>
    <member name="M:Castle.Windsor.Installer.ConfigurationInstaller.Environment(System.String)">
      <summary>
              Sets the configuration environment name.
            </summary>
      <param name="environmentName">The environment name.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Installer.ConfigurationInstaller.Environment(Castle.Windsor.Installer.EnvironmentDelegate)">
      <summary>
              Set the configuration environment strategy.
            </summary>
      <param name="environment">The environment strategy.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Windsor.IComponentsInstaller">
      <summary>
              Installs the components and facilities based on the
              information on the configuration store.
            </summary>
    </member>
    <member name="M:Castle.Windsor.IComponentsInstaller.SetUp(Castle.Windsor.IWindsorContainer,Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore)">
      <summary>
              Perform installation.
            </summary>
      <param name="container">Target container</param>
      <param name="store">Configuration store</param>
    </member>
    <member name="T:Castle.Windsor.Installer.DefaultComponentInstaller">
      <summary>
              Default <see cref="T:Castle.Windsor.IComponentsInstaller" /> implementation.
            </summary>
    </member>
    <member name="M:Castle.Windsor.Installer.DefaultComponentInstaller.SetUp(Castle.Windsor.IWindsorContainer,Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore)">
      <summary>
              Perform installation.
            </summary>
      <param name="container">Target container</param>
      <param name="store">Configuration store</param>
    </member>
    <member name="M:Castle.Windsor.Installer.FromAssembly.Containing(System.Type)">
      <summary>
                Scans the assembly containing specified type for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller" />, instantiates them and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])" /> can
                install them.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Installer.FromAssembly.Containing(System.Type,Castle.Windsor.Installer.InstallerFactory)">
      <summary>
                Scans the assembly containing specified type for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller" />, instantiates using given <see cref="T:Castle.Windsor.Installer.InstallerFactory" /> and returns so that
                <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])" /> can install them.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Installer.FromAssembly.Containing``1">
      <summary>
                Scans the assembly containing specified type for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller" />, instantiates them and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])" /> can
                install them.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Installer.FromAssembly.Containing``1(Castle.Windsor.Installer.InstallerFactory)">
      <summary>
                Scans the assembly containing specified type for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller" />, instantiates using given <see cref="T:Castle.Windsor.Installer.InstallerFactory" /> and returns so that
                <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])" /> can install them.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Installer.FromAssembly.InDirectory(Castle.MicroKernel.Registration.AssemblyFilter)">
      <summary>
                Scans assemblies in directory specified by <paramref name="filter" /> for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller" />, instantiates and returns so that
                <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])" /> can install them.
            </summary>
      <param name="filter">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Installer.FromAssembly.InDirectory(Castle.MicroKernel.Registration.AssemblyFilter,Castle.Windsor.Installer.InstallerFactory)">
      <summary>
                Scans assemblies in directory specified by <paramref name="filter" /> for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller" />, instantiates using given <see cref="T:Castle.Windsor.Installer.InstallerFactory" /> and
                returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])" /> can install them.
            </summary>
      <param name="filter">
      </param>
      <param name="installerFactory">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Installer.FromAssembly.InThisApplication">
      <summary>
                Scans current assembly and all refernced assemblies with the same first part of the name for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller" />, instantiates and returns so that
                <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])" /> can install them.
            </summary>
      <returns>
      </returns>
      <remarks>
                Assemblies are considered to belong to the same application based on the first part of the name. For example if the method is called from within <c>MyApp.exe</c> and <c>MyApp.exe</c> references
                <c>MyApp.SuperFeatures.dll</c>, <c>mscorlib.dll</c> and <c>ThirdPartyCompany.UberControls.dll</c> the <c>MyApp.exe</c> and <c>MyApp.SuperFeatures.dll</c> will be scanned for installers, and other
                assemblies will be ignored.
            </remarks>
    </member>
    <member name="M:Castle.Windsor.Installer.FromAssembly.InThisApplication(Castle.Windsor.Installer.InstallerFactory)">
      <summary>
                Scans current assembly and all refernced assemblies with the same first part of the name for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller" />, instantiates using given
                <see cref="T:Castle.Windsor.Installer.InstallerFactory" /> and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])" /> can install them.
            </summary>
      <param name="installerFactory">
      </param>
      <returns>
      </returns>
      <remarks>
                Assemblies are considered to belong to the same application based on the first part of the name. For example if the method is called from within <c>MyApp.exe</c> and <c>MyApp.exe</c> references
                <c>MyApp.SuperFeatures.dll</c>, <c>mscorlib.dll</c> and <c>ThirdPartyCompany.UberControls.dll</c> the <c>MyApp.exe</c> and <c>MyApp.SuperFeatures.dll</c> will be scanned for installers, and other
                assemblies will be ignored.
            </remarks>
    </member>
    <member name="M:Castle.Windsor.Installer.FromAssembly.Instance(System.Reflection.Assembly)">
      <summary>
                Scans the specified assembly with specified name for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller" />, instantiates them and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])" /> can
                install them.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Installer.FromAssembly.Instance(System.Reflection.Assembly,Castle.Windsor.Installer.InstallerFactory)">
      <summary>
                Scans the specified assembly with specified name for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller" />, instantiates using given <see cref="T:Castle.Windsor.Installer.InstallerFactory" /> and returns so that
                <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])" /> can install them.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Installer.FromAssembly.Named(System.String)">
      <summary>
                Scans the assembly with specified name for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller" />, instantiates them and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])" /> can install
                them.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Installer.FromAssembly.Named(System.String,Castle.Windsor.Installer.InstallerFactory)">
      <summary>
                Scans the assembly with specified name for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller" />, instantiates using given <see cref="T:Castle.Windsor.Installer.InstallerFactory" /> and returns so that
                <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])" /> can install them.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Installer.FromAssembly.This">
      <summary>
                Scans assembly that contains code calling this method for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller" />, instantiates them and returns so that <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])" />
                can install them.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.Installer.FromAssembly.This(Castle.Windsor.Installer.InstallerFactory)">
      <summary>
                Scans assembly that contains code calling this method for types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller" />, instantiates using given <see cref="T:Castle.Windsor.Installer.InstallerFactory" /> and returns so that
                <see cref="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])" /> can install them.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Windsor.Installer.InstallerFactory">
      <summary>
              Helper class used by <see cref="T:Castle.Windsor.Installer.FromAssembly" /> to filter/order and instantiate <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller" /> implementations
            </summary>
    </member>
    <member name="M:Castle.Windsor.Installer.InstallerFactory.CreateInstance(System.Type)">
      <summary>
              Performs custom instantiation of given <param name="installerType" /></summary>
      <remarks>
              Default implementation uses public parameterless constructor to create the instance.
            </remarks>
    </member>
    <member name="M:Castle.Windsor.Installer.InstallerFactory.Select(System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
              Performs custom filtering/ordering of given set of types.
            </summary>
      <param name="installerTypes">Set of concrete class types implementing <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller" /> interface.</param>
      <returns>Transformed <paramref name="installerTypes" />.</returns>
      <remarks>
              Default implementation simply returns types passed into it.
            </remarks>
    </member>
    <member name="T:Castle.Windsor.IWindsorContainer">
      <summary>
              The <c>IWindsorContainer</c> interface exposes all the 
              functionality the Windsor implements.
            </summary>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.AddChildContainer(Castle.Windsor.IWindsorContainer)">
      <summary>
              Registers a subcontainer. The components exposed
              by this container will be accessible from subcontainers.
            </summary>
      <param name="childContainer">
      </param>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.AddFacility(Castle.MicroKernel.IFacility)">
      <summary>
              Registers a facility within the container.
            </summary>
      <param name="facility">The <see cref="T:Castle.MicroKernel.IFacility" /> to add to the container.</param>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.AddFacility``1">
      <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility" /> facility to the container.
            </summary>
      <typeparam name="TFacility">The facility type.</typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.AddFacility``1(System.Action{``0})">
      <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility" /> facility to the container.
            </summary>
      <typeparam name="TFacility">The facility type.</typeparam>
      <param name="onCreate">The callback for creation.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.GetChildContainer(System.String)">
      <summary>
              Gets a child container instance by name.
            </summary>
      <param name="name">The container's name.</param>
      <returns>The child container instance or null</returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])">
      <summary>
              Runs the <paramref name="installers" /> so that they can register components in the container. For details see the documentation at http://j.mp/WindsorInstall
            </summary>
      <remarks>
              In addition to instantiating and passing every installer inline you can use helper methods on <see cref="T:Castle.Windsor.Installer.FromAssembly" /> class to automatically instantiate and run your installers.
              You can also use <see cref="N:Castle.Windsor.Configuration" /> class to install components and/or run aditional installers specofied in a configuration file.
            </remarks>
      <returns>The container.</returns>
      <example>
        <code>
                container.Install(new YourInstaller1(), new YourInstaller2(), new YourInstaller3());
              </code>
      </example>
      <example>
        <code>
                container.Install(FromAssembly.This(), Configuration.FromAppConfig(), new SomeOtherInstaller());
              </code>
      </example>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Register(Castle.MicroKernel.Registration.IRegistration[])">
      <summary>
              Registers the components with the <see cref="T:Castle.Windsor.IWindsorContainer" />. The instances of <see cref="T:Castle.MicroKernel.Registration.IRegistration" /> are produced by fluent registration API.
              Most common entry points are <see cref="M:Castle.MicroKernel.Registration.Component.For``1" /> method to register a single type or (recommended in most cases) 
              <see cref="M:Castle.MicroKernel.Registration.Classes.FromThisAssembly" />.
              Let the Intellisense drive you through the fluent API past those entry points. For details see the documentation at http://j.mp/WindsorApi
            </summary>
      <example>
        <code>
                container.Register(Component.For&lt;IService&gt;().ImplementedBy&lt;DefaultService&gt;().LifestyleTransient());
              </code>
      </example>
      <example>
        <code>
                container.Register(Classes.FromThisAssembly().BasedOn&lt;IService&gt;().WithServiceDefaultInterfaces().Configure(c =&gt; c.LifestyleTransient()));
              </code>
      </example>
      <param name="registrations">The component registrations created by <see cref="M:Castle.MicroKernel.Registration.Component.For``1" />, <see cref="M:Castle.MicroKernel.Registration.Classes.FromThisAssembly" /> or different entry method to the fluent API.</param>
      <returns>The container.</returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Release(System.Object)">
      <summary>
              Releases a component instance
            </summary>
      <param name="instance">
      </param>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.RemoveChildContainer(Castle.Windsor.IWindsorContainer)">
      <summary>
              Remove a child container
            </summary>
      <param name="childContainer">
      </param>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.String,System.Type)">
      <summary>
              Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.Type)">
      <summary>
              Returns a component instance by the service
            </summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.Type,System.Collections.IDictionary)">
      <summary>
              Returns a component instance by the service
            </summary>
      <param name="service">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.Type,System.Object)">
      <summary>
              Returns a component instance by the service
            </summary>
      <param name="service">
      </param>
      <param name="argumentsAsAnonymousType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve``1">
      <summary>
              Returns a component instance by the service
            </summary>
      <typeparam name="T">Service type</typeparam>
      <returns>The component instance</returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve``1(System.Collections.IDictionary)">
      <summary>
              Returns a component instance by the service
            </summary>
      <typeparam name="T">Service type</typeparam>
      <param name="arguments">
      </param>
      <returns>The component instance</returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve``1(System.Object)">
      <summary>
              Returns a component instance by the service
            </summary>
      <typeparam name="T">Service type</typeparam>
      <param name="argumentsAsAnonymousType">
      </param>
      <returns>The component instance</returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve``1(System.String)">
      <summary>
              Returns a component instance by the key
            </summary>
      <param name="key">Component's key</param>
      <typeparam name="T">Service type</typeparam>
      <returns>The Component instance</returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve``1(System.String,System.Collections.IDictionary)">
      <summary>
              Returns a component instance by the key
            </summary>
      <typeparam name="T">Service type</typeparam>
      <param name="key">Component's key</param>
      <param name="arguments">
      </param>
      <returns>The Component instance</returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve``1(System.String,System.Object)">
      <summary>
              Returns a component instance by the key
            </summary>
      <typeparam name="T">Service type</typeparam>
      <param name="key">Component's key</param>
      <param name="argumentsAsAnonymousType">
      </param>
      <returns>The Component instance</returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.String,System.Type,System.Collections.IDictionary)">
      <summary>
              Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="service">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.String,System.Type,System.Object)">
      <summary>
              Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="service">
      </param>
      <param name="argumentsAsAnonymousType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.ResolveAll``1">
      <summary>
              Resolve all valid components that match this type.
            </summary>
      <typeparam name="T">The service type</typeparam>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.ResolveAll(System.Type)">
      <summary>
              Resolve all valid components that match this service
              <param name="service">the service to match</param></summary>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.ResolveAll(System.Type,System.Collections.IDictionary)">
      <summary>
              Resolve all valid components that match this service
              <param name="service">the service to match</param><param name="arguments">Arguments to resolve the service</param></summary>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.ResolveAll(System.Type,System.Object)">
      <summary>
              Resolve all valid components that match this service
              <param name="service">the service to match</param><param name="argumentsAsAnonymousType">Arguments to resolve the service</param></summary>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.ResolveAll``1(System.Collections.IDictionary)">
      <summary>
              Resolve all valid components that match this type.
              <typeparam name="T">The service type</typeparam><param name="arguments">Arguments to resolve the service</param></summary>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.ResolveAll``1(System.Object)">
      <summary>
              Resolve all valid components that match this type.
              <typeparam name="T">The service type</typeparam><param name="argumentsAsAnonymousType">Arguments to resolve the service</param></summary>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.AddFacility(System.String,Castle.MicroKernel.IFacility)">
      <summary>
              Registers a facility within the container.
            </summary>
      <param name="idInConfiguration">The key by which the <see cref="T:Castle.MicroKernel.IFacility" /> gets indexed.</param>
      <param name="facility">The <see cref="T:Castle.MicroKernel.IFacility" /> to add to the container.</param>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.AddFacility``1(System.String)">
      <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility" /> facility to the container.
            </summary>
      <typeparam name="TFacility">The facility type.</typeparam>
      <param name="idInConfiguration">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.AddFacility``1(System.String,System.Action{``0})">
      <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility" /> facility to the container.
            </summary>
      <typeparam name="TFacility">The facility type.</typeparam>
      <param name="idInConfiguration">
      </param>
      <param name="configureFacility">The callback for creation.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.String,System.Collections.IDictionary)">
      <summary>
              Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.String,System.Object)">
      <summary>
              Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="argumentsAsAnonymousType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Windsor.IWindsorContainer.Kernel">
      <summary>
              Returns the inner instance of the MicroKernel
            </summary>
    </member>
    <member name="P:Castle.Windsor.IWindsorContainer.Name">
      <summary>
              Gets the container's name
            </summary>
      <remarks>
              Only useful when child containers are being used
            </remarks>
      <value>The container's name.</value>
    </member>
    <member name="P:Castle.Windsor.IWindsorContainer.Parent">
      <summary>
              Gets or sets the parent container if this instance
              is a sub container.
            </summary>
    </member>
    <member name="T:Castle.Windsor.IContainerAccessor">
      <summary>
              This interface should be implemented by classes
              that are available in a bigger context, exposing
              the container to different areas in the same application.
              <para>
                For example, in Web application, the (global) HttpApplication
                subclasses should implement this interface to expose 
                the configured container
              </para></summary>
    </member>
    <member name="M:Castle.Windsor.Proxy.AbstractProxyFactory.ObtainInterceptors(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel,Castle.MicroKernel.Context.CreationContext)">
      <summary>
              Obtains the interceptors associated with the component.
            </summary>
      <param name="kernel">The kernel instance</param>
      <param name="model">The component model</param>
      <param name="context">The creation context</param>
      <returns>interceptors array</returns>
    </member>
    <member name="T:Castle.Windsor.Proxy.DefaultProxyFactory">
      <summary>
              This implementation of <see cref="T:Castle.MicroKernel.IProxyFactory" /> relies 
              on DynamicProxy to expose proxy capabilities.
            </summary>
      <remarks>
              Note that only virtual methods can be intercepted in a 
              concrete class. However, if the component 
              was registered with a service interface, we proxy
              the interface and the methods don't need to be virtual,
            </remarks>
    </member>
    <member name="M:Castle.Windsor.Proxy.DefaultProxyFactory.#ctor">
      <summary>
              Constructs a DefaultProxyFactory
            </summary>
    </member>
    <member name="M:Castle.Windsor.Proxy.DefaultProxyFactory.Create(Castle.MicroKernel.IKernel,System.Object,Castle.Core.ComponentModel,Castle.MicroKernel.Context.CreationContext,System.Object[])">
      <summary>
              Creates the proxy for the supplied component.
            </summary>
      <param name="kernel"> The kernel. </param>
      <param name="target"> The target. </param>
      <param name="model"> The model. </param>
      <param name="constructorArguments"> The constructor arguments. </param>
      <param name="context"> The creation context </param>
      <returns> The component proxy. </returns>
    </member>
    <member name="M:Castle.Windsor.Proxy.DefaultProxyFactory.RequiresTargetInstance(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
      <summary>
              Determines if the component requires a target instance for proxying.
            </summary>
      <param name="kernel"> The kernel. </param>
      <param name="model"> The model. </param>
      <returns> true if an instance is required. </returns>
    </member>
    <member name="T:Castle.Windsor.WindsorContainer">
      <summary>
              Implementation of <see cref="T:Castle.Windsor.IWindsorContainer" />
              which delegates to <see cref="T:Castle.MicroKernel.IKernel" /> implementation.
            </summary>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.#ctor">
      <summary>
              Constructs a container without any external 
              configuration reference
            </summary>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore)">
      <summary>
              Constructs a container using the specified 
              <see cref="T:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore" /> implementation.
            </summary>
      <param name="store">The instance of an <see cref="T:Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore" /> implementation.</param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.Windsor.Configuration.IConfigurationInterpreter)">
      <summary>
              Constructs a container using the specified 
              <see cref="T:Castle.Windsor.Configuration.IConfigurationInterpreter" /> implementation.
            </summary>
      <param name="interpreter">The instance of an <see cref="T:Castle.Windsor.Configuration.IConfigurationInterpreter" /> implementation.</param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.Windsor.Configuration.IConfigurationInterpreter,Castle.Windsor.IEnvironmentInfo)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.WindsorContainer" /> class.
            </summary>
      <param name="interpreter">The interpreter.</param>
      <param name="environmentInfo">The environment info.</param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.#ctor(System.String)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.WindsorContainer" /> class using a
              resource pointed to by the parameter. That may be a file, an assembly embedded resource, a UNC path or a config file section.
              <para>
                Equivalent to the use of <c>new WindsorContainer(new XmlInterpreter(configurationUri))</c></para></summary>
      <param name="configurationUri">The XML file.</param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.MicroKernel.IKernel,Castle.Windsor.IComponentsInstaller)">
      <summary>
              Constructs a container using the specified <see cref="T:Castle.MicroKernel.IKernel" />
              implementation. Rarely used.
            </summary>
      <remarks>
              This constructs sets the Kernel.ProxyFactory property to
              <c>Proxy.DefaultProxyFactory</c></remarks>
      <param name="kernel">Kernel instance</param>
      <param name="installer">Installer instance</param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.#ctor(System.String,Castle.MicroKernel.IKernel,Castle.Windsor.IComponentsInstaller)">
      <summary>
              Constructs a container using the specified <see cref="T:Castle.MicroKernel.IKernel" />
              implementation. Rarely used.
            </summary>
      <remarks>
              This constructs sets the Kernel.ProxyFactory property to
              <c>Proxy.DefaultProxyFactory</c></remarks>
      <param name="name">Container's name</param>
      <param name="kernel">Kernel instance</param>
      <param name="installer">Installer instance</param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.MicroKernel.IProxyFactory)">
      <summary>
              Constructs with a given <see cref="T:Castle.MicroKernel.IProxyFactory" />.
            </summary>
      <param name="proxyFactory">A instance of an <see cref="T:Castle.MicroKernel.IProxyFactory" />.</param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.Windsor.IWindsorContainer,Castle.Windsor.Configuration.IConfigurationInterpreter)">
      <summary>
              Constructs a container assigning a parent container 
              before starting the dependency resolution.
            </summary>
      <param name="parent">The instance of an <see cref="T:Castle.Windsor.IWindsorContainer" /></param>
      <param name="interpreter">The instance of an <see cref="T:Castle.Windsor.Configuration.IConfigurationInterpreter" /> implementation</param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.#ctor(System.String,Castle.Windsor.IWindsorContainer,Castle.Windsor.Configuration.IConfigurationInterpreter)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Windsor.WindsorContainer" /> class.
            </summary>
      <param name="name">The container's name.</param>
      <param name="parent">The parent.</param>
      <param name="interpreter">The interpreter.</param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Dispose">
      <summary>
              Executes Dispose on underlying <see cref="T:Castle.MicroKernel.IKernel" /></summary>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.AddChildContainer(Castle.Windsor.IWindsorContainer)">
      <summary>
              Registers a subcontainer. The components exposed
              by this container will be accessible from subcontainers.
            </summary>
      <param name="childContainer">
      </param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.AddFacility(Castle.MicroKernel.IFacility)">
      <summary>
              Registers a facility within the container.
            </summary>
      <param name="facility">
      </param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.AddFacility``1">
      <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility" /> facility to the container.
            </summary>
      <typeparam name="T">The facility type.</typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.AddFacility``1(System.Action{``0})">
      <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility" /> facility to the container.
            </summary>
      <typeparam name="T">The facility type.</typeparam>
      <param name="onCreate">The callback for creation.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.GetChildContainer(System.String)">
      <summary>
              Gets a child container instance by name.
            </summary>
      <param name="name">The container's name.</param>
      <returns>The child container instance or null</returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Install(Castle.MicroKernel.Registration.IWindsorInstaller[])">
      <summary>
              Runs the <paramref name="installers" /> so that they can register components in the container. For details see the documentation at http://j.mp/WindsorInstall
            </summary>
      <remarks>
              In addition to instantiating and passing every installer inline you can use helper methods on <see cref="T:Castle.Windsor.Installer.FromAssembly" /> class to automatically instantiate and run your installers.
              You can also use <see cref="N:Castle.Windsor.Configuration" /> class to install components and/or run aditional installers specofied in a configuration file.
            </remarks>
      <returns>The container.</returns>
      <example>
        <code>
                container.Install(new YourInstaller1(), new YourInstaller2(), new YourInstaller3());
              </code>
      </example>
      <example>
        <code>
                container.Install(FromAssembly.This(), Configuration.FromAppConfig(), new SomeOtherInstaller());
              </code>
      </example>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Register(Castle.MicroKernel.Registration.IRegistration[])">
      <summary>
              Registers the components with the <see cref="T:Castle.Windsor.IWindsorContainer" />. The instances of <see cref="T:Castle.MicroKernel.Registration.IRegistration" /> are produced by fluent registration API.
              Most common entry points are <see cref="M:Castle.MicroKernel.Registration.Component.For``1" /> method to register a single type or (recommended in most cases) 
              <see cref="M:Castle.MicroKernel.Registration.Classes.FromThisAssembly" />.
              Let the Intellisense drive you through the fluent API past those entry points. For details see the documentation at http://j.mp/WindsorApi
            </summary>
      <example>
        <code>
                container.Register(Component.For&lt;IService&gt;().ImplementedBy&lt;DefaultService&gt;().LifestyleTransient());
              </code>
      </example>
      <example>
        <code>
                container.Register(Classes.FromThisAssembly().BasedOn&lt;IService&gt;().WithServiceDefaultInterfaces().Configure(c =&gt; c.LifestyleTransient()));
              </code>
      </example>
      <param name="registrations">The component registrations created by <see cref="M:Castle.MicroKernel.Registration.Component.For``1" />, <see cref="M:Castle.MicroKernel.Registration.Classes.FromThisAssembly" /> or different entry method to the fluent API.</param>
      <returns>The container.</returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Release(System.Object)">
      <summary>
              Releases a component instance
            </summary>
      <param name="instance">
      </param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.RemoveChildContainer(Castle.Windsor.IWindsorContainer)">
      <summary>
              Removes (unregisters) a subcontainer.  The components exposed by this container
              will no longer be accessible to the child container.
            </summary>
      <param name="childContainer">
      </param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.Type,System.Collections.IDictionary)">
      <summary>
              Returns a component instance by the service
            </summary>
      <param name="service">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.Type,System.Object)">
      <summary>
              Returns a component instance by the service
            </summary>
      <param name="service">
      </param>
      <param name="argumentsAsAnonymousType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.Type)">
      <summary>
              Returns a component instance by the service
            </summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.String,System.Type)">
      <summary>
              Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.String,System.Type,System.Collections.IDictionary)">
      <summary>
              Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="service">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.String,System.Type,System.Object)">
      <summary>
              Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="service">
      </param>
      <param name="argumentsAsAnonymousType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve``1(System.Collections.IDictionary)">
      <summary>
              Returns a component instance by the service
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve``1(System.Object)">
      <summary>
              Returns a component instance by the service
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="argumentsAsAnonymousType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve``1(System.String,System.Collections.IDictionary)">
      <summary>
              Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve``1(System.String,System.Object)">
      <summary>
              Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="argumentsAsAnonymousType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve``1">
      <summary>
              Returns a component instance by the service
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve``1(System.String)">
      <summary>
              Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.ResolveAll``1">
      <summary>
              Resolve all valid components that match this type.
            </summary>
      <typeparam name="T">The service type</typeparam>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.ResolveAll``1(System.Collections.IDictionary)">
      <summary>
              Resolve all valid components that match this type.
              <typeparam name="T">The service type</typeparam><param name="arguments">Arguments to resolve the service</param></summary>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.ResolveAll``1(System.Object)">
      <summary>
              Resolve all valid components that match this type.
              <typeparam name="T">The service type</typeparam><param name="argumentsAsAnonymousType">Arguments to resolve the service</param></summary>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.AddFacility(System.String,Castle.MicroKernel.IFacility)">
      <summary>
              Registers a facility within the container.
            </summary>
      <param name="idInConfiguration">
      </param>
      <param name="facility">
      </param>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.AddFacility``1(System.String)">
      <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility" /> facility to the container.
            </summary>
      <typeparam name="T">The facility type.</typeparam>
      <param name="idInConfiguration">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.AddFacility``1(System.String,System.Action{``0})">
      <summary>
              Creates and adds an <see cref="T:Castle.MicroKernel.IFacility" /> facility to the container.
            </summary>
      <typeparam name="T">The facility type.</typeparam>
      <param name="idInConfiguration">
      </param>
      <param name="configureFacility">The callback for creation.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.String,System.Collections.IDictionary)">
      <summary>
              Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="arguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.String,System.Object)">
      <summary>
              Returns a component instance by the key
            </summary>
      <param name="key">
      </param>
      <param name="argumentsAsAnonymousType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Windsor.WindsorContainer.Kernel">
      <summary>
              Returns the inner instance of the MicroKernel
            </summary>
    </member>
    <member name="P:Castle.Windsor.WindsorContainer.Name">
      <summary>
              Gets the container's name
            </summary>
      <remarks>
              Only useful when child containers are being used
            </remarks>
      <value>The container's name.</value>
    </member>
    <member name="P:Castle.Windsor.WindsorContainer.Parent">
      <summary>
              Gets or sets the parent container if this instance
              is a sub container.
            </summary>
    </member>
    <member name="T:Castle.Windsor.WindsorServiceProvider">
      <summary>
              Implementation of <see cref="T:System.IServiceProvider" /> and <see cref="T:Castle.Core.IServiceProviderEx" /> that uses a <see cref="T:Castle.Windsor.IWindsorContainer" /> or <see cref="T:Castle.MicroKernel.IKernel" /> as its component's source.
            </summary>
    </member>
    <member name="T:AssemblyGitBuild">
      <summary>
            Attribute specifying the hash of the GIT build which is updated by Bamboo on every build.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Common.BetOutcome">
      <summary>
            Localized bet outcome / odds field.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.BetOutcome.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.Common.BetOutcome" /> class
            </summary>
      <param name="type">Odds field name</param>
    </member>
    <member name="M:Sportradar.SDK.Common.BetOutcome.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.Common.BetOutcome.Translation">
      <summary>
            Localized odds field name (e.g. en="u", fi="u", ru="M") 
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.BetOutcome.Type">
      <summary>
            Odds field name (e.g. "u" for under)
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Common.BetTypeKey">
      <summary>
            Bet type key (e.g. "3w" = 2)
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.BetTypeKey.#ctor(System.Int64)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.Common.BetTypeKey" /> class
            </summary>
      <param name="odds_type_id">Bet type id</param>
    </member>
    <member name="M:Sportradar.SDK.Common.BetTypeKey.#ctor(System.Int64,System.Nullable{System.Int64})">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.Common.BetTypeKey" /> class
            </summary>
      <param name="odds_type_id">Bet type id</param>
      <param name="odds_sub_type">Optional bet subtype id</param>
    </member>
    <member name="M:Sportradar.SDK.Common.BetTypeKey.Equals(System.Object)">
      <summary>
            Check for equality.
            </summary>
      <param name="obj">other object</param>
      <returns>true when equal; false else</returns>
    </member>
    <member name="M:Sportradar.SDK.Common.BetTypeKey.Equals(Sportradar.SDK.Common.BetTypeKey)">
      <summary>
            Check for equality.
            </summary>
      <param name="other">other object</param>
      <returns>true when equal; false else</returns>
    </member>
    <member name="M:Sportradar.SDK.Common.BetTypeKey.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>
            Hash for current object
            </returns>
    </member>
    <member name="M:Sportradar.SDK.Common.BetTypeKey.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="P:Sportradar.SDK.Common.BetTypeKey.BetTypeId">
      <summary>
            Unique bet type id (e.g. type="3w", typeid="2")
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.BetTypeKey.BetSubType">
      <summary>
            Optional bet subtype id (e.g. type="ft3w" typeid="6" subtype="13" freetext="Next goal")
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Common.BetValue">
      <summary>
            Value associated with a specified <see cref="T:Sportradar.SDK.Common.BetTypeKey" />.
            This includes localized bet type name (e.g. en="hc", fi="Taaoitus")
            and localized outcomes/odds fields (e.g. "1", "x", "2" in different languages)
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.BetValue.#ctor(System.String,Sportradar.SDK.Common.LocalizedString,Sportradar.SDK.Common.BetTypeKey)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.Common.BetValue" /> class
            </summary>
      <param name="type">Odds type name</param>
      <param name="name">Odds internationalized name</param>
      <param name="key">Odds type key</param>
    </member>
    <member name="M:Sportradar.SDK.Common.BetValue.AddOutcome(Sportradar.SDK.Common.BetOutcome)">
      <exclude />
    </member>
    <member name="M:Sportradar.SDK.Common.BetValue.Clone">
      <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
      <returns>A new object that is a copy of this instance.</returns>
    </member>
    <member name="M:Sportradar.SDK.Common.BetValue.DeleteOutcome(Sportradar.SDK.Common.BetOutcome)">
      <exclude />
    </member>
    <member name="M:Sportradar.SDK.Common.BetValue.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.Common.BetValue.Key">
      <summary>
            Corresponding key.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.BetValue.Name">
      <summary>
            Localized bet type name
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.BetValue.Outcomes">
      <summary>
            Collection of localized outcomes / odds fields
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.BetValue.Type">
      <summary>
            Odds type name (international, e.g. "3w", "to", "hc" );
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Common.ClientPersistentStateItem">
      <summary>
            Client persistent state item.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.ClientPersistentStateItem.#ctor(System.String,System.Byte[],System.DateTime)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.Common.ClientPersistentStateItem" /> class.
            </summary>
      <param name="key">The key</param>
      <param name="value">The value</param>
      <param name="item_last_updated">The time the item was last updated</param>
      <exception cref="T:System.ArgumentException">key</exception>
    </member>
    <member name="P:Sportradar.SDK.Common.ClientPersistentStateItem.ItemLastUpdated">
      <summary>
            Time when item was last updated.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.ClientPersistentStateItem.Key">
      <summary>
            Persistent state item key.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.ClientPersistentStateItem.Value">
      <summary>
            Persistent state item value.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Common.DynamicConfigIgnoreClassAttribute">
      <summary>
            Attribute specifying that <see cref="T:System.Configuration.ConfigurationElement" /> can be ignored by the dynamic configuration handling code. 
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Common.DynamicConfigItemAttribute">
      <summary>
            Attribute specifying configuration property as dynamic. 
            Dynamic configuration properties can be updated by configuration server in runtime.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.LiveOddsPersistentStateItem.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="M:Sportradar.SDK.Common.PersistentStateItem.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="M:Sportradar.SDK.Common.PersistentStateItemKey.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="T:Sportradar.SDK.Common.SchemaValidationStrictness">
      <summary>
            Schema validation strictness.
            <remarks>
            Order is important - from least to most strict.
            Best choice is probably STRICT.
            This means we will not spend lots of CPU time while processing eventual junk messages. 
            Our schema supports any attributes so this is not a problem. 
            The only issue could present new (unknown) XML elements.
            </remarks></summary>
    </member>
    <member name="F:Sportradar.SDK.Common.SchemaValidationStrictness.OFF">
      <summary>
            No schema validation is performed at all.
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.SchemaValidationStrictness.ON">
      <summary>
            If schema validation fails the message is still deserialized
            (but it might fail with an exception later).
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.SchemaValidationStrictness.STRICT">
      <summary>
            Schema validation failure means the message must be discarded
            immediately.
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.SchemaValidationStrictness.VERY_STRICT">
      <summary>
            Same as above except that any warning is also treated as fatal error.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Common.EntityBase">
      <summary>
            Serves as a base class for all client data contracts/entities.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.EntityBase.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.Common.EntityBase.AdditionalData">
      <summary>
            Contains any additional XML attributes found while parsing XML feed messages
            that are not supported with the current version of the data contracts.
            These are represented as an XML attribute name-value tuples.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.EntityBase.EventId">
      <exclude />
    </member>
    <member name="P:Sportradar.SDK.Common.EntityBase.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.Common.Priority">
      <summary>
            Event priority.
            </summary>
      <remarks>
            Priorities are not used in this SDK release.
            </remarks>
    </member>
    <member name="F:Sportradar.SDK.Common.Priority.UNDEFINED">
      <summary>
            Undefined
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.Priority.LOW">
      <summary>
            Low priority
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.Priority.HIGH">
      <summary>
            High priority
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.PriorityQueueElt.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="T:Sportradar.SDK.Common.ProtocolProviderType">
      <summary>
            Type of protocol provider
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.ProtocolProviderType.UNKNOWN">
      <summary>
            Unknown
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.ProtocolProviderType.LIVEODDS">
      <summary>
            Live Odds Provider
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.ProtocolProviderType.LIVEODDS_VBL">
      <summary>
            Live Odds VBL Provider
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.ProtocolProviderType.LIVEODDS_VFL">
      <summary>
            Live Odds VFL Provider
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.ProtocolProviderType.LIVEODDS_VTO">
      <summary>
            Live Odds VTO Provider
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.ProtocolProviderType.LIVEODDS_BETPAL">
      <summary>
            Live Odds BetPal Provider
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.ProtocolProviderType.LIVEODDS_LIVEPLEX">
      <summary>
            Live Odds Liveplex Provider
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.ProtocolProviderType.LIVEODDS_SOCCER_ROULETTE">
      <summary>
            Live Odds Soccer Roulette provider
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.ProtocolProviderType.LIVEODDS_VHC">
      <summary>
            Live Odds Virtual Horse Classics
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.ProtocolProviderType.LIVEODDS_VDR">
      <summary>
            Live Odds Virtual Dog Racing
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.ProtocolProviderType.LIVEODDS_VFC">
      <summary>
            Virtual Football Cup
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.ProtocolProviderType.LIVESCOUT">
      <summary>
            Live Scout Provider
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.ProtocolProviderType.ODDS_CREATOR">
      <summary>
            Odds Creator Provider
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.ProtocolProviderType.LCOO">
      <summary>
            Odds Creator Provider
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Common.LocalizedString">
      <summary>
            Localized string container where a string is represented by its international value and 
            a collection of translations to other languages.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.LocalizedString.#ctor(System.String)">
      <summary>
            Constructs a new localized string.
            </summary>
      <param name="international_value">International value</param>
    </member>
    <member name="M:Sportradar.SDK.Common.LocalizedString.op_Inequality(Sportradar.SDK.Common.LocalizedString,Sportradar.SDK.Common.LocalizedString)">
      <summary>
            Check for non-equality.
            </summary>
      <remarks>
            Compares by the international value only.
            </remarks>
      <param name="x">First object</param>
      <param name="y">Second object</param>
      <returns>
            true when not equal; false else
            </returns>
    </member>
    <member name="M:Sportradar.SDK.Common.LocalizedString.op_Equality(Sportradar.SDK.Common.LocalizedString,Sportradar.SDK.Common.LocalizedString)">
      <summary>
            Check for equality.
            </summary>
      <remarks>
            Compares by the international value only.
            </remarks>
      <param name="x">First object</param>
      <param name="y">Second object</param>
      <returns>
            true when equal; false else
            </returns>
    </member>
    <member name="M:Sportradar.SDK.Common.LocalizedString.AddTranslation(System.String,System.String)">
      <summary>
            Adds a new translation to the string.
            Overrides the previous language translations if existed.
            </summary>
      <param name="lang">Language code</param>
      <param name="translation">Translation for this language</param>
    </member>
    <member name="M:Sportradar.SDK.Common.LocalizedString.Equals(System.Object)">
      <summary>
            Check for equality.
            </summary>
      <param name="obj">other object</param>
      <returns>true when equal; false else</returns>
    </member>
    <member name="M:Sportradar.SDK.Common.LocalizedString.Equals(Sportradar.SDK.Common.LocalizedString)">
      <summary>
            Check for equality.
            </summary>
      <remarks>
            Compares by the international value only.
            </remarks>
      <param name="other">other object</param>
      <returns>
            true when equal; false else
            </returns>
    </member>
    <member name="M:Sportradar.SDK.Common.LocalizedString.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>
            Hash for current object
            </returns>
    </member>
    <member name="M:Sportradar.SDK.Common.LocalizedString.GetTranslation(System.String)">
      <summary>
            Returns translation for the specified language.
            Falls back to international string if translation does not exist.
            </summary>
      <param name="lang">Language code (null for international string)</param>
      <returns>Translation for the specified language.</returns>
    </member>
    <member name="M:Sportradar.SDK.Common.LocalizedString.ToString">
      <summary>
            Returns international string
            </summary>
      <returns>International string</returns>
    </member>
    <member name="P:Sportradar.SDK.Common.LocalizedString.AvailableTranslationLanguages">
      <summary>
            Available language codes this instance is translated to.
            For instance "de", "en" and so on.
            </summary>
      <remarks>
            Might be empty, then you still have the international name
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Common.LocalizedString.International">
      <summary>
            Returns international string.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Common.TypeValueTuple">
      <summary>
            TypeValueTuple
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.TypeValueTuple.Type">
      <summary>
            Type
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.TypeValueTuple.Value">
      <summary>
            Value
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.TimeKeeper.TimeAddendum">
      <summary>
            Time to add to local time so it becomes server time (might be negative).
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Common.Utils.IStash`1">
      <summary>
            Stateful component that allows to stash elements until needed.
            You get duplicate detection and ordering guarantees.
            </summary>
      <typeparam name="T">Type of the elements</typeparam>
    </member>
    <member name="M:Sportradar.SDK.Common.Utils.IStash`1.AddStash(`0)">
      <summary>
            Add an item to stash.
            (When using the resequencer as kind of a stash for elements).
            </summary>
      <param name="item">a new element</param>
    </member>
    <member name="M:Sportradar.SDK.Common.Utils.IStash`1.ClearWaiting">
      <summary>
            Clear waiting (out-of-sequence) elements.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.Utils.IStash`1.GetWaiting">
      <summary>
            Get the out-of-sequence elements that are still waiting.
            </summary>
      <returns>the waiting elements</returns>
    </member>
    <member name="P:Sportradar.SDK.Common.Utils.IStash`1.MaxSeqWaiting">
      <summary>
            The waiting element with maximum sequence number.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Utils.IStash`1.MinSeqWaiting">
      <summary>
            The waiting element with minimum sequence number.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Common.Utils.IResequencer`1">
      <summary>
            Stateful component that allows to obtain items in correct sequence.
            </summary>
      <typeparam name="T">Type of the elements</typeparam>
    </member>
    <member name="M:Sportradar.SDK.Common.Utils.IResequencer`1.Add(`0)">
      <summary>
            Add a new element.
            </summary>
      <param name="item">a new element</param>
      <returns>
            true when item is in-sequence;
            false else (duplicate, out-of-sequence, etc.)
            </returns>
    </member>
    <member name="M:Sportradar.SDK.Common.Utils.IResequencer`1.Clear(System.Nullable{System.Int64})">
      <summary>
            Clear complete state and possibly also reset first desired state.
            <param name="fresh_seq_start">Possible fresh star for sequence numbers</param></summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Utils.IResequencer`1.LastSeqNum">
      <summary>
            Latest sequence number
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.Utils.MathExt.Lengthen(System.Double)">
      <summary>
            The opposite of Math.Truncate.
            </summary>
      <param name="num">Number</param>
      <returns>
            Truncate will round towards zero,
            this method rounds towards - or + infinity.
            This is like Math.Ceil for positive numbers,
            and like Math.Floor for negative numbers.
            </returns>
    </member>
    <member name="M:Sportradar.SDK.Common.Utils.MathExt.Lengthen(System.Decimal)">
      <summary>
            The opposite of Math.Truncate.
            </summary>
      <param name="num">Number</param>
      <returns>
            Truncate will round towards zero,
            this method rounds towards - or + infinity.
            This is like Math.Ceil for positive numbers,
            and like Math.Floor for negative numbers.
            </returns>
    </member>
    <member name="T:Sportradar.SDK.Common.Utils.StreamWrapper">
      <summary>
            Another workaround for a .NET bug
            (http://social.msdn.microsoft.com/Forums/en-US/netfxnetcom/thread/f4c3d019-aecd-4fc6-9dea-680f04faa900)
            
            <para>
            NetworkStream
            <list type="bullet"><item>non-blocking Read() returns 0 bytes when there is nothing to read</item><item>IOException when "the underlying Socket is closed." -&gt; reconnect</item><item>Write() is thread-safe</item></list></para><para>
            SslStream
            <list type="bullet"><item>&gt;non-blocking Read() throws IOException -&gt; no need to reconnect</item><item>
            after the exception a subsequent non-blocking Read() (when there is
            nothing to read) returns 5 bytes of SSL keep-alive data (23 3 1 0 17)
            23 is TLS application protocol, 3 1 means TLS 1.0, 3 0 would be SSL 3.0
            </item><item>Write() is NOT thread-safe</item></list></para>
              
             Unify the behavior to NetworkStream behavior.
            </summary>
      <remarks>
            This implementation of stream wrapper is not thread safe.
            </remarks>
    </member>
    <member name="M:Sportradar.SDK.Common.Utils.CommonUtils.EnsureDifferentThread(System.Boolean,System.Action)">
      <summary>
            When is_different_thread is true run in the same thread, else start a new one
            </summary>
      <param name="is_different_thread">boolean condition</param>
      <param name="action">action to be executed</param>
    </member>
    <member name="M:Sportradar.SDK.Common.Utils.CommonUtils.FromTimestamp(System.Int64,System.DateTimeKind)">
      <summary>
            Convert from UNIX timestamp to local or UTC timestamp.
            </summary>
      <param name="time">UTC time in UNIX format (*1000)</param>
      <param name="convert_to">Date time kind to convert to</param>
      <returns>Date time of the specified kind</returns>
    </member>
    <member name="M:Sportradar.SDK.Common.Utils.CommonUtils.IntegerToBoolean(System.Int32)">
      <summary>
            IntegerToBoolean
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.Common.Utils.CommonUtils.StringToBoolean(System.String)">
      <summary>
            StringToBoolean
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.Common.Utils.CommonUtils.StringToDateTime(System.String,System.String)">
      <summary>
            StringToDateTime
            </summary>
      <param name="value">
      </param>
      <param name="zone">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Sportradar.SDK.Common.Interfaces.QueueLimitAction">
      <summary>
            Queue limit action (whether a limit was reached or retreated)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.Interfaces.QueueLimitAction.REACHED">
      <summary>
            Queue limit was reached
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.Interfaces.QueueLimitAction.RETREATED">
      <summary>
            Queue limit was retreated
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Common.Interfaces.QueueLimitType">
      <summary>
            Type of queue size limit
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.Interfaces.QueueLimitType.NORMAL">
      <summary>
            Queue size below low threshold (not getting filled up)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.Interfaces.QueueLimitType.LOW">
      <summary>
            Queue size at low threshold (reason for being worried)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Common.Interfaces.QueueLimitType.HIGH">
      <summary>
            High threshold (almost at the full capacity)
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Common.Interfaces.QueueLimitEventArgs">
      <summary>
            Event arguments passed with the <see cref="!:LimitedPriorityQueueDelegates.QueueLimitDelegate" /></summary>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.QueueLimitEventArgs.#ctor(System.String,Sportradar.SDK.Common.Interfaces.QueueLimitType,Sportradar.SDK.Common.Interfaces.QueueLimitAction,System.Int32,System.Int32)">
      <summary>
            QueueLimitEventArgs constructor.
            </summary>
      <param name="queue_name">name of the queue</param>
      <param name="type">type of the limit</param>
      <param name="action">action of the limit</param>
      <param name="old_count">old count</param>
      <param name="new_count">new (current) count</param>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.QueueLimitEventArgs.Action">
      <summary>
            Whether queue limit was reached or retreated
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.QueueLimitEventArgs.NewCount">
      <summary>
            Current queue size
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.QueueLimitEventArgs.OldCount">
      <summary>
            Previous queue size
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.QueueLimitEventArgs.QueueName">
      <summary>
            Queue name
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.QueueLimitEventArgs.Type">
      <summary>
            Type of queue limit reached or retreated
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.ILoggerData.LoggingFeedName">
      <summary>
            Prefix used in logging 
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.ILoggerData.AlertLogLevel">
      <summary>
            Specifies log level threshold used while logging alert messages.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.ILoggerData.ClientInteractionLogLevel">
      <summary>
            Specifies log level threshold used while logging client interaction messages.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.ILoggerData.DeadLetterLogLevel">
      <summary>
            Specifies log level threshold used while logging dead letter messages.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.ILoggerData.InvalidMsgLogLevel">
      <summary>
            Specifies log level threshold used while logging invalid/corrupt messages.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.ILoggerData.TrafficLogLevel">
      <summary>
            Specifies log level threshold used while logging incoming and outgoing traffic (live feed messages).
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Common.Interfaces.IClientPersistentState">
      <summary>
            Persistent state store interface that should be implemented by the client.
            </summary>
      <remarks>If this interface is not implemented, XML feed error recovery will not be possible</remarks>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IClientPersistentState.Clear">
      <summary>
            Clears persistent state store contents.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IClientPersistentState.Read(System.String)">
      <summary>
            Retrieves value for the given key from the persistent store.
            </summary>
      <param name="key">Key</param>
      <returns>Retrieved item</returns>
      <remarks>Returns null if key is not found. Used at error recovery and for 
            double-checking whether persistent state store contents are consistent with buffered values.</remarks>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IClientPersistentState.ReadAll">
      <summary>
            Returns all persistent state items from the store.
            </summary>
      <returns>All persistent state items from the store</returns>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IClientPersistentState.Remove(System.String)">
      <summary>
            Removes an item by key
            </summary>
      <param name="key">Key</param>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IClientPersistentState.RemoveOld(System.DateTime)">
      <summary>
            Removes stale persistent state items that haven't been updated in a while.
            </summary>
      <param name="max_age">All items older than max_age will be removed from the store</param>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IClientPersistentState.Write(System.Collections.Generic.IList{Sportradar.SDK.Common.ClientPersistentStateItem})">
      <summary>
            Write batch of key-value pairs into client provided persistent store (DB, file system).
            </summary>
      <param name="items">Batch of items</param>
      <remarks>Overwrites existing values so that stale items can be removed.</remarks>
    </member>
    <member name="T:Sportradar.SDK.Common.Interfaces.IDeadLetterQueue">
      <summary>
            Dead Letter queue interface that should be implemented by the client.
            </summary>
      <remarks>Implementation of this interface is optional for the client</remarks>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IDeadLetterQueue.Enqueue(Sportradar.SDK.Common.EntityBase)">
      <summary>
            Enqueues a message into dead letter queue after the message was removed 
            from the poison queue and could not be delivered successfully to the client.
            </summary>
      <param name="failed_msg">Failed msg</param>
    </member>
    <member name="T:Sportradar.SDK.Common.Interfaces.IPersistentStateBuffer">
      <summary>
            Persistent state buffer interface that buffers the underlying client persistent state store.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IPersistentStateBuffer.Clear">
      <summary>
            Clears persistent state store contents.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IPersistentStateBuffer.GetAllProviderItems(Sportradar.SDK.Common.ProtocolProviderType)">
      <summary>
            Returns all persistent state items that belong to specific provider.
            </summary>
      <param name="provider_type">Provider type</param>
      <returns>All persistent state items that belong to specific provider.</returns>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IPersistentStateBuffer.Read(Sportradar.SDK.Common.PersistentStateItemKey)">
      <summary>
            Retrieves value for the given key from the persistent store.
            </summary>
      <param name="key">Key</param>
      <returns>Retrieved item</returns>
      <remarks>Returns null if key is not found. Used at error recovery and for 
            double-checking whether persistent state store contents are consistent with buffered values.</remarks>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IPersistentStateBuffer.Remove(Sportradar.SDK.Common.PersistentStateItemKey)">
      <summary>
            Removes an item by key
            </summary>
      <param name="key">Key</param>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IPersistentStateBuffer.Write(Sportradar.SDK.Common.PersistentStateItem)">
      <summary>
            Write persistent state item into client provided persistent store (DB, file system).
            </summary>
      <param name="item">Persistent state item</param>
      <remarks>Overwrites existing values so that stale items can be removed.</remarks>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IPersistentStateBuffer.TestStatus">
      <summary>
            Returns true if persistent state buffer is in consistent state and 
            if the underlying client state store is functioning properly.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.Common.Interfaces.IPersistentStateBuffer.OnPersistentStateStatusChanged">
      <summary>
            Fires event whenever persistent state buffer encounters an error condition (e.g. underlying state store error)
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Common.Interfaces.IStartable">
      <summary>
            Interface specifying that a component is startable, i.e. should first be started before 
            any other call are made and stopped at the end.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IStartable.Start">
      <summary>
            Start component.
            </summary>
      <remarks>
            The component should be initialized first.
            </remarks>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IStartable.Stop">
      <summary>
            Stop / shutdown component.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Common.Interfaces.IProtocolBase">
      <summary>
            All request and reply messages implement this interface.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Common.Interfaces.IPoisonQueue">
      <summary>
            Poison queue interface
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IPoisonQueue.Enqueue(Sportradar.SDK.Common.PoisonQueueElt)">
      <summary>
            Enqueue a new poison element.
            Throws PoisonQueueException if there is already poison elements for the same match enqueued.
            </summary>
      <param name="obj">Poison element</param>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IPoisonQueue.IsMatchPoisonous(System.Collections.Generic.IList{System.Int64})">
      <summary>
            Checks whether there is a poison element linked to this match
            </summary>
      <param name="match_ids">Match ids</param>
      <returns>Returns true if there is a poison element linked to this match</returns>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IPoisonQueue.WaitForElementRemoved(System.TimeSpan)">
      <summary>
            Waits until an element is removed (promoted or deceased) from the poison queue.
            </summary>
      <param name="wait_timeout">Wait timeout</param>
      <returns>True if the wait was successful or false if the timeout occurred.</returns>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IPoisonQueue.ProviderType">
      <summary>
            Poison queue must be assigned a to particular feed provider.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.Common.Interfaces.IPoisonQueue.OnPoisonQueueEltDead">
      <summary>
            Event raised whenever an element is to be dumped into dead letter queue.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.Common.Interfaces.IPoisonQueue.OnPoisonQueueEltPromoted">
      <summary>
            Event raised whenever an element is promoted from Poison queue and moved back into Main queue.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IProtocolData.BookmakerId">
      <summary>
            Bookmaker ID
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IProtocolData.BookmakerKey">
      <summary>
            Bookmaker key
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IProtocolData.EventRequestLimiter">
      <summary>
            Limits the number of matches that a client can reference in a given time frame (get status, meta info, book, subscribe or error recovery).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IProtocolData.LoginLimiter">
      <summary>
            Limits the number of logins a client can perform in a given time frame.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IProtocolData.MaxTimeSkew">
      <summary>
            Max message timestamp skew. Zero to disable the check.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IProtocolData.RequestLimiter">
      <summary>
            Limits the number of requests a client can send in a given time frame.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IProtocolData.SchemaStrictness">
      <summary>
            XSD schema validation strictness. Can be OFF, ON, STRICT or VERY STRICT
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IProtocolData.ScoutPassword">
      <summary>
            Scout client password
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IProtocolData.ScoutUsername">
      <summary>
            Scout client username
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IProtocolData.SendClientTimeInRequest">
      <summary>
            Whether client UTC time should be included in every request message (LiveOdds).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IProtocolData.SendClientVersionInLogin">
      <summary>
            Whether client version should be sent in login.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IProtocolData.RestartOnParseError">
      <summary>
            If true, the feed will reconnect on any parse error
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IConnectionData.CipherSettings">
      <summary>
            SSL stream cipher settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IConnectionData.ClientAliveMsgTimeout">
      <summary>
            Client alive message timeout
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IConnectionData.DisallowNonPrintableChars">
      <summary>
            Should non-printable characters in the stream trigger a disconnect.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IConnectionData.DoValidityCheck">
      <summary>
            Should connection provider do a quick validity check.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IConnectionData.Encoding">
      <summary>
            Communication channel character encoding
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IConnectionData.Hostname">
      <summary>
            Server name
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IConnectionData.InvalidDataReconnectWait">
      <summary>
            Delay before we try reconnecting to server after we received some garbage data
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IConnectionData.MaxReconnectWait">
      <summary>
            Delay before we try reconnecting to server after we got disconnected (max)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IConnectionData.MinReconnectWait">
      <summary>
            Delay before we try reconnecting to server after we got disconnected (min)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IConnectionData.Port">
      <summary>
            Server port number
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IConnectionData.ReceiveBufferSize">
      <summary>
            Message line buffer size. Complete message line should fit in here.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IConnectionData.ReceiveTimeout">
            Amount of time to wait for (socket) receive operation to complete successfully
        </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IConnectionData.SendTimeout">
      <summary>
            Amount of time to wait for (socket) send operation to complete successfully
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IConnectionData.ServerAliveMsgTimeout">
      <summary>
            Server alive message timeout
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IConnectionData.TotalBufferSize">
      <summary>
            Total message buffer size. A complete XML message should fit in here.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IConnectionData.UseSSL">
      <summary>
            Use secure sockets for communication.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Common.Interfaces.IConnectionProvider">
      <summary>
            Connection provider
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IConnectionProvider.Error(System.String,System.String)">
      <summary>
            Start immediate error recovery.
            Usually due to an error on the upper layer.
            </summary>
      <param name="opt_protocol_message">Optional message that should be sent before disconnection</param>
      <param name="log_message">Informative error description</param>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IConnectionProvider.SendMessage(System.String,System.Boolean)">
      <summary>
            Deliver a protocol unit (as a string) to the server.
            </summary>
      <param name="message">protocol unit (in string format)</param>
      <param name="only_try">when true do not throw any exceptions</param>
      <exception cref="T:Sportradar.SDK.Common.Exceptions.DisconnectedStateException">If we are currently disconnected</exception>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IConnectionProvider.Start">
      <summary>
            Start the connection provider (connects to the 
            server and start the automatic reconnection).
            <remarks></remarks>
            ConnectionData must be initialized or else an exception is thrown.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IConnectionProvider.Start(Sportradar.SDK.Common.Interfaces.IConnectionData)">
      <summary>
            Start the connection provider (connects to the 
            server and start the automatic reconnection).
            </summary>
      <param name="connection_data">connection data</param>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IConnectionProvider.Stop(System.String)">
      <summary>
            Stop the connection provider. Opposite of Start().
            </summary>
      <param name="opt_protocol_message">Optional message that should be sent before disconnection</param>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IConnectionProvider.WaitForConnection">
      <summary>
            Block and wait until the connection is established.
            </summary>
      <returns>
            true if the connection is established;
            false (should rarely happen) in case of a race-condition or when
            wait_time times out
            </returns>
      <remarks>
            The method might return true and the connection can get
            broken right after that, so do not assume after that method
            we are for sure in a "connected" state, it might have been
            just a temporary state.
            </remarks>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IConnectionProvider.WaitForDisconnection">
      <summary>
            Block and wait until the connection is not established anymore.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IConnectionProvider.ConnectionData">
      <summary>
            Obtain current connection data
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IConnectionProvider.IsStarted">
      <summary>
            Obtain whether the connection provider is running.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Interfaces.IConnectionProvider.RxEnabled">
      <summary>
            Whether reading from input stream is enabled or not 
            (i.e. input msg queue going over the high watermark should disable all RX)
            </summary>
    </member>
    <member name="E:Sportradar.SDK.Common.Interfaces.IConnectionProvider.OnAliveCheckNecessary">
      <summary>
            Invoked when the protocol requires an alive check.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.Common.Interfaces.IConnectionProvider.OnCommunicationError">
      <summary>
            Invoked when a communication error on the physical connection is detected
            </summary>
    </member>
    <member name="E:Sportradar.SDK.Common.Interfaces.IConnectionProvider.OnConnected">
      <summary>
            Invoked when the physical connection to the server is established.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.Common.Interfaces.IConnectionProvider.OnDisconnected">
      <summary>
            Invoked when the physical connection to the server is dropped.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.Common.Interfaces.IConnectionProvider.OnMessageReceived">
      <summary>
            Invoked when a new protocol data unit in string format is received.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.Common.Interfaces.IConnectionProvider.OnValidDataCheckNecessary">
      <summary>
            Invoked when the protocol requires a check for valid data.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Common.Interfaces.IProtocolRequest">
      <summary>
            All request messages implement this interface.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.Interfaces.IProtocolRequest.GetMessageType">
      <summary>
            Get type of the message.
            </summary>
      <returns>
            A human readable message type.
            </returns>
    </member>
    <member name="T:Sportradar.SDK.Common.Exceptions.NotStartedException">
      <summary>
            A required component was not started.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.Exceptions.NotStartedException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.Common.Exceptions.NotStartedException" /> class
            </summary>
      <param name="message">Exception message</param>
    </member>
    <member name="T:Sportradar.SDK.Common.Exceptions.NotInitializedException">
      <summary>
            Component not initialized exception.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.Exceptions.NotInitializedException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.Common.Exceptions.NotInitializedException" /> class
            </summary>
      <param name="message">Exception message</param>
    </member>
    <member name="T:Sportradar.SDK.Common.Exceptions.SdkConfigException">
      <summary>
            SDK configuration exception (e.g. configuration setting validation)
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.Exceptions.SdkConfigException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.Common.Exceptions.SdkConfigException" /> class
            </summary>
      <param name="message">Exception message</param>
    </member>
    <member name="M:Sportradar.SDK.Common.Exceptions.SdkConfigException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.Common.Exceptions.SdkConfigException" /> class
            </summary>
      <param name="message">Exception message</param>
      <param name="inner_exception">Inner exception</param>
    </member>
    <member name="T:Sportradar.SDK.Common.Exceptions.InitException">
      <summary>
            Initialization exception.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.Exceptions.InitException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.Common.Exceptions.InitException" /> class
            </summary>
      <param name="message">Exception message</param>
    </member>
    <member name="M:Sportradar.SDK.Common.Exceptions.InitException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.Common.Exceptions.InitException" /> class
            </summary>
      <param name="message">Exception message</param>
      <param name="inner_exception">Inner exception</param>
    </member>
    <member name="T:Sportradar.SDK.Common.Exceptions.InvalidDataReceivedException">
      <summary>
            Invalid data received exception.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.Exceptions.InvalidDataReceivedException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.Common.Exceptions.InvalidDataReceivedException" /> class
            </summary>
      <param name="message">Exception message</param>
    </member>
    <member name="T:Sportradar.SDK.Common.Exceptions.DefaultExceptionRenderer">
      <summary>
            Log4Net exception renderer. Includes special exception identifier for all exceptions 
            derived from <see cref="T:Sportradar.SDK.Common.Exceptions.SdkBaseException" />.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Common.Exceptions.SdkBaseException">
      <summary>
            SDK base application exception that all other SDK exception should derive from.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.Exceptions.SdkBaseException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.Common.Exceptions.SdkBaseException" /> class
            </summary>
      <param name="message">Exception message</param>
    </member>
    <member name="M:Sportradar.SDK.Common.Exceptions.SdkBaseException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.Common.Exceptions.SdkBaseException" /> class
            </summary>
      <param name="message">Exception message</param>
      <param name="inner_exception">Inner exception</param>
    </member>
    <member name="P:Sportradar.SDK.Common.Exceptions.SdkBaseException.Identifier">
      <summary>
            Special exception identifier that can be used for tracking down exception details in the log files.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Common.Exceptions.BufferOverflowException">
      <summary>
            Buffer overflow exception.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.Exceptions.BufferOverflowException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.Common.Exceptions.BufferOverflowException" /> class
            </summary>
      <param name="message">Exception message</param>
    </member>
    <member name="T:Sportradar.SDK.Common.Exceptions.LoginRateLimitingException">
      <summary>
            Login rate limiting threshold exceeded exception.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.Exceptions.LoginRateLimitingException.#ctor(System.TimeSpan,Sportradar.SDK.Common.Interfaces.IProtocolRequest)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.Common.Exceptions.LoginRateLimitingException" /> class
            </summary>
      <param name="wait_until">Required time to wait in order to pass the rate limiter</param>
      <param name="request">Login request message that was rejected during rate limiting</param>
    </member>
    <member name="T:Sportradar.SDK.Common.Exceptions.RateLimitingException">
      <summary>
            Rate limit threshold exceeded exception.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.Exceptions.RateLimitingException.#ctor(System.TimeSpan,Sportradar.SDK.Common.Interfaces.IProtocolRequest)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.Common.Exceptions.RateLimitingException" /> class
            </summary>
      <param name="wait_until">Required time to wait in order to pass the rate limiter</param>
      <param name="request">Request message that was rejected during rate limiting</param>
    </member>
    <member name="P:Sportradar.SDK.Common.Exceptions.RateLimitingException.WaitUntil">
      <summary>
            Required time to wait in order to pass the rate limiter
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Common.Exceptions.RateLimitingException.Command">
      <summary>
            Request message that was rejected during rate limiting
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Common.Exceptions.TimeSkewException">
      <summary>
            Client-Server system time skew exception.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.Exceptions.TimeSkewException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.Common.Exceptions.TimeSkewException" /> class
            </summary>
      <param name="message">Exception message</param>
    </member>
    <member name="T:Sportradar.SDK.Common.Exceptions.DisconnectedStateException">
      <summary>
            Communication channel disconnected exception.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Common.Exceptions.DisconnectedStateException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.Common.Exceptions.DisconnectedStateException" /> class
            </summary>
      <param name="message">Exception message</param>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Common.HomeAway`1">
      <summary>
            Home and away tuple (e.g. counters, stats).
            </summary>
      <typeparam name="T">
            Type that has a home and away value.
            </typeparam>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Common.HomeAway`1.#ctor(`0,`0)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.Common.HomeAway`1" /> class.
            </summary>
      <param name="team1">Team 1 / Home team</param>
      <param name="team2">Team 2 / Away team</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Common.HomeAway`1.ToString">
      <summary>
            Convert to string representation.
            </summary>
      <returns>
            Proper string representation.
            </returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Common.HomeAway`1.Team1">
      <summary>
            Team 1 / Home team.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Common.HomeAway`1.Team2">
      <summary>
            Team 2 / Away team.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Common.IdNameTuple">
      <summary>
            Id and localized name tuple with optional unique id field.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Common.IdNameTuple.#ctor(System.Int64,System.String,System.Boolean)">
      <summary>
            Initialize a new <see cref="T:Sportradar.SDK.FeedProviders.Common.IdNameTuple" /> instance.
            </summary>
      <param name="id">Entity id</param>
      <param name="value">Entity value</param>
      <param name="id_specified">Whether id is specified or not</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Common.IdNameTuple.#ctor(System.Int64,System.String,System.Int64,System.Boolean,System.Boolean)">
      <summary>
            Initialize a new <see cref="T:Sportradar.SDK.FeedProviders.Common.IdNameTuple" /> instance.
            </summary>
      <param name="id">Entity id</param>
      <param name="value">Entity value</param>
      <param name="unique_id">Entity unique id (i.e. team unique id)</param>
      <param name="id_specified">Whether id is specified or not</param>
      <param name="unique_id_specified">Whether unique id is specified or not</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Common.IdNameTuple.ToString">
      <summary>
            Convert to string representation.
            </summary>
      <returns>
            Proper string representation.
            </returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Common.IdNameTuple.Id">
      <summary>
            Entity id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Common.IdNameTuple.Name">
      <summary>
            Localized entity name
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Common.IdNameTuple.UniqueId">
      <summary>
            Specified the team unique id.
            The teams have two id's; one named id and another named uniqueid. The id is for that team in that tournament, 
            and the uniqueid is for that team in all tournaments. Not all teams have the uniqueid attribute, 
            so it should only be used to identify that two teams in different tournaments are the same.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Common.ErrorCause">
      <summary>
            Error cause.
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.Common.ErrorCause.UNKNOWN">
      <summary>
            Unknown
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.Common.ErrorCause.PARSE">
      <summary>
            Feed parsing error occurred
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.Common.ErrorCause.DISCONNECTED">
      <summary>
            OnDisconnected from server
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Common.ErrorSeverity">
      <summary>
            Error severity.
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.Common.ErrorSeverity.CRITICAL">
      <summary>
            Critical level
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.Common.ErrorSeverity.ERROR">
      <summary>
            Error level
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.Common.ErrorSeverity.WARNING">
      <summary>
            Warning level
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Common.Team">
      <summary>
            Home or Away team
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.Common.Team.UNDEFINED">
      <summary>
            Undefined
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.Common.Team.AWAY">
      <summary>
            Away team
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.Common.Team.HOME">
      <summary>
            Home team
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.Common.Team.NONE">
      <summary>
            None (neither home or away)
            </summary>
      <remarks>
            Different from <see cref="F:Sportradar.SDK.FeedProviders.Common.Team.UNDEFINED" /></remarks>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Common.FeedErrorEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.Common.ILiveFeeds.OnFeedError" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Common.FeedErrorEventArgs.Cause">
      <summary>
            Error cause
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Common.FeedErrorEventArgs.ErrorMessage">
      <summary>
            Error message
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Common.FeedErrorEventArgs.LocalTimestamp">
      <summary>
            Error timestamp (local UTC timestamp)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Common.FeedErrorEventArgs.Severity">
      <summary>
            Error severity
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Common.ILiveFeeds">
      <summary>
            Live feeds base client interface.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Common.ILiveFeeds.BookEvents(System.Collections.Generic.IEnumerable{System.Int64})">
      <summary>
            Book the specified events. Booked events cannot be cancelled through this interface.
            </summary>
      <param name="event_ids">event ids</param>
      <remarks>
        <para>
            You should prefer using the Live Calendar on the Betradar website (http://www.betradar.com) which
            offers automatic booking for certain types of events.
            </para>
        <para>
            Note that booking events will have a cost depending on the type of agreement you have with Sportradar.
            </para>
        <para>
            LiveScout: Expect <see cref="!:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnMatchBookingReply" /> message in reply.
            </para>
      </remarks>
            /// <returns>Request id. LiveOdds : You can use this to match response if "Include response reply number in meta" is enabled</returns></member>
    <member name="M:Sportradar.SDK.FeedProviders.Common.ILiveFeeds.ClearState">
      <summary>
        <para>
            Clears complete state for this provider, that can otherwise be used in case of feed error recovery
            which can occur after every feed server reconnect or at initial SDK startup.
            </para>
      </summary>
      <remarks>Should be used with extreme caution!</remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Common.ILiveFeeds.Subscribe(System.Collections.Generic.IEnumerable{System.Int64})">
      <summary>
            Subscribe to specified events.
            </summary>
      <param name="event_ids">Array of event ids</param>
      <remarks>
        <para>
            LiveOdds: If successful and you have "Enable response on register and unregister requests" enabled 
            in the XML config, then expect <see cref="!:Sportradar.SDK.FeedProviders.LiveOdds.ILiveOdds.OnMetaInfo" /> message with 
            <see cref="!:Sportradar.SDK.FeedProviders.LiveOdds.OddsReplyType" /> = "register" in response.
            </para>
        <para>
            LiveScout: Expect <see cref="!:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OneventUpdate" /> message is response.
            If event subscription is successful, a full match update is sent out.
            Otherwise explanation will be given in the response message (e.g. you do not have access 
            to the match or there are already two open subscriptions for the event).
            </para>
        <para>
            With LiveOdds you will automatically receive interesting updates and you should <b>not</b>
            Subscribe() unless you explicitly called <see cref="M:Sportradar.SDK.FeedProviders.Common.ILiveFeeds.Unsubscribe(System.Collections.Generic.IEnumerable{System.Int64})" /> manually for that event before.
            </para>
        <para>
            With LiveScout you <b>must</b> explicitly call Subscribe() at start-up or no data will be received.
            </para>
      </remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Common.ILiveFeeds.Unsubscribe(System.Collections.Generic.IEnumerable{System.Int64})">
      <summary>
            Unsubscribe from the specified events. After this no more events associated with these event ids will be sent.
            </summary>
      <remarks>
        <para>
            LiveOdds: If successful and you have “Enable response on register and unregister requests" 
            enabled in the XML config, then you should receive <see cref="!:Sportradar.SDK.FeedProviders.LiveOdds.ILiveOdds.OnMetaInfo" /> message with 
            <see cref="!:Sportradar.SDK.FeedProviders.LiveOdds.OddsReplyType" /> = "unregister" in response.
            </para>
        <para>
            LiveScout: Expect <see cref="!:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnMatchStop" /> message is response.
            </para>
      </remarks>
      <param name="event_ids">Array of event ids</param>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Common.ILiveFeeds.AvailableTranslations">
      <summary>
            Language codes of the currently available translations.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Common.ILiveFeeds.LastAliveMessage">
      <summary>
            Get time when the last alive message from the server was received.
            </summary>
      <remarks>
            Time is in UTC according to the local computer or DateTime.MinValue if no message was
            received yet in this session.
            
            A too old value might indicate a problem.
            Notice that you should not check against this value and disconnect manually
            <see cref="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.MaxTimeSkew">MaxTimeSkew</see> setting is meant for that.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Common.ILiveFeeds.LastServerMessage">
      <summary>
            Get time when the last message from the server was received.
            This includes alive messages that are periodically sent.
            </summary>
      <remarks>
            Time is in UTC according to the local computer or DateTime.MinValue if no message was
            received yet in this session.
            
            A too old value might indicate a problem.
            Notice that you should not check against this value and disconnect manually
            <see cref="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.MaxTimeSkew">MaxTimeSkew</see> setting is meant for that.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Common.ILiveFeeds.ServerTime">
      <summary>
            Get approximate server time.
            </summary>
      <remarks>
            Time is is synchronized from LiveOdds server in every received message and periodically from LiveScout 
            (according to <see cref="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveScout.ServerTimeSyncInterval">ServerTimeSyncInterval</see>).
            Interpolation is used so this should approximately be the time on the server (not the time of the last message).
            Value can be null if last successful synchronization was more than <see cref="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.MaxServerTimestampAge">MaxServerTimestampAge</see> ago.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Common.ILiveFeeds.SubscribedEvents">
      <summary>
            All event ids we are currently subscribed to.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.Common.ILiveFeeds.OnFeedError">
      <summary>
            Signals that a feed error has occurred (e.g. we got disconnected from the feed server, XML message parsing error occurred).
            </summary>
      <remarks>It is suggested that this event handler is wired to some Monitoring Service</remarks>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Vhc.RaceCompetitorVhc">
      <summary>
            Specifies a competitor in a horse race.
            </summary>
      <remarks>
            Used with VHC.
            </remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Vhc.RaceCompetitorVhc.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Vhc.RaceCompetitorVhc.HorseId">
      <summary>
            ID of the horse.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Vhc.RaceCompetitorVhc.HorseName">
      <summary>
            Name of the horse.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Vhc.RaceCompetitorVhc.JockeyId">
      <summary>
            Id of the jockey.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Vhc.RaceCompetitorVhc.JockeyName">
      <summary>
            Name of the jockey.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Vdr.RaceCompetitorVdr">
      <summary>
            Specifies a competitor in a dog race.
            </summary>
      <remarks>
            Used with VDR.
            </remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Vdr.RaceCompetitorVdr.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Vdr.RaceCompetitorVdr.DogId">
      <summary>
            Id of the dog
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Vdr.RaceCompetitorVdr.DogName">
      <summary>
            Name of the dog
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceResult">
      <summary>
            Represents the results of a race.
            </summary>
      <remarks>
            Used with VHC.
            </remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceResult.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceResult.Results">
      <summary>
            The actual results.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceResult.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.ILiveOddsRace">
      <summary>
            Interface describing events and methods in race oriented LiveOdds feeds
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.ILiveOddsRace.GetRacedayMetaInfo(System.Collections.Generic.IEnumerable{System.Int32})">
      <summary>
            Requests racedays meta info. <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnMetaInfo" /> will be triggered when response arrives.
            </summary>
      <param name="racedays">
                List of racedays to request meta info for
            </param>
      <returns>
                Returns immediately with the request number or zero but expect to receive an event afterwards.
            </returns>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.ILiveOddsRace.OnRaceResult">
      <summary>
            Alive message is transmitted every 10 seconds and contains status, timestamp in UTC and match header info 
            for the matches that we supply LiveOdds for at the time given. It also contains current bet status information for every match (started or stopped).
            Score indicates the current score in the match. 
            </summary>
      <remarks>
            SDK will send out bet stops for all matches if no alive message has been received in the last 20 seconds.
            In this case client shouldn't accept any bets for any matches until the connection is stable again.
            SDK will also take care that if the connection to the Betradar server is lost, bet stops for all matches are sent out 
            until a stable connection is established again.
            </remarks>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceCompetitor">
      <summary>
            Represents a competitor in a race
            Base class for <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Vdr.RaceCompetitorVdr" /> and <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Vhc.RaceCompetitorVhc" /></summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceCompetitor.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceCompetitor.Position">
      <summary>
            Position in the race.
            </summary>
      <remarks>
            1 means winner and so on.
            Only available in <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.ILiveOddsRace.OnRaceResult" /></remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceCompetitor.StartBox">
      <summary>
            Box where horse/dog is starting.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceCompetitor.Time">
      <summary>
            Time of the race.
            </summary>
      <remarks>
            Only available in <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.ILiveOddsRace.OnRaceResult" /></remarks>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceDay">
      <summary>
            Entity containg data about specific race day
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceDay.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceDay.Active">
      <summary>
            Whether race day is active.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceDay.ChannelId">
      <summary>
            Id of the channel where the race is broadcasted.
            </summary>
      <example>
            1
            </example>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceDay.EndTime">
      <summary>
            End time of the race day.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceDay.Id">
      <summary>
            Unique id of the race day.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceDay.Name">
      <summary>
            Name of the race day.
            </summary>
      <example>
            "Race day 1"
            </example>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceDay.ParentId">
      <summary>
            Parent id of the race day.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceDay.RaceDayNumber">
      <summary>
            Incremental race day number.
            </summary>
      <example>
            6785
            </example>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceDay.StartTime">
      <summary>
            Start time of the race day.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceDay.Status">
      <summary>
            Status.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceDay.Surface">
      <summary>
            Type of the surface.
            </summary>
      <example>
            "Dirt"
            </example>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceDay.TrackName">
      <summary>
            Name of the track
            </summary>
      <example>
            "Anbaren Parks"
            </example>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceHeader">
      <summary>
            Contains core data about a race
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceHeader.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceHeader.Booked">
      <summary>
            The meta-message includes matches that are booked or included in the package that is purchased. 
            By adding specifying includeavailable="true" in the meta request, or activating it through 
            XML configuration ‘Include non booked matches in meta’, the meta response will also include 
            matches that are available for booking but not booked yet. 
            The match element in the meta-response will then also include this property specifying whether 
            the match is already booked (true), or not booked yet (false).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceHeader.ParentId">
      <summary>
            Parent id
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceHeaderInfo">
      <summary>
            Entity containing <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceHeaderInfo.RaceHeader" /> and <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceHeaderInfo.RaceInfo" />.
            Appears in MetaInfo in race feeds
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceHeaderInfo.#ctor(Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceHeader,Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceInfo)">
      <summary>
            Initialize a new instance.
            </summary>
      <param name="hdr">Race header</param>
      <param name="infoVdr">Race infoVdr</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceHeaderInfo.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceHeaderInfo.RaceHeader">
      <summary>
            Basic race header.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceHeaderInfo.RaceInfo">
      <summary>
            Race information.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceInfo">
      <summary>
            Contains extra info about a race
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceInfo.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceInfo.Competitors">
      <summary>
            List of all the competitors in this race
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceInfo.Distance">
      <summary>
            Human readable actual distance.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceInfo.DistanceName">
      <summary>
            Name of the distance.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceInfo.EndTime">
      <summary>
            End time of the race.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceInfo.NumParticipants">
      <summary>
            Number of participants.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceInfo.RaceNumber">
      <summary>
            Race number
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceInfo.StartTime">
      <summary>
            Start time of the race.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceInfo.TrackName">
      <summary>
            Track name
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceMetaData">
      <summary>
        <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.MetaInfoDataContainer" /> for race oriented feeds
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceMetaData.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceMetaData.RaceDays">
      <summary>
            All the race days that are contained in <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.MetaInfo" /></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceMetaData.RaceHeaderInfos">
      <summary>
            Info about all the races are contained in <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.MetaInfo" /></summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.AliveWithOutrights">
      <summary>
            Represents an alive message containing both events and outright information
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.AliveWithOutrights.#ctor(System.Xml.XmlAttribute[])">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.AliveWithOutrights" /> class
            </summary>
      <param name="any_attr">An array of <see cref="T:System.Xml.XmlAttribute" /> containing extra values</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.AliveWithOutrights.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.AliveWithOutrights" /> instance
            </summary>
      <returns>a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.AliveWithOutrights" /> instance</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.AliveWithOutrights.OutrightHeaders">
      <summary>
            Gets a list of <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightHeader" /> items identifying outrights that Betradar is supplying at a given time
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetCancel">
      <summary>
            Indicates that an odds type for an outright has been cancelled for a reason.
            All bets accepted on the odds with that id should be cancelled and cashed out with an odd of 1,0 (stakes returned).
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetCancel.#ctor(System.Xml.XmlAttribute[])">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetCancel" /> class
            </summary>
      <param name="any_attr">An array of <see cref="T:System.Xml.XmlAttribute" /> containing extra values</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetCancel.ToString">
      <summary>
            Returnes a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetCancel" /> instance
            </summary>
      <returns>a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetCancel" /> instance</returns>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetClear">
      <summary>
        <para>
            Indicates that a situation occurred during the match so that a bet can be decided.
            Time which is set to (<see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Timestamp" /> - <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Time" />) seconds 
            indicates the time at which the event happened.
            The message also includes the match element indicating the match id and the cleared score with 
            an Odds element indicating the odds type, and this again with each EventOddsField and the status of the outcomes.
            </para>
        <para>
            Some bettypes, like Asian handicap and Asian total, can also include void factor for each EventOddsField element. 
            Void factor can either be 1 or 0.5 indicating that the whole or half the bet is voided and should be refunded to the customer. 
            When the void factor is set to 0.5 the outcome attribute will indicate if the other half is won or lost. 
            </para>
        <para>
            The id attribute in the Odds element corresponds to the odds elements in the previously sent out odds change messages. 
            Evaluation of bet outcomes is responsibility of the client.
            </para>
      </summary>
      <remarks>
            Possible combinations of outcome and void factor:
            <list type="bullet"><item><description>outcome="0" and no voidfactor: Lose entire bet</description></item><item><description>outcome="1" and no voidfactor: Win entire bet</description></item><item><description>outcome="0" and voidfactor="1": Refund entire bet</description></item><item><description>outcome="1" and voidfactor="0.5": Refund half bet and win other half </description></item><item><description>outcome="0" and voidfactor="0.5": Refund half bet and lose other half</description></item></list></remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetClear.#ctor(System.Xml.XmlAttribute[])">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetClear" /> class
            </summary>
      <param name="any_attr">An array of <see cref="T:System.Xml.XmlAttribute" /> containing extra values</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetClear.ToString">
      <summary>
            Returnes a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetClear" /> instance
            </summary>
      <returns>a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetClear" /> instance</returns>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStart">
      <summary>
            Indicates that the bets for a particular outright can open again.
            The message contains s <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Timestamp" /> and also a <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Time" /> attribute 
            which tells when the situation occurred in seconds before the <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Timestamp" />.
            If time is 0, bet start is from timestamp, if time &gt; 0, bet start is from 
            (<see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Timestamp" /> - <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Time" />). 
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStart.#ctor(System.Xml.XmlAttribute[])">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStart" /> class
            </summary>
      <param name="any_attr">An array of <see cref="T:System.Xml.XmlAttribute" /> containing extra values</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStart.ToString">
      <summary>
            Returnes a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStart" /> instance
            </summary>
      <returns>a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStart" /> instance</returns>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStop">
      <summary>
            Indicates that a betstop situation occurred during a match (e.g. goal, red card or other important event occurred).
            When the bets can open again, a "betstart" message will be sent.
            Bet stop message contains <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Timestamp" /> and also a <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Time" /> attribute which tells 
            when the situation occurred in seconds before the <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Timestamp" />.
            If time is 0 betstop is from timestamp, if time &gt; 0, betstop is from 
            (<see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Timestamp" /> - <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Time" />). 
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStop.#ctor(System.Xml.XmlAttribute[])">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStop" /> class
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStop.ToString">
      <summary>
            Returnes a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStop" /> instance
            </summary>
      <returns>a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStop" /> instance</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStop.IsArtifical">
      <summary>
            Gets a value indicating whether current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStop" /> was issued by the SDK itself or as a result
            of message received thrgough the feed
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightOddsChange">
      <summary>
            When an odds change occurs, all the odds types for that match are sent in a message. 
            Only active odds types contain odds fields, while inactive odds types do not.
            Each odds type also has an attribute named changed which indicates whether this odds type has been changed or not. 
            An attribute score indicates the current score in the match.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightOddsChange.#ctor(System.Xml.XmlAttribute[])">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightOddsChange" /> class
            </summary>
      <param name="any_attr">An array of <see cref="T:System.Xml.XmlAttribute" /> containing extra values</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightOddsChange.ToString">
      <summary>
            Returnes a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightOddsChange" /> instance
            </summary>
      <returns>a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightOddsChange" /> instance</returns>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.SingleOutrightEvent">
      <summary>
            Base class for events associated with (only) one outright
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.SingleOutrightEvent.#ctor(System.Xml.XmlAttribute[])">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.SingleOutrightEvent" /> class
            </summary>
      <param name="any_attr">An array of <see cref="T:System.Xml.XmlAttribute" /> containing extra values</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.SingleOutrightEvent.ToString">
      <summary>
            Returnes a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.SingleOutrightEvent" /> instance
            </summary>
      <returns>a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.SingleOutrightEvent" /> instance</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.SingleOutrightEvent.OutrightHeader">
      <summary>
            Gets or sets a <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.SingleOutrightEvent.OutrightHeader" /> instance containing basic information about an outright associated with current event
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.SingleOutrightEvent.Priority">
      <summary>
            Gets a <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.SingleOutrightEvent.Priority" /> enum member specifying the priority of the current event
            </summary>
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.SingleOutrightWithOddsEvent">
      <summary>
            Represents an event associated with a single outright which carries odds information
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.SingleOutrightWithOddsEvent.#ctor(System.Xml.XmlAttribute[])">
      <summary>
            Initializes a new instances of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.SingleOutrightWithOddsEvent" /> class
            </summary>
      <param name="any_attr">An array of <see cref="T:System.Xml.XmlAttribute" /> containing extra values</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.SingleOutrightWithOddsEvent.ToString">
      <summary>
            Returnes a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.SingleOutrightWithOddsEvent" /> instance
            </summary>
      <returns>a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.SingleOutrightWithOddsEvent" /> instance</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.SingleOutrightWithOddsEvent.Odds">
      <summary>
            Gets a list of <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOdds" /> instances representing the odds for the outright associated with the
            current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.SingleOutrightWithOddsEvent" /> instance
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.AliveWithOutrightsEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.ILiveOddsWithOutrights.OnAliveWithOutrights" />.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.AliveWithOutrightsEventArgs.#ctor(Sportradar.SDK.FeedProviders.LiveOdds.Outrights.AliveWithOutrights)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.AliveWithOutrightsEventArgs" /> class
            </summary>
      <param name="alive">A <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.AliveWithOutrightsEventArgs.AliveWithOutrights" /> instance containing information about current events and outrights</param>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.AliveWithOutrightsEventArgs.AliveWithOutrights">
      <summary>
            Gets a <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.AliveWithOutrightsEventArgs.AliveWithOutrights" /> instance containing information about current events and outrights
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetCancelEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.ILiveOddsWithOutrights.OnOutrightBetCancel" />.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetCancelEventArgs.#ctor(Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetCancel)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetCancelEventArgs" /> instance
            </summary>
      <param name="outrightBetCancel">A <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetCancelEventArgs.OutrightBetCancel" /> instance containing information about cancelled markets and the associated outright</param>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetCancelEventArgs.OutrightBetCancel">
      <summary>
            Gets a <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetCancelEventArgs.OutrightBetCancel" /> instance containing information about cancelled markets and the associated outright
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetClearEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.ILiveOddsWithOutrights.OnOutrightBetClear" />.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetClearEventArgs.#ctor(Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetClear)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetClearEventArgs" /> class
            </summary>
      <param name="outrightBetClear">A <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetClearEventArgs.OutrightBetClear" /> instance containing information about cleared markets and associated outright</param>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetClearEventArgs.OutrightBetClear">
      <summary>
            Gets a <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetClearEventArgs.OutrightBetClear" /> instance containing information about cleared markets and associated outright
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStartEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.ILiveOddsWithOutrights.OnOutrightBetStart" />.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStartEventArgs.#ctor(Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStart)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStartEventArgs" /> class
            </summary>
      <param name="outrightBetStart">A <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStartEventArgs.OutrightBetStart" /> instance containing information about outright on which the betting can be started</param>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStartEventArgs.OutrightBetStart">
      <summary>
            Gets a <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStartEventArgs.OutrightBetStart" /> instance containing information about outright on which the betting can be started
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStopEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.ILiveOddsWithOutrights.OnOutrightBetStop" />.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStopEventArgs.#ctor(Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStop)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStopEventArgs" /> class
            </summary>
      <param name="outrightBetStop">A <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStopEventArgs.OutrightBetStop" /> instance containing information about the outright on which the betting must be stopped</param>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStopEventArgs.OutrightBetStop">
      <summary>
            Gets a <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStopEventArgs.OutrightBetStop" /> instance containing information about the outright on which the betting must be stopped
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightOddsChangeEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.ILiveOddsWithOutrights.OnOutrightOddsChange" />.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightOddsChangeEventArgs.#ctor(Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightOddsChange)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightOddsChangeEventArgs" /> class
            </summary>
      <param name="outrightOddsChange">A <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightOddsChangeEventArgs.OutrightOddsChange" /> instance containing new odds for the associated markets</param>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightOddsChangeEventArgs.OutrightOddsChange">
      <summary>
            Gets a <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightOddsChangeEventArgs.OutrightOddsChange" /> instance containing new odds for the associated markets
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.ILiveOddsWithOutrights">
      <summary>
            Interface describing events and methods common for all LiveOdds feeds containing outrights
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.ILiveOddsWithOutrights.GetOutrightList(System.Collections.Generic.IEnumerable{System.Int64})">
      <summary>
            Request meta-information about outrights specified by it's ids
            </summary>
      <param name="outright_ids">Specifies the outrights for which to retrieve meta info</param>
      <returns>Returns immediately with the request number or zero, but expect to receive <see cref="!:ILiveOdds.OnMetaInfo" /> event in response</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.ILiveOddsWithOutrights.GetOutrightStatus(System.Int64,System.Nullable{System.DateTime},System.Boolean)">
      <summary>
            Requests the outright status for a given time ("current" server request). 
            This includes odds, activation of odds and status for the ouright requested,
            current bet status and all bet clearing messages before the timestamp.
            </summary>
      <param name="outright_id">Outright id</param>
      <param name="from">Outright status on particular time (leave null for current outright status)</param>
      <param name="package">
            All replies get packaged in one see <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.ILiveOddsWithOutrights.OnOutrightStatus" /> when true;
            else normal events will get invoked.
            </param>
      <returns>
            Returns immediately with the request number or zero but expect to receive an event afterwards.
            </returns>
      <remarks>
            SDK already handles error recovery for on-going outrights, no matter whether there is a crash or 
            connection to the server is lost, so during normal operation there should be no need to call
            this method! 
            
            The purpose of it is for book-keeping after an outright has ended.
            For instance after an outright is not active anymore you might want to settle all open bets or
            check whether a outright is really about to start.
            
            Notice that the outright messages do not include a message number (msgnr). The received "state" is an
            abstract concept derived from the sent messages not any sent message so it cannot have a sequence number.
            </remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.ILiveOddsWithOutrights.GetOutrightsStatus(System.Collections.Generic.IEnumerable{System.Int64},System.Nullable{System.DateTime},System.Boolean)">
      <summary>
            Requests the outright statuses for a given time ("current" server request). 
            This includes odds, activation of odds and status for the outright requested,
            current bet status and all bet clearing messages before the timestamp.
            </summary>
      <param name="outright_ids">Outright ids, maximum is 50 per request to avoid having server queue filling up</param>
      <param name="from">Outrights statuses on particular time (leave null for current outright status)</param>
      <param name="package">
            All replies get packaged in one see <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.ILiveOddsWithOutrights.OnOutrightStatus" /> when true;
            else normal events will get invoked.
            </param>
      <returns>
            Returns immediately with the request number or zero but expect to receive an event afterwards.
            </returns>
      <remarks>
            SDK already handles error recovery for on-going outrights, no matter whether there is a crash or 
            connection to the server is lost, so during normal operation there should be no need to call
            this method! 
            
            The purpose of it is for book-keeping after an outright has ended.
            For instance after an outright is not active anymore you might want to settle all open bets or
            check whether a match is really about to start.
            
            Notice that the match messages do not include a message number (msgnr). The received "state" is an
            abstract concept derived from the sent messages not any sent message so it cannot have a sequence number.
            </remarks>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.ILiveOddsWithOutrights.OnAliveWithOutrights">
      <summary>
            Alive message is transmitted every 10 seconds and contains status, timestamp in UTC and match header info 
            for the matches that we supply LiveOdds for at the time given. It also contains current bet status information for every match (started or stopped).
            Score indicates the current score in the match. 
            </summary>
      <remarks>
            SDK will send out bet stops for all matches if no alive message has been received in the last 20 seconds.
            In this case client shouldn't accept any bets for any matches until the connection is stable again.
            SDK will also take care that if the connection to the Betradar server is lost, bet stops for all matches are sent out 
            until a stable connection is established again.
            </remarks>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.ILiveOddsWithOutrights.OnOutrightBetCancel">
      <summary>
            Signals that odds type for an outright should be cancelled due to some reason.
            All bets accepted on the odds with that Id should be cancelled and cashed out with an odd of 1,0 (stakes returned).
            If the starttime and endtime are also specified, then only bets accepted in this interval should be cancelled.
            The starttime and endtime are timestamps in UTC.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.ILiveOddsWithOutrights.OnOutrightBetClear">
      <summary>
        <para>
            Signals that bets placed on this outright can be settled
            Timestamp - time indicates the time at which the bet clear event happened.
            The event also contains the cleared score with an Odds element indicating the odds type, 
            and this again with each EventOddsField, and the status of the outcomes (true/false). 
            </para>
        <para>
            Id in the Odds element corresponds to the Odds elements in one of the previous OnOddsChange events.
            Evaluation of the bet outcomes is the responsibility of the client system.
            </para>
      </summary>
      <remarks>
        <para>
            Some bettypes, like asian handicap and asian total, can include void factor for each EventOddsField element. 
            Void factor can either be 1 or 0.5 indicating that the whole or half the bet is voided and should be refunded to the customer. 
            When the void factor is set to 0.5 the outcome attribute will indicate if the other half has won or lost. 
            </para>
        <para>
            These are all possible combinations of outcome and void factors:
            <list type="number"><item><description>outcome="0" and no voidfactor: Lose entire bet</description></item><item><description>outcome="1" and no voidfactor: Win entire bet</description></item><item><description>outcome="0" and voidfactor="1": Refund entire bet</description></item><item><description>outcome="1" and voidfactor="0.5": Refund half bet and win other half</description></item><item><description>outcome="0" and voidfactor="0.5": Refund half bet and lose other half</description></item></list></para>
      </remarks>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.ILiveOddsWithOutrights.OnOutrightBetStart">
      <summary>
            Signals that bets for a specific outright can open again after they have been stopped.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.ILiveOddsWithOutrights.OnOutrightBetStop">
      <summary>
            Signals that a bet stop situation occurred for a specific outright.
            OnBetStart event is triggered when the bets can open again.
            </summary>
      <remarks>
            Bet stop is triggered after following events take place: 
            <list type="number"><item><description>Goals</description></item><item><description>Red cards</description></item><item><description>Penalty</description></item><item><description>One on one situations</description></item><item><description>Free kicks within 20 meters</description></item><item><description>Match is interrupted temporarily</description></item></list>
            
            Administrative events which cause a bet stop condition:
            <list type="number"><item><description>Loss of TV coverage</description></item><item><description>Loss of connection to the scout</description></item></list></remarks>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.ILiveOddsWithOutrights.OnOutrightOddsChange">
      <summary>
            Signals that an odds change has occurred, specifying all odds types for a particular match. 
            Odds types that are active will contain odds fields, while inactive odds types will not.
            Each odds type also has a Changed flag indicating whether this odds type has been changed or not. 
            Score indicates the current score in the match.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.ILiveOddsWithOutrights.OnOutrightStatus">
      <summary>
            Occurs when outright status messages are received
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.MatchAndOutrightMetaData">
      <summary>
            Contains meta information for associated matches and outrights
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.MatchAndOutrightMetaData.#ctor(System.Collections.Generic.List{Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeaderInfo},System.Collections.Generic.List{Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightHeaderInfo})">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.MatchAndOutrightMetaData" /> class
            </summary>
      <param name="matchHeaderInfos">A list of <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeaderInfo" /> containing information about current matches</param>
      <param name="outrightHeaderInfos">A list of <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightHeaderInfo" /> containing information about current aoutrights</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.MatchAndOutrightMetaData.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.MatchAndOutrightMetaData" /> instance
            </summary>
      <returns>a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.MatchAndOutrightMetaData" /> instance</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.MatchAndOutrightMetaData.OutrightHeaderInfos">
      <summary>
            Gets a list of <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightHeaderInfo" /> instances containing meta information about associated outrights
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightHeader">
      <summary>
            Contains basic information about an outright
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightHeader.ToString">
      <summary>
            Returnes a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightHeader" /> instance
            </summary>
      <returns>a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightHeader" /> instance</returns>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightHeaderInfo">
      <summary>
            Combines a <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightHeaderInfo.OutrightHeader" /> and <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightHeaderInfo.OutrightInfo" /> instances
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightHeaderInfo.#ctor(Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightHeader,Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightHeaderInfo" /> class
            </summary>
      <param name="outrightHeader">A <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightHeaderInfo.OutrightHeader" /> instance containing basic information about the outright</param>
      <param name="outrightInfo">A <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightHeaderInfo.OutrightInfo" /> instance containing extended information about the outright</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightHeaderInfo.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightHeaderInfo" /> instance
            </summary>
      <returns>a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightHeaderInfo" /> instance</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightHeaderInfo.OutrightHeader">
      <summary>
            Gets a <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightHeaderInfo.OutrightHeader" /> instance containing basic information about the outright
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightHeaderInfo.OutrightInfo">
      <summary>
            Gets a <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightHeaderInfo.OutrightInfo" /> instance containing extended information about the outright
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightInfo">
      <summary>
            Outright information containing the date and time, sport, category and tournament of the outright
            and what TV-channels this match is broadcasted on.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightInfo.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightInfo" /> instance
            </summary>
      <returns>a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightInfo" /> instance</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightInfo.Sport">
      <summary>
            Gets a <see cref="T:Sportradar.SDK.FeedProviders.Common.IdNameTuple" /> specifying the sport associated with the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightInfo" /> instance
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightInfo.Category">
      <summary>
            Gets a <see cref="T:Sportradar.SDK.FeedProviders.Common.IdNameTuple" /> specifying the category associated with the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightInfo" /> instance
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightInfo.Tournament">
      <summary>
            Gets a <see cref="T:Sportradar.SDK.FeedProviders.Common.IdNameTuple" /> specifying the tournament associated with the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightInfo" /> instance
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightInfo.UniqueTournament">
      <summary>
            Gets a <see cref="T:Sportradar.SDK.FeedProviders.Common.IdNameTuple" /> specifying the unique tournament associated with the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightInfo" /> instance
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightInfo.Season">
      <summary>
            Gets a <see cref="T:Sportradar.SDK.FeedProviders.Common.IdNameTuple" /> specifying the season associated with the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightInfo" /> instance
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightInfo.Name">
      <summary>
            Gets the name of the outright represented by the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightInfo" /> instance
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightInfo.EndDate">
      <summary>
            Gets a <see cref="T:System.DateTime" /> specifying the end-date of the outright represented by the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightInfo" /> instance
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.CoveredFromType">
      <summary>
            Indicates whether the match is being covered from a television feed or the scout is at the match venue
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.CoveredFromType.TV">
      <summary>
            Covered from a television
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.CoveredFromType.VENUE">
      <summary>
            Covered from the match venue
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.CoveredFromType.NA">
      <summary>
            Covered from not specified
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.BetPal">
      <summary>
            BetPal info object
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.BetPal.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.BetPal.Type">
      <summary>
            Type
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ScoreCardSummary">
      <summary>
            Used for live reporting of results/cards and final results (e.g. fulltime, halftime, overtime).
            </summary>
      <remarks>
            Evaluation of the bet outcomes is the responsibility of the Client system.
            </remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ScoreCardSummary.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ScoreCardSummary.CardsByTime">
      <summary>
            List of card summaries sorted by time
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ScoreCardSummary.ScoresByTime">
      <summary>
            List of score summaries sorted by time
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ScoreCardSummary.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.Card">
      <summary>
            Card type (yellow or red)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.Card.UNDEFINED">
      <summary>
            Undefined
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.Card.YELLOW">
      <summary>
            Yellow card
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.Card.YELLOWRED">
      <summary>
            2nd yellow card resulting in a red card
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.Card.RED">
      <summary>
            Red card
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.OddsScoreType">
      <summary>
            Score type (full time, half time, live, etc.)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.OddsScoreType.UNDEFINED">
      <summary>
            Undefined
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.OddsScoreType.FT">
      <summary>
            Score at full time
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.OddsScoreType.HT">
      <summary>
            Score at half time
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.OddsScoreType.OT">
      <summary>
            Score after over time
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.OddsScoreType.PEN">
      <summary>
            Score after penalties
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.OddsScoreType.LIVE">
      <summary>
            Score during a match
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.OddsScoreType.SCORE">
      <summary>
            Score after a goal was scored.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ILiveOdds">
      <summary>
            Live odds client interface.
            </summary>
      <remarks>
            Usually there is <b>no</b> need to call any methods, just
            handle the events.
            </remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ILiveOdds.GetAllBetTypes">
      <summary>
            Returns all available bet types.
            </summary>
      <returns>Available bet types.</returns>
      <remarks>
            The method returns a cached response that is periodically fetched from the server.
            <see cref="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOddsBetTypes.RefreshInterval" /> controlls the interval.
            </remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ILiveOdds.GetBetType(Sportradar.SDK.Common.BetTypeKey)">
      <summary>
            Returns detailed bet type information for the specified type.
            </summary>
      <param name="key">Bet type key</param>
      <returns>Detailed bet type information for the specified type.</returns>
      <remarks>
            The method returns a cached response that is periodically fetched from the server.
            <see cref="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOddsBetTypes.RefreshInterval" /> controlls the interval.
            </remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ILiveOdds.GetScoreAndCardSummary(System.Int64)">
      <summary>
            Requests a list of all cards and scores for a match.
            </summary>
      <param name="match_id">Match id</param>
      <returns>Returns immediately with the request number or zero, but expect to receive OnScoreCardSummary event in response</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ILiveOdds.RegisterBetTypes(System.Collections.Generic.IEnumerable{Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.RegisterUnregisterBetType})">
      <summary>
            Register specific bet types within the given match.
            This gives the opportunity to activate specific odd types for a match.
            </summary>
      <remarks>
            There is <b>no</b> need to call this method (all bet types are registered automatically).
            <b>Beware</b> when there are more instances of the same bet type (i.e. "Next goal"), this will activate all
            (except the ones that are already decided - safety precaution).
            </remarks>
      <param name="betTypes">List of matches and bet types to register</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ILiveOdds.UnregisterBetTypes(System.Collections.Generic.IEnumerable{Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.RegisterUnregisterBetType})">
      <summary>
            Unregister from specific bet types within the given match.
            This gives the opportunity to deactivate specific odd types for a match.
            </summary>
      <remarks>
            There is <b>no</b> need to call this method.
            <b>Beware</b> when there are more instances of the same bet type active (i.e. "Next goal"), this will deactivate all!
            </remarks>
      <param name="betTypes">List of matches and bet types to unregister from</param>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ILiveOdds.TestManager">
      <summary>
            Manages replay on test server.
            Only available if Test=true and the feed support replay.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ILiveOdds.OnScoreCardSummary">
      <summary>
        <para>
            This event can be used for two types of information - live reporting of results/cards and final results (fulltime/halftime).
            Event is triggered as soon as a score/card is detected during a match and includes the timestamp of the actual event.
            The Id uniquely identifies each score and card.
            In addition, the scoring team and the player causing the event are both specified. 
            </para>
        <para>
            The same card and the same score can be sent several times; this is used to update information, for example player or time.
            When no time is known it is set to “-1", and the player attribute is empty.
            Cancelled indicates whether the score or card is cancelled or not. If cancelled then a new message with the correct score will be sent for score cancelling.
            </para>
        <para>
            There is also live score information available during a match.
            After the match is ended, results with time=T, and type: halftime(ht), fulltime(ft), after overtime(ao), after penalties(pen) or score(when the goal happened) are indicated. 
            T is the match time in minutes when the goal occurred. Here all cards registered during the match are sent. 
            For the score types ht, ft, ot and pen there is no Id attribute.
            Score indicates the current score in the match. Evaluation of the bet outcomes is the responsibility of the Client system.
            </para>
      </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ILiveOddsTestManager">
      <summary>
            Enables replay of matches on LiveOdds test server.
            Wait for <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnConnectionStable" /> before using it
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ILiveOddsTestManager.ChangeXmlConfig(System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Sends XML config change request. Note: Reply is not according to XSD schema, so parsing will fail but changes will come into effect
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ILiveOddsTestManager.ResetXmlConfig">
      <summary>
            Sends <XmlConfig reset="true" />
            Forces xml config update.  Note: Reply is not according to XSD schema, so parsing will fail but changes will come into effect
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ILiveOddsTestManager.StartAuto">
      <summary>
            Automatically start replay of all matches with a delay of 48 hours, essentially replicating the conditions on the live-system
            48 hours ago. This gives you all matches that were offered in Live Odds at this time, regardless if you had them booked in live-system.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ILiveOddsTestManager.StartMatchReplay(System.Int64,System.Nullable{System.Int64},System.Nullable{System.TimeSpan},System.Nullable{System.Int32},System.Nullable{System.Boolean})">
      <summary>
            Starts to replay a single recent match (must have ended at least 1 hour ago)
            </summary>
      <param name="match_id">Match id to replay</param>
      <param name="msgn_nr">If specified, it will start the replay at specified message number</param>
      <param name="fast_forward">If specified, skips the match to the specified time</param>
      <param name="speed">The amount of milliseconds between messages. This can be used to speed up the replay of a match.</param>
      <param name="persistent">If multiple clients are logged in with the same client id they will all receive the XML messages for the started match. If one of the clients disconnects,
             the messages will still be sent to the other clients. After reconnecting, the disconnected client will receive all messages from that point on again.</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ILiveOddsTestManager.StartScenario(System.Int32,System.Nullable{System.TimeSpan},System.Nullable{System.Int32},System.Nullable{System.Boolean})">
      <summary>
            Start replay of a pre-recorded match. These matches are not subject to time restrictions, and can be replayed at any time.
            The start of the test will usually be set to a few seconds before the first message. A test replay may contain more than one
            match, e.g. recording for an entire day. In this case it’s possible that at the default start time, one or more of the matches
            is already underway.
            </summary>
      <param name="scenario_number">Which scenario to start</param>
      <param name="fast_forward">If specified, skips the test to the specified time</param>
      <param name="speed">The amount of milliseconds between messages. This can be used to speed up the replay of a match.</param>
      <param name="persistent">If multiple clients are logged in with the same client id they will all receive the XML messages for the started match. If one of the clients disconnects,
             the messages will still be sent to the other clients. After reconnecting, the disconnected client will receive all messages from that point on again.</param>
      <remarks>
        <list type="bullet">
          <item>
            <description>1 - Soccer - Deep Coverage</description>
          </item>
          <item>
            <description>2 - Soccer - Basic Coverage</description>
          </item>
          <item>
            <description>3 - Tennis</description>
          </item>
          <item>
            <description>4 - Ice Hockey</description>
          </item>
          <item>
            <description>5 - Basketball</description>
          </item>
          <item>
            <description>6 - Baseball</description>
          </item>
          <item>
            <description>7 - American Football</description>
          </item>
          <item>
            <description>8 - Handball</description>
          </item>
          <item>
            <description>9 - Futsal</description>
          </item>
          <item>
            <description>10 - Volleyball</description>
          </item>
          <item>
            <description>11 - Beach Volleyball</description>
          </item>
          <item>
            <description>12 - Badminton</description>
          </item>
          <item>
            <description>13 - Rugby Union</description>
          </item>
          <item>
            <description>14 - Darts</description>
          </item>
          <item>
            <description>15 - Snooker</description>
          </item>
          <item>
            <description>17 - Ice Hockey with penalties</description>
          </item>
          <item>
            <description>18 - Ice Hockey with overtime</description>
          </item>
          <item>
            <description>19 - Soccer - ExtraTime</description>
          </item>
          <item>
            <description>20 - American Football - Short match</description>
          </item>
          <item>
            <description>21 - Table Tennis</description>
          </item>
          <item>
            <description>22 – Basketball with overtime</description>
          </item>
          <item>
            <description>23 – Bowls</description>
          </item>
          <item>
            <description>24 – Cricket</description>
          </item>
          <item>
            <description>25 – Darts - Match in sets</description>
          </item>
          <item>
            <description>26 – Darts - Match in legs with draw</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ILiveOddsTestManager.StopAll(System.Nullable{System.Boolean})">
      <summary>
            Stops all currently running Single match replays and Test match replays
            </summary>
      <param name="persistent">if true also ends persistent matches</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ILiveOddsTestManager.StopAuto">
      <summary>
            Stops replay of delayed matches
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.BaseScoreCardEntry">
      <summary>
            Score/Card summary by time. Used for live reporting of results/cards and final results (fulltime/halftime).
            The same card and the same score can be sent several times; this is used to update information, for example player or time.
            Serves as a base class for <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.CardEntry" /> and <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ScoreEntry" />.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.BaseScoreCardEntry.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.BaseScoreCardEntry.AffectedPlayer">
      <summary>
            Player that scored or received a card.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.BaseScoreCardEntry.AffectedTeam">
      <summary>
            Team that scored or received a card.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.BaseScoreCardEntry.Cancelled">
      <summary>
            True if a particular score or card has been cancelled.
            After this a new message with the correct score will be sent for score cancelling.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.BaseScoreCardEntry.Id">
      <summary>
            Id that uniquely identifies each score and card.
            For score types "ht", "ft", "ot" and "pen" Id will not be set.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.BaseScoreCardEntry.PlayerId">
      <summary>
            Id of player that scored or received a card.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.BaseScoreCardEntry.Time">
      <summary>
            Match time in minutes when the goal/card occurred.
            When no time is known it is set to “-1", and the <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.BaseScoreCardEntry.AffectedPlayer" /> property is empty.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.CardEntry">
      <summary>
            Card summary by time that is updated live.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.CardEntry.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.CardEntry.Type">
      <summary>
            Card type (yellow or red)
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ExtraMatchInfo">
      <summary>
            Additional information about period lengths, number of sets played, etc., that is included with <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchInfo" />.
            Other information might be added later on, so a client should be able to handle it.
            </summary>
      <remarks>
            Currently following types are available.
            <para>
            For Soccer, Hockey, Handball, Basketball, Futsal and American Football:
            <list type="bullet"><item>PeriodLength</item><item>OvertimeLength</item></list></para><para>
            For Tennis, Volleyball, Beach Volleyball, Badminton and Table Tennis:
            <list type="bullet"><item>NumberOfSets</item></list></para><para>
            Volleyball:
            <list type="bullet"><item>Format</item></list></para><para>
            Darts:
            <list type="bullet"><item>DrawPossible</item><item>BestOfXSets</item><item>BestOfXLegs</item><item>LegsInLastSet</item></list></para></remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ExtraMatchInfo.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ExtraMatchInfo.Type">
      <summary>
            Type of additional match information (e.g. NumberOfSets, PeriodLength, OvertimeLength)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ExtraMatchInfo.Value">
      <summary>
            Info value
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.LiveOddsMetaData">
      <summary>
        <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.MetaInfoDataContainer" /> for match oriented feeds
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.LiveOddsMetaData.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.LiveOddsMetaData.MatchHeaderInfos">
      <summary>
            Match meta information.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader">
      <summary>
            Basic match information.
            </summary>
      <example>
            active="1" betstatus="started" gamescore="0:0" matchid="935457" score="1:0" server="1" setscore1="6:3" setscore2="1:3" status="2set" tiebreak="false"
            </example>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.Booked">
      <summary>
            The meta-message includes matches that are booked or included in the package that is purchased. 
            By adding specifying includeavailable="true" in the meta request, or activating it through 
            XML configuration ‘Include non booked matches in meta’, the meta response will also include 
            matches that are available for booking but not booked yet. 
            The match element in the meta-response will then also include this property specifying whether 
            the match is already booked (true), or not booked yet (false).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.AutoTraded">
      <summary>
            Indicates if is match auto traded
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.Balls">
      <summary>
            Used by baseball and similar sports. Part of pitch count statistic.
            Denotes the number of fouls (bad throws) from the pitcher for current half-inning.
            </summary>
      <remarks>
            Can be 0, 1, 2 or 3.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.Bases">
      <summary>
            Used by baseball and similar sports.
            Comma separated list which tells if a base is occupied or not.
            </summary>
      <remarks>
            Each component can either be 0 or 1 so examples are for instance
            "0,1,0" or "1,1,0" .
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.Batter">
      <summary>
            Used by baseball and similar sports.
            Denotes which batter is currently active.
            </summary>
      <remarks>
            The number can be from 1 - 9 for each side.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.BetStopReason">
      <summary>
            The reason why a betstop occured.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.ClearedScore">
      <summary>
            Cleared score in bet clear and bet clear rollback situations.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.ClockStopped">
      <summary>
            Indicates that a clock has been stopped in the middle of the match for Basketball, Ice Hockey and Handball matches.
            This status will only be present if the corresponding XML configuration is activated.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.Corners">
      <summary>
            Number of corners for the Home/Away team.
            </summary>
      <remarks>
            Only if corner and card counters are activated in the XML configuration.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.CurrentCtTeam">
      <summary>
            Current ct team
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.CurrentEnd">
      <summary>
            Current end in set
            </summary>
      <remarks>
            Used in Bowls
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.Delivery">
      <summary>
            Player of which team will deliver the next bowl
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.Dismissals">
      <summary>
            Number of dismissals per team
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.EarlyBetStatus">
      <summary>
            Early bet status (if configured in XML LiveOdds config).
            This status is set to “started" once the score is changed and remains so until the match continues (re-kick off),
            which causes that “earlybetstatus" is set to “stopped".
            The bookmaker can now decide whether to receive new prices right after the score change or after the match continues (re-kick off).
            If one or both of the flags betstatus or earlybetstatus is set to started it can be treated as betstart, otherwise it is betstop.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.Expedite">
      <summary>
            Expedite
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.GameScore">
      <summary>
            Provides the point score in the current Tennis game. The score is in the format 15:40.
            If one player has advantage the game score will be 50:40 or 40:50.
            This attribute is also used for the tiebreak score when the game is in a tiebreak.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.Innings">
      <summary>
            Number of innings
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.LegScore">
      <summary>
            Used in darts
            Leg (game) score
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.MatchTime">
      <summary>
            Indicates the playing minute of the match.
            Only included for soccer, ice hockey and basketball matches when the match has status
            1p, 2p, 1p_ot or 2p_ot in soccer and 1p, 2p, 3p and ot in ice hockey and 1q, 2q, 3q, 4q and ot for basket.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.MatchTimeExtended">
      <summary>
            Extended match time  (if configured in XML LiveOdds config).
            This will also show the injury time.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.Outs">
      <summary>
             Used by baseball and similar sports.
             Denotes the number of outs in current half-inning.
             </summary>
      <remarks>
             In baseball, an out occurs when the defensive,
             or fielding, team effects any of a number of different events,
             and the umpire rules a batter or baserunner out. When a player is called out,
             he is said to be retired. When three outs are recorded in an inning during a team's
             turn at offense, that team's half of the inning finishes, and it is said that "the side is retired."
            
             Can be 0, 1 or 2.
             </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.Over">
      <summary>
            Number of overs
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.PentaltyRuns">
      <summary>
            Number of penalty runs per team
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.Position">
      <summary>
            Ball position will be sent as x yards to go till opponent’s end zone for the team in possession.
            Number in range [1,100]; e.g. own x will be sent as “100 – x" while opposite x will be sent as “x"
            </summary>
      <remarks>-1 = undefined; will not be updated during overtime (set to -1)</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.Possession">
      <summary>
            Which team has the ball.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.RedCards">
      <summary>
            Number of red cards for the Home/Away team.
            </summary>
      <remarks>
            Only if corner and card counters are activated in the XML configuration.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.RemainingBowls">
      <summary>
            The remaining bowls of the teams
            </summary>
      <remarks>
            Used in Bowls
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.RemainingReds">
      <summary>
            Remaining red balls (used in snooker).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.RemainingTime">
      <summary>
            Remaining time for basketball matches only (if this has been activated for your account).
            This will contain the remaining minutes and seconds in the format mm:ss (e.g. "38:10").
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.RemainingTimeInPeriod">
      <summary>
            Specifies the remaining time in this period (when this applies).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.Score">
      <summary>
            Indicates the current score in the match. Before the match has started the value of the score attribute will be “-:-",
            afterwards it will be in the format “0:0".
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.Server">
      <summary>
            Indicates which player has the serve at the moment during a Tennis match.
            Possible values are “1" for player one and “2" for player two.
            This is optional as some Tennis matches might not have this.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.SetScores">
      <summary>
            For Tennis it contains the scores for all sets that have ended and the current running set.
            For Ice Hockey and Basketball it includes the period score for all finished periods.
            If "Show current period score during period" XML config setting is enabled, the score of the
            current period will be included also during the current period, not only after the period is over.
            </summary>
      <remarks>
            Currently scores for max. 10 sets are included (index [0-9])
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.SourceId">
      <summary>
            Client's own match id. It will be empty if we are missing your id for a particular match.
            </summary>
      <remarks>
            To do this you need to contact our support team, so they can set it up.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.StatusId">
      <summary>
            Gets the status identifier.
            </summary>
      <value>The status identifier.</value>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.Strikes">
      <summary>
             Used by baseball and similar sports. Part of pitch count statistic.
             Denotes the number of fouls from the striker for current half-inning.
             </summary>
      <remarks>
             A strike in baseball results when a batter swings at and misses a pitch,
             doesn't swing at a pitch in the strike zone or hits a foul ball that is not caught.
            
             Can be 0, 1 or 2.
             </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.Suspend">
      <summary>
            Number of suspensions.
            </summary>
      <remarks>
            "Include power play counters in feed" feature must be enabled to
            get this value for supported sports (currently handball, futsal and icehockey).
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.Throw">
      <summary>
            Number of throws. (Snooker?)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.TieBreak">
      <summary>
            Indicates if a Tennis match is in a tiebreak.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.Try">
      <summary>
            Try number. A number in range [1,4], it's the current “down" until reaching the 10 yards if defined
            </summary>
      <remarks>-1 = undefined; will not be updated during overtime (set to -1)</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.Visit">
      <summary>
            Number of turns (used in snooker).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.Yards">
      <summary>
            Yards till first down. How many yards down in this drive (the drive is a series of offensive plays)
            </summary>
      <remarks>-1 = undefined; will not be updated during overtime (set to -1)</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.YellowCards">
      <summary>
            Number of yellow cards for the Home/Away team.
            </summary>
      <remarks>
            Only if corner and card counters are activated in the XML configuration.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.YellowRedCards">
      <summary>
            Number of yellow cards that resulted in red card for the Home/Away team.
            </summary>
      <remarks>
            Only if corner and card counters are activated in the XML configuration.
            </remarks>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeaderInfo">
      <summary>
            Combined <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeaderInfo.MatchHeader" /> and <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeaderInfo.MatchInfo" /> information.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeaderInfo.#ctor(Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader,Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchInfo)">
      <summary>
            Initialize a new instance.
            </summary>
      <param name="hdr">Match header</param>
      <param name="info">Match info</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeaderInfo.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeaderInfo.MatchHeader">
      <summary>
            Basic match header.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeaderInfo.MatchInfo">
      <summary>
            Match information.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchInfo">
      <summary>
            Match information containing the date and time of the match, sport, category, tournament, teams
            and what TV-channels this match is broadcasted on.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchInfo.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchInfo.AwayTeam">
      <summary>
            Away team, localized
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchInfo.AwayCompetitors">
      <summary>
            Away competitors, localized
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchInfo.BetPal">
      <summary>
            BetPal info object
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchInfo.Category">
      <summary>
            Category, localized (e.g. Germany, Italy, International, etc.)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchInfo.CoverageInfo">
      <summary>
            Info about match coverage
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchInfo.CoveredFrom">
      <summary>
            Gets the info whether the match is being covered from a television feed or the scout is at the match venue.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchInfo.DateOfMatch">
      <summary>
            Date of match in UTC
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchInfo.ExtraInfo">
      <summary>
            Additional match info (e.g. period lengths, etc.)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchInfo.HomeTeam">
      <summary>
            Home team, localized
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchInfo.HomeCompetitors">
      <summary>
            Home competitors, localized
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchInfo.Round">
      <summary>
            Round, localized, used in VTO
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchInfo.Sport">
      <summary>
            Sport, localized (e.g. Soccer, Basketball, etc.)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchInfo.Tournament">
      <summary>
            Tournament, localized (e.g. Premier League)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchInfo.Season">
      <summary>
            Season, localized
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchInfo.StreamingChannels">
      <summary>
            List of streaming channels where this match is broadcasted
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchInfo.TvChannels">
      <summary>
            List of TV channels where this match is broadcasted (e.g. PREMIERE Austria)
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.RegisterUnregisterBetType">
      <summary>
            Supports activation of the whole match as well as activation of odds types 
            and nested odds fields for a particular match.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.RegisterUnregisterBetType.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.RegisterUnregisterBetType.BetTypes">
      <summary>
            Activation of odds types and nested odds fields for this match
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.RegisterUnregisterBetType.MatchId">
      <summary>
            Match id
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ScoreEntry">
      <summary>
            Score summary by time that is updated live or when final results after full/half/over time are known.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ScoreEntry.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ScoreEntry.Score">
      <summary>
            Score (home:away)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ScoreEntry.Type">
      <summary>
            Indicates score type during a match (e.g. full time, half time, live, etc.).
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsCommonFeedProvider.OnAlive">
      <summary>
            Occurs when [on alive received].
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsFeedProvider.ExecuteGetOutrightStatus(System.Collections.Generic.IEnumerable{System.Int64},System.Nullable{System.DateTime},System.Boolean)">
      <summary>
            Sends a 'current' request to the feed server instructing it to send status for the specified outrights.
            </summary>
      <param name="outright_ids">The id's of the outrights for which to get the status</param>
      <param name="from">The time from which to get the status</param>
      <param name="package">Indicates whether the messages should be packed before notifying the user</param>
      <returns>The value of the request used to identify the resulting message(s)</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsFeedProvider.ConsiderMetaTranslations(Sportradar.SDK.FeedProviders.LiveOdds.Common.MetaInfo)">
      <summary>
            Merges the translations from the passed <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.MetaInfo" /> instance
            </summary>
      <param name="meta">A <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.MetaInfo" /> instance containing translations to be merged</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsFeedProvider.GetOutrightList(System.Collections.Generic.IEnumerable{System.Int64})">
      <summary>
            Request meta-information about outrights specified by it's ids
            </summary>
      <param name="outright_ids">Specifies the outrights for which to retrieve meta info</param>
      <returns>Returns immediately with the request number or zero, but expect to receive <see cref="!:ILiveOdds.OnMetaInfo" /> event in response</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsFeedProvider.GetOutrightStatus(System.Int64,System.Nullable{System.DateTime},System.Boolean)">
      <summary>
            Requests the outright status for a given time ("current" server request). 
            This includes odds, activation of odds and status for the ouright requested,
            current bet status and all bet clearing messages before the timestamp.
            </summary>
      <param name="outright_id">Outright id</param>
      <param name="from">Outright status on particular time (leave null for current outright status)</param>
      <param name="package">
            All replies get packaged in one see <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsFeedProvider.OnOutrightStatus" /> when true;
            else normal events will get invoked.
            </param>
      <returns>
            Returns immediately with the request number or zero but expect to receive an event afterwards.
            </returns>
      <remarks>
            SDK already handles error recovery for on-going outrights, no matter whether there is a crash or 
            connection to the server is lost, so during normal operation there should be no need to call
            this method! 
            
            The purpose of it is for book-keeping after an outright has ended.
            For instance after an outright is not active anymore you might want to settle all open bets or
            check whether a outright is really about to start.
            
            Notice that the outright messages do not include a message number (msgnr). The received "state" is an
            abstract concept derived from the sent messages not any sent message so it cannot have a sequence number.
            </remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsFeedProvider.GetOutrightsStatus(System.Collections.Generic.IEnumerable{System.Int64},System.Nullable{System.DateTime},System.Boolean)">
      <summary>
            Requests the outright statuses for a given time ("current" server request). 
            This includes odds, activation of odds and status for the outright requested,
            current bet status and all bet clearing messages before the timestamp.
            </summary>
      <param name="outright_ids">Outright ids, maximum is 50 per request to avoid having server queue filling up</param>
      <param name="from">Outrights statuses on particular time (leave null for current outright status)</param>
      <param name="package">
            All replies get packaged in one see <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsFeedProvider.OnOutrightStatus" /> when true;
            else normal events will get invoked.
            </param>
      <returns>
            Returns immediately with the request number or zero but expect to receive an event afterwards.
            </returns>
      <remarks>
            SDK already handles error recovery for on-going outrights, no matter whether there is a crash or 
            connection to the server is lost, so during normal operation there should be no need to call
            this method! 
            
            The purpose of it is for book-keeping after an outright has ended.
            For instance after an outright is not active anymore you might want to settle all open bets or
            check whether a match is really about to start.
            
            Notice that the match messages do not include a message number (msgnr). The received "state" is an
            abstract concept derived from the sent messages not any sent message so it cannot have a sequence number.
            </remarks>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsFeedProvider.OnAliveWithOutrights">
      <summary>
            Alive message is transmitted every 10 seconds and contains status, timestamp in UTC and match header info 
            for the matches that we supply LiveOdds for at the time given. It also contains current bet status information for every match (started or stopped).
            Score indicates the current score in the match. 
            </summary>
      <remarks>
            SDK will send out bet stops for all matches if no alive message has been received in the last 20 seconds.
            In this case client shouldn't accept any bets for any matches until the connection is stable again.
            SDK will also take care that if the connection to the Betradar server is lost, bet stops for all matches are sent out 
            until a stable connection is established again.
            </remarks>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsFeedProvider.OnOutrightBetCancel">
      <summary>
            Signals that odds type for an outright should be cancelled due to some reason.
            All bets accepted on the odds with that Id should be cancelled and cashed out with an odd of 1,0 (stakes returned).
            If the starttime and endtime are also specified, then only bets accepted in this interval should be cancelled.
            The starttime and endtime are timestamps in UTC.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsFeedProvider.OnOutrightBetClear">
      <summary>
        <para>
            Signals that bets placed on this outright can be settled
            Timestamp - time indicates the time at which the bet clear event happened.
            The event also contains the cleared score with an Odds element indicating the odds type, 
            and this again with each EventOddsField, and the status of the outcomes (true/false). 
            </para>
        <para>
            Id in the Odds element corresponds to the Odds elements in one of the previous OnOddsChange events.
            Evaluation of the bet outcomes is the responsibility of the client system.
            </para>
      </summary>
      <remarks>
        <para>
            Some bettypes, like asian handicap and asian total, can include void factor for each EventOddsField element. 
            Void factor can either be 1 or 0.5 indicating that the whole or half the bet is voided and should be refunded to the customer. 
            When the void factor is set to 0.5 the outcome attribute will indicate if the other half has won or lost. 
            </para>
        <para>
            These are all possible combinations of outcome and void factors:
            <list type="number"><item><description>outcome="0" and no voidfactor: Lose entire bet</description></item><item><description>outcome="1" and no voidfactor: Win entire bet</description></item><item><description>outcome="0" and voidfactor="1": Refund entire bet</description></item><item><description>outcome="1" and voidfactor="0.5": Refund half bet and win other half</description></item><item><description>outcome="0" and voidfactor="0.5": Refund half bet and lose other half</description></item></list></para>
      </remarks>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsFeedProvider.OnOutrightBetStart">
      <summary>
            Signals that bets for a specific outright can open again after they have been stopped.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsFeedProvider.OnOutrightBetStop">
      <summary>
            Signals that a bet stop situation occurred for a specific outright.
            OnBetStart event is triggered when the bets can open again.
            </summary>
      <remarks>
            Bet stop is triggered after following events take place: 
            <list type="number"><item><description>Goals</description></item><item><description>Red cards</description></item><item><description>Penalty</description></item><item><description>One on one situations</description></item><item><description>Free kicks within 20 meters</description></item><item><description>Match is interrupted temporarily</description></item></list>
            
            Administrative events which cause a bet stop condition:
            <list type="number"><item><description>Loss of TV coverage</description></item><item><description>Loss of connection to the scout</description></item></list></remarks>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsFeedProvider.OnOutrightOddsChange">
      <summary>
            Signals that an odds change has occurred, specifying all odds types for a particular match. 
            Odds types that are active will contain odds fields, while inactive odds types will not.
            Each odds type also has a Changed flag indicating whether this odds type has been changed or not. 
            Score indicates the current score in the match.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsFeedProvider.OnOutrightStatus">
      <summary>
            Occurs when outright status messages are received
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsDispatcher.#ctor(Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsFeedMonitor,Sportradar.SDK.Common.ProtocolProviderType,Sportradar.SDK.Services.SdkLogger.ISdkLogger,Sportradar.SDK.FeedProviders.LiveOdds.Internal.IFakeBetStopFactoryWithOutrights,Sportradar.SDK.Common.Interfaces.ITimeKeeper)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsDispatcher" /> class
            </summary>
      <param name="feed_monitor">A <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsFeedMonitor" /> used to monitor the feed</param>
      <param name="provider_type">A <see cref="T:Sportradar.SDK.Common.ProtocolProviderType" /> specifying the type of protocol provider</param>
      <param name="sdk_logger">A <see cref="T:Sportradar.SDK.Services.SdkLogger.ISdkLogger" /> used for traffic, client interaction, ... logging</param>
      <param name="fake_betstop_factory">A <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.IFakeBetStopFactoryWithOutrights" /> used to create SDK generated bet-stops</param>
      <param name="server_timekeeper">A <see cref="T:Sportradar.SDK.Common.Interfaces.ITimeKeeper" /> tracking the server time</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsDispatcher.DispatchEntity(Sportradar.SDK.Common.EntityBase)">
      <summary>
            Dispatches the entity.
            </summary>
      <param name="entity">The entity.</param>
      <returns>
      </returns>
      <exception cref="T:System.ArgumentNullException">dispatcher_state</exception>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsDispatcher.OnAliveWithOutrights">
      <summary>
            Occurs when [on alive with outrights received].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsDispatcher.OnOutrightBetCancel">
      <summary>
            Occurs when <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetCancel" /> is received
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsDispatcher.OnOutrightBetClear">
      <summary>
            Occurs when <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetClear" /> is received
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsDispatcher.OnOutrightBetStart">
      <summary>
            Occurs when <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStart" /> is received
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsDispatcher.OnOutrightBetStop">
      <summary>
            Occurs when <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightBetStop" /> is received
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsDispatcher.OnOutrightOddsChange">
      <summary>
            Occurs when <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.OutrightOddsChange" /> is received
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsWithOutrightsDispatcher.OnOutrightStatus">
      <summary>
            Occurs when outright status messages are received
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerWithOutrights.HandleDisconnect(System.Nullable{System.DateTime})">
      <summary>
            Executes steps required to handle situation when the connection to the feed server is lost
            </summary>
      <param name="time">A <see cref="T:System.DateTime" /> instance indicating when the disconnect occurred</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerWithOutrights.DispatchBetStop(Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId)">
      <summary>
            Dispatches a bet-stop for the event associated with the passed <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId" /> instance
            </summary>
      <param name="event_id">A <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId" /> instance identifying the event for which to dispatch the bet-stop</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerWithOutrights.UpdateActiveEvents(Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive)">
      <summary>
            Updates the list of active events with information retrieved from the passed <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive" /> message
            </summary>
      <param name="alive">A <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive" /> message containing information about active events</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerWithOutrights.AnalyzeAlive(Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive)">
      <summary>
            Processes the passed <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive" /> instance in order to determine whether there are any out-of-sync events
            </summary>
      <remarks>Note that the provided <code>alive</code> entity must be a <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.AliveWithOutrights" /></remarks>
      <param name="alive">The <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive" /> instance to be processed</param>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper">
      <summary>
            A wrapper used by the error manager which wrapps a <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.SingleHeaderEvent" /> and <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.SingleOutrightEvent" />
            into a common type
            </summary>
      <summary>
            A wrapper used by the error manager which wrapps a <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.SingleHeaderEvent" /> and <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.SingleOutrightEvent" />
            into a common type
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId">
      <summary>
            A unique identifier for the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper" /> instances
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId.#ctor(System.Int64,Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.HeaderType)">
      <summary>
            Constructs a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId" /> class
            </summary>
      <param name="id">Id of the event wrapped by the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId" /> instance</param>
      <param name="type">A <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.HeaderType" /> specifying the type (event, outright, ...) of the wrapped item</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId.#ctor(Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper)">
      <summary>
            Constructs a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId" /> class
            </summary>
      <param name="entity">
      </param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId.GetHashCode">
      <summary>
            Calculates and returns the hash code of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId" /> instance
            </summary>
      <returns>A hash code of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId" /> instance</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId.Equals(System.Object)">
      <summary>
            Determines whether the passed <see cref="T:System.Object" /> is equal to current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId" /> instance
            </summary>
      <param name="obj">A <see cref="T:System.Object" /> instance to be checked for equality to current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId" /> instance</param>
      <returns>True if the passed <see cref="T:System.Object" /> is equal to current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId" /> instance; Otherwise false</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId.ToString">
      <summary>
            Constructs and returns a <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId" /> instance
            </summary>
      <returns>A <see cref="T:System.String" /> representation of the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId" /> instance</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId.Id">
      <summary>
            Gets the id of the event wrapped by the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId" /> instance
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId.Type">
      <summary>
            Gets a <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.HeaderType" /> specifying the type (event, outright, ...) of the wrapped item
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.m_header">
      <summary>
            The <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventHeader" /> property backing field
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.m_entity">
      <summary>
            The <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.Entity" /> property backing field
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.m_entity_type">
      <summary>
            The <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EntityType" /> property backing field
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.m_key">
      <summary>
            The <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.Key" /> property backing field
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.#ctor(Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase,Sportradar.SDK.FeedProviders.LiveOdds.Common.EventHeader,Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.HeaderType)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper" /> from the provided values
            </summary>
      <param name="entity">A <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase" /> instance</param>
      <param name="header">A <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventHeader" /></param> instance
            <param name="entityType">A <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.HeaderType" />enum member specifying the type of the source entity</param></member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.#ctor(Sportradar.SDK.FeedProviders.LiveOdds.Common.SingleHeaderEvent)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper" /> from the provided <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.SingleHeaderEvent" /></summary>
      <param name="singleHeaderEvent">
      </param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.#ctor(Sportradar.SDK.FeedProviders.LiveOdds.Outrights.SingleOutrightEvent)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper" /> from the provided <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Outrights.SingleOutrightEvent" /> instance
            </summary>
      <param name="singleOoutrightEvent">
      </param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.TryCreateFromEntityBase(Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase,Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper@)">
      <summary>
            Attempts to construct a <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper" /> from the provided <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase" /> instnace
            </summary>
      <param name="oddsEntity">A <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase" /> instance</param>
      <param name="wrapper">If method returned <code>true</code> the constructed <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper" />, otherwise undefined"/&gt;</param>
      <returns>True if <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper" /> could be created from the provided <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase" />; Otherwise false.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.Header">
      <summary>
            Gets the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventHeader" /> instance associated with the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper" /> instance
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.Entity">
      <summary>
            Gets the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase" /> instance from which the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper" /> was constructed
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EntityType">
      <summary>
            Gets the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.HeaderType" /> enum member specifying the type of the entity from which the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper" /> instance was created
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.Key">
      <summary>
            Gets a <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId" /> instance used to uniquely identify the event associated with current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper" /></summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsCommonFeedProviderBase.Start">
      <summary>
            Start component.
            </summary>
      <remarks>
            The component should be initialized first.
            </remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsCommonFeedProviderBase.Stop">
      <summary>
            Stop / shutdown component.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsCommonFeedProviderBase.AvailableMetadataTranslations">
      <summary>
            Gets the available metadata translations.
            </summary>
      <value>
            The available metadata translations.
            </value>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsCommonFeedProviderBase.AvailableTranslations">
      <summary>
            Language codes of the currently available translations.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsCommonFeedProviderBase.IsConnectionStable">
      <summary>
            Is the current connection stable enough to accept bets safely?
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsCommonFeedProviderBase.LastAliveMessage">
      <summary>
            Get time when the last alive message from the server was received.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsCommonFeedProviderBase.LastServerMessage">
      <summary>
            Get time when the last message from the server was received.
            This includes alive messages that are periodically sent.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsCommonFeedProviderBase.ProtoProvider">
      <summary>
            Underlying protocol provider.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsCommonFeedProviderBase.ServerTime">
      <summary>
            Get current server time (or null if it is stale).
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsCommonFeedProviderBase.OnBetCancel">
      <summary>
            Occurs when [on bet cancel].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsCommonFeedProviderBase.OnBetCancelUndo">
      <summary>
            Occurs when [on bet cancel undone].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsCommonFeedProviderBase.OnBetClear">
      <summary>
            Occurs when [on bet clear].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsCommonFeedProviderBase.OnBetClearRollback">
      <summary>
            Occurs when [on bet clear rollback].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsCommonFeedProviderBase.OnBetStart">
      <summary>
            Occurs when [on bet start].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsCommonFeedProviderBase.OnBetStop">
      <summary>
            Occurs when [on bet stop].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsCommonFeedProviderBase.OnConnectionStable">
      <summary>
            Occurs when connection stable.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsCommonFeedProviderBase.OnConnectionUnstable">
      <summary>
            Occurs when connection unstable.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsCommonFeedProviderBase.OnEventMessages">
      <summary>
            Occurs when [on match messages received].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsCommonFeedProviderBase.OnEventStatus">
      <summary>
            Occurs when [on match status received].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsCommonFeedProviderBase.OnFeedError">
      <summary>
            Occurs when [on feed error].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsCommonFeedProviderBase.OnMetaInfo">
      <summary>
            Occurs when [on meta info received].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsCommonFeedProviderBase.OnOddsChange">
      <summary>
            Occurs when [on odds change].
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedProvider.ConsiderMetaTranslations(Sportradar.SDK.FeedProviders.LiveOdds.Common.MetaInfo)">
      <summary>
            Considers the meta translations to extract data from.
            </summary>
      <param name="meta">Metainfo message.</param>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedProvider.AvailableBetTypeTranslations">
      <summary>
            Gets the available bet type translations.
            </summary>
      <value>
            The available bet type translations.
            </value>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedProvider.ProviderType">
      <summary>
            Gets the type of the provider.
            </summary>
      <value>
            The type of the provider.
            </value>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedProvider.SubscribedEvents">
      <summary>
            All match ids for matches were are currently subscribed to.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedProvider.OnScoreCardSummary">
      <summary>
            Occurs when [on score card received].
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedProviderBetPal">
      <summary>
            BetPal provider.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedProviderBetPal.ProviderType">
      <summary>
            Gets the type of the provider.
            </summary>
      <value>
            The type of the provider.
            </value>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedProviderLivePlex.ProviderType">
      <summary>
            Gets the type of the provider.
            </summary>
      <value>
            The type of the provider.
            </value>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedProviderSoccerRoulette.ProviderType">
      <summary>
            Gets the type of the provider.
            </summary>
      <value>
            The type of the provider.
            </value>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedProviderVbl">
      <summary>
            Virtual basketball league LiveOdds provider.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedProviderVbl.ProviderType">
      <summary>
            Gets the type of the provider.
            </summary>
      <value>
            The type of the provider.
            </value>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedProviderVfl">
      <summary>
            Virtual football league LiveOdds provider.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedProviderVfl.ProviderType">
      <summary>
            Gets the type of the provider.
            </summary>
      <value>
            The type of the provider.
            </value>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedProviderVto">
      <summary>
            BetPal provider.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedProviderVto.ProviderType">
      <summary>
            Gets the type of the provider.
            </summary>
      <value>
            The type of the provider.
            </value>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsRaceFeedProvider.ConsiderMetaTranslations(Sportradar.SDK.FeedProviders.LiveOdds.Common.MetaInfo)">
      <summary>
            Considers the meta translations to extract data from.
            </summary>
      <param name="meta">Metainfo message.</param>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsRaceFeedProvider.OnRaceResult">
      <summary>
            Occurs when [on race result received].
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsFeedDispatcher.DispatchEntity(Sportradar.SDK.Common.EntityBase)">
      <summary>
            Dispatches the entity.
            </summary>
      <param name="entity">The entity.</param>
      <returns>
      </returns>
      <exception cref="T:System.ArgumentNullException">dispatcher_state</exception>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsFeedDispatcher.DispatchParseError(Sportradar.SDK.Common.Interfaces.IMessageIdentifier,System.String)">
      <summary>
            DispatchParseError
            </summary>
      <param name="identifier">
      </param>
      <param name="message">
      </param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsFeedDispatcher.DispatchUserRequest(Sportradar.SDK.FeedProviders.LiveOdds.Common.UserRequest,System.Nullable{Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsReplyType},System.Int64)">
      <summary>
            Dispatches the user request.
            </summary>
      <param name="request">The request.</param>
      <param name="reply_type">The reply_type.</param>
      <param name="key">The key.</param>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsFeedDispatcher.AfterMessageDispatched">
      <summary>
            Occurs when [after message dispatched].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsFeedDispatcher.OnAlive">
      <summary>
            Occurs when [on alive received].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsFeedDispatcher.OnBetCancel">
      <summary>
            Occurs when [on bet cancel].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsFeedDispatcher.OnBetCancelUndo">
      <summary>
            Occurs when [on bet cancel undone].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsFeedDispatcher.OnBetClear">
      <summary>
            Occurs when [on bet clear].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsFeedDispatcher.OnBetClearRollback">
      <summary>
            Occurs when [on bet clear rollback].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsFeedDispatcher.OnBetStart">
      <summary>
            Occurs when [on bet start].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsFeedDispatcher.OnBetStop">
      <summary>
            Occurs when [on bet stop].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsFeedDispatcher.OnConnectionStable">
      <summary>
            Occurs when connection stable.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsFeedDispatcher.OnConnectionUnstable">
      <summary>
            Occurs when connection unstable.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsFeedDispatcher.OnEventMessages">
      <summary>
            Occurs when [on match messages received].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsFeedDispatcher.OnEventStatus">
      <summary>
            Occurs when [on match status received].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsFeedDispatcher.OnFeedError">
      <summary>
            Occurs when [on feed error].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsFeedDispatcher.OnMetaInfo">
      <summary>
            Occurs when [on meta info received].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsFeedDispatcher.OnOddsChange">
      <summary>
            Occurs when [on odds change].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsFeedDispatcher.OnRaceResult">
      <summary>
            Occurs when [on race result].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsFeedDispatcher.OnScoreCard">
      <summary>
            Occurs when [on score card received].
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsEntityFactory.BuildAlive(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LiveOdds.Incoming.BetradarLiveOdds)">
      <summary>
      </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsEntityFactory.BuildBetCancel(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LiveOdds.Incoming.BetradarLiveOdds)">
      <summary>
      </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsEntityFactory.BuildBetCancelUndo(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LiveOdds.Incoming.BetradarLiveOdds)">
      <summary>
      </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsEntityFactory.BuildBetClear(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LiveOdds.Incoming.BetradarLiveOdds)">
      <summary>
      </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsEntityFactory.BuildBetClearRollback(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LiveOdds.Incoming.BetradarLiveOdds)">
      <summary>
      </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsEntityFactory.BuildBetStart(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LiveOdds.Incoming.BetradarLiveOdds)">
      <summary>
      </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsEntityFactory.BuildBetStop(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LiveOdds.Incoming.BetradarLiveOdds)">
      <summary>
            BuildBetStop
            </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsEntityFactory.BuildIrrelevantOddsChange(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LiveOdds.Incoming.BetradarLiveOdds)">
      <summary>
            BuildIrrelevantOddsChange
            </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsEntityFactory.BuildMetaInfo(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LiveOdds.Incoming.BetradarLiveOdds)">
      <summary>
            BuildMetaInfo
            </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsEntityFactory.BuildOddsChange(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LiveOdds.Incoming.BetradarLiveOdds)">
      <summary>
            BuildOddsChange
            </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsEntityFactory.BuildReplyStartEnd(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LiveOdds.Incoming.BetradarLiveOdds)">
      <summary>
            BuildReplyStartEnd
            </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsEntityFactory.BuildScoreCardSummary(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LiveOdds.Incoming.BetradarLiveOdds)">
      <summary>
            BuildScoreCardSummary
            </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedDispatcher.DispatchArtificialBetStops(System.Nullable{System.Int64},System.Collections.Generic.IEnumerable{System.Int64})">
      <summary>
            Dispatches the explicit bet stops.
            </summary>
      <param name="event_ids">The event_ids.</param>
      <param name="virtual_game_id">Virtual game id of the event</param>
      <exception cref="T:System.ArgumentNullException">event_ids</exception>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedDispatcher.DispatchConnectionStable(System.Nullable{System.Int64})">
      <summary>
            Dispatches the connection is stable.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedDispatcher.DispatchConnectionUnstable(System.Nullable{System.Int64})">
      <summary>
            Dispatches the connection is unstable.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedDispatcher.DispatchEntity(Sportradar.SDK.Common.EntityBase)">
      <summary>
            Dispatches the entity.
            </summary>
      <param name="entity">The entity.</param>
      <returns>
      </returns>
      <exception cref="T:System.ArgumentNullException">dispatcher_state</exception>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedDispatcher.DispatchUserRequest(Sportradar.SDK.FeedProviders.LiveOdds.Common.UserRequest,System.Nullable{Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsReplyType},System.Int64)">
      <summary>
            Dispatches the user request.
            </summary>
      <param name="request">The request.</param>
      <param name="reply_type">The reply_type.</param>
      <param name="key">The key.</param>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedDispatcher.OnAlive">
      <summary>
            Occurs when [on alive received].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedDispatcher.OnBetCancel">
      <summary>
            Occurs when [on bet cancel].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedDispatcher.OnBetCancelUndo">
      <summary>
            Occurs when [on bet cancel undone].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedDispatcher.OnBetClear">
      <summary>
            Occurs when [on bet clear].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedDispatcher.OnBetClearRollback">
      <summary>
            Occurs when [on bet clear rollback].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedDispatcher.OnBetStart">
      <summary>
            Occurs when [on bet start].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedDispatcher.OnBetStop">
      <summary>
            Occurs when [on bet stop].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedDispatcher.OnConnectionStable">
      <summary>
            Occurs when connection stable.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedDispatcher.OnConnectionUnstable">
      <summary>
            Occurs when connection unstable.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedDispatcher.OnEventMessages">
      <summary>
            Occurs when [on match messages received].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedDispatcher.OnEventStatus">
      <summary>
            Occurs when [on match status received].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedDispatcher.OnFeedError">
      <summary>
            Occurs when [on feed error].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedDispatcher.OnMetaInfo">
      <summary>
            Occurs when [on meta info received].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedDispatcher.OnOddsChange">
      <summary>
            Occurs when [on odds change].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedDispatcher.OnRaceResult">
      <summary>
            Occurs when [on race result].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.LiveOddsFeedDispatcher.OnScoreCard">
      <summary>
            Occurs when [on score card received].
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.m_active_events">
      <summary>
            A <see cref="T:System.Collections.Generic.ISet`1" /> containing identifiers for active events (matches or outcomes)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.m_bad_events">
      <summary>
            A <see cref="T:System.Collections.Generic.ISet`1" /> containing identifiers for bad events (out of sequence, ...)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.m_current_request_possible">
      <summary>
            A <see cref="T:System.Collections.Generic.IDictionary`2" /> used to map event identifiers to value specifying whether the current request for them is possible
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.m_event_ids_to_request_id">
      <summary>
            A <see cref="T:System.Collections.Generic.IDictionary`2" /> used to map event identifiers to to request numbers of corresponding 'current' request.
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.m_event_reply_timestamp">
      <summary>
            A <see cref="T:System.Collections.Generic.IDictionary`2" /> used to link event identifiers to timestamps of the associated 'current' requests
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.m_entities_received_during_recovery">
      <summary>
            A <see cref="T:System.Collections.Generic.IDictionary`2" /> used to link event identifiers to entities received during event recovery
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.m_request_and_responses">
      <summary>
            A <see cref="T:System.Collections.Generic.IDictionary`2" /> used to link 'current' requests to entities received for that particular request
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.m_error_recovery_dispatcher">
      <summary>
            A <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.IFeedRecoveryDispatcher" /> used to dispatch events generated by the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase" /> instance.
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.m_live_odds_config">
      <summary>
            A <see cref="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOdds" /> instance representing the SDK configuration
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.m_protocol_provider_type">
      <summary>
            A <see cref="T:Sportradar.SDK.Common.ProtocolProviderType" /> identifying the protocol provider used with current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase" /> instance 
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.m_request_producer">
      <summary>
            A <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsRequestProducer" /> instance used to produce requests for the feed server
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.m_timekeeper">
      <summary>
            A <see cref="T:Sportradar.SDK.Common.Interfaces.ITimeKeeper" /> instance used to track server time
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.m_enabled">
      <summary>
            Value specifying whether the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase" /> is enabled
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.m_alive_received">
      <summary>
            A value specifying whether at least one alive entity was received by the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase" /></summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.m_message_dispatcher">
      <summary>
            A <see cref="T:Sportradar.SDK.Common.Interfaces.IMessageDispatcher" /> used to dispatch messages
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.m_dispatched_msg_numbers">
      <summary>
            A <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ISequenceMonitor" /> used to track message numbers of dispatched entities
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.m_received_msg_numbers">
      <summary>
            A <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ISequenceMonitor" /> used to track message numbers of received entities
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.g_lock">
      <summary>
            A <see cref="T:System.Object" /> used to synchronize access to critical regions.
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.g_log">
      <summary>
            A <see cref="T:log4net.ILog" /> instance used for execution logging. 
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.#ctor(Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsFeedMonitor,Sportradar.SDK.FeedProviders.LiveOdds.Internal.IFeedRecoveryDispatcher,Sportradar.SDK.FeedProviders.LiveOdds.Internal.ILiveOddsRequestProducer,Sportradar.SDK.Common.ProtocolProviderType,Sportradar.SDK.Common.Interfaces.ITimeKeeper,Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOdds)">
      <summary>
            Constructs a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase" /> class
            </summary>
      <param name="feed_monitor">
      </param>
      <param name="error_recovery_dispatcher">
      </param>
      <param name="request_producer">
      </param>
      <param name="protocol_provider_type">
      </param>
      <param name="timekeeper">
      </param>
      <param name="live_odds_config">
      </param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.UpdateActiveEvents(Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive)">
      <summary>
            When overridden in derived class, it updates the list of active events with information retrieved from the passed <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive" /> message
            </summary>
      <param name="alive">A <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive" /> message containing information about active events</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.AnalyzeAlive(Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive)">
      <summary>
            When overridden in derived class, it processes the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive" /> derived instance
            </summary>
      <param name="alive">
      </param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.SendCurrentRequests(System.Collections.Generic.List{Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId})">
      <summary>
            When overridden in derived class, it sends a 'current' request for out-of-sync events
            </summary>
      <param name="bad_events">A <see cref="T:System.Collections.Generic.List`1" /> containing keys for out-of-sync events</param>
      <returns>A <see cref="T:System.Collections.Generic.List`1" /> containing <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId" /> specifying events for which the current request was made</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.DispatchBetStop(Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId)">
      <summary>
            When overridden in derived class, it dispatches a bet-stop for the event associated with the passed <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId" /> instance
            </summary>
      <param name="wrapper_id">A <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId" /> instance identifying the event for which to dispatch the bet-stop</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.HandleDisconnect(System.Nullable{System.DateTime})">
      <summary>
            When overridden in derived class, executes required steps to handle situation when the connection to the feed server is lost
            </summary>
      <param name="time">A <see cref="T:System.DateTime" /> instance indicating when the disconnect occurred</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.Disable">
      <summary>
            Disables (stops) the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase" /> instance
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.Enable">
      <summary>
            Enables (starts) the current <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase" /> instance
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.RegisterMessageDispatcher(Sportradar.SDK.Common.Interfaces.IMessageDispatcher)">
      <summary>
            Registers a <see cref="T:Sportradar.SDK.Common.Interfaces.IMessageDispatcher" /> used to dispatch events
            </summary>
      <param name="message_dispatcher">
      </param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.IsOutOfSync(Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper)">
      <summary>
            Determines whether the event associated with the passed <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper" /> is out of sync and recovery for it must be made
            </summary>
      <returns>True if the event associated with the passed <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper" /> is out of sync. Otherwise false</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.DelayedAliveAnalysis(Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive)">
      <summary>
            Starts the delayed execution of <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive" /> instance analysis, which checks for out-of-sync events
            </summary>
      <param name="alive">
      </param>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.IsConnectionStable">
      <summary>
            Gets a value indicating whether the connection to feed server is stable
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManagerBase.VirtualGameId">
      <summary>
            Gets a value specifying the gameId of the virtual game 
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManager">
      <summary>
            Handles the complete LiveOdds error-recovery algorithm using (minimal amount of) "current" requests.
            For virtual games there are more instances with each one handling one game.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManager.UpdateActiveEvents(Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive)">
      <summary>
            Updates the list of active events with information retrieved from the passed <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive" /> message
            </summary>
      <param name="alive">A <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive" /> message containing information about active events</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManager.HandleDisconnect(System.Nullable{System.DateTime})">
      <summary>
            Executes steps required to handle situation when the connection to the feed server is lost
            </summary>
      <param name="time">A <see cref="T:System.DateTime" /> instance indicating when the disconnect occurred</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManager.DispatchBetStop(Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId)">
      <summary>
            Dispatches a bet-stop for the event associated with the passed <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId" /> instance
            </summary>
      <param name="event_id">A <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId" /> instance identifying the event for which to dispatch the bet-stop</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManager.AnalyzeAlive(Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive)">
      <summary>
            Processes the passed <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive" /> instance in order to determine whether there are any out-of-sync events
            </summary>
      <param name="alive">The <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive" /> instance to be processed</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.ErrorManager.SendCurrentRequests(System.Collections.Generic.List{Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId})">
      <summary>
            Sends a 'current' request for out-of-sync events
            </summary>
      <param name="bad_events">A <see cref="T:System.Collections.Generic.List`1" /> containing <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId" /> instances for out-of-sync events</param>
      <returns>A <see cref="T:System.Collections.Generic.List`1" /> containing <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.EventWrapper.EventWrapperId" /> specifying events for which the current request was made</returns>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.UserRequestManager">
      <summary>
            Handles batching of replies for a user-request (so he gets everything at once with "replyend")
            and flagging messages with IsOutOfBand.
            </summary>
      <remarks>
            User can also request data to directly get messages (not batched) in this case
            this component is stateless but still does the IsOutOfBand flagging.
            </remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.UserRequestManager.Disable">
      <summary>
            Disable all operation (prevents intercepting messages).
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Internal.UserRequestManager.Enable">
      <summary>
            Enable all operation.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.MatchMsgNrStatusTuple">
      <summary>
            Match id, message number and betstatus tuple.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.MatchMsgNrStatusTuple.BetStatus">
      <summary>
            Current bet status.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.MatchMsgNrTuple">
      <summary>
            Match id, message number tuple.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.MatchMsgNrTuple.MatchId">
      <summary>
            Gets or sets the match id.
            </summary>
      <value>
            The match id.
            </value>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.MatchMsgNrTuple.MsgNr">
      <summary>
            Gets or sets the message number.
            </summary>
      <value>
            The message number.
            </value>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Internal.MatchMsgNrTuple.Timestamp">
      <summary>
            Timestamp of the thing
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Internal.Interfaces.ILiveOddsWithOutrightsDispatcher">
      <summary>
            Defines a contract implemented by classes used to dispatch outright related messages to the user
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.Interfaces.ILiveOddsWithOutrightsDispatcher.OnAliveWithOutrights">
      <summary>
            Occurs when [AliveWithOutrights with outrights received].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.Interfaces.ILiveOddsWithOutrightsDispatcher.OnOutrightBetCancel">
      <summary>
            Occurs when [OutrightBetCancel is received]
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.Interfaces.ILiveOddsWithOutrightsDispatcher.OnOutrightBetClear">
      <summary>
            Occurs when [OutrightBetClear is received]
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.Interfaces.ILiveOddsWithOutrightsDispatcher.OnOutrightBetStart">
      <summary>
            Occurs when [OutrightBetStart is received]
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.Interfaces.ILiveOddsWithOutrightsDispatcher.OnOutrightBetStop">
      <summary>
            Occurs when [OutrightBetStop is received]
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.Interfaces.ILiveOddsWithOutrightsDispatcher.OnOutrightOddsChange">
      <summary>
            Occurs when [OutrightOddsChange is received]
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Internal.Interfaces.ILiveOddsWithOutrightsDispatcher.OnOutrightStatus">
      <summary>
            Occurs when outright status messages are received
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive">
      <summary>
        <para>
            Betradar system sends Alive message every 10 seconds so that a bookmaker client can be sure 
            that it has a working connection to the Betradar system at all times. 
            </para>
        <para>
            This message contains status, timestamp in UTC, and empty Match elements to identify the events 
            that Betradar system supplies live odds for at the given time.
            Every event element also contains betstatus information ("started" or "stopped").
            </para>
        <para>
            Score information included with the event indicates the current score in the event while the msgnr 
            indicates the number of the last message sent for this event. 
            </para>
      </summary>
      <remarks>
            SDK will stop all bets on all events in case it hasn't received any alive messages in timespan 
            defined in settings or if the connection to the Betradar system is lost. All bets are stopped until the connection 
            with the Betradar system is stable again.
            
            Event appears in "alive" approximately 15 minutes before start and stays in "alive" 5 minutes after
            end (after operator closed the event).
            </remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive.EventHeaders">
      <summary>
            List of empty event elements to identify the events that Betradar system 
            supplies live odds for at the given time (with betstatus and score information).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive.EventId">
      <exclude />
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.Alive.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetCancel">
      <summary>
            Indicates that an odds type for a match has been cancelled for a reason.
            All bets accepted on the odds with that id should be cancelled and cashed out with an odd of 1,0 (stakes returned).
            If the <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetCancel.StartTime" /> and <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetCancel.EndTime" /> are set, 
            only bets accepted in this interval should be cancelled.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetCancel.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetCancel.EndTime">
      <summary>
            If <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetCancel.StartTime" /> and <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetCancel.EndTime" /> are set
            only bets accepted in this interval should be cancelled or in <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetCancelUndo" /> uncancelled
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetCancel.StartTime">
      <summary>
            If <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetCancel.StartTime" /> and <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetCancel.EndTime" /> are set
            only bets accepted in this interval should be cancelled or in <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetCancelUndo" /> uncancelled
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetCancel.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetCancelUndo">
      <summary>
            Indicates undo of some previous bet cancellation when for some reason an odds type has been cancelled 
            when it shouldn’t have been. Odds element will match the Odds element of the corresponding “cancelbet" message.
            <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetCancel.StartTime" /> and <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetCancel.EndTime" /> will also 
            match the values from the previous “cancelbet" message.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetCancelUndo.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetCancelUndo.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetClear">
      <summary>
        <para>
            Indicates that a situation occurred during the match so that a bet can be decided.
            Time which is set to (<see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Timestamp" /> - <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Time" />) seconds 
            indicates the time at which the event happened.
            The message also includes the match element indicating the match id and the cleared score with 
            an Odds element indicating the odds type, and this again with each EventOddsField and the status of the outcomes.
            </para>
        <para>
            Some bet types, like Asian handicap and Asian total, can also include void factor for each EventOddsField element. 
            Void factor can either be 1 or 0.5 indicating that the whole or half the bet is voided and should be refunded to the customer. 
            When the void factor is set to 0.5 the outcome attribute will indicate if the other half is won or lost. 
            </para>
        <para>
            The id attribute in the Odds element corresponds to the odds elements in the previously sent out odds change messages. 
            Evaluation of bet outcomes is responsibility of the client.
            </para>
      </summary>
      <remarks>
            Possible combinations of outcome and void factor:
            <list type="bullet"><item><description>outcome="0" and no void factor: Lose entire bet</description></item><item><description>outcome="1" and no void factor: Win entire bet</description></item><item><description>outcome="0" and void factor="1": Refund entire bet</description></item><item><description>outcome="1" and void factor="0.5": Refund half bet and win other half </description></item><item><description>outcome="0" and void factor="0.5": Refund half bet and lose other half</description></item></list></remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetClear.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetClear.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetClearRollback">
      <summary>
            Indicates that a wrong information was sent out about a bet clearing and that previous bet clear 
            should be rolled back now. Odds identified by corresponding ids tell what odds the bet clear rollback is for.
            <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.ClearedScore" /> will be set to the cleared score of the original bet clearing.
            The time for the original bet clearing is (<see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Timestamp" /> - <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Time" />) seconds.
            The odds element also includes odds field elements to indicate what field was cleared in the original bet clearing. 
            The client is responsible to handle this accordingly.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetClearRollback.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetClearRollback.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetStart">
      <summary>
            Indicates that the bets for a particular match can open again.
            The message contains s <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Timestamp" /> and also a <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Time" /> attribute 
            which tells when the situation occurred in seconds before the <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Timestamp" />.
            If time is 0, bet start is from timestamp, if time &gt; 0, bet start is from 
            (<see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Timestamp" /> - <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Time" />). 
            <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.Score" /> indicates the current score in the match.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetStart.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetStart.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetStop">
      <summary>
            Indicates that a betstop situation occurred during a match (e.g. goal, red card or other important event occurred).
            When the bets can open again, a "betstart" message will be sent.
            Bet stop message contains <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Timestamp" /> and also a <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Time" /> attribute which tells 
            when the situation occurred in seconds before the <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Timestamp" />.
            If time is 0 betstop is from timestamp, if time &gt; 0, betstop is from 
            (<see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Timestamp" /> - <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Time" />). 
            <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader.Score" /> indicates the current score in the match.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetStop.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetStop.IsArtifical">
      <summary>
            Was this BetStop triggered by the SDK itself
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetStop.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.IrrelevantOddsChange">
      <summary>
            Indicates that a change occurred which should be of no interest to the client.
            This could for example be bet clearing of an odds type which is unsubscribed. 
            If this is not set, then an odds update is sent instead.
            </summary>
      <remarks>
            This message is only active if client has enabled the "Send irrelevant change message for changes that aren’t of interest"
            XML configuration option.
            </remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.IrrelevantOddsChange.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.IrrelevantOddsChange.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.MetaInfo">
      <summary>
            Contains event meta-information in response to client meta request or when a event is added to the system 
            or when a event has been cancelled. 
             </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.MetaInfo.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.MetaInfo.EventId">
      <exclude />
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.MetaInfo.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsChange">
      <summary>
            When an odds change occurs, all the odds types for that match are sent in a message. 
            Only active odds types contain odds fields, while inactive odds types do not.
            Each odds type also has an attribute named changed which indicates whether this odds type has been changed or not. 
            An attribute score indicates the current score in the match.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsChange.#ctor(System.Xml.XmlAttribute[])">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsChange" /> class.
            </summary>
      <param name="orig">
            Network version of the entity.
            </param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsChange.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsChange.ToStringWithoutTypeName">
      <exclude />
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsChange.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase">
      <summary>
            Serves as a base class that all LiveOdds entities should be derived from.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.#ctor(System.Xml.XmlAttribute[])">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase" /> class.
            </summary>
      <param name="any_attr">
            Unknown attributes that are unrecognized by this version of SDK
            </param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.IsOutOfBand">
      <summary>
            Is the message out-of-band by purpose
            i.e., explicitly requested by user?
            True when yes; false else (usually).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Messages">
      <summary>
            Additional textual information attached to the message.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Msgnr">
      <summary>
            To make sure that client system receives all messages from the Betradar system, all messages sent out have an incremental id.
            It starts with 1 for every event. Only messages that change the state of a event include this attribute.
            Alive, meta-information and login response messages do not include it.
            </summary>
      <remarks>
        <para>
            If "Send bet clearings even if match is not active" XML configuration option is enabled 
            Sportradar will send bet clearings and bet cancellations even if match has been deactivated.
            When this option has been activated, you will not receive all msgnr for that match.
            </para>
        <para>
            For example, you might have received up to msgnr 100 for a match, and then it is deactivated. 
            When the match has ended you will receive all bet clearings starting at msgnr 135 for example. 
            Also during the bet clearing some msgnr might be omitted.
            </para>
      </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.ReplyNr">
      <summary>
            Reply number matching the request number, thus enabling us to pair request and response messages properly.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.ReplyType">
      <summary>
            Message reply type (e.g. Current, Error, Register)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.ServerType">
      <summary>
            Live odds feed server type (e.g. LiveOdds, BetPal, ...)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.ServerVersion">
      <summary>
            XML feeds server version
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Status">
      <summary>
            Live Odds status specifying the actual message type (e.g. current, clearbet, change, score, cards, etc.)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Time">
      <summary>
            Time in seconds.
            For "betstart", "betstop", "betclear" it tells when the situation occurred in seconds before <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Timestamp" />.
            Also used to indicate time for the original bet clearing in case of "betrollback".
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.Timestamp">
      <summary>
            Time from server in UTC.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase.VirtualGameId">
      <summary>
            Virtual game id.
            </summary>
      <remarks>
            If one server is used for multiple feeds this identifies the source.
            </remarks>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.ReplyStartEnd">
      <summary>
            Reply start and reply end messages can be used to easier group the response messages together
            and to know when a new response starts and ends.
            </summary>
      <remarks>
            Only available if "Include response reply number" option is enabled in the XML feed configuration.
            </remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.ReplyStartEnd.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.ReplyStartEnd.IsStart">
      <summary>
            Specifies whether this is a ReplyStart or ReplyEnd message.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.ReplyStartEnd.EventId">
      <exclude />
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.ReplyStartEnd.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.SingleHeaderEvent">
      <summary>
            Base class for all events that regard only one event
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.SingleHeaderEvent.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.SingleHeaderEvent.EventHeader">
      <summary>
            Core info about the event for this event
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.SingleHeaderWithOddsEvent">
      <summary>
            Base class for all events that regard only one event and contain odds
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.SingleHeaderWithOddsEvent.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.SingleHeaderWithOddsEvent.Odds">
      <summary>
            Odds relevant to the event
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommon">
      <summary>
            Interface describing events and methods common for all LiveOdds feeds which do not contain outrights
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommon.OnAlive">
      <summary>
            Alive message is transmitted every 10 seconds and contains status, timestamp in UTC and match header info 
            for the matches that we supply LiveOdds for at the time given. It also contains current bet status information for every match (started or stopped).
            Score indicates the current score in the match. 
            </summary>
      <remarks>
            SDK will send out bet stops for all matches if no alive message has been received in the last 20 seconds.
            In this case client shouldn't accept any bets for any matches until the connection is stable again.
            SDK will also take care that if the connection to the Betradar server is lost, bet stops for all matches are sent out 
            until a stable connection is established again.
            </remarks>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventBetStatus">
      <summary>
            Bet status
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventBetStatus.UNDEFINED">
      <summary>
            Undefined
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventBetStatus.STARTED">
      <summary>
            Betting started
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventBetStatus.STOPPED">
      <summary>
            Betting stopped
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsType">
      <summary>
            Event odds type
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsType.UNDEFINED">
      <summary>
            Undefined
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsType.ITEM3W">
      <summary>
            3 way
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsType.NG">
      <summary>
            Next goal (obsolete now, replaced with a special <see cref="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsType.FT3W">FT3W</see> odds type)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsType.HC">
      <summary>
            Handicap
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsType.TO">
      <summary>
            Total
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsType.FT3W">
      <summary>
            Free text - 3 way
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsType.FT2W">
      <summary>
            Free text - 2 way
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsType.FTNW">
      <summary>
            Free text - n way
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsType.OUTRIGHT">
      <summary>
            Outright
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus">
      <summary>
            Event status as used by Live Odds.
            </summary>
      <remarks>
            Soccer:
            <list type="bullet"><item><description>not_started	    Not started yet</description></item><item><description>1p	            1st period of the match</description></item><item><description>paused	        Match pause</description></item><item><description>2p	            2nd period of the match</description></item><item><description>ended	        The match has ended</description></item><item><description>awaiting_ot	    Waiting for overtime to start</description></item><item><description>ot	            Overtime (when normal time is over)</description></item><item><description>1p_ot	        1st overtime period</description></item><item><description>ot_ht	        Pause between 1st and 2nd overtime period</description></item><item><description>2p_ot	        2nd overtime period</description></item><item><description>after_ot	        Overtime is finished</description></item><item><description>awaiting_pen	    Waiting for penalty shooting to start</description></item><item><description>pen	            Penalty shooting</description></item><item><description>ended	        The match has ended</description></item><item><description>interrupted	    The match has been interrupted</description></item></list>
            
            Tennis:
            <list type="bullet"><item><description>not_started	    Not started yet</description></item><item><description>1set	            1st set</description></item><item><description>2set	            2nd set</description></item><item><description>3set	            3rd set</description></item><item><description>4set	            4th set</description></item><item><description>5set	            5th set</description></item><item><description>ended	        The match has ended</description></item><item><description>walkover	        A player won the match on walkover</description></item><item><description>retired	        The match is ended because a player has retired</description></item><item><description>delayed	        The match start is delayed</description></item><item><description>interrupted	    The match has been interrupted</description></item></list>
            
            Ice Hockey:
            <list type="bullet"><item><description>not_started	    Not started yet</description></item><item><description>1p	            1st period</description></item><item><description>2p	            2nd period</description></item><item><description>3p	            3rd period</description></item><item><description>paused	        Match pause</description></item><item><description>ot	            Overtime (Used during the entire overtime)</description></item><item><description>pen	            Penalty shooting</description></item><item><description>ended	        The match has ended</description></item><item><description>interrupted	    The match has been interrupted</description></item><item><description>awaiting_ot	    Waiting for overtime to start</description></item><item><description>after_ot	        Overtime is finished</description></item><item><description>awaiting_pen	    Waiting for penalty shooting to start</description></item></list>
            
            Basketball:
            <list type="bullet"><item><description>not_started      Not started yet</description></item><item><description>1q               1st quarter</description></item><item><description>pause1	        1st pause</description></item><item><description>2q	            2nd quarter</description></item><item><description>pause2	        2nd pause</description></item><item><description>3q	            3rd quarter</description></item><item><description>pause3	        3rd pause</description></item><item><description>4q	            4th quarter</description></item><item><description>ended	        The match has ended</description></item><item><description>ot	            Overtime (Used during the entire overtime)</description></item><item><description>interrupted	    The match has been interrupted</description></item><item><description>awaiting_ot	    Waiting for overtime to start</description></item><item><description>after_ot	        Overtime is finished</description></item></list>
            
            Handball:
            <list type="bullet"><item><description>not_started	    Not started yet</description></item><item><description>1p	            1st period of the match</description></item><item><description>paused	        Match pause</description></item><item><description>2p	            2nd period of the match</description></item><item><description>ended	        The match has ended</description></item><item><description>awaiting_ot	    Waiting for overtime to start</description></item><item><description>ot	            Overtime (when normal time is over)</description></item><item><description>1p_ot	        1st overtime period</description></item><item><description>ot_ht	        Pause between 1st and 2nd overtime period</description></item><item><description>2p_ot	        2nd overtime period</description></item><item><description>after_ot	        Overtime is finished</description></item><item><description>awaiting_pen	    Waiting for penalty shooting to start</description></item><item><description>pen	            Penalty shooting</description></item><item><description>ended	        The match has ended</description></item><item><description>interrupted	    The match has been interrupted</description></item></list>
            
            Volleyball:
            <list type="bullet"><item><description>not_started	    Not started yet</description></item><item><description>1set	            1st set</description></item><item><description>pause1	        1st pause</description></item><item><description>2set	            2nd set</description></item><item><description>pause2	        2nd pause</description></item><item><description>3set	            3rd set</description></item><item><description>pause3	        3rd pause</description></item><item><description>4set	            4th set</description></item><item><description>pause4	        4th pause</description></item><item><description>5set	            5th set</description></item><item><description>ended	        The match has ended</description></item><item><description>walkover	        A player won the match on walkover</description></item><item><description>retired	        The match is ended because a player has retired</description></item><item><description>delayed	        The match start is delayed</description></item><item><description>interrupted	    The match has been interrupted</description></item><item><description>gset	            Used if there is a golden set</description></item></list>
            
            Beach volleyball:
            <list type="bullet"><item><description>not_started	    Not started yet</description></item><item><description>1set	            1st set</description></item><item><description>pause1	        1st pause</description></item><item><description>2set	            2nd set</description></item><item><description>pause2	        2nd pause</description></item><item><description>3set	            3rd set</description></item><item><description>ended	        The match has ended</description></item><item><description>walkover	        A player won the match on walkover</description></item><item><description>retired	        The match is ended because a player has retired</description></item><item><description>delayed	        The match start is delayed</description></item><item><description>interrupted	    The match has been interrupted</description></item><item><description>gset	            Used if there is a golden set</description></item></list>
            
            Futsal:
            <list type="bullet"><item><description>not_started	    Not started yet</description></item><item><description>1p	            1st period of the match</description></item><item><description>paused	        Match pause</description></item><item><description>2p	            2nd period of the match</description></item><item><description>ended	        The match has ended</description></item><item><description>awaiting_ot	    Waiting for overtime to start</description></item><item><description>ot	            Overtime (when normal time is over)</description></item><item><description>1p_ot	        1st overtime period</description></item><item><description>ot_ht	        Pause between 1st and 2nd overtime period</description></item><item><description>2p_ot	        2nd overtime period</description></item><item><description>after_ot	        Overtime is finished</description></item><item><description>awaiting_pen	    Waiting for penalty shooting to start</description></item><item><description>pen	            Penalty shooting</description></item><item><description>ended	        The match has ended</description></item><item><description>interrupted	    The match has been interrupted</description></item></list>
            
            Baseball:
            <list type="bullet"><item><description>not_started     Not started yet</description></item><item><description>1IT             1st inning top</description></item><item><description>BT1B1           Break 1st top 1st bottom</description></item><item><description>1IB             1st inning bottom</description></item><item><description>BT2B1           Break 2nd top 1st bottom</description></item><item><description>2IT             2nd inning top</description></item><item><description>BT2B2           Break 2nd top 2nd bottom</description></item><item><description>2IB             2nd inning bottom</description></item><item><description>BT3B2           Break 3rd top 2nd bottom</description></item><item><description>3IT             3rd inning top</description></item><item><description>BT3B3           Break 3rd top 3rd bottom</description></item><item><description>3IB             3rd inning bottom</description></item><item><description>BT4B3           Break 4th top 3rd bottom</description></item><item><description>4IT             4th inning top</description></item><item><description>BT4B4           Break 4th top 4th bottom</description></item><item><description>4IB             4th inning bottom</description></item><item><description>BT5B4           Break 5th top 4th bottom</description></item><item><description>5IT             5th inning top</description></item><item><description>BT5B5           Break 5th top 5th bottom</description></item><item><description>5IB             5th inning bottom</description></item><item><description>BT6B5           Break 6th top 5th bottom</description></item><item><description>6IT             6th inning top</description></item><item><description>BT6B6           Break 6th top 6th bottom</description></item><item><description>6IB             6th inning bottom</description></item><item><description>BT7B6           Break 7th top 6th bottom</description></item><item><description>7IT             7th inning top</description></item><item><description>BT7B7           Break 7th top 7th bottom</description></item><item><description>7IB             7th inning bottom</description></item><item><description>BT8B7           Break 8th top 7th bottom</description></item><item><description>8IT             8th inning top</description></item><item><description>BT8B8           Break 8th top 8th bottom</description></item><item><description>8IB             8th inning bottom</description></item><item><description>BT9B8           Break 9th top 8th bottom</description></item><item><description>9IT             9th inning top</description></item><item><description>BT9B9           Break 9th top 9th bottom</description></item><item><description>9IB             9th inning bottom</description></item><item><description>BTEIB9          Break EI top 9th bottom</description></item><item><description>EIT             Extra inning top</description></item><item><description>BTEIBEI         Break EI top EI bottom</description></item><item><description>EIB             Extra inning bottom</description></item></list>
            
            American Football:
            <list type="bullet"><item><description>not_started     Not started yet</description></item><item><description>1q              1st quarter</description></item><item><description>pause1          1st pause</description></item><item><description>2q              2nd quarter</description></item><item><description>pause2          2nd pause</description></item><item><description>3q              3rd quarter</description></item><item><description>pause3          3rd pause</description></item><item><description>4q              4th quarter</description></item><item><description>ended           The match has ended</description></item><item><description>ot              Overtime (Used during the entire overtime)</description></item><item><description>interrupted     The match has been interrupted</description></item><item><description>awaiting_ot     Waiting for overtime to start</description></item><item><description>after_ot        Overtime is finished</description></item></list>
            
            For Badminton:
            <list type="bullet"><item><description>not_started      Not started yet</description></item><item><description>1set	            1st set</description></item><item><description>pause1	        1st pause</description></item><item><description>2set	            2nd set</description></item><item><description>pause2	        2nd pause</description></item><item><description>3set	            3rd set</description></item><item><description>ended            The match has ended</description></item><item><description>walkover	        A player won the match on walkover</description></item><item><description>retired	        The match is ended because a player has retired</description></item><item><description>delayed	        The match start is delayed</description></item><item><description>interrupted	    The match has been interrupted</description></item><item><description>postponed	    The match has been postponed</description></item></list>
            
            For Rugby:
            <list type="bullet"><item><description>not_started	    Not started yet</description></item><item><description>1p	            1st period of the match</description></item><item><description>paused	        Match pause</description></item><item><description>2p	            2nd period of the match</description></item><item><description>ended	        The match has ended</description></item><item><description>awaiting_ot	    Waiting for overtime to start</description></item><item><description>ot	            Overtime (when normal time is over)</description></item><item><description>1p_ot	        1st overtime period</description></item><item><description>ot_ht	        Pause between 1st and 2nd overtime period</description></item><item><description>2p_ot	        2nd overtime period</description></item><item><description>after_ot	        Overtime is finished</description></item><item><description>awaiting_pen	    Waiting for penalty shooting to start</description></item><item><description>pen	            Penalty shooting</description></item><item><description>SD	            Sudden death</description></item><item><description>ended	        The match has ended</description></item><item><description>interrupted	    The match has been interrupted</description></item></list>
            
            For Dart:
            <list type="bullet"><item><description>not_started	    Not started yet</description></item><item><description>in_progress	    The match is in progress</description></item><item><description>paused	        Match pause</description></item><item><description>delayed	        The match start is delayed</description></item><item><description>interrupted	    The match has been interrupted</description></item><item><description>abandoned	    The match has been abandoned</description></item><item><description>walkover	        A player won the match on walkover</description></item><item><description>retired	        The match is ended because a player has retired</description></item></list></remarks>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.UNDEFINED">
      <summary>
            Undefined
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.NOT_STARTED">
      <summary>
            Not started
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.STARTED">
      <summary>
            Started
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM1P">
      <summary>
            1st period
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM2P">
      <summary>
            2nd period
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM3P">
      <summary>
            3rd period
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM4P">
      <summary>
            4th period
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM5P">
      <summary>
            5th period
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM1SET">
      <summary>
            1st set
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM2SET">
      <summary>
            2nd set
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM3SET">
      <summary>
            3rd set
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM4SET">
      <summary>
            4th set
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM5SET">
      <summary>
            5th set
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM6SET">
      <summary>
            6th set
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM7SET">
      <summary>
            7th set
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM1Q">
      <summary>
            1st quarter
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM2Q">
      <summary>
            2nd quarter
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM3Q">
      <summary>
            3rd quarter
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM4Q">
      <summary>
            4th quarter
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM1G">
      <summary>
            1st game
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM2G">
      <summary>
            2nd game
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM3G">
      <summary>
            3rd game
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM4G">
      <summary>
            4th game
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM5G">
      <summary>
            5th game
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.PAUSED">
      <summary>
            Paused
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.PAUSE1">
      <summary>
            1st pause
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.PAUSE2">
      <summary>
            2nd pause
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.PAUSE3">
      <summary>
            3rd pause
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.PAUSE4">
      <summary>
            4th pause
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.PAUSE5">
      <summary>
            5th pause
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.PAUSE6">
      <summary>
            6th pause
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.OT">
      <summary>
            Overtime
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.AWAITING_OT">
      <summary>
            Awaiting overtime
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM1P_OT">
      <summary>
            1st period overtime
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.OT_HT">
      <summary>
            Overtime halftime
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM2P_OT">
      <summary>
            2nd period overtime
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.AFTER_OT">
      <summary>
            After overtime
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.AWAITING_PEN">
      <summary>
            Awaiting penalties
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.PEN">
      <summary>
            Penalties
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.AFTER_PEN">
      <summary>
            After penalties
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ENDED">
      <summary>
            Ended
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.POSTPONED">
      <summary>
            Postponed
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.DELAYED">
      <summary>
            Delayed
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.CANCELED">
      <summary>
            Canceled, used in LiveOdds
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.CANCELLED">
      <summary>
            Cancelled, used in VHC, VDR, VTO
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.INTERRUPTED">
      <summary>
            Interrupted
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ABANDONED">
      <summary>
            Abandoned
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.WALKOVER">
      <summary>
            Walkover
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.WALKOVER1">
      <summary>
            1st walkover
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.WALKOVER2">
      <summary>
            2nd walkover
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.RETIRED">
      <summary>
            Retired
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.RETIRED1">
      <summary>
            1st retired
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.RETIRED2">
      <summary>
            2nd retired
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM1IT">
      <summary>
            1st inning (top)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM1IB">
      <summary>
            1st inning (bottom)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM2IT">
      <summary>
            2nd inning (top)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM2IB">
      <summary>
            2nd inning (bottom)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM3IT">
      <summary>
            3rd inning (top)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM3IB">
      <summary>
            3rd inning (bottom)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM4IT">
      <summary>
            4th inning (top)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM4IB">
      <summary>
            4th inning (bottom)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM5IT">
      <summary>
            5th inning (top)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM5IB">
      <summary>
            5th inning (bottom)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM6IT">
      <summary>
            6th inning (top)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM6IB">
      <summary>
            6th inning (bottom)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM7IT">
      <summary>
            7th inning (top)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM7IB">
      <summary>
            7th inning (bottom)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM8IT">
      <summary>
            8th inning (top)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM8IB">
      <summary>
            8th inning (bottom)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM9IT">
      <summary>
            9th inning (top)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM9IB">
      <summary>
            9th inning (bottom)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.EIT">
      <summary>
            Extra inning top
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.EIB">
      <summary>
            Extra inning bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.BT1B1">
      <summary>
            Break 1st top 1st bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.BT2B1">
      <summary>
            Break 2nd top 1st bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.BT2B2">
      <summary>
            Break 2nd top 2nd bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.BT3B2">
      <summary>
            Break 3rd top 2nd bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.BT3B3">
      <summary>
            Break 3rd top 3rd bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.BT4B3">
      <summary>
            Break 4th top 3rd bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.BT4B4">
      <summary>
            Break 4th top 4th bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.BT5B4">
      <summary>
            Break 5th top 4th bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.BT5B5">
      <summary>
            Break 5th top 5th bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.BT6B5">
      <summary>
            Break 6th top 5th bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.BT6B6">
      <summary>
            Break 6th top 6th bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.BT7B6">
      <summary>
            Break 7th top 6th bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.BT7B7">
      <summary>
            Break 7th top 7th bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.BT8B7">
      <summary>
            Break 8th top 7th bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.BT8B8">
      <summary>
            Break 8th top 8th bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.BT9B8">
      <summary>
            Break 9th top 8th bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.BT9B9">
      <summary>
            Break 9th top 9th bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.BTEIB9">
      <summary>
            Break EI top 9th bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.BTEIBEI">
      <summary>
            Break EI top EI bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.GSET">
      <summary>
            Golden set
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.SD">
      <summary>
            Sudden death
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.AFTER_SD">
      <summary>
            After sudden death
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.IN_PROGRESS">
      <summary>
            In progress
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.SESSION_BREAK">
      <summary>
            Session break
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.DEFAULTED1">
      <summary>
            Defaulted 1
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.DEFAULTED2">
      <summary>
            Defaulted 2
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM1I_HT">
      <summary>
            First innings, home team
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM1I_AT">
      <summary>
            First innings, away team
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM2I_HT">
      <summary>
            Second innings, home team
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM2I_AT">
      <summary>
            Second innings, away team
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.AWAITING_SO">
      <summary>
            Awaiting super over
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.SO_HT">
      <summary>
            Super over, home team
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.SO_AT">
      <summary>
            Super over, away team
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.AFTER_SO">
      <summary>
            After super over
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.INNINGS_BREAK">
      <summary>
            Innings break
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.SO_BREAK">
      <summary>
            Super over break
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.LUNCH_BREAK">
      <summary>
            Lunch break
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.TEA_BREAK">
      <summary>
            Tea break
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.STUMPS">
      <summary>
            Stumps
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.INJURY_BREAK">
      <summary>
            Injury break
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.AWAITING_SD">
      <summary>
            Awaiting sudden death
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM1MAP">
      <summary>
            First map
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM2MAP">
      <summary>
            Second map
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM3MAP">
      <summary>
            Third map
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM4MAP">
      <summary>
            Fourth map
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM5MAP">
      <summary>
            Fifth map
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM6MAP">
      <summary>
            Sixth map
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventStatus.ITEM7MAP">
      <summary>
            Seventh map
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsMatchEarlyBetStatus">
      <summary>
            Early bet status
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsMatchEarlyBetStatus.UNDEFINED">
      <summary>
            Undefined
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsMatchEarlyBetStatus.STARTED">
      <summary>
            Started
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsMatchEarlyBetStatus.STOPPED">
      <summary>
            Stopped
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsReplyType">
      <summary>
            Message reply type that identifies the type of message coming from betradar.com. 
            This attribute is used for replies to error, current, unregister, register and score requests from clients.
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsReplyType.UNDEFINED">
      <summary>
            Undefined
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsReplyType.CURRENT">
      <summary>
            Reply to Current request from client
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsReplyType.ERROR">
      <summary>
            Reply to Error request from client
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsReplyType.REGISTER">
      <summary>
            Reply to Register request from client
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsReplyType.UNREGISTER">
      <summary>
            Reply to Unregister request from client
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsReplyType.SCOREANDCARDSUMMARY">
      <summary>
            Reply to ScoreAndCard request from client
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsReplyType.RISKADJUSTMENT_UPDATE">
      <summary>
            Risk adjustment notification
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsServerType">
      <summary>
            Live odds feed server type
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsServerType.UNDEFINED">
      <summary>
            Undefined
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsServerType.LIVEODDS">
      <summary>
            Regular Live odds feed.
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsServerType.SCOUTMATCH">
      <summary>
            Live odds with scout matches delivered in the same feed as regular matches.
            This is an extension to the regular LiveOdds feed and needs to be purchased first.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsStatus">
      <summary>
            Live Odds status specifying the actual message type (e.g. current, clearbet, change, score, cards, etc.)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsStatus.UNDEFINED">
      <summary>
            Undefined
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsStatus.BETSTOP">
      <summary>
            Bet stop message status
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsStatus.BETSTART">
      <summary>
            Bet start message status
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsStatus.CHANGE">
      <summary>
            Change message status
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsStatus.ALIVE">
      <summary>
            Alive message status
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsStatus.CLEARBET">
      <summary>
            Clear bet message status
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsStatus.CANCELBET">
      <summary>
            Cancel bet message status
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsStatus.UNDOCANCELBET">
      <summary>
            Undo cancel bet message status
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsStatus.ROLLBACK">
      <summary>
            Bet clear rollback message status
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsStatus.SCORE">
      <summary>
            Score message status
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsStatus.CARDS">
      <summary>
            Cards message status
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsStatus.LOGINOK">
      <summary>
            Login OK message status
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsStatus.LOGINFAILED">
      <summary>
            Login failed message status
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsStatus.META">
      <summary>
            Meta info message status
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsStatus.ERROR">
      <summary>
            Error message status
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsStatus.REPLYSTART">
      <summary>
            Reply start message status
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsStatus.REPLYEND">
      <summary>
            Reply end message status
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsStatus.TRANSLATION">
      <summary>
            Translation message status
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsStatus.IRRELEVANTCHANGE">
      <summary>
            Irrelevant change message status
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsStatus.RESULT">
      <summary>
            Race result status
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsTypeFieldStatus">
      <summary>
            Odds field status used during bet type registration.
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsTypeFieldStatus.UNDEFINED">
      <summary>
            None
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsTypeFieldStatus.ITEM0">
      <summary>
            0
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsTypeFieldStatus.ITEM1">
      <summary>
            1
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsTypeFieldStatus.ITEM2">
      <summary>
            2
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase">
      <summary>
            Interface describing events and methods common for all LiveOdds feeds
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.GetEventList(System.Nullable{System.DateTime},System.Nullable{System.DateTime},System.Boolean)">
      <summary>
            Request meta-information about all events(matches, races, outcomes, ...) in a given interval. The maximum interval is 10 days.
            If no date is specified, all events started 24 hours in the past, and 7 days in the future are returned. 
            The response message includes teams playing, event date and time, TV channel names and sport/category/tournament for every event.
            </summary>
      <param name="from">Start of time interval</param>
      <param name="to">End of time interval</param>
      <param name="include_available">Include matches that are available for booking but not booked yet.</param>
      <returns>Returns immediately with the request number or zero, but expect to receive <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnMetaInfo" /> event in response</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.GetEventList(System.Collections.Generic.IEnumerable{System.Int64})">
      <summary>
            Request meta-information about the events(matches, races) specified by it's ids
            The response message includes teams playing, match date and time, TV channel names and sport/category/tournament for every match.
            </summary>
      <param name="event_ids">Return meta info only for the matches specified.</param>
      <returns>Returns immediately with the request number or zero, but expect to receive <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnMetaInfo" /> event in response</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.GetEventMessages(System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Boolean)">
      <summary>
            Request exact match messages ("error" server request).
            </summary>
      <param name="match_id">Match id</param>
      <param name="from">Sequence number of the first included message (null means 1)</param>
      <param name="to">Sequence number of the last included message or greater (null means MaxValue)</param>
      <param name="package">
            All replies get packaged in one see <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnEventMessages" /> when true;
            else normal events will get invoked.
            </param>
      <returns>
            Returns immediately with the request number or zero but expect to receive an event afterwards.
            </returns>
      <remarks>
            Notice that the reply is throttled on the server so it may take some minutes to receive the whole reply.
            
            SDK already handles error recovery for on-going matches, no matter whether there is a crash or 
            connection to the server is lost, so during normal operation there should be no need to call
            this method! 
            
            </remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.GetEventStatus(System.Int64,System.Nullable{System.DateTime},System.Boolean)">
      <summary>
            Requests the match status for a given time ("current" server request). 
            This includes odds, activation of odds and match status for the match requested,
            current bet status and all bet clearing messages before the timestamp.
            </summary>
      <param name="event_id">Match id</param>
      <param name="from">Match status on particular time (leave null for current match status)</param>
      <param name="package">
            All replies get packaged in one see <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnEventStatus" /> when true;
            else normal events will get invoked.
            </param>
      <returns>
            Returns immediately with the request number or zero but expect to receive an event afterwards.
            </returns>
      <remarks>
            SDK already handles error recovery for on-going matches, no matter whether there is a crash or 
            connection to the server is lost, so during normal operation there should be no need to call
            this method! 
            
            The purpose of it is for book-keeping after a match has ended.
            For instance after a match is not active anymore you might want to settle all open bets or
            check whether a match is really about to start.
            
            Notice that the match messages do not include a message number (msgnr). The received "state" is an
            abstract concept derived from the sent messages not any sent message so it cannot have a sequence number.
            If you are interested in replaying certain messages for a match you could try <see cref="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.GetEventMessages(System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Boolean)" />.
            </remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.GetEventsStatus(System.Collections.Generic.IEnumerable{System.Int64},System.Nullable{System.DateTime},System.Boolean)">
      <summary>
            Requests the match statuses for a given time ("current" server request). 
            This includes odds, activation of odds and match status for the matches requested,
            current bet status and all bet clearing messages before the timestamp.
            </summary>
      <param name="event_id">Match ids, maximum is 50 per request to avoid having server queue filling up</param>
      <param name="from">Matches statuses on particular time (leave null for current match status)</param>
      <param name="package">
            All replies get packaged in one see <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnEventStatus" /> when true;
            else normal events will get invoked.
            </param>
      <returns>
            Returns immediately with the request number or zero but expect to receive an event afterwards.
            </returns>
      <remarks>
            SDK already handles error recovery for on-going matches, no matter whether there is a crash or 
            connection to the server is lost, so during normal operation there should be no need to call
            this method! 
            
            The purpose of it is for book-keeping after a match has ended.
            For instance after a match is not active anymore you might want to settle all open bets or
            check whether a match is really about to start.
            
            Notice that the match messages do not include a message number (msgnr). The received "state" is an
            abstract concept derived from the sent messages not any sent message so it cannot have a sequence number.
            If you are interested in replaying certain messages for a match you could try <see cref="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.GetEventMessages(System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Boolean)" />.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.IsConnectionStable">
      <summary>
            Is the current connection stable enough to accept bets safely?
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnBetCancel">
      <summary>
            Signals that odds type for a match should be cancelled due to some reason.
            All bets accepted on the odds with that Id should be cancelled and cashed out with an odd of 1,0 (stakes returned).
            If the starttime and endtime are also specified, then only bets accepted in this interval should be cancelled.
            The starttime and endtime are timestamps in UTC.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnBetCancelUndo">
      <summary>
            Signals that an odds type has been cancelled due to some reason when it actually shouldn’t have been. 
            This can be undone. The Odds element should match the Odds element in the corresponding OnCancelBet event.
            The same goes for the starttime and endtime - they should match the values in the OnCancelBet event.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnBetClear">
      <summary>
        <para>
            Signals that situation occurred during the match so that a bet can be decided. 
            Timestamp - time indicates the time at which the bet clear event happened.
            The event also contains the cleared score with an Odds element indicating the odds type, 
            and this again with each EventOddsField, and the status of the outcomes (true/false). 
            </para>
        <para>
            Id in the Odds element corresponds to the Odds elements in one of the previous OnOddsChange events.
            Evaluation of the bet outcomes is the responsibility of the client system.
            </para>
      </summary>
      <remarks>
        <para>
            Some bettypes, like asian handicap and asian total, can include void factor for each EventOddsField element. 
            Void factor can either be 1 or 0.5 indicating that the whole or half the bet is voided and should be refunded to the customer. 
            When the void factor is set to 0.5 the outcome attribute will indicate if the other half has won or lost. 
            </para>
        <para>
            These are all possible combinations of outcome and void factors:
            <list type="number"><item><description>outcome="0" and no voidfactor: Lose entire bet</description></item><item><description>outcome="1" and no voidfactor: Win entire bet</description></item><item><description>outcome="0" and voidfactor="1": Refund entire bet</description></item><item><description>outcome="1" and voidfactor="0.5": Refund half bet and win other half</description></item><item><description>outcome="0" and voidfactor="0.5": Refund half bet and lose other half</description></item></list></para>
      </remarks>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnBetClearRollback">
      <summary>
            Signals that there was some wrong information sent out about bet clearing.
            Notification includes the Odds element that rollback is targeted to.
            The clearedscore contains the cleared score of the original bet clearing. 
            The time for the original bet clearing is timestamp – time seconds.
            The Odds element includes a list of EventOddsField elements to indicate what field was cleared in the original bet clearing. 
            The Client system is responsible to handle this accordingly.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnBetStart">
      <summary>
            Signals that bets for a specific match can open again after they have been stopped.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnBetStop">
      <summary>
            Signals that a bet stop situation occurred for a specific match.
            OnBetStart event is triggered when the bets can open again.
            </summary>
      <remarks>
            Bet stop is triggered after following events take place: 
            <list type="number"><item><description>Goals</description></item><item><description>Red cards</description></item><item><description>Penalty</description></item><item><description>One on one situations</description></item><item><description>Free kicks within 20 meters</description></item><item><description>Match is interrupted temporarily</description></item></list>
            
            Administrative events which cause a bet stop condition:
            <list type="number"><item><description>Loss of TV coverage</description></item><item><description>Loss of connection to the scout</description></item></list></remarks>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnConnectionStable">
      <summary>
            Signals that the initial sync is complete and the connection to the server is stable.
            </summary>
      <remarks>
            Only after this event match state changes SHOULD be processed (and bets accepted).
            Messages received before that event should not be completely ignored, but handled with care.
            </remarks>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnConnectionUnstable">
      <summary>
            Signals that the connection is unstable.
            </summary>
      <remarks>
            After this event match state changes SHOULD NOT be processed (and bets accepted).
            Messages received after that event should not be completely ignored, but handled with care.
            </remarks>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnEventMessages">
      <summary>
            Signals that all of the requested match messages were received.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnEventStatus">
      <summary>
            Signals that a requested match status was received.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnMetaInfo">
      <summary>
            Event contains information like the date and time of the match, sport, category, tournament, teams and what TV-channels a match is broadcasted on.
            When a match is removed, Active is set to false for the match with an optional textual reason why the match has been removed.
            Active flag can also set to false if the client has unregistered a match. The message element will include the text unregistered in such cases.
            Match meta-information will also be broadcasted when a match is added to the system, or when a match has been cancelled.
            </summary>
      <remarks>
        <para>
            The teams have two id's; one named id and another named uniqueid. 
            The id is for that team in that tournament, and the uniqueid is for that team in all tournaments. 
            Not all teams have the uniqueid attribute, so it should only be used to identify that two teams in different tournaments are the same.
            </para>
        <para>
            It is possible to include you own match id’s in the meta message. 
            To do this you need to contact our support team, so they can setup this. 
            When this is done an extra attribute named SourceId will be included in the meta event. 
            It will be left empty if we are missing your id for a particular match.
            </para>
      </remarks>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnOddsChange">
      <summary>
            Signals that an odds change has occurred, specifying all odds types for a particular match. 
            Odds types that are active will contain odds fields, while inactive odds types will not.
            Each odds type also has a Changed flag indicating whether this odds type has been changed or not. 
            Score indicates the current score in the match.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetStopReason">
      <summary>
            Reason abut a bet stop.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetStopReason.#ctor(System.String,System.Int32)">
      <summary>
            Reason for betstop.
            </summary>
      <param name="reason">textual reason description</param>
      <param name="id">id of the reason</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetStopReason.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetStopReason.Id">
      <summary>
            Betstop reason id.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetStopReason.Reason">
      <summary>
            Explanation of the betstop.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventHeader">
      <summary>
            Contains core data about an event.
            Base class for <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceHeader" /> and <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.MatchHeader" /></summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventHeader.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventHeader.Active">
      <summary>
            Set to false when a match is removed (in this case also see the <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventHeader.Message" /> for the reason for removal).
            Also set to false if the client has unregistered a match. The message element will include the text "unregistered" in such case.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventHeader.BetStatus">
      <summary>
            Current bet status
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventHeader.Id">
      <summary>
            Betradar id for the event 
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventHeader.Message">
      <summary>
            Optional textual message attached to the match (e.g. why a match has been removed, 
            information that a client has unregistered from a match, etc.)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventHeader.Msgnr">
      <summary>
            Incremental message id that starts with 1 for every match.
            Only messages that changes the state of a match will include this property.
            Alive messages, meta-information and login response messages will not include this incremental id.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventHeader.Status">
      <summary>
            Event status
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOdds">
      <summary>
            Match odds and corresponding odd fields.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOdds.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOdds.Active">
      <summary>
            Whether odds are active or not
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOdds.Changed">
      <summary>
            Indicates if this odds type has been changed or not.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOdds.Combination">
      <summary>
            Contains information about combination of bets and can have values of 0 – 4, 
            where 0 indicates unlimited combination, 1 indicates single bet 
            and 2-4 indicates 2-4 combinations, respectively.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOdds.ForTheRest">
      <summary>
            Contains the handicap value for the rest of the match in addition to the special odds value which reflects 
            the handicap value for the whole match.
            </summary>
      <remarks>
            Available only with "Include Asian Handicap spread for the rest for all Asian Handicap markets" turned on.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOdds.Freetext">
      <summary>
            The freetext as received from the server.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOdds.Id">
      <summary>
            Unique identifier for this particular odds in this match, and will be used whenever this odds is sent out. 
            This id will also be used when this odds is cleared.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOdds.MostBalanced">
      <summary>
            Marks the most balanced odds of an odds type.
            </summary>
      <remarks>
            Present only if "Mark most balanced odds" XML configuration settings has been activated.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOdds.Name">
      <summary>
            Specifies the textual description of this odds (international value is freetext)
            (e.g. subtype="2" freetext="Which team has kick off?".)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOdds.OddsFields">
      <summary>
            Collection of odds fields.
            Odds types that are active contain odds fields, while inactive odds types do not.
            Key is represented by the odds type.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOdds.SpecialOddsValue">
      <summary>
            Special odds values are specified only for some odds types like total, handicap and freetext3way/2way/nway.
            This indicates the total value, handicap value or freetext details respectively.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOdds.SubType">
      <summary>
            Specifies with the freetext odds and tells what kind of freetext odds this is
            (e.g. subtype="2" freetext="Which team has kick off?".)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOdds.Type">
      <summary>
            Odds type
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOdds.TypeId">
      <summary>
            Odds type id that is the same for this odds type in all matches.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsField">
      <summary>
            Match odds field specifying each outcome for a specific odds type.
            Only odds types that are active contain odds fields.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsField.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsField.Active">
      <summary>
            Whether odds field is active or not.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsField.Outcome">
      <summary>
            Status of the outcome. See also <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsField.VoidFactor" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsField.PlayerId">
      <summary>
            The ID of the player referenced in the bet.
            </summary>
      <remarks>
            Available only with "Include playerid in oddsfield tag" turned on.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsField.Probability">
      <summary>
            Outcome probability
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsField.Type">
      <summary>
            Type of odds field (e.g. over, under, etc.)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsField.TypeId">
      <summary>
            Optional odds type id
            </summary>
      <remarks>
            Available only with "Include typeid in oddsfield tag" turned on.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsField.Value">
      <summary>
            Odds field value
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsField.ViewIndex">
      <summary>
            Returns the original index(position) of EventOddsField as SDK stores them in a IDictionary
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsField.VoidFactor">
      <summary>
            Void factor can either be 1 or 0.5, indicating that the whole or half of the bet is voided
            and should be refunded to the customer. When the void factor is set to 0.5, the <see cref="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsField.Outcome" />
            will indicate if the other half has won or lost.
            </summary>
      <remarks>
            Only some bet types, like asian handicap and asian total, can include void factor.
            Possible combinations of outcome and void factor:
            <list type="bullet"><item><description>outcome="0" and no void factor: Lose entire bet</description></item><item><description>outcome="1" and no void factor: Win entire bet</description></item><item><description>outcome="0" and void factor="1": Refund entire bet</description></item><item><description>outcome="1" and void factor="0.5": Refund half bet and win other half</description></item><item><description>outcome="0" and void factor="0.5": Refund half bet and lose other half</description></item></list></remarks>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsLite">
      <summary>
            Match odds used for bet type registration request (i.e. activation and deactivation of odds types and fields).
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsLite.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsLite.SubType">
      <summary>
            Specified with the freetext odds and tells what kind of freetext odds this is
            (e.g. subtype="2" freetext="Which team has kick off?".)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventOddsLite.Type">
      <summary>
            Odds type
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.MetaInfoDataContainer">
      <summary>
            Base class for data contained in <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.MetaInfo" />.
            Classes extending this one are <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.LiveOddsMetaData" /> and <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.RaceMetaData" /></summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.RaceResultEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.RaceLiveOdds.Common.ILiveOddsRace.OnRaceResult" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.RaceResultEventArgs.RaceResult">
      <summary>
            Entity that contains all the info about the event
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetCancelUndoEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnBetCancelUndo" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetCancelUndoEventArgs.BetCancelUndo">
      <summary>
            Entitiy that contains all the info about the event
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetClearRollbackEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnBetClearRollback" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetClearRollbackEventArgs.BetClearRollback">
      <summary>
            Entitiy that contains all the info about the event
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetStopEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnBetStop" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetStopEventArgs.BetStop">
      <summary>
            Entitiy that contains all the info about the event
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventDataReceivedEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnEventMessages" /> and <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnEventStatus" />.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventDataReceivedEventArgs.#ctor(System.Int64,System.Collections.Generic.List{Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsEntityBase})">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventDataReceivedEventArgs" /> class
            </summary>
      <param name="replyNr">A value generated when the request was issued to feed server</param>
      <param name="messages">A <see cref="T:System.Collections.Generic.List`1" /> containing messages associated with the <code>replyNr</code></param>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventDataReceivedEventArgs.ReplyNr">
      <summary>
            Reply number which correspond with request number
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.EventDataReceivedEventArgs.Messages">
      <summary>
            All the received messages.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.AliveEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommon.OnAlive" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.AliveEventArgs.Alive">
      <summary>
            Entitiy that contains all the info about the event
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetCancelEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnBetCancel" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetCancelEventArgs.BetCancel">
      <summary>
            Entity that contains all the info about the event
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetClearEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnBetClear" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetClearEventArgs.BetClear">
      <summary>
            Entitiy that contains all the info about the event
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetStartEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnBetStart" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.BetStartEventArgs.BetStart">
      <summary>
            Entity that contains all the info about the event
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.MetaInfoEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnMetaInfo" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.MetaInfoEventArgs.MetaInfo">
      <summary>
            Entitiy that contains all the info about the event
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsChangeEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.Common.ILiveOddsCommonBase.OnOddsChange" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.OddsChangeEventArgs.OddsChange">
      <summary>
            Entitiy that contains all the info about the event
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.ScoreCardSummaryEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveOdds.LiveOdds.ILiveOdds.OnScoreCardSummary" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.ScoreCardSummaryEventArgs.ScoreCardSummary">
      <summary>
            Entitiy that contains all the info about the event
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.UserRequest">
      <summary>
            Use requests.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveOdds.Common.UserRequest.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.LiveOdds.Common.UserRequest" /> class.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveOdds.Common.UserRequest.List">
      <summary>
            Gets or sets the list.
            </summary>
      <value>
            The list.
            </value>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.ConnectionTest">
      <summary>
            Connection test.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.ConnectionTest.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ConnectionTest.EventId">
      <exclude />
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ConnectionTest.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.Lineups">
      <summary>
            The current lineup.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.Lineups.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Lineups.MatchId">
      <summary>
            Match ID.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Lineups.Players">
      <summary>
            List of players in lineup
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Lineups.Managers">
      <summary>
            Team managers
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Lineups.TeamOfficals">
      <summary>
            Team officals
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Lineups.EventId">
      <exclude />
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Lineups.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.MatchBooking">
      <summary>
            Match booking reply. This reply is sent when a client books a match.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.MatchBooking.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchBooking.MatchId">
      <summary>
            The ID of the match booking reply is for.
            </summary>
      <remarks>
            Currently broken on the server and null is always returned.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchBooking.Message">
      <summary>
            If the match booking fails for any reason (match already bought, match finished etc.), 
            the message will contain an explanation.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchBooking.Result">
      <summary>
            Result of match booking (either valid or invalid)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchBooking.EventId">
      <exclude />
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchBooking.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.MatchData">
      <summary>
            Match time information during a game.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.MatchData.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchData.MatchId">
      <summary>
            Match id.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchData.MatchTime">
      <summary>
            Match time.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchData.RemainingTimeInPeriod">
      <summary>
            Specifies the remaining time in this period (when this applies).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchData.EventId">
      <exclude />
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchData.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.MatchList">
      <summary>
            List of matches in the time frame requested by the client.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.MatchList.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchList.Matches">
      <summary>
            List of matches in the time frame requested by the client.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchList.EventId">
      <exclude />
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchList.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.MatchListUpdate">
      <summary>
            List of matches sent unsolicited from server (uses same format as MatchList for now).
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.MatchListUpdate.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.MatchStop">
      <summary>
            Reply sent when a client unsubscribes from a match or when a match subscription failed.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.MatchStop.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchStop.MatchId">
      <summary>
            Match id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchStop.Reason">
      <summary>
            Reason for match subscription failure or notification that un-subscription was successful.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchStop.EventId">
      <exclude />
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchStop.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate">
      <summary>
            Match information message. Contains statistical information about a match
            as well as individual events (e.g. goals, cards, etc.).
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.Attacks">
      <summary>
            Attacks statistics.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.BlackCards">
      <summary>
            Black cards (badminton).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.Category">
      <summary>
            Sport category.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.Corners">
      <summary>
            Corner statistics.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.Court">
      <summary>
            Type of court.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.DangerousAttacks">
      <summary>
            Dangerous attack statistics.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.DirectFoulsPeriod">
      <summary>
            Direct fouls for current period statistics (futsal).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.DirectFreeKicks">
      <summary>
            Direct free kicks statistics (futsal).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.Events">
      <summary>
            List of scout events.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.FreeKicks">
      <summary>
            Free kick statistics.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.FreeThrows">
      <summary>
            Free throws statistics.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.GoalkeeperSaves">
      <summary>
            Goal keeper saves statistics.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.GoalKicks">
      <summary>
            Goal kick statistics.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.Gold">
      <summary>
            Gets the gold.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.IceConditions">
      <summary>
            Ice conditons
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.Injuries">
      <summary>
            Injuries statistics.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.Innings">
      <summary>
            Innings
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.IsTieBreak">
      <summary>
            Whether the match is currently in tie break status (tennis).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.KickoffTeam">
      <summary>
            Kickoff team
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.KickoffTeamFirstHalf">
      <summary>
            Kickoff team
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.KickoffTeamOt">
      <summary>
            Kickoff team
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.KickoffTeamSecondHalf">
      <summary>
            Kickoff team
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.MatchFormat">
      <summary>
            Match format
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.MatchHeader">
      <summary>
            Basic match information.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.MatchStatus">
      <summary>
            Current match status. Same status codes as in LiveOdds and LiveScore.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.MatchStatusStart">
      <summary>
            Time stamp for when match status was set in UTC.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.Networth">
      <summary>
            Gets the networth.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.Offsides">
      <summary>
            Offside statistics.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.OpeningFaceoff1StPeriod">
      <summary>
            Opening faceoff 1st period
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.OpeningFaceoff2NdPeriod">
      <summary>
            Opening faceoff 2nd period
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.OpeningFaceoff3RdPeriod">
      <summary>
            Opening faceoff 3rd period
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.OpeningFaceoffOvertime">
      <summary>
            Opening faceoff overtime
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.Penalties">
      <summary>
            Penalties statistics.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.PitchConditions">
      <summary>
            Pitch / grass conditions.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.PossesionTeam">
      <summary>
            Which team currently has possession of the ball.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.Possession">
      <summary>
            Ball possession statistics.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.RedCards">
      <summary>
            Red card statistics.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.Score">
      <summary>
            Match score information.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.Scout">
      <summary>
            Scout
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.Serve">
      <summary>
            Which player/team currently has the serve (tennis, volleyball).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.ShotsBlocked">
      <summary>
            Shots blocked statistics.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.ShotsOffTarget">
      <summary>
            Shots off target statistics.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.ShotsOnTarget">
      <summary>
            Shots on target statistics.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.Sport">
      <summary>
            Type of sport.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.SurfaceType">
      <summary>
            Surface type (tennis).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.Suspensions">
      <summary>
            Suspensions statistics.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.Throwins">
      <summary>
            Throw-in statistics.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.Tournament">
      <summary>
            Sport tournament.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.WeatherConditions">
      <summary>
            Weather conditions.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.YellowCards">
      <summary>
            Yellow cards statistics.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.EventId">
      <exclude />
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.OddsSuggestions">
      <summary>
            Suggested live odds for the match which are generated based on statistical models.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.OddsSuggestions.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.OddsSuggestions.MatchId">
      <summary>
            Match id.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.OddsSuggestions.Odds">
      <summary>
            Collection of suggested odd values for this match.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.OddsSuggestions.EventId">
      <exclude />
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.OddsSuggestions.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.Player">
      <summary>
            A player in the lineup.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.Player.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Player.Id">
      <summary>
            ID of the player.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Player.MatchRoles">
      <summary>
            Match roles
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Player.Attributes">
      <summary>
            Attributes
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Player.IsSubstitute">
      <summary>
            Is the player a substitute?
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Player.Name">
      <summary>
            Name of the player.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Player.Position">
      <summary>
            Player position
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Player.ShirtNumber">
      <summary>
            Shirt number.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Player.Team">
      <summary>
            Team of the player.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Player.Nickname">
      <summary>
            Player nickname
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Player.EventId">
      <exclude />
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Player.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.ScoutEntityBase">
      <summary>
            Serves as a base class that all LiveOdds entities should be derived from.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.ScoutEntityBase.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.ScoutInfos">
      <summary>
            Match information messages (e.g. Distance between teams, Pre-match avg. odds, etc.)
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.ScoutInfos.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutInfos.Infos">
      <summary>
            Collection of match information messages.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutInfos.MatchId">
      <summary>
            Match id.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutInfos.EventId">
      <exclude />
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutInfos.Priority">
      <exclude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.Manager">
      <summary>
            Team manager
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.Manager.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Manager.Id">
      <summary>
            Manager id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Manager.Name">
      <summary>
            Manager name
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Manager.Team">
      <summary>
            Home or Away team
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.TeamOffical">
      <summary>
            Team offical
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.TeamOffical.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.TeamOffical.Id">
      <summary>
            Manager id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.TeamOffical.Name">
      <summary>
            Manager name
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.TeamOffical.Team">
      <summary>
            Home or Away team
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.BookMatchResult">
      <summary>
            Book match result
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.BookMatchResult.UNDEFINED">
      <summary>
            Undefined
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.BookMatchResult.VALID">
      <summary>
            Valid
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.BookMatchResult.INVALID">
      <summary>
            Invalid
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.FormatType">
      <summary>
            Format type
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.LIMITEDOVERS">
      <summary>
            Limited overs
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.OVERS">
      <summary>
            Overs
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.DAYS">
      <summary>
            Days
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.MANDATORYPOWERPLAYOVERS">
      <summary>
            Mandatory powerplay overs
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.BATTINGPOWERPLAYOVERS">
      <summary>
            Batting powerplay overs
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.POWERPLAY1OVERS">
      <summary>
            Powerplay 1 overs
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.POWERPLAY2OVERS">
      <summary>
            Powerplay 2 overs
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.POWERPLAY3OVERS">
      <summary>
            Powerplay 3 overs
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.MAXOVERSPERBOWLER">
      <summary>
            Max overs per bowler
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.REVIEWS">
      <summary>
            Reviews
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.MAPS">
      <summary>
            Maps
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.ROUNDS">
      <summary>
            Rounds
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.OVERTIMEROUNDS">
      <summary>
            Overtime rounds
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.NUMBEROFPERIODS">
      <summary>
            Number of periods
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.PERIODLENGTH">
      <summary>
            Period length
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.TRYVALUE">
      <summary>
            Try value
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.CONVERSIONVALUE">
      <summary>
            Conversion value
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.PENALTYVALUE">
      <summary>
            Penalty value
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.DROPGOALVALUE">
      <summary>
            Drop goal value
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.PENALTYTRYVALUE">
      <summary>
            Penalty try value
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.NUMBEROVERTIMEPERIODS">
      <summary>
            Number overtime time periods
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.LENGTHOVERTIMEPERIODS">
      <summary>
            Length overtime periods
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.LENGTHSUDDENDEATH">
      <summary>
            Length sudden death
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.PENALTYSHOOTOUT">
      <summary>
            Penalty shootout
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.RULESET">
      <summary>
            Rule set
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.TWOPOINTCONVERSIONYARDLINE">
      <summary>
            Two point conversion yard line
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.EXTRAPOINTYARDLINE">
      <summary>
            Extra point yard line
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.NOBALLPENALTYVALUE">
      <summary>
            Penalty value of no ball
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.FormatType.TIEBREAKERMETHOD">
      <summary>
            How a tied match is resolved, if at all
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.IceConditions">
      <summary>
            Ice conditions
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.Inning">
      <summary>
            Inning half
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.Inning.T">
      <summary>
            Top
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.Inning.B">
      <summary>
            Bottom
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.Sex">
      <summary>
            Sex (gender) of the contestant or the whole team.
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.Sex.UNDEFINED">
      <summary>
            Undefined.
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.Sex.MALE">
      <summary>
            Male team or contestant.
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.Sex.FEMALE">
      <summary>
            Female team or contestant.
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.Sex.MIXED">
      <summary>
            Mixed team.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.Coverage">
      <summary>
            Type of match coverage.
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.Coverage.UNDEFINED">
      <summary>
            Undefined
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.Coverage.TV">
      <summary>
            TV coverage
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.Coverage.VENUE">
      <summary>
            Coverage from the venue
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.EventType">
      <summary>
            Event type. See LiveScout documentation to see which event types are supported for each sport.
            New event types can be offered in future.
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.UNDEFINED">
      <summary>
             Unknown, check event id
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TEMPORARY_INTERRUPTION">
      <summary>
             Temporary interruption
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.GAME_ON">
      <summary>
             Game on
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.GOAL">
      <summary>
             Goal
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.YELLOW_CARD">
      <summary>
             Yellow card
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SUSPENSION">
      <summary>
             Suspension
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.YELLOWRED_CARD">
      <summary>
             Yellow and red card
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BLUE_CARD">
      <summary>
            Yellow and red card
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.RED_CARD">
      <summary>
             Red card
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SUBSTITUTION">
      <summary>
             Substitution
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.INJURY_TIME">
      <summary>
             Injury time
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BALL_POSSESSION">
      <summary>
             Ball possession
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.FREE_KICK_COUNT">
      <summary>
             Free kick count
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.GOAL_KICK_COUNT">
      <summary>
             Goal kick count
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.THROW_IN_COUNT">
      <summary>
             Throw in count
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.OFFSIDE_COUNT">
      <summary>
             Offside count
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CORNER_KICK_COUNT">
      <summary>
             Corner kick count
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SHOT_ON_TARGET_COUNT">
      <summary>
             Shot on target count
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SHOT_OFF_TARGET_COUNT">
      <summary>
             Shot off target count
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.GOALKEEPER_SAVE_COUNT">
      <summary>
             Goalkeeper save count
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.FOUL">
      <summary>
             Foul at Basketball
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.FOULS_COUNT">
      <summary>
             Fouls count at Soccer
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.FREE_KICK">
      <summary>
             Free kick
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.GOAL_KICK">
      <summary>
             Goal kick
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.THROW_IN">
      <summary>
             Throw in
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.OFFSIDE">
      <summary>
             Offside
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CORNER">
      <summary>
             Corner
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SHOT_ON_TARGET">
      <summary>
             Shot on target
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SHOT_OFF_TARGET">
      <summary>
             Shot off target
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.GOALKEEPER_SAVE">
      <summary>
             Goalkeeper save
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.INJURY">
      <summary>
             Injury
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SEVEN_METER_THROW">
      <summary>
             7 meter throw at Handball
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PENALTY_AWARDED">
      <summary>
             Penalty awarded at Futsal
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PENALTY_SHOOTOUT">
      <summary>
             Penalty shootout at Ice Hockey
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.WEATHER_CONDITIONS">
      <summary>
             Weather conditions
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.ATTENDANCE">
      <summary>
             Attendance
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PLAYER_BACK_FROM_INJURY">
      <summary>
             Player back from injury
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SHOT_BLOCKED_COUNT">
      <summary>
             Shot blocked count
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SHOT_BLOCKED">
      <summary>
             Shot blocked
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SEVEN_METER_THROW_MISSED">
      <summary>
             7 meter throw missed at Handball
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PENALTY_MISSED">
      <summary>
             Penalty missed at Soccer
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PENALTY_SHOOTOUT_MISSED">
      <summary>
             Penalty shootout missed at Ice Hockey
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PENALTY_SHOOTOUT_EVENT_DEEP_COVERAGE">
      <summary>
             Penalty shootout event deep coverage
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BET_START">
      <summary>
             Bet start
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BET_STOP">
      <summary>
             Bet stop
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.KICKOFF_TEAM">
      <summary>
             Kick-off team at Soccer
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.WHICH_TEAM_STARTS_WITH_POSSESSION">
      <summary>
             Which team starts with possession at Ice Hockey
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.MATCH_STATUS">
      <summary>
             Match status
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PITCH_CONDITIONS">
      <summary>
             Pitch conditions
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.FREE_TEXT">
      <summary>
             Free text
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POSSIBLE_CORNER">
      <summary>
             Possible corner
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CANCELLED_CORNER">
      <summary>
             Cancelled corner
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POSSIBLE_GOAL">
      <summary>
             Possible goal
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CANCELLED_GOAL">
      <summary>
             Cancelled goal
             Extra info: 0 or -1(not specified, 1(off side, 2(foul, 3(incorrect entry, 4(out of bounds, 5(play stopped
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.WHICH_TEAM_SERVES_FIRST">
      <summary>
             Which team serves first
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.MATCH_ABOUT_TO_START">
      <summary>
             Match about to start
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TENNIS_SCORE_CHANGE">
      <summary>
             Tennis score change
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CANCELLED_POINT">
      <summary>
             Cancelled point
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DANGEROUS_ATTACK">
      <summary>
             Dangerous attack
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BALL_SAFE">
      <summary>
             Ball safe
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BALL_IN_PLAY">
      <summary>
             Ball in play at Volleyball and Beach Volleyball
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BALL_IN_PLAY_SERVICE_TAKEN">
      <summary>
             Ball in play / Service taken at Tennis
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TENNIS_SERVICE_FAULT">
      <summary>
             Tennis service fault
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.WHO_WON_JUMP_BALL">
      <summary>
             Who won jump ball
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.REBOUND">
      <summary>
             Rebound
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TIMEOUT">
      <summary>
             Timeout
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TIME_STARTSTOP">
      <summary>
             Time start/stop
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BASKETBALL_SCORE_CHANGE">
      <summary>
             Basketball score change
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BASKETBALL_SCORE_MISS">
      <summary>
             Basketball score miss
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.MANUAL_TIME_ADJUSTMENT">
      <summary>
             Manual time adjustment
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POSSIBLE_RED_CARD">
      <summary>
             Possible red card
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CANCELLED_RED_CARD">
      <summary>
             Cancelled red card
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POSSIBLE_7_METER_THROW">
      <summary>
             Possible 7 meter throw at Handball
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POSSIBLE_PENALTY">
      <summary>
             Possible penalty at Soccer, Ice Hockey and Futsal
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CANCELLED_PENALTY">
      <summary>
             Cancelled penalty
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DELETED_EVENT_ALERT">
      <summary>
             Deleted event alert
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.VOLLEYBALL_SCORE_CHANGE">
      <summary>
             Volleyball score change
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TIMEOUT_OVER">
      <summary>
             Timeout over
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SUSPENSION_OVER">
      <summary>
             Suspension over
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POSSIBLE_EMPTY_NET_SITUATION">
      <summary>
             Possible empty net situation
             Events (POSSIBLE_EMPTY_NET_SITUATION and EMPTY_NET_SITUATION) were switched on 2014-12-02
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.EMPTY_NET_SITUATION">
      <summary>
             Empty net situation
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.EMPTY_NET_SITUATION_OVER">
      <summary>
             Empty net situation over
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.EMPTY_NET_SITUATION_CANCELLED">
      <summary>
             Empty net situation cancelled
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.FREE_THROW">
      <summary>
             Free throw
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.NUMBER_OF_FREE_THROWS">
      <summary>
             Number of free throws
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.WHO_SERVES_FIRST_IN_TIE_BREAK_SET">
      <summary>
             Who serves first in tie break set
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DIRECT_FOUL">
      <summary>
             Direct foul
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DIRECT_FREE_KICK">
      <summary>
             Direct free kick
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SERVICE_TAKEN">
      <summary>
             Service taken
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BALL_POSITION">
      <summary>
             Ball position
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PLAY_RESUMES_AFTER_GOAL">
      <summary>
             Play resumes after goal
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.ENABLE_DISABLE_CORNER_MARKETS">
      <summary>
             Enable/disable corner markets
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.ENABLE_DISABLE_BOOKING_MARKETS">
      <summary>
             Enable/disable booking markets
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POSSIBLE_YELLOW_CARD">
      <summary>
             Possible yellow card
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CANCELLED_YELLOW_CARD">
      <summary>
             Cancelled yellow card
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.EARLY_BETSTATUS">
      <summary>
             Early bet status
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SCRUM_OUTCOME">
      <summary>
             Scrum outcome
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.MISSED_RUGBY_POINT">
      <summary>
             Missed rugby point
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.LINE_OUT">
      <summary>
             Line out
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.COVERAGE_STATUS">
      <summary>
             Coverage status
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PENALTY_SHOOTOUT_STARTING_TEAM">
      <summary>
             Penalty shootout starting team
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BALL_CHANGE_FREQUENCY">
      <summary>
             Ball change frequency
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CHAIR_UMPIRE_ON_COURT">
      <summary>
             Chair umpire on court (Tennis)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BREAK_DUE_TO_EXTREME_WEATHER_CONDITIONS">
      <summary>
             Break due to extreme weather conditions (Tennis)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BREAK_DUE_TO_EXTREME_WEATHER_CONDITIONS_OVER">
      <summary>
             Break due to extreme weather conditions over (Tennis)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TOILET_BREAK_OR_CHANGE_OF_ATTIRE">
      <summary>
             Toilet break / change of attire (Tennis)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TOILET_BREAK_OR_CHANGE_OF_ATTIRE_OVER">
      <summary>
             Toilet break / change of attire over (Tennis)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.MATCH_STOP_OR_SUSPENSION">
      <summary>
             Match stop / suspension (Tennis)
             Extra info:
             3(injury), 4(flood light failure), 5(persons entering field of play), 6 (crowd control issue),
             7(water break), 8(disciplinary issue), 9(gone to TMO (video referee))
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.MATCH_STOP_OR_SUSPENSION_OVER">
      <summary>
             Match stop / suspension over (Tennis)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CODE_VIOLATION">
      <summary>
             Code violation (Tennis)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TIME_VIOLATION">
      <summary>
             Time violation (Tennis)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TRAINER_CALLED">
      <summary>
             Trainer called (Tennis)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TRAINER_CALLED_FINISHED">
      <summary>
             Trainer called finished (Tennis)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.WHO_WON_COIN_TOSS">
      <summary>
             Who won coin toss (Tennis)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.WHO_MADE_FIRST_SERVER_DECISION">
      <summary>
             Who made first server decision (Tennis)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.WHICH_PLAYER_SERVES_FIRST_WITHIN_A_DOUBLES_TEAM">
      <summary>
             Which player serves first within a doubles team (Tennis)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.MATCH_CALLED">
      <summary>
             Match called (Tennis)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.WHICH_PLAYER_RECEIVES_FIRST_WITHIN_A_DOUBLES_TEAM">
      <summary>
             Which player receives first within a doubles team (Tennis)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.ATTACK">
      <summary>
             Attack (Tennis)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.REPLAY_OF_POINT">
      <summary>
             Replay of point (Tennis)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.WHICH_TEAM_STARTS_SERVING_ON_THE_LEFT_HAND_SIDE_OF_THE_UMPIRE">
      <summary>
             Which team starts serving on the left hand side of the umpire (Tennis)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DARTS_SCORE_CHANGE">
      <summary>
             Darts score change
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SINGLE_DART_THROW">
      <summary>
             Single dart throw
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BEST_OF_LEGS">
      <summary>
             Best of legs
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BEST_OF_FRAMES">
      <summary>
             Best of frames
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SNOOKER_SCORE_CHANGE">
      <summary>
             Snooker score change
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.UNSCHEDULED_BREAK">
      <summary>
             Unscheduled break
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BADMINTON_SCORE_CHANGE">
      <summary>
             Badminton score change
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BLACKCARD">
      <summary>
             Black card
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BALL_RECYCLED">
      <summary>
             Ball recycled
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BALL_KICKED">
      <summary>
             Ball kicked
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.NEW_PHASE">
      <summary>
             New phase
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SCRUM_RESET">
      <summary>
             Scrum reset
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.LINE_OUT_WON">
      <summary>
             Line out won
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TAP_AND_GO">
      <summary>
             Tap and go
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.RESET_PHASE_COUNT">
      <summary>
             Reset phase count
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.KICK_TO_TOUCH">
      <summary>
             Kick to touch
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TWENTYTWO_DROP_OUT">
      <summary>
             Twenty two drop out
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TEMPERATURE">
      <summary>
             Temperature
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.WIND">
      <summary>
             Wind
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TRY">
      <summary>
             Try
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PENALTY_TRY">
      <summary>
             Penalty try
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CONVERSION">
      <summary>
             Conversion
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PENALTY_POINTS">
      <summary>
             Penalty points
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DROP_GOAL">
      <summary>
             Drop goal
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DROP_GOAL_FROM_MARK">
      <summary>
             Drop goal from mark
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TABLE_TENNIS_SCORE_CHANGE">
      <summary>
             Table tennis score change
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TURNOVER">
      <summary>
             Turnover
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.WIND_ADVANTAGE">
      <summary>
             Wind advantage
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.GOING_FOR_KICK_AT_GOAL">
      <summary>
             Going for kick at goal
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TELEVISION_MATCH_OFFICIAL_ASSISTS">
      <summary>
             Television match official assists
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DROP_GOAL_ATTEMPT">
      <summary>
             Drop goal attempt
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DENIED_TRY">
      <summary>
             Denied try
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DENIED_DROP_GOAL">
      <summary>
             Denied drop goal
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BALL_POT">
      <summary>
             Ball pot
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.FREE_BALL">
      <summary>
             Free ball
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SNOOKER_FOUL">
      <summary>
             Snooker foul
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.RERACK">
      <summary>
             Rerack
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.REMOVE_BALL">
      <summary>
             Remove ball
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.ADD_BALL">
      <summary>
             Add ball
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.EXPEDITE_MODE">
      <summary>
             Expedite mode
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TABLE_TENNIS_VIOLATION">
      <summary>
             Table tennis violation
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PLAYERS_WALK_ON">
      <summary>
             Players walk on
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TABLE_READY">
      <summary>
             Table ready
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PLAY_ABOUT_TO_START">
      <summary>
             Play about to start
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POSSIBLE_TRY">
      <summary>
             Possible try
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PENALTY_ADVANTAGE">
      <summary>
             Penalty advantage (used in Rugby)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DROP_OUT">
      <summary>
             Drop out (used in Rugby)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TWENTY_M_RESTART">
      <summary>
             20m restart (used in Rugby)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.FORTY_TWENTY">
      <summary>
             40-20 (used in Rugby)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.FREE_BALL_AWARDED">
      <summary>
             Free ball awarded (snooker)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TOSS">
      <summary>
             Toss
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SESSION_STARTED">
      <summary>
             Session started
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SESSION_FINISHED">
      <summary>
             Session finished
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.INNINGS_STARTED">
      <summary>
             Innings started
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.INNINGS_FINISHED">
      <summary>
             Innings finished
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.OVER_STARTED">
      <summary>
             Over started
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.OVER_FINISHED">
      <summary>
             Over finished
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BOWLER_RUNNING_IN">
      <summary>
             Bowler running in
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BALL_FINISHED">
      <summary>
             Ball finished
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PITCH_MAP">
      <summary>
             Pitch map
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BALL_HIT">
      <summary>
             Ball hit
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DOT_BALL">
      <summary>
             Dot ball
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BOUNDARY">
      <summary>
             Boundary
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.RUNS">
      <summary>
             Runs
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.ONE_SHORT">
      <summary>
             One short
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.EXTRAS_NO_BALL">
      <summary>
             Extras no ball
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.EXTRAS_WIDE">
      <summary>
             Extras wide
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.EXTRAS_BYE">
      <summary>
             Extras bye
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.EXTRAS_BYE_BYE">
      <summary>
             Extras bye bye
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.EXTRAS_PENALTY_RUNS">
      <summary>
             Extras penalty runs
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.FREE_HIT">
      <summary>
             Free hit
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DISMISSAL_RETIRED">
      <summary>
             Dismissal retired
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DISMISSAL_BOWLED">
      <summary>
             Dismissal bowled
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DISMISSAL_TIMED_OUT">
      <summary>
             Dismissal timed out
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DISMISSAL_CAUGHT">
      <summary>
             Dismissal caught
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DISMISSAL_HANDLED_THE_BALL">
      <summary>
             Dismissal handled by the ball
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DISMISSAL_HIT_THE_BALL_TWICE">
      <summary>
             Dismissal hit the ball twice
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DISMISSAL_HIT_WICKET">
      <summary>
             Dismissal hit wicket
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DISMISSAL_LBW">
      <summary>
             Dismissal lbw
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DISMISSAL_OBSTRUCTING_THE_FIELD">
      <summary>
             Dismissal obstructing the field
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DISMISSAL_RUN_OUT">
      <summary>
             Dismissal run out
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DISMISSAL_STUMPED">
      <summary>
             Dismissal stumped
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DEAD_BALL">
      <summary>
             Dead ball
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POSSIBLE_WICKET">
      <summary>
             Possible wicket
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POSSIBLE_BOUNDARY">
      <summary>
             Possible boundary
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.APPEAL">
      <summary>
             Appeal
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.THIRD_UMPIRE">
      <summary>
             Third umpire
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DECISION_REVIEW">
      <summary>
             Decision review
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DECISION_REVIEW_RESULT">
      <summary>
             Decision review result
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BATSMAN_COMING_ON">
      <summary>
             Batsman coming on
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BOWLER_CHANGE">
      <summary>
             Bowler change
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.RETIRED_HURT">
      <summary>
             Retired hurt
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.FOLLOW_ON">
      <summary>
             Follow on
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.NEW_BALL">
      <summary>
             New ball
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DUCKWORTH_LEWIS">
      <summary>
             Duckworth lewis
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CORRECT_BATSMAN_DATA">
      <summary>
             Correct Batsman data (Cricket)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CORRECT_BOWLER_DATA">
      <summary>
             Correct bowler data (Cricket)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CORRECT_TEAM_DATA">
      <summary>
             Correct team data (Cricket)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CORRECT_BATSMAN_ON_STRIKE">
      <summary>
             Correct batsman on strike (Cricket)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CORRECT_BALL_DATA">
      <summary>
             Correct ball data (Cricket)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.REDUCED_OVERS_MATCH">
      <summary>
             Reduced overs match (Cricket)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POWER_PLAY_STARTED">
      <summary>
             Power play started (Cricket)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POWER_PLAY_FINISHED">
      <summary>
             Power play finished (Cricket)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DEFENSIVE_FOUL">
      <summary>
             Defensive foul (Handball)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.STEAL">
      <summary>
             Steal (Handball)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TECHNICAL_FOUL">
      <summary>
             Technical foul (Handball)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TECHNICAL_FAULT">
      <summary>
             Technical fault (Handball)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.EXCLUSION">
      <summary>
             Exclusion (Handball)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POSSIBLE_SUSPENSION">
      <summary>
             Possible suspension (Handball)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POSSIBLE_EXCLUSION">
      <summary>
             Possible exclusion (Handball)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CANCELLED_SUSPENSION">
      <summary>
             Cancelled suspension (Handball)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SAFETY">
      <summary>
             Safety
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.EXTRA_POINT">
      <summary>
             Extra point
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POSSIBLE_FIELD_GOAL">
      <summary>
             Possible field goal
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CANCELED_FIELD_GOAL">
      <summary>
             Canceled field goal
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.FIELD_GOAL_RESULT">
      <summary>
             Field goal result
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TURNOVER_AF">
      <summary>
             Turnover af
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.FUMBLE">
      <summary>
             Fumble
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CANCELLED_EXCLUSION">
      <summary>
             Cancelled exclusion (Handball)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.INTERCEPTION">
      <summary>
             Interception
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PLAY_START_AF">
      <summary>
             Play start af
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PLAY_OVER_AF">
      <summary>
             Play over af
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PUNT_RESULT">
      <summary>
             Punt result
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CHALLENGE_AF">
      <summary>
             Challenge af
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POSSIBLE_CHALLENGE">
      <summary>
             Possible challenge
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PENALTY">
      <summary>
             Penalty
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POSSIBLE_TOUCHDOWN">
      <summary>
             Possible touchdown
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TV_TIMEOUT">
      <summary>
             TV Timeout (Ice Hockey)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PASS">
      <summary>
             Pass
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.RUSH">
      <summary>
             Rush
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SACK">
      <summary>
             Sack
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TV_TIMEOUT_OVER">
      <summary>
             Tv Timeout over (Ice Hockey)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CANCELED_CHALLENGE">
      <summary>
             Delayed penalty (Ice Hockey)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TOUCHDOWN">
      <summary>
             Touchdown
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.AMERICAN_FOOTBALL_KICKOFF">
      <summary>
             American football kickoff
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.FUMBLE_RECOVERED">
      <summary>
             Fumble recovered
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POSSIBLE_TURNOVER">
      <summary>
             Possible turnover
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CANCELED_TURNOVER">
      <summary>
             Canceled turnover
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POSSIBLE_2_POINT_CONVERSION">
      <summary>
             Possible 2 point conversion
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CANCELED_2_POINT_CONVERSION">
      <summary>
             Canceled 2 point conversion
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POSSIBLE_EXTRA_POINT">
      <summary>
             Possible extra point
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CANCELED_EXTRA_POINT">
      <summary>
             Canceled extra point
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POSSIBLE_SAFETY">
      <summary>
             Possible safety
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CANCELED_SAFETY">
      <summary>
             Canceled safety
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POSSIBLE_PUNT">
      <summary>
             Possible punt
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CANCELED_PUNT">
      <summary>
             Canceled punt
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TWO_POINT_CONVERSION">
      <summary>
             Two point conversion
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.VIDEO_REVIEW_START">
      <summary>
             Video review start
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.VIDEO_REVIEW_OVER">
      <summary>
             Video review over
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.RULE_SET">
      <summary>
             Rule set
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SCORE_CHANGE">
      <summary>
             Score change
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BOWLER_STARTS">
      <summary>
             Bowler starts
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.JACK_ROLL">
      <summary>
             Jack roll
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.REDELIVER_JACK">
      <summary>
             Redeliver jack
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BOWL">
      <summary>
             Bowl
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.WARNING">
      <summary>
             Warning
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.RESTART_END">
      <summary>
             Restart end
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DEAD_END">
      <summary>
             Dead end
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DEAD_JACK">
      <summary>
             Dead jack
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DEAD_BOWL">
      <summary>
             Dead bowl
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.REPLAY_BOWL">
      <summary>
             Replay bowl
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DISQUALIFICATION">
      <summary>
             Disqualification
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.END_START">
      <summary>
             End start
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TRIAL_END">
      <summary>
             Trial end
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.START_DELAYED">
      <summary>
             Start delayed
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.MATCH_FORMAT">
      <summary>
             Match format
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.FIRST_SET_AWARDED">
      <summary>
             First set awarded
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DELAYED_PENALTY">
      <summary>
             Delayed penalty
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SCORE_ADJUSTMENT">
      <summary>
             Score adjustment (Handball, Basketball and Volleyball)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TWO_POINT_MISS_COUNT">
      <summary>
             Two point miss count (Basketball)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.THREE_POINT_MISS_COUNT">
      <summary>
             Three point miss count (Basketball)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.REBOUND_COUNT">
      <summary>
             Rebound count (Basketball)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PLAY_START">
      <summary>
             Play start (Basketball)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PLAY_OVER">
      <summary>
             Play over (Basketball)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PLAY_CANCELLED">
      <summary>
             Play cancelled (Basketball)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PASS_COUNT">
      <summary>
             Pass count (American Football)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.RUSH_COUNT">
      <summary>
             Rush count (American Football)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PENALTY_COUNT">
      <summary>
             Penalty count (American Football)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PLAY_START_COUNT">
      <summary>
             Play start count (American Football)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.FUMBLE_COUNT">
      <summary>
             Fumble count (American Football)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.FUMBLE_RECOVERED_COUNT">
      <summary>
             Fumble recovered count (American Football)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TURNOVER_COUNT">
      <summary>
             Turnover count (American Football)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.INTERCEPTION_COUNT">
      <summary>
             Turnover count (American Football)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CHALLENGE_COUNT">
      <summary>
             Interception count (American Football)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DRIVES_COUNT">
      <summary>
             Drives count (American Football)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CHALLENGE_DECISION">
      <summary>
             Challenge decision
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.USE_CHALLENGES_OFFICIAL_REVIEWS">
      <summary>
             Use challenges official reviews
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.OVERRULE">
      <summary>
             Overrule
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CHALLENGE">
      <summary>
             Challenge
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CHALLENGE_NOT_CONFIRMED">
      <summary>
             Challenge not confirmed
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PASSIVE_PLAY">
      <summary>
             Passive play
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PASSIVE_PLAY_CALLED">
      <summary>
             Passive play called (Handball)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PASSIVE_PLAY_CANCELED">
      <summary>
             Passive play canceled
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SEVENTH_PLAYER_SUB">
      <summary>
             Seventh player sub
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.ACTIVE_GOAL_KEEPER">
      <summary>
             Active goal keeper
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PLAY_START_BB">
      <summary>
             Play start bb
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.PLAY_OVER_BB">
      <summary>
             Play over bb
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.RUNNERS_IN_MOTION">
      <summary>
             Runners in motion
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CHECKED_RUNNER">
      <summary>
             Checked runner
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.RUNNER_ADVANCES_TO_BASE_X">
      <summary>
             Runner advances to base
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.RUN_SCORED">
      <summary>
             Run scored
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.RUNNER_OUT">
      <summary>
             Runner out
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.STRIKE">
      <summary>
             Strike
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BALL">
      <summary>
             Ball
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.FOUL_BALL">
      <summary>
             Foul ball
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.WHO_THROWS_THE_FIRST_PITCH">
      <summary>
             Who throws the first pitch
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BATTER_OUT">
      <summary>
             Batter out
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BATTER_ADVANCES_TO_BASE_X">
      <summary>
             Batter advanced to base x
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BALK">
      <summary>
             Balk
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.STEAL_BASKETBALL">
      <summary>
             Steal basketball
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.TURNOVER_BASKETBALL">
      <summary>
             Turnover
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BLOCK">
      <summary>
             Block
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.BIG_PLAY">
      <summary>
             Big play
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POSSIBLE_DEFENSIVE_RETURN">
      <summary>
             Possible defensive return
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DEFENSIVE_RETURN">
      <summary>
             Defensive return
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.DEFENSIVE_RETURN_NOT_CONFIRMED">
      <summary>
             Defensive return not confirmed
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POSSIBLE_FOURTH_DOWN_ATTEMPT">
      <summary>
             Possible fourth down attempt
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.SCORE_EVENT_CORRECTION">
      <summary>
            Score event correction
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.POSSIBLE_ONSIDE_KICK">
      <summary>
            Possible onside kick
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.STATS_CORRECTION">
      <summary>
             Stats correction
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.EventType.CANCELED_VIDEO_REVIEW">
      <summary>
            Sent when video review is not confirmed
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.ScoutFeedType">
      <summary>
            Type of scout match information message (full, delta or deltaupdate).
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutFeedType.UNDEFINED">
      <summary>
            Undefined
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutFeedType.FULL">
      <summary>
            Full message
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutFeedType.DELTA">
      <summary>
            Delta message
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutFeedType.DELTAUPDATE">
      <summary>
            Delta update message
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.ConnectionChangeEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnClosed" /> and <see cref="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnOpened" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ConnectionChangeEventArgs.LocalTimestamp">
      <summary>
            Connection change timestamp (local UTC timestamp)
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.LineupsEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnLineups" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.LineupsEventArgs.Lineups">
      <summary>
            The lineups
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.MatchBookingReplyEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnMatchBookingReply" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchBookingReplyEventArgs.MatchBooking">
      <summary>
            Match booking reply
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.MatchDataEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnMatchData" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchDataEventArgs.MatchData">
      <summary>
            Gets the match data.
            </summary>
      <value>
            The match data.
            </value>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.MatchListEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnMatchList" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchListEventArgs.MatchList">
      <summary>
            List of match infos
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchListEventArgs.WasRequested">
      <summary>
            Is the event a reply for something we asked for?
            true when yes; false else (when some schedule was changed and we get this)
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.MatchStopEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnMatchStop" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchStopEventArgs.MatchId">
      <summary>
            Match id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchStopEventArgs.Reason">
      <summary>
            Reason could be a match subscription failure or client unsubscribing from a match.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdateEventArgs">
      <summary>
            Event arguments passed <see cref="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnMatchUpdate" />, <see cref="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnMatchUpdateDelta" />, 
            <see cref="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnMatchUpdateDeltaUpdate" /> and <see cref="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnMatchUpdateFull" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdateEventArgs.MatchUpdate">
      <summary>
            Match update (full, delta or delta update)
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.OddsSuggestionEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnOddsSuggestion" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.OddsSuggestionEventArgs.MatchId">
      <summary>
            Match id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.OddsSuggestionEventArgs.Odds">
      <summary>
            Collection of odd values
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.ScoutInfoEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnScoutInfo" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutInfoEventArgs.MatchId">
      <summary>
            Match id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutInfoEventArgs.ScoutInfos">
      <summary>
            Basic information about the match
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.Attribute">
      <summary>
            Attribute
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.Attribute.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Attribute.Type">
      <summary>
            Type
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Attribute.TypeId">
      <summary>
            Type id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Attribute.Value">
      <summary>
            Value
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Attribute.ValueId">
      <summary>
            Value id
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.Court">
      <summary>
            Court
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.Court.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Court.CourtSeq">
      <summary>
            Court seq
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Court.Id">
      <summary>
            Id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Court.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.Format">
      <summary>
            Format
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.Format.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Format.Type">
      <summary>
            Format type
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Format.Value">
      <summary>
            Format value
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.Innings">
      <summary>
            Innings
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.Innings.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Innings.Dismissals">
      <summary>
            Dismissals
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Innings.Runs">
      <summary>
            Runs
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Innings.StatusId">
      <summary>
            Status id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Innings.StatusName">
      <summary>
            Status Name
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.Gold">
      <summary>
            gold
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.Gold.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Gold.MapNr">
      <summary>
            mapnr
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Gold.T1">
      <summary>
            t1
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Gold.T2">
      <summary>
            t2
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.Networth">
      <summary>
            Networth
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.Networth.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Networth.MapNr">
      <summary>
            mapnr
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Networth.T1">
      <summary>
            t1
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Networth.T2">
      <summary>
            t2
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.InningScore">
      <summary>
            Inning score
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.InningScore.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.InningScore.Inning">
      <summary>
            Inning
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.InningScore.Score">
      <summary>
            Inning
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.MatchRole">
      <summary>
            Match role
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.MatchRole.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchRole.Description">
      <summary>
            Description
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchRole.Id">
      <summary>
            Id
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.Scout">
      <summary>
            Scout
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.Scout.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.Scout.Id">
      <summary>
            Id
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent">
      <summary>
            Scout event like a card, corner kick, half time, penalty, etc.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.Assists">
      <summary>
            Assists
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.Automatic">
      <summary>
            Identifies whether event was automatically generated automatically or not.
            </summary>
      <remarks>
            Probably not useful.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.BallNumber">
      <summary>
            Ball number
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.Balls">
      <summary>
            Number of balls.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.BallSpotting">
      <summary>
            Ball spotting
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.BaseInfo">
      <summary>
            Base info.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.BreakScore">
      <summary>
            Break score
            </summary>
      <remarks>
            Used in snooker
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.CorrectedFrom">
      <summary>
            Corrected from, used with score correction event
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.CorrectedTo">
      <summary>
            Corrected to, used with score correction event
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.Deaths">
      <summary>
            Deaths
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.Denies">
      <summary>
            Denies
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.DismissalsInInnings">
      <summary>
            Dismissals in innings
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.EarlyBetstartType">
      <summary>
            earlybetstarttype
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.EndScore">
      <summary>
            End score
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.Errors">
      <summary>
            Number of errors.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.ErrorsAway">
      <summary>
            Erros away
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.ErrorsHome">
      <summary>
            Errors home
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.Experience">
      <summary>
            Experience
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.ExtraInfo">
      <summary>
            Integer value, meaning of this attribute depends on event type:
            <list type="bullet"><item><description>30 (score): 0 or -1 = not specified, 1 = penalty, 2 = own goal, 3 = header</description></item><item><description>1019 (cancel goal): 0 or -1 = not specified, 1 = off side, 2 = foul, 3 = incorrect entry</description></item><item><description>1013 (match status): match status enumeration</description></item><item><description>1025 (tennis full score): tennis point type – 0=standard, 1=ace, 2=double fault opponent</description></item><item><description>158 (injury): Player still injured – 1=yes, 0=no 165 (attendance): Attendance</description></item><item><description>1039 (manual time adjustment): Number of seconds adjusted. Can be both a positive and a negative integer</description></item><item><description>1044 (event deleted): Id of event that was deleted</description></item><item><description>1037 (basketball points): Number of points scored – 1, 2 or 3</description></item><item><description>1038 (basketball points missed): Point attempt missed – 1, 2 or 3 (points)</description></item><item><description>1046 (volleyball full score): volleyball point type – 0=standard, 1=ace, 2=service error</description></item><item><description>1056 (number of free throws): Number of free throws</description></item><item><description>1036 (time start stop): 1 = time is running, 0 = time is stopped</description></item><item><description>43 (suspensions): Number of minutes player is suspended for</description></item><item><description>90 (injury time): Number of minutes injury time added</description></item><item><description>1082 (corner markets): 1 = safe to accept bets, 0 = not safe</description></item><item><description>1083 (booking markets): 1 = safe to accept bets, 0 = not safe</description></item><item><description>1002 (penalty shootout): -1=penalty not taken, 1=penalty scored, 0=penalty missed</description></item><item><description>1060 (direct free kick): -1 = not taken, 0 = miss, 1 = score</description></item><item><description>1102 (coverage status):   0 - match covered, 1 - coverage abandoned (used when abandoning coverage after a match has started), 2 - match will not be covered (used when we are unable to cover a match that we were supposed to cover)</description></item></list>
            All counter event types (throw in count etc.): Number of events of this type for team specified by “side" attribute
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.ExtraInfoBaseball">
      <summary>
            Extra info baseball.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.ExtraInfoBasketball">
      <summary>
            Extra info for basketball game
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.ExtraInfoBowls">
      <summary>
            Extra info for bowls game
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.ExtraInfoCricket">
      <summary>
            Extra info for cricket game
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.ExtraInfoCsGo">
      <summary>
            Extra info for counter strike global offensive
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.ExtraInfoDarts">
      <summary>
            Extra info for dart game
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.ExtraInfoFootball">
      <summary>
            Extra info for football game
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.ExtraInfoHandball">
      <summary>
            Extra info for handball game
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.ExtraInfoIceHockey">
      <summary>
            Extra info ice hockey.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.ExtraInfoSnooker">
      <summary>
            Extra info for snooker game
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.ExtraInfoVolleyball">
      <summary>
            Extra info for volleyball game
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.FirstBaseLoaded">
      <summary>
            First base loaded
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.FrameNumber">
      <summary>
            Frame number
            </summary>
      <remarks>
            Used in snooker
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.FrameScore">
      <summary>
            Frame score
            </summary>
      <remarks>
            Used in snooker
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.GameNumber">
      <summary>
            In tennis, which game number in the set.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.GameScore">
      <summary>
            In tennis, the game score.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.HeroesAliveAway">
      <summary>
            Level
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.HeroesAliveHome">
      <summary>
            Heroes alive home
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.HeroId">
      <summary>
            Hero Id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.HeroName">
      <summary>
            Hero Name
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.HitsAway">
      <summary>
            Hits away
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.HitsHome">
      <summary>
            Hits home
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.Id">
      <summary>
            Unique event id.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.Info">
      <summary>
            Text description of event.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.InningHalf">
      <summary>
            Inning half.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.InningsScore">
      <summary>
            Innings scores
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.Kills">
      <summary>
            Kills
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.KillsAway">
      <summary>
            Kills away
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.KillsHome">
      <summary>
            Kills home
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.LastHits">
      <summary>
            Last hits
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.LegScore">
      <summary>
            Used in darts
            Leg (game) score
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.Level">
      <summary>
            Level
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.MapNumber">
      <summary>
            Map number
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.MapScore">
      <summary>
            Map score
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.MatchScore">
      <summary>
            In tennis, the match score.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.MatchTime">
      <summary>
            Match time, mm:ss (e.g. 40:00 or 00:00).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.NetWorth">
      <summary>
            Net worth
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.Outs">
      <summary>
            Number of outs.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.PeriodNumber">
      <summary>
            Period number of match.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.PeriodScore">
      <summary>
            Period score.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.PitchCount">
      <summary>
            Pitch count.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.Player1Id">
      <summary>
            Sportradar player id for player 1 connected to this event.
            The meaning of this attribute depends on event type:
            <list type="bullet"><item><description>30 (goal): Goal scorer</description></item><item><description>50, 40, 45 (red, yellow, yellow/red card): Who got card</description></item><item><description>60 (substitution): Outgoing player</description></item><item><description>154 (corner): Who took corner</description></item><item><description>161 (penalty awarded): Who caused penalty – offender</description></item><item><description>155, 156 (shot on/off target): Who shot</description></item><item><description>153 (off side): Who was off side</description></item><item><description>158 (injury): Who was injured</description></item></list></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.Player2Id">
      <summary>
            Sportradar player id for player 2 connected to this event.
            The meaning of this attribute depends on event type:
            <list type="bullet"><item><description>60 (substitution): Incoming player</description></item><item><description>161 (penalty awarded): Who was awarded a penalty</description></item></list></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.Player3Id">
      <summary>
            Sportradar player id for player 3 connected to this event.
            The meaning of this attribute depends on event type:
            <list type="bullet"><item><description>30 (goal): player3 = Second assisting player</description></item></list></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.Player4Id">
      <summary>
            Sportradar player id for player 3 connected to this event.
            The meaning of this attribute depends on event type:
            <list type="bullet"><item><description>30 (goal): player3 = Second assisting player</description></item></list></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.PosX">
      <summary>
            Horizontal position on pitch, posx being a number from 0 to 100.
            The reference point 0 is at home teams goal.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.PosY">
      <summary>
            Vertical position on pitch, posy being a number from 0 to 100.
            The reference point 0 is on top of pitch when home teams goal is on the left hand side.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.RemainingTimeInPeriod">
      <summary>
            Remaining time of match, mm:ss
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.RoundNumber">
      <summary>
            Round number
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.Runs">
      <summary>
            Number of runs.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.RunsAway">
      <summary>
            Runs away
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.RunsHome">
      <summary>
            Runs home
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.RunsInInnings">
      <summary>
            Runs in innings
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.SecondBaseLoaded">
      <summary>
            Second base loaded
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.SecondScoreType">
      <summary>
            Seconds score type
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.Server">
      <summary>
            Serving team
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.ServerTime">
      <summary>
            Server time of event, time stamp in UTC.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.SetNumber">
      <summary>
            In tennis, which set number in the match.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.SetScore">
      <summary>
            In tennis, the set score.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.Side">
      <summary>
            Which side had an event - home, away or none.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.Strikes">
      <summary>
            Number of strikes.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.ThirdBaseLoaded">
      <summary>
            Third loaded
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.Type">
      <summary>
            Each event type has an id (e.g. yellow card 40, event deleted 1044, early bet status 1091, etc.).
            See LiveScout documentation to see which event types are supported for each sport.
            New event types can be offered in the future.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.WeaponId">
      <summary>
            Weapon id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.WeaponName">
      <summary>
            Weapon name
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.DragonKills">
      <summary>
            Dragon kills
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.BaronKills">
      <summary>
            Baron kills
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.InhibitorKills">
      <summary>
            Inhibitor kills
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.TowerKills">
      <summary>
            Tower kills
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.DoubleKills">
      <summary>
            Double kills
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.TripleKills">
      <summary>
            Triple kills
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.QuadraKills">
      <summary>
            Quadra kills
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.PentaKills">
      <summary>
            Penta kills
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.MapName">
      <summary>
            Map name
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutEvent.ItemName">
      <summary>
            Item name
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.ScoutInfo">
      <summary>
            Contains basic information about the match.
            </summary>
      <remarks>
            Could be that this information is only of interest for the flash scout client.
            </remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.ScoutInfo.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutInfo.Header">
      <summary>
            Caption text.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutInfo.Link">
      <summary>
            Whether this is URL or not.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutInfo.Order">
      <summary>
            Sort order
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutInfo.Value">
      <summary>
            Info text. If Link is true then this is URL.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader">
      <summary>
            Basic match information specifying match id, teams playing, bet status, feed type and other info.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.Active">
      <summary>
            Is match active?
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.BetStatus">
      <summary>
            Whether market is open or closed.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.ConnectionStatus">
      <summary>
            Whether scout is currently connected or not.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.CoveredFrom">
      <summary>
            Whether the match is covered from TV or venue.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.Device">
      <summary>
            Device used for scouting
            <list type="bullet"><item><description>1 – Hardphone/Asterisk</description></item><item><description>2 – Softphone</description></item><item><description>3 – Scout Admin</description></item><item><description>4 – Scout Mobile App</description></item><item><description>5 – External Data Feed</description></item></list></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.Distance">
      <summary>
            Distance between teams in km.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.ExtraInfo">
      <summary>
            Integer specifying special information for the match.
            Can be one of the following:
            <list type="bullet"><item><description>1 – Soccer match played 2*40 minutes (+2*10 minutes extra time)</description></item><item><description>2 – Tennis no advantage rule, super tie break to 10 points</description></item><item><description>3 – Tennis no advantage rule, super tie break to 7 points</description></item><item><description>4 – Tennis no advantage rule, no super tie break</description></item><item><description>5 – Tennis advantage rule, super tie break to 10 points</description></item><item><description>6 – Tennis advantage rule, super tie break to 7 points</description></item><item><description>7 – Basketball 12 minute periods</description></item><item><description>8 – Volleyball best of 3 sets</description></item><item><description>9 - Soccer match played 2*35 minutes (+2* 5 minutes extra time)</description></item><item><description>10 - Soccer match played 2*30 minutes (+2* 5 minutes extra time)</description></item><item><description>11 - Soccer match played 2*25 minutes (+2* 5 minutes extra time)</description></item><item><description>12 - Ice hockey 10 minutes extra time periods</description></item><item><description>13 - Ice hockey 20 minutes extra time periods</description></item><item><description>14 – Futsal match played 2*25 minutes (+2* 5 minutes extra time)</description></item></list>
            Tennis advantage rule is when games must be won by at least 2 points
            (i.e. the use of deuce and advantage player X).
            In doubles matches advantage rule is usually not used.
            Super tie break in tennis is when the last set is a special tie break set.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.FirstServe">
      <summary>
            Which player / team has first serve of match (tennis).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.FirstServeGoldenSet">
      <summary>
            Which player / team has first serve of golden set
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.FirstServeTieBreak">
      <summary>
            Which player / team has first serve in tie-break (tennis).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.IsBooked">
      <summary>
            Whether the match is booked by the client.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.IsDeepCoverage">
      <summary>
            Whether this is a deep coverage match.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.IsTimeRunning">
      <summary>
            Whether time/clock is running/active or not.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.MatchId">
      <summary>
            Match Id.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.MatchTime">
      <summary>
            Match time, mm:ss (e.g. 40:00 or 00:00).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.NumberOfSets">
      <summary>
            Number of sets in match (tennis).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.SetLimit">
      <summary>
            Number of points needed to win a set
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.Sex">
      <summary>
            Gender (sex) of the player / team.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.SourceId">
      <summary>
            Customer matchid. Included if set up and if available for this match. Contact
            Sportradar in order to include this in the scout feed
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.CoverageStatusId">
      <summary>
            Gets the coverage status identifier.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.St1Id">
      <summary>
            Betradar super team id for team 1.
            </summary>
      <remarks>
            Super team is the parent a certain team derives from.
            New sponsor might completely change the name of the team
            no matter it is actually the same thing.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.St2Id">
      <summary>
            Betradar super team id for team 2.
            </summary>
      <remarks>
            Super team is the parent a certain team derives from.
            New sponsor might completely change the name of the team
            no matter it is actually the same thing.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.Start">
      <summary>
            Official match start time, as a timestamp in UTC.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.Team1">
      <summary>
            Betradar team 1 (home team).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.Team1Abbreviation">
      <summary>
            Team 1 abbreviation
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.Team2">
      <summary>
            Betradar team 2 (away team).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.Team2Abbreviation">
      <summary>
            Team 2 abbreviation
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.TieBreakLastSet">
      <summary>
            Last set has tie break.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.TypeOfFeed">
      <summary>
            Whether this is a full, delta or deltaupdate message.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.MatchHeader.WonJumpBall">
      <summary>
            Which team won jump ball at the start of the match.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.ScoutOddsField">
      <summary>
            Scout odds field consisting of odds side and corresponding odds value (e.g. description="Under 1.5" side="betunder" value="2.9").
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.ScoutOddsField.op_Explicit(Sportradar.SDK.ProtocolProviders.LiveScout.Server.OddsField)~Sportradar.SDK.FeedProviders.LiveScout.ScoutOddsField">
      <exclude />
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.ScoutOddsField.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutOddsField.Description">
      <summary>
            Description of this odds value (e.g. Home, Draw, Over 1.5, Under 1.5, etc).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutOddsField.Side">
      <summary>
            Odds value side (e.g. home, draw, betover, betunder, etc).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutOddsField.Value">
      <summary>
            Odds value (e.g. 1.75)
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.ScoutOdds">
      <summary>
            Scout odds of specific type/subtype and corresponding odd fields.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.ScoutOdds.op_Explicit(Sportradar.SDK.ProtocolProviders.LiveScout.Server.Odds)~Sportradar.SDK.FeedProviders.LiveScout.ScoutOdds">
      <exclude />
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.ScoutOdds.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutOdds.AlsoOdds">
      <summary>
            Not important, used for compatibility with
            other systems.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutOdds.Description">
      <summary>
            Description of this odds type or a freetext description (e.g. "1st Half - Exact number of goals").
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutOdds.GuthMatchId">
      <summary>
            Guth (legacy system) match id.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutOdds.ManualActive">
      <summary>
            Were odds manually activated?
            </summary>
      <remarks>
            Probably not important, used for compatibility with
            other systems.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutOdds.MatchId">
      <summary>
            Match id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutOdds.SpecialOddsValue">
      <summary>
            This property is set only for some odds types: total, handicap and freetext3way/2way/nway. 
            It indicates the total value, handicap value or freetext details respectively
            (e.g. special odds value for "Free Text nway" is "1st Half - Exact number of goals 3=8.75, 2=3.7, 1=2.4, 0=2.85, 4+=20")
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutOdds.SubType">
      <summary>
            Tells what kind of freetext odds this is (e.g. SubType="2" resolves to Description="Which team has kick off?").
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutOdds.Type">
      <summary>
            Odds type represented by a numeric id.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutOdds.ValidDate">
      <summary>
            Time when odds were calculated.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.LiveScout.ScoutOdds.Values">
      <summary>
            Collection of odds field values (e.g. for 1x2: Home=2.5, Draw=2.9, Away=2.85). 
            Key is represented by an odds value Side.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus">
      <summary>
            Match status as used by Live Odds. Not all match statuses are used by each sport.
            </summary>
      <remarks>
            Match statuses used by the different sports:
            <list type="bullet"><item><description>
            Soccer: NOT_STARTED, FIRST_HALF, HALFTIME, SECOND_HALF, INTERRUPTED, ABANDONED, ENDED, AWAITING_OT, FIRST_HALF_OT, OT_HALFTIME, SECOND_HALF_OT, AFTER_OT, AWAITING_PENALTIES, PENALTY_SHOOTING, AFTER_PENALTIES
            </description></item><item><description>
            Ice Hockey: NOT_STARTED, FIRST_HALF, HALFTIME, SECOND_HALF, INTERRUPTED, ABANDONED, ENDED, AWAITING_OT, FIRST_HALF_OT, OT_HALFTIME, SECOND_HALF_OT, AFTER_OT, AWAITING_PENALTIES, PENALTY_SHOOTING, AFTER_PENALTIES
            </description></item><item><description>
            Tennis: NOT_STARTED, FIRST_SET, SECOND_SET, THIRD_SET, FOURTH_SET, FIFTH_SET, ENDED, WALKOVER1, WALKOVER2, RETIRED1, RETIRED2, DELAYED, INTERRUPTED, ABANDONED, DEFAULTED1, DEFAULTED2
            </description></item><item><description>
            Basketball: NOT_STARTED, FIRST_QUARTER, FIRST_PAUSE, SECOND_QUARTER, SECOND_PAUSE, THIRD_QUARTER, THIRD_PAUSE, FOURTH_QUARTER, ENDED, AWAITING_OT, OVERTIME, AFTER_OT, INTERRUPTED, ABANDONED
            </description></item><item><description>
            Volleyball: NOT_STARTED, FIRST_SET, FIRST_PAUSE, SECOND_SET, SECOND_PAUSE , THIRD_SET, THIRD_PAUSE, FOURTH_SET, FOURTH_PAUSE, FIFTH_SET, ENDED, GOLDEN_SET, WALKOVER1, WALKOVER2, RETIRED1, RETIRED2, DELAYED, INTERRUPTED, ABANDONED
            </description></item><item><description>
            Beach Volleyball: NOT_STARTED, FIRST_SET, FIRST_PAUSE, SECOND_SET, SECOND_PAUSE , THIRD_SET, ENDED, GOLDEN_SET, WALKOVER1, WALKOVER2, RETIRED1, RETIRED2, DELAYED, INTERRUPTED, ABANDONED
            </description></item><item><description>
            Handball: NOT_STARTED, FIRST_HALF, HALFTIME, SECOND_HALF, INTERRUPTED, ABANDONED, ENDED, AWAITING_OT, FIRST_HALF_OT, OT_HALFTIME, SECOND_HALF_OT, AFTER_OT, AWAITING_PENALTIES, PENALTY_SHOOTING, AFTER_PENALTIES
            </description></item><item><description>
            Futsal: NOT_STARTED, FIRST_HALF, HALFTIME, SECOND_HALF, INTERRUPTED, ABANDONED, ENDED, AWAITING_OT, FIRST_HALF_OT, OT_HALFTIME,SECOND_HALF_OT, AFTER_OT, AWAITING_PENALTIES, PENALTY_SHOOTING, AFTER_PENALTIES
            </description></item><item><description>
            Rugby union: NOT_STARTED, FIRST_HALF, HALFTIME, SECOND_HALF, AWAITING_OT, FIRST_HALF_OT, OT_HALFTIME,SECOND_HALF_OT, AFTER_OT, AWAITING_PENALTIES, PENALTY_SHOOTING, AFTER_PENALTIES, AWAITING_SD, SUDDEN_DEATH, AFTER_SD, ENDED, INTERRUPTED, ABANDONED, POSTPONED
            </description></item><item><description>
            Darts: NOT_STARTED, IN_PROGRESS, PAUSE, ENDED, WALKOVER1, WALKOVER2, RETIRED1, RETIRED2, DEFAULTED1, DEFAULTED2, DELAYED, INTERRUPTED, ABANDONED
            </description></item></list></remarks>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.UNDEFINED">
      <summary>
            Undefined
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.NOT_STARTED">
      <summary>
            Not started yet
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FIRST_PERIOD">
      <summary>
            1st period of the match
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SECOND_PERIOD">
      <summary>
            2nd period of the match
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.THIRD_PERIOD">
      <summary>
            3rd period of the match
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FOURTH_PERIOD">
      <summary>
            4th period of the match
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FIFTH_PERIOD">
      <summary>
            5th period of the match
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FIRST_HALF">
      <summary>
            1st half of the match
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SECOND_HALF">
      <summary>
            2nd half of the match
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FIRST_SET">
      <summary>
            1st set
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SECOND_SET">
      <summary>
            2nd set
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.THIRD_SET">
      <summary>
            3rd set
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FOURTH_SET">
      <summary>
            4th set
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FIFTH_SET">
      <summary>
            5th set
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SIXTH_SET">
      <summary>
            6th set
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SEVENTH_SET">
      <summary>
            7th set
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FIRST_QUARTER">
      <summary>
            1st quarter
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SECOND_QUARTER">
      <summary>
            2nd quarter
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.THIRD_QUARTER">
      <summary>
            3rd quarter
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FOURTH_QUARTER">
      <summary>
            4th quarter
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.GOLDEN_SET">
      <summary>
            Golden set (volleyball and beach volleyball)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.STARTED">
      <summary>
            Match started
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.IN_PROGRESS">
      <summary>
            In progress
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.PAUSE">
      <summary>
            Match paused
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.HALFTIME">
      <summary>
            Half time
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.OVERTIME">
      <summary>
            Match overtime
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FIRST_HALF_OT">
      <summary>
            1st half of overtime
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SECOND_HALF_OT">
      <summary>
            2nd half of overtime
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.PENALTY_SHOOTING">
      <summary>
            Penalty shooting
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.POSTPONED">
      <summary>
            The match has been postponed and will be played later.
            </summary>
      <remarks>
            Signals a significant delay (will not be played on the same day), in which case a new match (with a different match ID) will be created. 
            </remarks>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.DELAYED">
      <summary>
            The match start is delayed
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.CANCELLED">
      <summary>
            The match has been cancelled
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.INTERRUPTED">
      <summary>
            The match has been interrupted
            </summary>
      <remarks>
            Interrupted after start, will continue later. If the match cannot be continued, it will then be abandoned.
            </remarks>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.ABANDONED">
      <summary>
            The match has been abandoned
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.WALKOVER">
      <summary>
            A walkover has been awarded
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.RETIRED">
      <summary>
            Player retired
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.WALKOVER1">
      <summary>
            Player 1 won by walkover
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.WALKOVER2">
      <summary>
            Player 2 won by walkover
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.RETIRED1">
      <summary>
            Player 1 retired
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.RETIRED2">
      <summary>
            Player 2 retired
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.DEFAULTED1">
      <summary>
            Player 1 defaulted (e.g. by being disqualified or failing to attend the match)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.DEFAULTED2">
      <summary>
            Player 2 defaulted (e.g. by being disqualified or failing to attend the match)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.ENDED">
      <summary>
            The match has ended
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.AWAITING_OT">
      <summary>
            Waiting for overtime to start
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.OT_HALFTIME">
      <summary>
            Pause between 1st and 2nd overtime period 
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.AWAITING_PENALTIES">
      <summary>
            Waiting for penalty shooting to start
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.AFTER_OT">
      <summary>
            Overtime is finished
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.AFTER_PENALTIES">
      <summary>
            Penalties are finished
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FIRST_PAUSE">
      <summary>
            1st pause
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SECOND_PAUSE">
      <summary>
            2nd pause
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.THIRD_PAUSE">
      <summary>
            3rd pause
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FOURTH_PAUSE">
      <summary>
            4th pause
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FIFTH_PAUSE">
      <summary>
            5th pause
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SIXTH_PAUSE">
      <summary>
            6th pause
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SUDDEN_DEATH">
      <summary>
            Sudden death
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.AWAITING_SD">
      <summary>
            Awaiting sudden death
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.AFTER_SD">
      <summary>
            After sudden death
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SESSION_BREAK">
      <summary>
            Session break
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FIRST_INNINGS_HOME_TEAM">
      <summary>
            First innings home team
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FIRST_INNINGS_AWAY_TEAM">
      <summary>
            First innings away team
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SECOND_INNINGS_HOME_TEAM">
      <summary>
            Second innings home team
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SECOND_INNINGS_AWAY_TEAM">
      <summary>
            Second innings away team
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.AWAITING_SUPER_OVER">
      <summary>
            Awaiting super over
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SUPER_OVER_HOME_TEAM">
      <summary>
            Super over home team
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SUPER_OVER_AWAY_TEAM">
      <summary>
            Super over away team
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.AFTER_SUPER_OVER">
      <summary>
            After supoer over
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.INNINGS_BREAK">
      <summary>
            Innings break
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SUPER_OVER_BREAK">
      <summary>
            Super over break
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.LUNCH_BREAK">
      <summary>
            Lunch break
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.TEA_BREAK">
      <summary>
            Tea break
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.STUMPS">
      <summary>
            Stumps
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FIRST_INNING_TOP">
      <summary>
            First inning top
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.BREAK_TOP1_BOTTOM1">
      <summary>
            Break top 1 bottom 1
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FIRST_INNING_BOTTOM">
      <summary>
            First inning bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.BREAK_TOP2_BOTTOM1">
      <summary>
            Break top 2 bottom 1
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SECOND_INNING_TOP">
      <summary>
            Second inning top
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.BREAK_TOP2_BOTTOM2">
      <summary>
            Break top 2 bottom 2
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SECOND_INNING_BOTTOM">
      <summary>
            Second inning bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.BREAK_TOP3_BOTTOM2">
      <summary>
            Break top 3 bottom 2
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.THIRD_INNING_TOP">
      <summary>
            Third inning top
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.BREAK_TOP3_BOTTOM3">
      <summary>
            Break top 3 bottom 3
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.THIRD_INNING_BOTTOM">
      <summary>
            Third inning bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.BREAK_TOP4_BOTTOM3">
      <summary>
            Break top 4 bottom 3
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FOURTH_INNING_TOP">
      <summary>
            Fourth inning top
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.BREAK_TOP4_BOTTOM4">
      <summary>
            Break top 4 bottom 4
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FOURTH_INNING_BOTTOM">
      <summary>
            Fourth inning bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.BREAK_TOP5_BOTTOM4">
      <summary>
            Break top 5 bottom 4
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FIFTH_INNING_TOP">
      <summary>
            Fifth inning top
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.BREAK_TOP5_BOTTOM5">
      <summary>
            Break top 5 bottom 5
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FIFTH_INNING_BOTTOM">
      <summary>
            Fifth inning bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.BREAK_TOP6_BOTTOM5">
      <summary>
            Break top 6 bottom 5
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SIXTH_INNING_TOP">
      <summary>
            Sixth inning top
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.BREAK_TOP6_BOTTOM6">
      <summary>
            Break top 6 bottom 6
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SIXTH_INNING_BOTTOM">
      <summary>
            Sixth inning bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.BREAK_TOP7_BOTTOM6">
      <summary>
            Break top 7 bottom 6
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SEVENTH_INNING_TOP">
      <summary>
            Seventh inning top
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.BREAK_TOP7_BOTTOM7">
      <summary>
            Break top 7 bottom 7
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SEVENTH_INNING_BOTTOM">
      <summary>
            Seventh inning bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.BREAK_TOP8_BOTTOM7">
      <summary>
            Break top 8 bottom 7
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.EIGHTH_INNING_TOP">
      <summary>
            Eighth inning top
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.BREAK_TOP8_BOTTOM8">
      <summary>
            Break top 8 bottom 8
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.EIGHTH_INNING_BOTTOM">
      <summary>
            Eighth  inning bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.BREAK_TOP9_BOTTOM8">
      <summary>
            Break top 9 bottom 8
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.NINTH_INNING_TOP">
      <summary>
            Ninth inning top
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.BREAK_TOP9_BOTTOM9">
      <summary>
            Break top 9 bottom 9
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.NINTH_INNING_BOTTOM">
      <summary>
            Ninth inning bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.BREAK_TOPEI_BOTTOM9">
      <summary>
            Break top extra inning bottom 9
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.EXTRA_INNING_TOP">
      <summary>
            Extra inning top
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.BREAK_TOPEI_BOTTOMEI">
      <summary>
            Break top extra inning bottom extra inning
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.EXTRA_INNING_BOTTOM">
      <summary>
            Extra inning bottom
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FIRST_MAP">
      <summary>
            First map
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SECOND_MAP">
      <summary>
            Second map
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.THIRD_MAP">
      <summary>
            Third map
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FOURTH_MAP">
      <summary>
            Fourth map
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FIFTH_MAP">
      <summary>
            Fifth map
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SIXTH_MAP">
      <summary>
            Sixth map
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SEVENTH_MAP">
      <summary>
            Seventh map
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FIRST_GAME">
      <summary>
            First game
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.SECOND_GAME">
      <summary>
            Second game
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.THIRD_GAME">
      <summary>
            Third game
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FOURTH_GAME">
      <summary>
            Fourth game
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatus.FIFTH_GAME">
      <summary>
            Fifth game
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatusClasses">
      <summary>
            Group ScoutMatchStatus in to different classes.
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatusClasses.DELAYED">
      <summary>
            An unexpected delay has occurred on the match.
            </summary>
      <remarks>
            You should not purge such matches in that state.
            </remarks>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.ScoutMatchStatusClasses.TERMINAL">
      <summary>
            Terminal states.
            </summary>
      <remarks>
            The match is no longer intersting for us after the transition to that state.
            </remarks>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.MatchBetStatus">
      <summary>
            Bet status (whether market is open or closed)
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.MatchBetStatus.UNDEFINED">
      <summary>
            Undefined
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.MatchBetStatus.NOT_STARTED">
      <summary>
            Not started
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.MatchBetStatus.STARTED">
      <summary>
            Started
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.MatchBetStatus.BETSTOP">
      <summary>
            Bet stop
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.PitchConditions">
      <summary>
            Pitch conditions.
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.PitchConditions.UNDEFINED">
      <summary>
            Undefined
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.PitchConditions.GOOD">
      <summary>
            Good
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.PitchConditions.MEDIUM">
      <summary>
            Medium
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.PitchConditions.BAD">
      <summary>
            Bad
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.PitchConditions.UNKNOWN">
      <summary>
            Unknown
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.SurfaceType">
      <summary>
            Type of surface
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.SurfaceType.UNDEFINED">
      <summary>
            Undefined
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.SurfaceType.SAND">
      <summary>
            Sand
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.SurfaceType.HARDCOURT">
      <summary>
            Hard court
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.SurfaceType.GRASS">
      <summary>
            Grass
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.SurfaceType.CARPET">
      <summary>
            Carpet
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.SurfaceType.UNKNOWN">
      <summary>
            Unknown
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.WeatherConditions">
      <summary>
            Weather conditions
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.WeatherConditions.UNDEFINED">
      <summary>
            Undefined
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.WeatherConditions.GOOD">
      <summary>
            Good
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.WeatherConditions.MEDIUM">
      <summary>
            Medium
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.WeatherConditions.BAD">
      <summary>
            Bad
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.WeatherConditions.UNKNOWN">
      <summary>
            Unknown
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.LiveScout.WeatherConditions.INDOOR">
      <summary>
            Indoor
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout">
      <summary>
            Live scout client interface.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.GetMatchList(System.Int32,System.Int32,System.Boolean)">
      <summary>
            Request a list of available scout matches for a given time frame.
            By default only matches you have access to will be sent.
            You can also request all available matches by setting the <paramref name="include_avail" />.
            If this is done the reply will also include matches that are open for booking.
            </summary>
      <param name="hours_back">Start of time frame</param>
      <param name="hours_fwd">End  of time frame</param>
      <param name="include_avail">Whether to also include all available matches for booking</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.SubscribeTest(System.Int64,System.Nullable{System.Int32},System.Nullable{System.Int32})">
      <summary>
            Request a full feed for the match, and then update messages will follow in the same pace as they were sent out live.
            </summary>
      <param name="match_id">Match id.</param>
      <param name="message_delay">Specifies how many milliseconds to wait in between sending out each message.</param>
      <param name="start_message">
            Specifies which message to start replay on (how far into the match).
            If startmessage is greater than or equal to the number of messages for the match, a full feed for the finished match is sent out, and no more messages will follow after this.
            </param>
      <remarks>
            This should only be used on the test server.
            </remarks>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnClosed">
      <summary>
            Signals that the underlaying connection has been closed (disconnect)
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnLineups">
      <summary>
            Player lineups for both teams were received.
            </summary>
      <remarks>
            The event is dispatched immediately after subscribing to a match and every time the lineup changes.
            XML configuration option "Send lineups for matches where this is available" needs to be activated (currently works just for deep coverage soccer matches).
            </remarks>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnMatchBookingReply">
      <summary>
            Reply sent when a client books a match. If match booking failed for some reason
            (match already bought, match finished etc.), the reply will contain additional explanation.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnMatchData">
      <summary>
            Occurs when [on match data].
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnMatchList">
      <summary>
            Signals that a list of matches in the time frame requested by the client has been received.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnMatchListUpdate">
      <summary>
            Signals that an unsolicited list of matches has been received.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnMatchStop">
      <summary>
            Reply sent after client unsubscribed from a match.
            It could also be sent if match subscription failed for any reason (e.g. too many match subscriptions).
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnMatchUpdate">
      <summary>
        <para>
            Signals that a match update message was received. There are three types of match information messages:
            full match feed, delta match feed and delta update feed (see MatchHeader.TypeOfFeed).
            All three can contain statistical information as well as individual events (an event being a goal, card, etc.).
            </para>
        <para>
            When a client application subscribes to a match, it will receive a full match update immediately after
            (given the subscription was successful). This message will contain all data for the match. Different event types
            are offered for different sports. Note that new event types will be added in the future.
            </para>
        <para>
            After a full match update is received, most updates will be sent as delta updates. In these messages only the new data is sent,
            if a yellow card is given only this event will be sent. In addition summary data will be sent for the event type in question,
            i.e. the total number of yellow cards for the home/away team for the match.
            </para>
        <para>
            If an existing event is changed, a delta update is sent for this event. E.g. a yellow card event is entered,
            and 1 minute later the event is updated by including which player got the card.
            Client must consider this as an update to an existing event, and not a new event (based on Event Id property).
            </para>
      </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnMatchUpdateDelta">
      <summary>
            Delta match update event.
            See <see cref="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnMatchUpdate" /> for more info.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnMatchUpdateDeltaUpdate">
      <summary>
            Delta update match update event.
            See <see cref="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnMatchUpdate" /> for more info.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnMatchUpdateFull">
      <summary>
            Full match update event.
            See <see cref="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnMatchUpdate" /> for more info.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnOddsSuggestion">
      <summary>
            Suggested live odds are constantly updated and sent out according to match events.
            These odds are generated based on statistical models. The format of Odds entities is the same as with LiveOdds interface.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnOpened">
      <summary>
            Signals that the underlaying connection has been opened (connect)
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.LiveScout.ILiveScout.OnScoutInfo">
      <summary>
            Signals some basic information about the match. Sent out when a client subscribes to a match.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.LiveScout.Internal.LiveScoutEntityFactory.BuildFakeBetStop(System.Int64,System.DateTime)">
      <summary>
            Generates a special MatchUpdate messages that contains a betstop event.
            </summary>
      <param name="match_id">Id of the match</param>
      <param name="time">Time when the event should have happened</param>
      <returns>
            An instance of <see cref="T:Sportradar.SDK.FeedProviders.LiveScout.MatchUpdate" />.
            </returns>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.LiveScout.Internal.LiveScoutFeedProviderExt">
      <summary>
            ILiveScout extension methods.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.#ctor">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getOutcomeTypeIds(System.Int32,System.Int32)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.BegingetOutcomeTypeIds(System.Int32,System.Int32,System.AsyncCallback,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.EndgetOutcomeTypeIds(System.IAsyncResult)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getOutcomeTypeIdsAsync(System.Int32,System.Int32)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getOutcomeTypeIdsAsync(System.Int32,System.Int32,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getTennisSidebetsWithTournamentIdAndCategoryId(System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.BegingetTennisSidebetsWithTournamentIdAndCategoryId(System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.AsyncCallback,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.EndgetTennisSidebetsWithTournamentIdAndCategoryId(System.IAsyncResult)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getTennisSidebetsWithTournamentIdAndCategoryIdAsync(System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getTennisSidebetsWithTournamentIdAndCategoryIdAsync(System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getGenders">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.BegingetGenders(System.AsyncCallback,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.EndgetGenders(System.IAsyncResult)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getGendersAsync">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getGendersAsync(System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getTournaments(System.Int32)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.BegingetTournaments(System.Int32,System.AsyncCallback,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.EndgetTournaments(System.IAsyncResult)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getTournamentsAsync(System.Int32)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getTournamentsAsync(System.Int32,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getVolleySidebetsWithTournamentIdAndCategoryId(System.Int32,System.Nullable{System.Int32}[],System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Int32)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.BegingetVolleySidebetsWithTournamentIdAndCategoryId(System.Int32,System.Nullable{System.Int32}[],System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.AsyncCallback,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.EndgetVolleySidebetsWithTournamentIdAndCategoryId(System.IAsyncResult)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getVolleySidebetsWithTournamentIdAndCategoryIdAsync(System.Int32,System.Nullable{System.Int32}[],System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Int32)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getVolleySidebetsWithTournamentIdAndCategoryIdAsync(System.Int32,System.Nullable{System.Int32}[],System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSidebetsWithTournamentIdAndCategoryId(System.Int32,System.Int32,System.Int32,System.Nullable{System.Int32}[],System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.BegingetSidebetsWithTournamentIdAndCategoryId(System.Int32,System.Int32,System.Int32,System.Nullable{System.Int32}[],System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.AsyncCallback,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.EndgetSidebetsWithTournamentIdAndCategoryId(System.IAsyncResult)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSidebetsWithTournamentIdAndCategoryIdAsync(System.Int32,System.Int32,System.Int32,System.Nullable{System.Int32}[],System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSidebetsWithTournamentIdAndCategoryIdAsync(System.Int32,System.Int32,System.Int32,System.Nullable{System.Int32}[],System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSidebetsWithMatchidAndKey(System.Int64,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Double)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.BegingetSidebetsWithMatchidAndKey(System.Int64,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Double,System.AsyncCallback,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.EndgetSidebetsWithMatchidAndKey(System.IAsyncResult)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSidebetsWithMatchidAndKeyAsync(System.Int64,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Double)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSidebetsWithMatchidAndKeyAsync(System.Int64,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Double,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getTennisSidebets(System.Double,System.Double,System.Int32,System.Int32,System.Int32)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.BegingetTennisSidebets(System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.AsyncCallback,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.EndgetTennisSidebets(System.IAsyncResult)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getTennisSidebetsAsync(System.Double,System.Double,System.Int32,System.Int32,System.Int32)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getTennisSidebetsAsync(System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getTennisMatchInfo(System.Int64)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.BegingetTennisMatchInfo(System.Int64,System.AsyncCallback,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.EndgetTennisMatchInfo(System.IAsyncResult)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getTennisMatchInfoAsync(System.Int64)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getTennisMatchInfoAsync(System.Int64,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSurfaces">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.BegingetSurfaces(System.AsyncCallback,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.EndgetSurfaces(System.IAsyncResult)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSurfacesAsync">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSurfacesAsync(System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSidebetsWithKey(System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Double)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.BegingetSidebetsWithKey(System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Double,System.AsyncCallback,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.EndgetSidebetsWithKey(System.IAsyncResult)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSidebetsWithKeyAsync(System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Double)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSidebetsWithKeyAsync(System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Double,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getVolleySidebetsWithKey(System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Double)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.BegingetVolleySidebetsWithKey(System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Double,System.AsyncCallback,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.EndgetVolleySidebetsWithKey(System.IAsyncResult)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getVolleySidebetsWithKeyAsync(System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Double)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getVolleySidebetsWithKeyAsync(System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Double,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getOddsTypeIds(System.Int32,System.Boolean)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.BegingetOddsTypeIds(System.Int32,System.Boolean,System.AsyncCallback,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.EndgetOddsTypeIds(System.IAsyncResult)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getOddsTypeIdsAsync(System.Int32,System.Boolean)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getOddsTypeIdsAsync(System.Int32,System.Boolean,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getVolleySidebets(System.Int32,System.Nullable{System.Int32}[],System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.BegingetVolleySidebets(System.Int32,System.Nullable{System.Int32}[],System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32,System.AsyncCallback,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.EndgetVolleySidebets(System.IAsyncResult)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getVolleySidebetsAsync(System.Int32,System.Nullable{System.Int32}[],System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getVolleySidebetsAsync(System.Int32,System.Nullable{System.Int32}[],System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSidebets(System.Int32,System.Nullable{System.Int32}[],System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.BegingetSidebets(System.Int32,System.Nullable{System.Int32}[],System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.AsyncCallback,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.EndgetSidebets(System.IAsyncResult)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSidebetsAsync(System.Int32,System.Nullable{System.Int32}[],System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSidebetsAsync(System.Int32,System.Nullable{System.Int32}[],System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getTennisSidebetsWithKey(System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Double)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.BegingetTennisSidebetsWithKey(System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,System.AsyncCallback,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.EndgetTennisSidebetsWithKey(System.IAsyncResult)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getTennisSidebetsWithKeyAsync(System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Double)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getTennisSidebetsWithKeyAsync(System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSidebetsWithMatchid(System.Int64,System.Nullable{System.Int32}[],System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.BegingetSidebetsWithMatchid(System.Int64,System.Nullable{System.Int32}[],System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.AsyncCallback,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.EndgetSidebetsWithMatchid(System.IAsyncResult)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSidebetsWithMatchidAsync(System.Int64,System.Nullable{System.Int32}[],System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSidebetsWithMatchidAsync(System.Int64,System.Nullable{System.Int32}[],System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getCategories(System.Int32)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.BegingetCategories(System.Int32,System.AsyncCallback,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.EndgetCategories(System.IAsyncResult)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getCategoriesAsync(System.Int32)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getCategoriesAsync(System.Int32,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSports">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.BegingetSports(System.AsyncCallback,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.EndgetSports(System.IAsyncResult)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSportsAsync">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSportsAsync(System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.checkStatus">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.BegincheckStatus(System.AsyncCallback,System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.EndcheckStatus(System.IAsyncResult)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.checkStatusAsync">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.checkStatusAsync(System.Object)">
      <remarks />
    </member>
    <member name="M:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.CancelAsync(System.Object)">
      <remarks />
    </member>
    <member name="E:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getOutcomeTypeIdsCompleted">
      <remarks />
    </member>
    <member name="E:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getTennisSidebetsWithTournamentIdAndCategoryIdCompleted">
      <remarks />
    </member>
    <member name="E:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getGendersCompleted">
      <remarks />
    </member>
    <member name="E:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getTournamentsCompleted">
      <remarks />
    </member>
    <member name="E:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getVolleySidebetsWithTournamentIdAndCategoryIdCompleted">
      <remarks />
    </member>
    <member name="E:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSidebetsWithTournamentIdAndCategoryIdCompleted">
      <remarks />
    </member>
    <member name="E:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSidebetsWithMatchidAndKeyCompleted">
      <remarks />
    </member>
    <member name="E:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getTennisSidebetsCompleted">
      <remarks />
    </member>
    <member name="E:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getTennisMatchInfoCompleted">
      <remarks />
    </member>
    <member name="E:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSurfacesCompleted">
      <remarks />
    </member>
    <member name="E:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSidebetsWithKeyCompleted">
      <remarks />
    </member>
    <member name="E:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getVolleySidebetsWithKeyCompleted">
      <remarks />
    </member>
    <member name="E:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getOddsTypeIdsCompleted">
      <remarks />
    </member>
    <member name="E:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getVolleySidebetsCompleted">
      <remarks />
    </member>
    <member name="E:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSidebetsCompleted">
      <remarks />
    </member>
    <member name="E:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getTennisSidebetsWithKeyCompleted">
      <remarks />
    </member>
    <member name="E:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSidebetsWithMatchidCompleted">
      <remarks />
    </member>
    <member name="E:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getCategoriesCompleted">
      <remarks />
    </member>
    <member name="E:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.getSportsCompleted">
      <remarks />
    </member>
    <member name="E:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.OddsCreatorService.checkStatusCompleted">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.staticInfoData">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.staticInfoData.id">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.staticInfoData.name">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.outcome">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.outcome.id">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.outcome.odds">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.outcome.spread">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.oddsTypeData">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.oddsTypeData.description">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.oddsTypeData.oddsTypeId">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.oddsTypeData.outcomes">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getOutcomeTypeIdsCompletedEventHandler">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getOutcomeTypeIdsCompletedEventArgs">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getOutcomeTypeIdsCompletedEventArgs.Result">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getTennisSidebetsWithTournamentIdAndCategoryIdCompletedEventHandler">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getTennisSidebetsWithTournamentIdAndCategoryIdCompletedEventArgs">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getTennisSidebetsWithTournamentIdAndCategoryIdCompletedEventArgs.Result">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getGendersCompletedEventHandler">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getGendersCompletedEventArgs">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getGendersCompletedEventArgs.Result">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getTournamentsCompletedEventHandler">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getTournamentsCompletedEventArgs">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getTournamentsCompletedEventArgs.Result">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getVolleySidebetsWithTournamentIdAndCategoryIdCompletedEventHandler">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getVolleySidebetsWithTournamentIdAndCategoryIdCompletedEventArgs">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getVolleySidebetsWithTournamentIdAndCategoryIdCompletedEventArgs.Result">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getSidebetsWithTournamentIdAndCategoryIdCompletedEventHandler">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getSidebetsWithTournamentIdAndCategoryIdCompletedEventArgs">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getSidebetsWithTournamentIdAndCategoryIdCompletedEventArgs.Result">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getSidebetsWithMatchidAndKeyCompletedEventHandler">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getSidebetsWithMatchidAndKeyCompletedEventArgs">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getSidebetsWithMatchidAndKeyCompletedEventArgs.Result">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getTennisSidebetsCompletedEventHandler">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getTennisSidebetsCompletedEventArgs">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getTennisSidebetsCompletedEventArgs.Result">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getTennisMatchInfoCompletedEventHandler">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getTennisMatchInfoCompletedEventArgs">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getTennisMatchInfoCompletedEventArgs.Result">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getSurfacesCompletedEventHandler">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getSurfacesCompletedEventArgs">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getSurfacesCompletedEventArgs.Result">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getSidebetsWithKeyCompletedEventHandler">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getSidebetsWithKeyCompletedEventArgs">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getSidebetsWithKeyCompletedEventArgs.Result">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getVolleySidebetsWithKeyCompletedEventHandler">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getVolleySidebetsWithKeyCompletedEventArgs">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getVolleySidebetsWithKeyCompletedEventArgs.Result">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getOddsTypeIdsCompletedEventHandler">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getOddsTypeIdsCompletedEventArgs">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getOddsTypeIdsCompletedEventArgs.Result">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getVolleySidebetsCompletedEventHandler">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getVolleySidebetsCompletedEventArgs">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getVolleySidebetsCompletedEventArgs.Result">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getSidebetsCompletedEventHandler">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getSidebetsCompletedEventArgs">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getSidebetsCompletedEventArgs.Result">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getTennisSidebetsWithKeyCompletedEventHandler">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getTennisSidebetsWithKeyCompletedEventArgs">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getTennisSidebetsWithKeyCompletedEventArgs.Result">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getSidebetsWithMatchidCompletedEventHandler">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getSidebetsWithMatchidCompletedEventArgs">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getSidebetsWithMatchidCompletedEventArgs.Result">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getCategoriesCompletedEventHandler">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getCategoriesCompletedEventArgs">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getCategoriesCompletedEventArgs.Result">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getSportsCompletedEventHandler">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getSportsCompletedEventArgs">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.getSportsCompletedEventArgs.Result">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.checkStatusCompletedEventHandler">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.checkStatusCompletedEventArgs">
      <remarks />
    </member>
    <member name="P:Sportradar.SDK.ProtocolProviders.ProtocolUnits.OddsCreator.checkStatusCompletedEventArgs.Result">
      <remarks />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.OddsCreator.IdName">
      <summary>
            Id and name tuple
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.IdName.#ctor(System.Int32,System.String)">
      <summary>
            IdName constructor
            </summary>
      <param name="id">An id</param>
      <param name="name">A name</param>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.OddsCreator.IdName.Id">
      <summary>
            Id of the instance
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.OddsCreator.IdName.Name">
      <summary>
            Name of the instance
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.OddsCreator.OddsType">
      <summary>
            OddsCreator odds type
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.OddsType.#ctor(System.Int32,System.String,System.Collections.Generic.List{Sportradar.SDK.FeedProviders.OddsCreator.Outcome})">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.OddsCreator.OddsType" /> class.
            </summary>
      <param name="oddsTypeId">The odds type id.</param>
      <param name="description">The description.</param>
      <param name="outcomes">The outcomes.</param>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.OddsCreator.OddsType.Description">
      <summary>
            Gets or sets the description.
            </summary>
      <value>
            The description.
            </value>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.OddsCreator.OddsType.OddsTypeId">
      <summary>
            Gets or sets the odds type id.
            </summary>
      <value>
            The odds type id.
            </value>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.OddsCreator.OddsType.Outcomes">
      <summary>
            Gets or sets the outcomes.
            </summary>
      <value>
            The outcomes.
            </value>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.OddsCreator.Outcome">
      <summary>
            OddsCreator outcome
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.Outcome.#ctor(System.Int32,System.Double,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.OddsCreator.Outcome" /> class.
            </summary>
      <param name="id">The id.</param>
      <param name="odds">The odds.</param>
      <param name="spread">The spread.</param>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.OddsCreator.Outcome.Id">
      <summary>
            Gets or sets the id.
            </summary>
      <value>
            The id.
            </value>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.OddsCreator.Outcome.Odds">
      <summary>
            Gets or sets the odds.
            </summary>
      <value>
            The odds.
            </value>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.OddsCreator.Outcome.Spread">
      <summary>
            Gets or sets the spread.
            </summary>
      <value>
            The spread.
            </value>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.OddsCreator.OddsCreatorException">
      <summary>
            OddsCreator base exception
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.OddsCreatorException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.OddsCreator.OddsCreatorException" /> class
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.OddsCreatorException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.OddsCreator.OddsCreatorException" /> class
            </summary>
      <param name="message">Exception message</param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.OddsCreatorException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Sportradar.SDK.FeedProviders.OddsCreator.OddsCreatorException" /> class
            </summary>
      <param name="message">Exception message</param>
      <param name="inner_exception">Inner exception</param>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.OddsCreator.IOddsCreator">
      <summary>
            The Betradar odds calculation web services will calculate a number of different odds types 
            based on your match bet and total (over/under) odds. We offer a range of different odds
            types for several different sports.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.IOddsCreator.GetCategories(System.Int32)">
      <summary>
            Returns a list of category ids and the corresponding descriptions we provide
            for a specified sport. This list represents the categories where we offer further
            odds calculation.
            </summary>
      <param name="sportId">The sport id to fetch the categories from.</param>
      <returns>Collection of ids and names of categories.</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.IOddsCreator.GetGenders">
      <summary>
            Returns a list of gender ids and the corresponding gender
            description used to calculate tennis odds.
            </summary>
      <returns>Collection of ids and names of genders.</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.IOddsCreator.GetOddsTypeIds(System.Int32,System.Boolean)">
      <summary>
            Returns a list of odds type ids and the corresponding odds type
            names. This list represents the odds types we offer for each sport.
            </summary>
      <param name="sportId">The sport id.</param>
      <param name="needMatchId">If set to false, only odds types that does not require match id are returned, otherwise all available.</param>
      <returns>Collection of ids and names of genders.</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.IOddsCreator.GetOutcomeTypeIds(System.Int32,System.Int32)">
      <summary>
            Returns a list of outcome type ids and the corresponding outcome type names. 
            This list represents the outcomes we offer for a particular sport/odds type combination.
            </summary>
      <param name="sportId">The sport id.</param>
      <param name="oddsTypeId">The odds type id.</param>
      <returns>Collection of ids and names of genders.</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.IOddsCreator.GetSidebets(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Int32[])">
      <summary>
            Special odds calculation with a given tournament id and category id.
            </summary>
      <remarks>
            This method follows the same as getSidebets. In addition it adjusts the odds key according to the configuration set at betradar.com,
            based on given tournament and / or category id. Default values will be chosen if none are set explicitly. To ignore either the
            tournament or category id, set id to 0.
            </remarks>
      <param name="homeOdds">The home odds.</param>
      <param name="drawOdds">The draw odds.</param>
      <param name="awayOdds">The away odds.</param>
      <param name="totalSpread">The total spread.</param>
      <param name="overOdds">The over odds.</param>
      <param name="underOdds">The under odds.</param>
      <param name="sportId">The sport id.</param>
      <param name="categoryId">Id to indicate the category configuration we do calculations based upon. Set to 0 if category should not be taken into consideration.</param>
      <param name="tournamentId">Id to indicate the tournament configuration we do calculations based upon. Set to 0 if tournament should not be taken into consideration.</param>
      <param name="oddsTypeIds">List of ids corresponding to the odds type ids you want adjusted.(The possible odds type ids are described in detail in
            “Life Cycle of Odds” documentation, available in the download section at betradar.com). If the list is empty,all available odds types will be generated.</param>
      <returns>
            Collection of odds types
            </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.IOddsCreator.GetSidebets(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Double)">
      <summary>
            Special odds calculation with a given oddstype id and odds key.
            </summary>
      <remarks>
            This method lets you request odds for a specific market, adjusted to the key you provide.
            </remarks>
      <param name="homeOdds">Your home team match bet odds.</param>
      <param name="drawOdds">Your draw match bet odds (set to 0.0 for sports where a draw outcome is not possible (Basketball, American Football, Baseball and so on).</param>
      <param name="awayOdds">Your away team match bet odds.</param>
      <param name="totalSpread">Your total odds spread.</param>
      <param name="overOdds">Your over odds.</param>
      <param name="underOdds">Your under odds.</param>
      <param name="sportId">The sport id.</param>
      <param name="oddsTypeId">The odds type you want adjusted.</param>
      <param name="oddsKey">The odds key you want your odds adjusted to.</param>
      <returns>Collection of odds  types</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.IOddsCreator.GetSidebets(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32[])">
      <summary>
            General special odds calculation.
            </summary>
      <remarks>
            Main method where most of the special odds are adjusted. The odds keys are adjusted according to the 
            configuration set in betradar.com, or default values if none are set.
            </remarks>
      <param name="homeOdds">Your home team match bet odds.</param>
      <param name="drawOdds">Your draw match bet odds (set to 0.0 for sports where a draw outcome is not possible (Basketball, American Football, Baseball and so on).</param>
      <param name="awayOdds">Your away team match bet odds.</param>
      <param name="totalSpread">Your total odds spread.</param>
      <param name="overOdds">Your over odds.</param>
      <param name="underOdds">Your under odds.</param>
      <param name="sportId">The internal Betradar sport id. </param>
      <param name="oddsTypeIds">List of ids corresponding to the odds type ids you want adjusted. (The possible odds type ids are described 
            in detail in “Life Cycle of Odds” documentation, available in the download section at betradar.com). If the list is empty, all available
            odds types will be generated.</param>
      <returns>Collection of odds  types</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.IOddsCreator.GetSidebets(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int64,System.Double,System.Int32)">
      <summary>
            Special odds calculation with a given match id, odds type and odds key.
            </summary>
      <remarks>
            This method lets you request odds for a given match, for a specific market,
            adjusted to the key you provide
            </remarks>
      <param name="homeOdds">Your home team match bet odds.</param>
      <param name="drawOdds">Your draw match bet odds (set to 0.0 for sports where a draw outcome is not possible (Basketball, American Football, Baseball and so on).</param>
      <param name="awayOdds">Your away team match bet odds.</param>
      <param name="totalSpread">Your total odds spread.</param>
      <param name="overOdds">Your over odds.</param>
      <param name="underOdds">Your under odds.</param>
      <param name="matchId">The Betradar match id.</param>
      <param name="oddsKey">The odds key you want your odds adjusted to.</param>
      <param name="oddsTypeId">The odds type you want adjusted.</param>
      <returns>
            Collection of odds  types
            </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.IOddsCreator.GetSidebets(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int64,System.Int32[])">
      <summary>
            Special odds calculation with a given match id.
            </summary>
      <param name="homeOdds">Your home team match bet odds.</param>
      <param name="drawOdds">Your draw match bet odds (set to 0.0 for sports where a draw outcome is not possible (Basketball, American Football, Baseball and so on).</param>
      <param name="awayOdds">Your away team match bet odds.</param>
      <param name="totalSpread">Your total odds spread.</param>
      <param name="overOdds">Your over odds.</param>
      <param name="underOdds">Your under odds.</param>
      <param name="matchId">The Betradar match id.</param>
      <param name="oddsTypeIds">List of ids corresponding to the odds type ids you want adjusted. (The possible odds type ids are described
            in detail in “Life Cycle of Odds” documentation, available in the download section at betradar.com). If the list is empty, all available
            odds types will be generated.</param>
      <returns>
            Collection of odds  types
            </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.IOddsCreator.GetSports">
      <summary>
            Returns a list of sport ids and the corresponding sport names. This list represents the sports where we offer further odds calculation.
            </summary>
      <returns>Collection of ids and names of sports.</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.IOddsCreator.GetSurfaces">
      <summary>
            Returns a list of surface ids and the corresponding surface type names used to calculate tennis odds.
            </summary>
      <returns>Collection of ids and names of surfaces.</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.IOddsCreator.GetTennisSidebets(System.Double,System.Double,System.Int32,System.Int32,System.Int32)">
      <summary>
            Tennis special odds calculation
            </summary>
      <remarks>
            This is a specific method to calculate tennis special odds. The tennis odds calculation requires other 
            input parameters than the rest of the sports.
            </remarks>
      <param name="homeOdds">Your home team match bet odds.</param>
      <param name="awayOdds">Your away team match bet odds.</param>
      <param name="gender">Id to indicate if this is a match played by men or women.</param>
      <param name="bestOfSets">Specify if the match is best of 3 sets or best of 5 sets.</param>
      <param name="surface">Id to indicate what kind of surface the match is played on.</param>
      <returns>Collection of odds  types</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.IOddsCreator.GetTennisSidebets(System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Tennis special odds calculation with tournament id and category id
            </summary>
      <remarks>
            This method does the same as getTennisSidebets(homeOdds, awayOdds, gender, bestOfSets, surface).
            In addition it adjusts the odds key according to the configuration set at betradar.com, based on given 
            tournament and / or category id. Default values will be chosen if none are set explicitly. 
            To ignore either the tournament or category id, set id to 0.
            </remarks>
      <param name="homeOdds">Your home team match bet odds.</param>
      <param name="awayOdds">Your away team match bet odds.</param>
      <param name="gender">Id to indicate if this is a match played by men or women.</param>
      <param name="bestOfSets">Specify if the match is best of 3 sets or best of 5 sets.</param>
      <param name="surface">Id to indicate what kind of surface the match is played on.</param>
      <param name="categoryId">Id to indicate the category configuration we do calculations based upon. Set to 0 if category should not be taken into consideration.</param>
      <param name="tournamentId">Id to indicate the tournament configuration we do calculations based upon. Set to 0 if tournament should not be taken into consideration</param>
      <returns>Collection of odds  types</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.IOddsCreator.GetTennisSidebets(System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Double)">
      <summary>
            Tennis special odds calculation with odds type and odds key
            </summary>
            This method lets you request odds for tennis for a specific market, adjusted to the key you provide.
            <remarks></remarks><param name="homeOdds">Your home team match bet odds.</param><param name="awayOdds">Your away team match bet odds.</param><param name="gender">Id to indicate if this is a match played by men or women.</param><param name="bestOfSets">Specify if the match is best of 3 sets or best of 5 sets.</param><param name="surface">Id to indicate what kind of surface the match is played on.</param><param name="oddsTypeId">The odds type you want adjusted.</param><param name="oddsKey">The odds key you want your odds adjusted to.</param><returns>Collection of odds  types</returns></member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.IOddsCreator.GetTennisMatchInfo(System.Int64)">
      <summary>
            Gets the tennis match information
            </summary>
      <param name="matchId">The match identifier</param>
      <returns>Collection of ids and names of tournaments</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.IOddsCreator.GetTournaments(System.Int32)">
      <summary>
            Returns a list of tournament ids and the corresponding tournament names. 
            This list represents the tournaments for a specified category.
            </summary>
      <param name="categoryId">The category id to get the tournaments in.</param>
      <returns>Collection of ids and names of tournaments.</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.IOddsCreator.GetVolleySidebets(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Int32[])">
      <summary>
            (Beach) Volleyball special odds calculation
            </summary>
      <remarks>
            This method calculates volleyball / beach volleyball special odds.
            The odds calculation requires other input parameters than the rest of the sports.
            </remarks>
      <param name="homeOdds">Your home team match bet odds.</param>
      <param name="drawOdds">Your draw match bet odds (set to 0.0 for sports where a draw outcome is not possible (Basketball, American Football, Baseball and so on).</param>
      <param name="awayOdds">Your away team match bet odds.</param>
      <param name="totalSpread">Your total odds spread.</param>
      <param name="overOdds">Your over odds.</param>
      <param name="underOdds">Your under odds.</param>
      <param name="sportId">The internal Betradar sport id. </param>
      <param name="gender">Id to indicate if this is a match played by men or women.</param>
      <param name="topLeague">Number to indicate whether it is a top league game or not</param>
      <param name="oddsTypeIds">List of ids corresponding to the odds type ids you want adjusted. (The possible odds type ids are described
            in detail in “Life Cycle of Odds” documentation, available in the download section at betradar.com). If the list is empty, all available
            odds types will be generated.</param>
      <returns>Collection of odds  types</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.IOddsCreator.GetVolleySidebets(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Double)">
      <summary>
            (Beach) Volleyball special odds calculation with odds type and odds key
            </summary>
      <remarks>
            This method lets you request odds for volleyball for a specific market, adjusted to the key you provide.
            </remarks>
      <param name="homeOdds">Your home team match bet odds.</param>
      <param name="drawOdds">Your draw match bet odds (set to 0.0 for sports where a draw outcome is not possible (Basketball, American Football, Baseball and so on).</param>
      <param name="awayOdds">Your away team match bet odds.</param>
      <param name="totalSpread">Your total odds spread.</param>
      <param name="overOdds">Your over odds.</param>
      <param name="underOdds">Your under odds.</param>
      <param name="sportId">The internal Betradar sport id. </param>
      <param name="gender">Id to indicate if this is a match played by men or women.</param>
      <param name="topLeague">Number to indicate whether it is a top league game or not</param>
      <param name="oddsTypeId">The odds type you want adjusted.</param>
      <param name="oddsKey">The odds key you want your odds adjusted to.</param>
      <returns>Collection of odds  types</returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.OddsCreator.IOddsCreator.GetVolleySidebets(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[])">
      <summary>
            (Beach) Volleyball special odds calculation with tournament id and category id
            </summary>
      <remarks>
            This method does the same as getVolleySidebets. In addition it adjusts the odds
            key according to the configuration set at betradar.com, based on given tournament and / or
            category id. Default values will be chosen if none are set explicitly. To ignore either the
            tournament or category id, set id to 0.
            </remarks>
      <param name="homeOdds">Your home team match bet odds.</param>
      <param name="drawOdds">Your draw match bet odds (set to 0.0 for sports where a draw outcome is not possible (Basketball, American Football, Baseball and so on).</param>
      <param name="awayOdds">Your away team match bet odds.</param>
      <param name="totalSpread">Your total odds spread.</param>
      <param name="overOdds">Your over odds.</param>
      <param name="underOdds">Your under odds.</param>
      <param name="sportId">The internal Betradar sport id. </param>
      <param name="categoryId">Id to indicate the category configuration we do calculations based upon. Set to 0 if category should not be taken into consideration.</param>
      <param name="tournamentId">Id to indicate the tournament configuration we do calculations based upon. Set to 0 if tournament should not be taken into consideration.</param>
      <param name="gender">Id to indicate if this is a match played by men or women.</param>
      <param name="topLeague">Number to indicate whether it is a top league game or not</param>
      <param name="oddsTypeIds">List of ids corresponding to the odds type ids you want adjusted. (The possible odds type ids are described
            in detail in “Life Cycle of Odds” documentation, available in the download section at betradar.com). If the list is empty, all available
            odds types will be generated.</param>
      <returns>Collection of odds  types</returns>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.FeedType">
      <summary>
            Feed type
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.CardType">
      <summary>
            CardType Emun
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.Lcoo.CardType.UNDEFINED">
      <summary>
            Undefined
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.Lcoo.CardType.RED">
      <summary>
            Red
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.Lcoo.CardType.YELLOWRED">
      <summary>
            Yellowred
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.Lcoo.CardType.YELLOW">
      <summary>
            Yellow
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.Hand">
      <summary>
            Hand enum
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.Lcoo.Hand.UNDEFINED">
      <summary>
            Undefined
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.Lcoo.Hand.RIGHT">
      <summary>
            Right
            </summary>
    </member>
    <member name="F:Sportradar.SDK.FeedProviders.Lcoo.Hand.LEFT">
      <summary>
            Left
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.AggregateScoreEntity">
      <summary>
            Contains aggregated results from best of 2 matches.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.AggregateScoreEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.BetEntity">
      <summary>
            Contains odds for specific odds type
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.BetEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.BetEntity.Odds">
      <summary>
            Odds and their bet value        
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.BetEntity.OddsType">
      <summary>
            Odd type
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.BetfairIdEntity">
      <summary>
            Contains Betfair identifier information
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.BetfairIdEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.BetfairIdEntity.EventId">
      <summary>
            Event identifier
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.BetfairIdEntity.Runner1">
      <summary>
            Runner 1 identifier
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.BetfairIdEntity.Runner2">
      <summary>
            Runner 2 identifier
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.BetfairIdEntity.SportId">
      <summary>
            Sport identifier
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.BetResultEntity">
      <summary>
            Contains information about match bet result
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.BetResultEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.BetResultEntity.VoidFactor">
      <summary>
            Void factor
             <remarks> Void factor can either be 1 or 0.5, indicating that the whole or half of the bet is voided
             and should be refunded to the customer. When the void factor is set to 0.5, the {@link #getStatus()}
             will indicate if the other half has won or lost. </remarks></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.BetResultEntity.Status">
      <summary>
            Bet status. Lost if false
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.BetResultEntity.Reason">
      <summary>
            Reason information
            <remarks> It might happen that the match ends with a result which Betradar has made no
            odds suggestion for. If this is the case {@link #getOutcome()} will be "C"
            and {@code #getReason()} will contain explanation </remarks></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.BetResultEntity.OddsType">
      <summary>
            Odds type        
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.BetResultEntity.Outcome">
      <summary>
            Outcome
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.BetResultEntity.PlayerId">
      <summary>
            The ID of the player referenced in the bet.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.BetResultEntity.TeamId">
      <summary>
            The ID of the team referenced in the bet.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.BetResultEntity.SpecialBetValue">
      <summary>
            Special odds value
            <remarks> Special odds values are specified only for some odds types like total,
            handicap and freetext3way/2way/nway. This indicates the total value,
            handicap value or freetext details respectively. </remarks></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.BetResultEntity.OutcomeId">
      <summary>
            Outcome id
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.CardEntity">
      <summary>
            Contains information about a card
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.CardEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.CardEntity.Player">
      <summary>
            Affected player        
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.CardEntity.Id">
      <summary>
            Unique id of the live event
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.CardEntity.Time">
      <summary>
            Match time of the card
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.CardEntity.Type">
      <summary>
            Type of card (Yellow, Red or YellowRed)
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.CardsEntity">
      <summary>
            Contains multiple card entities
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.CardsEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.CardsEntity.Cards">
      <summary>
            Cards        
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.CardsEntity.Doubtful">
      <summary>
             Mark if the corners market has conflicting source information
            <remarks> Note : Only available if “Mark doubtful bookings and goals” is checked in config </remarks></summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.CategoryEntity">
      <summary>
            Entity that contains information about category
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.CategoryEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.CategoryEntity.Id">
      <summary>
            Category id
            <returns> category id </returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.CategoryEntity.IsoId">
      <summary>
            ISO country id
            <remarks> Note : Only available if “ISO country codes and names” is checked in config </remarks></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.CategoryEntity.IsoName">
      <summary>
            ISO country name
            <remarks> Note : Only available if “ISO country codes and names” is checked in config </remarks></summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.CommentEntity">
      <summary>
            Container entity for comments
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.CommentEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.CommentEntity.Language">
      <summary>
            Language
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.CommentEntity.Value">
      <summary>
            Comment        
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.CompetitorsEntity">
      <summary>
            Contains information about competitors in event
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.CompetitorsEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.CompetitorsEntity.Players">
      <summary>
            Players
            list of {@link PlayerEntity}
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.CompetitorsEntity.Texts">
      <summary>
            Contains texts for competitors
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.CoordinatesEntity">
      <summary>
            Contain GPS latitude and longitude
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.CoordinatesEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.CoordinatesEntity.Latitude">
      <summary>
            Latitude of GPS coordinates        
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.CoordinatesEntity.Longitude">
      <summary>
            Longitude of GPS coordinates                
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.CornerEntity">
      <summary>
            Provides the number of corners awarded to each team in the course of the 1st Half, 2nd Half, and FT
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.CornerEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.CornerEntity.Count">
      <summary>
            Corner count
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.CornerEntity.Team">
      <summary>
            Which team was the corner awarded to 
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.CornerEntity.Type">
      <summary>
            Which part of the game (1st Half/2nd Half/FT)
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.CornersEntity">
      <summary>
            Contains multiple corner entities
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.CornersEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.CornersEntity.Corners">
      <summary>
            Cards        
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.CornersEntity.Doubtful">
      <summary>
             Mark if the corners market has conflicting source information
            <remarks> Note : Only available if “Mark doubtful bookings and goals” is checked in config </remarks></summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.DateInfoEntity">
      <summary>
            Contains the date and time of the game and optional “delayed match info”
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.DateInfoEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.DateInfoEntity.Comment">
      <summary>
            Comment with translations. For example if match is delayed
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.DateInfoEntity.ConfirmedMatchStart">
      <summary>
            The confirmed match start in UTC
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.DateInfoEntity.Info">
      <summary>
            Information about this date
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.DateInfoEntity.MatchDate">
      <summary>
            Match date in UTC
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.EventInfoEntity">
      <summary>
            Contains meta information about the outright
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.EventInfoEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.EventInfoEntity.Active">
      <summary>
            Event status
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.EventInfoEntity.EventDate">
      <summary>
            Event date in UTC       
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.EventInfoEntity.EventEndDate">
      <summary>
            Event end date in UTC        
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.EventInfoEntity.EventName">
      <summary>
            Event names
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.EventInfoEntity.EventStart">
      <summary>
            Event start in UTC        
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.EventInfoEntity.TournamentId">
      <summary>
            Tournament id
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.FixtureEntity">
      <summary>
            Contains all the meta info about specific fixture
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.FixtureEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.FixtureEntity.AamsCalendarId">
      <summary>
            AAMS Calendar id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.FixtureEntity.AggregateScore">
      <summary>
            Aggregated result (best of two matches)
            <remarks> Note : Only available if “Series Results” is checked in config </remarks></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.FixtureEntity.AustrianDistrict">
      <summary>
            AustrianDistrict
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.FixtureEntity.Competitors">
      <summary>
            Information about competitors
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.FixtureEntity.DateInfo">
      <summary>
            Date and time of the game, and optional
            information about match delay
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.FixtureEntity.EventInfo">
      <summary>
            Meta information about the outright
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.FixtureEntity.HasStatistics">
      <summary>
            Is match offered in Betradar statistics service
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.FixtureEntity.LiveMultiCast">
      <summary>
            Is match offered in Betradar Live Centre Soccer service
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.FixtureEntity.LiveScore">
      <summary>
            Is match offered in Betradar Live Score service
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.FixtureEntity.NeutralGround">
      <summary>
            Is match played on neutral ground
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.FixtureEntity.NumberOfFrames">
      <summary>
            Number of frames
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.FixtureEntity.NumberOfSets">
      <summary>
            Number of sets that are due to be played in a tennis match
            <remarks> Note : Only available if ““Numbers of sets in tennis” is checked in config </remarks></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.FixtureEntity.RoundInfo">
      <summary>
            Round info
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.FixtureEntity.SeriesResult">
      <summary>
            Results from best of 3, 5 or 7 matches
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.FixtureEntity.StatusInfo">
      <summary>
            Fixture status
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.FixtureEntity.StreamingMatch">
      <summary>
            Flags all matches that are available within our Streaming / Live Channel product
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.FixtureEntity.Venue">
      <summary>
            Name of the venue/stadium where the match is played
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.FixtureEntity.Players">
      <summary>
            Information about players
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.GoalEntity">
      <summary>
            Contains information about a goal
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.GoalEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.GoalEntity.Player">
      <summary>
            Scoring player        
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.GoalEntity.Id">
      <summary>
            Unique id of the live event
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.GoalEntity.ScoringTeam">
      <summary>
            Scoring team of this goal
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.GoalEntity.Score">
      <summary>
            Score
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.GoalEntity.Time">
      <summary>
            Match time of the goal
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.GoalEntity.Type">
      <summary>
            Goal type
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.GoalsEntity">
      <summary>
            Contains multiple goal entities
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.GoalsEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.GoalsEntity.Goals">
      <summary>
            Goals        
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.GoalsEntity.Doubtful">
      <summary>
            Mark if the corners market has conflicting source information
            <remarks> Note : Only available if “Mark doubtful bookings and goals” is checked in config </remarks></summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.LcooBetDataEntity">
      <summary>
            Main entity that is dispatched to the SDK user.
            Contains all the data that was received
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.LcooBetDataEntity.#ctor">
      <summary>
            LcooBetDataEntity
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.LcooBetDataEntity.#ctor(System.Xml.XmlAttribute[])">
      <summary>
            LcooBetDataEntity
            </summary>
      <param name="any_attr">
      </param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.LcooBetDataEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.LcooBetDataEntity.OutrightEntities">
      <summary>
            All outrights in this update
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.LcooBetDataEntity.MatchEntities">
      <summary>
            All matches in this update
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.LcooBetDataEntity.ThreeBallEntities">
      <summary>
            All threeballs in this update
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.LcooEntityBase">
      <summary>
            Serves as a base class that all LCoO entities should be derived from
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.LcooEntityBase.#ctor(System.Xml.XmlAttribute[])">
      <summary>
            LcooEntityBase
            </summary>
      <param name="any_attr">
      </param>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.LcooEntityBase.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.LcooEntityBase.Priority">
      <summary>
            Priority
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.LcooEntityBase.FeedType">
      <summary>
            Feed type
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity">
      <summary>
            Contains information about match
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.#ctor">
      <summary>
            MatchEntity
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.Aamsids">
      <summary>
            AAMS(Amministrazione Autonoma dei Monopoli di Stado –
            Autonomous Administration of the State Monopolies) ids
            <remarks> Note : Only available if “Include AAMS ids” is checked in config </remarks><returns> AAMS ids</returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.AwayTeamBetradarMatchId">
      <summary>
            Away team betradar match id
            <returns>away team betradar match id</returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.AwayTeamMonitoringMatchId">
      <summary>
            Away team monitoring match id
            <returns>away team monitoring match id</returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.BetdaqId">
      <summary>
            BETDAQ betting exchange identifier
            <returns> BETDAQ identifier</returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.BetfairId">
      <summary>
            Betfair betting exchange entity
            <remarks> Note : Only available if “Include Betfair id's” is checked in config </remarks><returns> Betfair entity </returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.BetResults">
      <summary>
            Bet results
            <remarks> Note : Only available if “Settle markets” is checked in config </remarks><returns> list of bet results </returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.Cards">
      <summary>
            Cards for this match
            <returns> cards </returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.Corners">
      <summary>
            Corners for this match
            <returns> cards </returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.Category">
      <summary>
            Category that the match belongs to
            <returns> category </returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.Fixture">
      <summary>
            Match meta information
            <returns> match meta information </returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.Goals">
      <summary>
            Goals for this match
            <returns> goals </returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.HomeTeamBetradarMatchId">
      <summary>
            Home team betradar match id
            <returns>home team betradar match id</returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.HomeTeamMonitoringMatchId">
      <summary>
            Home team monitoring match id
            <returns>home team monitoring match id</returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.Information">
      <summary>
            Textual information about the match
            <returns> textual information about the match </returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.MatchId">
      <summary>
            Betradar's match id
            <remarks> Note : Only available if “Include Monitoring matchid” is checked in config </remarks><returns> match id </returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.MessageTime">
      <summary>
            Message creation time in UTC
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.MonitoringMatchId">
      <summary>
            Betradar's monitoring matchId
            <returns> monitoring match ID </returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.Odds">
      <summary>
            Match odds
            <returns> list of match odds </returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.Pitcher">
      <summary>
            Starting pitcher for each team
            <remarks> Note : Only available if “Pitcher”” is checked in config
            Requires American League package </remarks><returns> starting pitcher for each team </returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.Probabilities">
      <summary>
            Probabilities estimated by Betradar for each outcome of a bet
            <remarks> Note : Only available if “Betradar probability” is checked in config </remarks><returns> list of probabilities </returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.Result">
      <summary>
            Match result information
            <returns> match result information </returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.RotationNumber">
      <summary>
            Gets rotation number for both teams
            <remarks> Rotation numbers are assigned to the participants in a sporting event, 
            and form an event identifier which is standard across all sportsbooks. </remarks><returns> rotation number for both teams </returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.Sport">
      <summary>
            Sport that the match belongs to
            <returns> sport </returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.Tournament">
      <summary>
            Tournament that the match belongs to
            <returns> tournament </returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.TvChannels">
      <summary>
            TV channels for this match
            <returns> list of TV channels </returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity.EventId">
      <exlude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.OddsEntity">
      <summary>
            OddsEntity
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.OddsEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OddsEntity.Id">
      <summary>
            Odd value
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OddsEntity.OutCome">
      <summary>
            Outcome
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OddsEntity.OutcomeId">
      <summary>
            Outcome id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OddsEntity.PlayerId">
      <summary>
            Special odds value
            <remarks> Special odds values are specified only for some odds types like total,
            handicap and freetext3way/2way/nway. This indicates the total value,
            handicap value or freetext details respectively.
            </remarks></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OddsEntity.SpecialBetValue">
      <summary>
            Special bet value  
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OddsEntity.TeamId">
      <summary>
            Team id    
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OddsEntity.Value">
      <summary>
            Odds value 
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.OddsProbabilityEntity">
      <summary>
            Contains information about probability for specific odd
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.OddsProbabilityEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OddsProbabilityEntity.Id">
      <summary>
            Odds id        
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OddsProbabilityEntity.Outcome">
      <summary>
            Outcome        
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OddsProbabilityEntity.OutcomeId">
      <summary>
            Outcome id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OddsProbabilityEntity.PlayerId">
      <summary>
            Player id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OddsProbabilityEntity.SpecialBetValue">
      <summary>
            Special bet value
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OddsProbabilityEntity.TeamId">
      <summary>
            Team id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OddsProbabilityEntity.Value">
      <summary>
            Probability of an odd        
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.OutrightEntity">
      <summary>
            Contains information about specific outright
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.OutrightEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OutrightEntity.AAmsOutrightIDs">
      <summary>
            AAMS(Amministrazione Autonoma dei Monopoli di Stado –
            Autonomous Administration of the State Monopolies) ids
            <remarks> Note : Only available if “Include AAMS ids” is checked in config </remarks><returns> AAMS ids </returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OutrightEntity.Category">
      <summary>
            Category        
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OutrightEntity.Fixture">
      <summary>
            Fixture        
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OutrightEntity.Id">
      <summary>
            Id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OutrightEntity.AamsCalendarId">
      <summary>
            AAMS Calendar id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OutrightEntity.MessageTime">
      <summary>
            Message creation time in UTC
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OutrightEntity.Odds">
      <summary>
            Odds
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OutrightEntity.Result">
      <summary>
            Outrights results
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OutrightEntity.Sport">
      <summary>
            Sport
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OutrightEntity.StageId">
      <summary>
            Stage id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OutrightEntity.EventId">
      <exlude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.OutrightResultEntity">
      <summary>
            Contains results for an outright
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.OutrightResultEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OutrightResultEntity.Id">
      <summary>
            Id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OutrightResultEntity.DeadHeatFactor">
      <summary>
            Dead heat factor
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OutrightResultEntity.Value">
      <summary>
            Result        
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.PitcherEntity">
      <summary>
            Contains information about a pitcher
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.PitcherEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.PitcherEntity.Hand">
      <summary>
            Pitcher hand (left or right)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.PitcherEntity.Name">
      <summary>
            Pitcher name
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.PlayerEntity">
      <summary>
            Contains information about a player
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.PlayerEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.PlayerEntity.Id">
      <summary>
            Id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.PlayerEntity.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.PlayerEntity.Order">
      <summary>
            Order. Identifies which player (1-4) is this
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.PlayerEntity.SuperId">
      <summary>
            Universal player identifier
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.PlayerEntity.TeamId">
      <summary>
            Team id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.PlayerEntity.Value">
      <summary>
            Player        
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.PlayersEntity">
      <summary>
            Contains information about players
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.PlayersEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.PlayersEntity.Players">
      <summary>
            Players
            list of {@link PlayerEntity}
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.ProbabilityEntity">
      <summary>
            Contains information about probabilities for outcomes for specific odds type
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.ProbabilityEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.ProbabilityEntity.OddsProbabilities">
      <summary>
            Information about odds probability
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.ProbabilityEntity.OddsType">
      <summary>
            Odds type
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.ResultEntity">
      <summary>
            Container for all result information including comments on the event
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.ResultEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.ResultEntity.Comment">
      <summary>
            Comment about this result
            For example: Each goal difference with time of goal and
            goal scorer.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.ResultEntity.ScoresInfo">
      <summary>
            Scores info
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.ResultEntity.WinningOutcome">
      <summary>
            Winning outcome
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.RoundInfoEntity">
      <summary>
            Container entity for round information
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.RoundInfoEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.RoundInfoEntity.Cupround">
      <summary>
            Cupround. Used for cup matches        
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.RoundInfoEntity.Id">
      <summary>
            Id
            <returns> id </returns></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.RoundInfoEntity.MatchNr">
      <summary>
            Match number. Used for some cup matches.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.RoundInfoEntity.Round">
      <summary>
            League round of the match. Used for league matches
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.ScoresInfoEntity">
      <summary>
            Container entity for all event results (scores)
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.ScoresInfoEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.ScoresInfoEntity.Scores">
      <summary>
            Was score decided by the Football Association
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.ScoresInfoEntity.DecidedByFa">
      <summary>
            Scores
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.SeriesResultEntity">
      <summary>
            Holds results from best of 3, 5 or 7 matches
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.SeriesResultEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.SeriesResultEntity.ToStringWithoutTypeName">
      <exclude />
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.SeriesResultEntity.Value">
      <summary>
            Result that indicates how many matches the Home and Away team has won
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.SeriesResultEntity.Winner">
      <summary>
            Series winner
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.ThreeBallEntity">
      <summary>
            Three ball entity
            <remarks> Note : Used in golf. 
            The three balls element is very similar to the regular Match element.
            The main difference is that instead of providing two teams the
            Golf 3 balls provide three competing teams.</remarks></summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.ThreeBallEntity.#ctor">
      <summary>
            ThreeBallEntity
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.ThreeBallEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.ThreeBallEntity.Category">
      <summary>
            Category that the match belongs to
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.ThreeBallEntity.Fixture">
      <summary>
            Fixture
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.ThreeBallEntity.Id">
      <summary>
            Id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.ThreeBallEntity.MessageTime">
      <summary>
            Message creation time in UTC
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.ThreeBallEntity.Odds">
      <summary>
            List of odds
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.ThreeBallEntity.Result">
      <summary>
            Results
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.ThreeBallEntity.Round">
      <summary>
            Round
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.ThreeBallEntity.Sport">
      <summary>
            Sport that the three ball belongs to
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.ThreeBallEntity.Tournament">
      <summary>
            Tournament that the three ball belongs to
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.ThreeBallEntity.EventId">
      <exlude />
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.MatchEventOdds">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.Lcoo.ILcoo.OnMatch" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.MatchEventOdds.MatchEntity">
      <summary>
            Entitiy that contains all the info about the received match
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.OutrightEventOdds">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.Lcoo.ILcoo.OnOutright" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.OutrightEventOdds.OutrightEntity">
      <summary>
            Entitiy that contains all the info about the received outright
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.ThreeBallEventArgs">
      <summary>
            Event arguments passed with <see cref="E:Sportradar.SDK.FeedProviders.Lcoo.ILcoo.OnThreeBall" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.ThreeBallEventArgs.ThreeBallEntity">
      <summary>
            Entitiy that contains all the info about the three ball
            </summary>
      <remarks>
            Used in golf.
            In Three Ball, the members of a group of three players compete in match play against one another, 
            with each member of the group playing individual matches against the other two members.
            </remarks>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.ILcoo">
      <summary>
            Represents an access point for Live Cycle of Odds feed.
            When <see cref="M:Sportradar.SDK.Common.Interfaces.IStartable.Start" /> is called it will start pooling data
            using HTTP protocol. <see cref="E:Sportradar.SDK.FeedProviders.Lcoo.ILcoo.OnOutright" /> , <see cref="E:Sportradar.SDK.FeedProviders.Lcoo.ILcoo.OnMatch" /> and <see cref="E:Sportradar.SDK.FeedProviders.Lcoo.ILcoo.OnThreeBall" />
            will be called when apropriate data is received.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.ILcoo.ClearQueue">
      <summary>
            Send request to the server to delete all pending messages in queue.
            </summary>
      <remarks>
            Usually used if you were disconnected for a long period and you are receiving old messages
            </remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.ILcoo.Refresh">
      <summary>
            Immediately checks if new data is available on the server.
            </summary>
      <remarks>
            You usually do not need to call this as the data fetching is automated. 
            </remarks>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.Lcoo.ILcoo.OnMatch">
      <summary>
            Invoked when new <see cref="T:Sportradar.SDK.FeedProviders.Lcoo.MatchEntity" /> is received from the server
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.Lcoo.ILcoo.OnOutright">
      <summary>
            Invoked when new <see cref="T:Sportradar.SDK.FeedProviders.Lcoo.OutrightEntity" /> is received from the server
            </summary>
    </member>
    <member name="E:Sportradar.SDK.FeedProviders.Lcoo.ILcoo.OnThreeBall">
      <summary>
            Invoked when new <see cref="T:Sportradar.SDK.FeedProviders.Lcoo.ThreeBallEntity" /> is received from the server
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.SportEntity">
      <summary>
            Entity for specific sport
            It contains all the data that is relevant for this sport
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.SportEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.SportEntity.Id">
      <summary>
            Sport id
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.StatusInfoEntity">
      <summary>
            Status info
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.StreamingMatch">
      <summary>
            Streaming match
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.StreamingMatch.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.TextEntity">
      <summary>
            Entity specifying textual information.
            It is mostly used to put names on sports, categories, tournaments and teams.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.TextEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.TextEntity.Id">
      <summary>
            Id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.TextEntity.Language">
      <summary>
            Language        
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.TextEntity.Superid">
      <summary>
            Universal id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.TextEntity.TeamId">
      <summary>
            Team id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.TextEntity.Text">
      <summary>
            List of {@link TextEntity}
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.TextEntity.Type">
      <summary>
            Type
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.TextEntity.Value">
      <summary>
            Value
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.TextsEntity">
      <summary>
            Contains a list of {@link TextEntity}
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.TextsEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.TextsEntity.ToStringWithoutTypeName">
      <exclude />
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
      <returns>A string that represents the current object.</returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.TextsEntity.Texts">
      <summary>
            Texts
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.TournamentEntity">
      <summary>
            Contains information about a specific tournament
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.TournamentEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.TournamentEntity.Id">
      <summary>
            Tournament id        
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.TournamentEntity.SuperTournament">
      <summary>
            Id and name of SuperTournament
            <remarks>  Note : Only available if “Supertournament” is checked in config
            The purpose of this ID is to group related Tournament's together.
            A competition like the UEFA Champions League is divided into 10 different Tournaments
            (Qualification, 8 groups A-H, Final phase). All of these tournaments share a common
            SuperTournament</remarks></summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.TvChannelEntity">
      <summary>
            Contains TV channel information
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.TvChannelEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.TvChannelEntity.Id">
      <summary>
            Id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.TvChannelEntity.Name">
      <summary>
            Name
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.TvChannelEntity.StartDate">
      <summary>
            Start date in UTC
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.VenueEntity">
      <summary>
            Contains information about the venue/stadium where the event is played
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.VenueEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.VenueEntity.Coordinates">
      <summary>
            Coordinates
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.VenueEntity.Value">
      <summary>
            Name of venue
            </summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.VenueEntity.Id">
      <summary>
            Id
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.WinningOutcomeEntity">
      <summary>
            Contains information about winning outcome
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.WinningOutcomeEntity.ToString">
      <summary>
            Returns a string that represents the current object.
            </summary>
      <remarks>Can be used for diagnostics purposes.</remarks>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.WinningOutcomeEntity.Outcome">
      <summary>
            Winning outcome
            <remarks> Note : If "C" then <see cref="P:Sportradar.SDK.FeedProviders.Lcoo.WinningOutcomeEntity.Reason" /> should explain why there is no winner</remarks></summary>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.WinningOutcomeEntity.Reason">
      <summary>
            Reason for cancellations        
            </summary>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityFactory">
      <summary>
             A {@link LcooEntityFactory} implementation which uses classes generated from xsd.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityFactory.BuildLcooEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.BetradarBetData)">
      <summary>
            BuildLcooBetDataEntity
            </summary>
      <param name="orig">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper">
      <summary>
            LcooEntityHelper
            </summary>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildAggregateScoreEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.AggregateScore)">
      <summary>
            BuildAggregateScoreEntity
            </summary>
      <param name="aggregate_score">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildBetEntities(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.MatchOdds)">
      <summary>
            BuildBetEntities
            </summary>
      <param name="odds">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildBetEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.OutrightOdds)">
      <summary>
            BuildBetEntity
            </summary>
      <param name="odd">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildBetEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Bet)">
      <summary>
            BuildBetEntity
            </summary>
      <param name="bet">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildBetfairIdEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.BetfairIDs)">
      <summary>
            BuildBetfairIDEntity
            </summary>
      <param name="betfair">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildBetResultEntities(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.BetResultW[])">
      <summary>
            BuildBetResultEntities
            </summary>
      <param name="bet_results">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildBetResultEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.BetResultW)">
      <summary>
            BuildBetResultEntity
            </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildCardEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.CardsCard)">
      <summary>
            BuildCardEntity
            </summary>
      <param name="card">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildCardsEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Cards)">
      <summary>
            BuildCardsEntity
            </summary>
      <param name="cards">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildCategoryEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Category)">
      <summary>
            BuildCategoryEntity
            </summary>
      <param name="category">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildCommentEntities(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Comment[])">
      <summary>
            BuildCommentEntities
            </summary>
      <param name="comments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildCommentEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Comment)">
      <summary>
            BuildCommentEntity
            </summary>
      <param name="comment">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildCompetitorsEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Competitors)">
      <summary>
            BuildCompetitorsEntity
            </summary>
      <param name="competitors">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildCoordinatesEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Coordinates)">
      <summary>
            BuildCoordinatesEntity
            </summary>
      <param name="coordinates">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildDateInfoEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.DateInfo)">
      <summary>
            BuildDateInfoEntity
            </summary>
      <param name="date_info">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildEventInfoEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.EventInfo)">
      <summary>
            BuildEventInfoEntity
            </summary>
      <param name="event_info">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildEventName(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.EventName)">
      <summary>
            BuildEventName
            </summary>
      <param name="event_name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildFixtureEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Fixture)">
      <summary>
            BuildFixtureEntity
            </summary>
      <param name="fixture">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildGoalEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.GoalsGoal)">
      <summary>
            BuildGoalEntity
            </summary>
      <param name="goal">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildGoalsEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Goals)">
      <summary>
            BuildGoalsEntity
            </summary>
      <param name="goals">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildInfo(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Info)">
      <summary>
            BuildInfo
            </summary>
      <param name="info">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildMatchEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Match,System.Nullable{Sportradar.SDK.FeedProviders.Lcoo.FeedType},System.Nullable{System.DateTime},Sportradar.SDK.FeedProviders.Lcoo.SportEntity,Sportradar.SDK.FeedProviders.Lcoo.CategoryEntity,Sportradar.SDK.FeedProviders.Lcoo.TournamentEntity)">
      <summary>
            BuildMatchEntity
            </summary>
      <param name="match">
      </param>
      <param name="feed_type">
      </param>
      <param name="message_time">
      </param>
      <param name="sport">
      </param>
      <param name="category">
      </param>
      <param name="tournament">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildOddsEntities(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Odds[])">
      <summary>
            BuildOddsEntities
            </summary>
      <param name="odds">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildOddsEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Odds)">
      <summary>
            BuildOddsEntity
            </summary>
      <param name="odds">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildOddsProbabilityEntities(System.Collections.Generic.List{Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.P})">
      <summary>
            BuildOddsProbabilityEntities
            </summary>
      <param name="p_list">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildOddsProbabilityEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.P)">
      <summary>
            BuildOddsProbabilityEntity
            </summary>
      <param name="p">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildOutrightEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Outright,System.Nullable{Sportradar.SDK.FeedProviders.Lcoo.FeedType},System.Nullable{System.DateTime},Sportradar.SDK.FeedProviders.Lcoo.SportEntity,Sportradar.SDK.FeedProviders.Lcoo.CategoryEntity)">
      <summary>
            BuildOutrightEntity
            </summary>
      <param name="outright">
      </param>
      <param name="feed_type">
      </param>
      <param name="message_time">
      </param>
      <param name="sport_entity">
      </param>
      <param name="category">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildOutrightResultEntities(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.OutrightResultResult[])">
      <summary>
            BuildOutrightResultEntities
            </summary>
      <param name="results">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildOutrightResultEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.OutrightResultResult)">
      <summary>
            BuildOutrightResultEntity
            </summary>
      <param name="result">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildPitcherEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Pitcher)">
      <summary>
            BuildPitcherEntity
            </summary>
      <param name="pitcher">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildPlayer1Entity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Player1)">
      <summary>
            BuildPlayer1Entity
            </summary>
      <param name="player">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildPlayer2Entity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Player2)">
      <summary>
            BuildPlayer2Entity
            </summary>
      <param name="player">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildPlayer3Entity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Player3)">
      <summary>
            BuildPlayer3Entity
            </summary>
      <param name="player">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildPlayer4Entity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Player4)">
      <summary>
            BuildPlayer3Entity
            </summary>
      <param name="player">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildPlayerEntity(System.Collections.Generic.List{Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Text},System.String,System.Nullable{System.Int32},System.Int32)">
      <summary>
            BuildPlayerEntity
            </summary>
      <param name="texts">
      </param>
      <param name="value">
      </param>
      <param name="superid">
      </param>
      <param name="id">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildProbabilityEntities(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Probabilities)">
      <summary>
            BuildProbabilityEntities
            </summary>
      <param name="probabilities">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildProbabilityEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.PR)">
      <summary>
            BuildProbabilityEntity
            </summary>
      <param name="probability">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildResultEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Result)">
      <summary>
            BuildResultEntity
            </summary>
      <param name="result">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildRotationNumber(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.RotationNumber)">
      <summary>
            BuildRotationNumber
            </summary>
      <param name="rotation_number">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildRoundInfoEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.RoundInfo)">
      <summary>
            BuildRoundInfoEntity
            </summary>
      <param name="round_info">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildScoresInfoEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.ScoreInfo)">
      <summary>
            BuildScoresInfoEntity
            </summary>
      <param name="score_info">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildSeriesResultEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.SeriesResult)">
      <summary>
            BuildSeriesResultEntity
            </summary>
      <param name="series_result">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildSportEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Sport)">
      <summary>
            BuildSportEntity
            </summary>
      <param name="sport">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildTextEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Text)">
      <summary>
            BuildTextEntity
            </summary>
      <param name="text">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildTexts(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Text[])">
      <summary>
            BuildTexts
            </summary>
      <param name="texts">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildTextsList(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Texts[])">
      <summary>
            BuildTextsList
            </summary>
      <param name="texts">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildThreeBallEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.ThreeBall,System.Nullable{Sportradar.SDK.FeedProviders.Lcoo.FeedType},System.Nullable{System.DateTime},Sportradar.SDK.FeedProviders.Lcoo.SportEntity,Sportradar.SDK.FeedProviders.Lcoo.CategoryEntity,Sportradar.SDK.FeedProviders.Lcoo.TournamentEntity)">
      <summary>
            ThreeBallEntity
            </summary>
      <param name="three_ball">
      </param>
      <param name="feed_type">
      </param>
      <param name="message_time">
      </param>
      <param name="sport">
      </param>
      <param name="category">
      </param>
      <param name="tournament">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildTimestamp(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Timestamp)">
      <summary>
            BuildTimestamp
            </summary>
      <param name="timestamp">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildTournamentEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Tournament)">
      <summary>
            BuildTournamentEntity
            </summary>
      <param name="tournament">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildTvChannelEntities(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.TVChannelInfo)">
      <summary>
            BuildTvChannelEntities
            </summary>
      <param name="tv_channels">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildTvChannelEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.MatchOnTV)">
      <summary>
            BuildTvChannelEntity
            </summary>
      <param name="tv_channel">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildVenueEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.Venue)">
      <summary>
            BuildVenueEntity
            </summary>
      <param name="venue">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.BuildWinningOutcomeEntity(Sportradar.SDK.ProtocolProviders.ProtocolUnits.LCoO.Incoming.W)">
      <summary>
            WinningOutcomeEntity
            </summary>
      <param name="outcome">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Sportradar.SDK.FeedProviders.Lcoo.Internal.LcooEntityHelper.FixtureTimeZone">
      <summary>
            Timezone to use
            </summary>
    </member>
    <member name="T:JetBrains.Annotations.CanBeNullAttribute">
      <summary>
            Indicates that the value of the marked element could be <c>null</c> sometimes,
            so the check for <c>null</c> is necessary before its usage
            </summary>
      <example>
        <code>
            [CanBeNull] public object Test() { return null; }
            public void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code>
      </example>
    </member>
    <member name="T:JetBrains.Annotations.NotNullAttribute">
      <summary>
            Indicates that the value of the marked element could never be <c>null</c></summary>
      <example>
        <code>
            [NotNull] public object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code>
      </example>
    </member>
    <member name="T:JetBrains.Annotations.StringFormatMethodAttribute">
      <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor. The format string
            should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />-like form
            </summary>
      <example>
        <code>
            [StringFormatMethod("message")]
            public void ShowError(string message, params object[] args) { /* do something */ }
            public void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code>
      </example>
    </member>
    <member name="M:JetBrains.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
      <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
    </member>
    <member name="T:JetBrains.Annotations.InvokerParameterNameAttribute">
      <summary>
            Indicates that the function argument should be string literal and match one
            of the parameters of the caller function. For example, ReSharper annotates
            the parameter of <see cref="T:System.ArgumentNullException" /></summary>
      <example>
        <code>
            public void Foo(string param) {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code>
      </example>
    </member>
    <member name="T:JetBrains.Annotations.ContractAnnotationAttribute">
      <summary>
            Describes dependency between method input and output
            </summary>
      <syntax>
        <p>Function Definition Table syntax:</p>
        <list>
          <item>FDT      ::= FDTRow [;FDTRow]*</item>
          <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
          <item>Input    ::= ParameterName: Value [, Input]*</item>
          <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
          <item>Value    ::= true | false | null | notnull | canbenull</item>
        </list>
            If method has single input parameter, it's name could be omitted.<br />
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same)
            for method output means that the method doesn't return normally.<br /><c>canbenull</c> annotation is only applicable for output parameters.<br />
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row,
            or use single attribute with rows separated by semicolon.<br /></syntax>
      <examples>
        <list>
          <item>
            <code>
            [ContractAnnotation("=&gt; halt")]
            public void TerminationMethod()
            </code>
          </item>
          <item>
            <code>
            [ContractAnnotation("halt &lt;= condition: false")]
            public void Assert(bool condition, string text) // regular assertion method
            </code>
          </item>
          <item>
            <code>
            [ContractAnnotation("s:null =&gt; true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code>
          </item>
          <item>
            <code>
            // A method that returns null if the parameter is null, and not null if the parameter is not null
            [ContractAnnotation("null =&gt; null; notnull =&gt; notnull")]
            public object Transform(object data) 
            </code>
          </item>
          <item>
            <code>
            [ContractAnnotation("s:null=&gt;false; =&gt;true,result:notnull; =&gt;false, result:null")]
            public bool TryParse(string s, out Person result)
            </code>
          </item>
        </list>
      </examples>
    </member>
    <member name="T:JetBrains.Annotations.LocalizationRequiredAttribute">
      <summary>
            Indicates that marked element should be localized or not
            </summary>
      <example>
        <code>
            [LocalizationRequiredAttribute(true)]
            public class Foo {
              private string str = "my string"; // Warning: Localizable string
            }
            </code>
      </example>
    </member>
    <member name="T:JetBrains.Annotations.UsedImplicitlyAttribute">
      <summary>
            Indicates that the marked symbol is used implicitly
            (e.g. via reflection, in external library), so this symbol
            will not be marked as unused (as well as by other usage inspections)
            </summary>
    </member>
    <member name="T:JetBrains.Annotations.MeansImplicitUseAttribute">
      <summary>
            Should be used on attributes and causes ReSharper
            to not mark symbols marked with such attributes as unused
            (as well as by other usage inspections)
            </summary>
    </member>
    <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Access">
      <summary>Only entity marked with attribute considered used</summary>
    </member>
    <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Assign">
      <summary>Indicates implicit assignment to a member</summary>
    </member>
    <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
      <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
    </member>
    <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
      <summary>Indicates implicit instantiation of a type</summary>
    </member>
    <member name="T:JetBrains.Annotations.ImplicitUseTargetFlags">
      <summary>
            Specify what is considered used implicitly
            when marked with <see cref="T:JetBrains.Annotations.MeansImplicitUseAttribute" />
            or <see cref="T:JetBrains.Annotations.UsedImplicitlyAttribute" /></summary>
    </member>
    <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.Members">
      <summary>Members of entity marked with attribute are considered used</summary>
    </member>
    <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.WithMembers">
      <summary>Entity marked with attribute and all its members considered used</summary>
    </member>
    <member name="T:JetBrains.Annotations.InstantHandleAttribute">
      <summary>
            Tells code analysis engine if the parameter is completely handled
            when the invoked method is on stack. If the parameter is a delegate,
            indicates that delegate is executed while the method is executed.
            If the parameter is an enumerable, indicates that it is enumerated
            while the method is executed
            </summary>
    </member>
    <member name="T:JetBrains.Annotations.PureAttribute">
      <summary>
            Indicates that a method does not make any observable state changes.
            The same as <c>System.Diagnostics.Contracts.PureAttribute</c></summary>
      <example>
        <code>
            [Pure] private int Multiply(int x, int y) { return x * y; }
            public void Foo() {
              const int a = 2, b = 2;
              Multiply(a, b); // Waring: Return value of pure method is not used
            }
            </code>
      </example>
    </member>
    <member name="T:NodaTime.CalendarSystem">
      <summary>
            A calendar system maps the non-calendar-specific "local time line" to human concepts
            such as years, months and days.
            </summary>
      <remarks>
        <para>
            Many developers will never need to touch this class, other than to potentially ask a calendar
            how many days are in a particular year/month and the like. Noda Time defaults to using the ISO-8601
            calendar anywhere that a calendar system is required but hasn't been explicitly specified.
            </para>
        <para>
            If you need to obtain a <see cref="T:NodaTime.CalendarSystem" /> instance, use one of the static properties or methods in this
            class, such as the <see cref="P:NodaTime.CalendarSystem.Iso" /> property or the <see cref="M:NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)" /> method.
            </para>
        <para>Although this class is currently sealed (as of Noda Time 1.2), in the future this decision may
            be reversed. In any case, there is no current intention for third-party developers to be able to implement
            their own calendar systems (for various reasons). If you require a calendar system which is not
            currently supported, please file a feature request and we'll see what we can do.
            </para>
      </remarks>
      <threadsafety>
            All calendar implementations are immutable and thread-safe. See the thread safety
            section of the user guide for more information.
            </threadsafety>
    </member>
    <member name="M:NodaTime.CalendarSystem.ForId(System.String)">
      <summary>
            Fetches a calendar system by its unique identifier. This provides full round-tripping of a calendar
            system. It is not guaranteed that calling this method twice with the same identifier will return
            identical references, but the references objects will be equal.
            </summary>
      <param name="id">The ID of the calendar system. This is case-sensitive.</param>
      <returns>The calendar system with the given ID.</returns>
      <seealso cref="P:NodaTime.CalendarSystem.Id" />
      <exception cref="T:System.Collections.Generic.KeyNotFoundException">No calendar system for the specified ID can be found.</exception>
    </member>
    <member name="M:NodaTime.CalendarSystem.GetPersianCalendar">
      <summary>
            Returns a Persian (also known as Solar Hijri) calendar system. This is the main calendar in Iran
            and Afghanistan, and is also used in some other countries where Persian is spoken.
            </summary>
      <remarks>
            The true Persian calendar is an astronomical one, where leap years depend on vernal equinox.
            A complicated algorithmic alternative approach exists, proposed by Ahmad Birashk,
            but this isn't generally used in society. The implementation here is somewhat simpler, using a
            33-year leap cycle, where years  1, 5, 9, 13, 17, 22, 26, and 30 in each cycle are leap years.
            This is the same approach taken by the BCL <c>PersianCalendar</c> class, and the dates of
            this implementation align exactly with the BCL implementation.
            </remarks>
      <returns>A Persian calendar system.</returns>
    </member>
    <member name="M:NodaTime.CalendarSystem.GetHebrewCalendar(NodaTime.Calendars.HebrewMonthNumbering)">
      <summary>
            Returns a Hebrew calendar, as described at http://en.wikipedia.org/wiki/Hebrew_calendar. This is a
            purely mathematical calculator, applied proleptically to the period where the real calendar was observational. 
            </summary>
      <remarks>
        <para>Please note that in version 1.3.0 of Noda Time, support for the Hebrew calendar is somewhat experimental,
            particularly in terms of calculations involving adding or subtracting years. Additionally, text formatting
            and parsing using month names is not currently supported, due to the challenges of handling leap months.
            It is hoped that this will be improved in future versions.</para>
        <para>The implementation for this was taken from http://www.cs.tau.ac.il/~nachum/calendar-book/papers/calendar.ps,
            which is a public domain algorithm presumably equivalent to that given in the Calendrical Calculations book
            by the same authors (Nachum Dershowitz and Edward Reingold).
            </para>
      </remarks>
      <param name="monthNumbering">The month numbering system to use</param>
      <returns>A Hebrew calendar system for the given month numbering.</returns>
    </member>
    <member name="M:NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)">
      <summary>
            Returns a pure proleptic Gregorian calendar system, which defines every
            fourth year as leap, unless the year is divisible by 100 and not by 400.
            This improves upon the Julian calendar leap year rule.
            </summary>
      <remarks>
            Although the Gregorian calendar did not exist before 1582 CE, this
            calendar system assumes it did, thus it is proleptic. This implementation also
            fixes the start of the year at January 1.
            </remarks>
      <param name="minDaysInFirstWeek">The minimum number of days in the first week of the year.
            When computing the WeekOfWeekYear and WeekYear properties of a particular date, this is
            used to decide at what point the week year changes.</param>
      <returns>A suitable Gregorian calendar reference; the same reference may be returned by several
            calls as the object is immutable and thread-safe.</returns>
    </member>
    <member name="M:NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)">
      <summary>
            Returns a pure proleptic Julian calendar system, which defines every
            fourth year as a leap year. This implementation follows the leap year rule
            strictly, even for dates before 8 CE, where leap years were actually
            irregular.
            </summary>
      <remarks>
            Although the Julian calendar did not exist before 45 BCE, this calendar
            assumes it did, thus it is proleptic. This implementation also fixes the
            start of the year at January 1.
            </remarks>
      <param name="minDaysInFirstWeek">The minimum number of days in the first week of the year.
            When computing the WeekOfWeekYear and WeekYear properties of a particular date, this is
            used to decide at what point the week year changes.</param>
      <returns>A suitable Julian calendar reference; the same reference may be returned by several
            calls as the object is immutable and thread-safe.</returns>
    </member>
    <member name="M:NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)">
      <summary>
            Returns a Coptic calendar system, which defines every fourth year as
            leap, much like the Julian calendar. The year is broken down into 12 months,
            each 30 days in length. An extra period at the end of the year is either 5
            or 6 days in length. In this implementation, it is considered a 13th month.
            </summary>
      <remarks>
        <para>
            Year 1 in the Coptic calendar began on August 29, 284 CE (Julian), thus
            Coptic years do not begin at the same time as Julian years. This calendar
            is not proleptic, as it does not allow dates before the first Coptic year.
            </para>
        <para>
            This implementation defines a day as midnight to midnight exactly as per
            the ISO calendar. Some references indicate that a Coptic day starts at
            sunset on the previous ISO day, but this has not been confirmed and is not
            implemented.
            </para>
      </remarks>
      <param name="minDaysInFirstWeek">The minimum number of days in the first week of the year.
            When computing the WeekOfWeekYear and WeekYear properties of a particular date, this is
            used to decide at what point the week year changes.</param>
      <returns>A suitable Coptic calendar reference; the same reference may be returned by several
            calls as the object is immutable and thread-safe.</returns>
    </member>
    <member name="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)">
      <summary>
            Returns an Islamic, or Hijri, calendar system.
            </summary>
      <remarks>
        <para>
            This returns a tablular calendar, rather than one based on lunar observation. This calendar is a
            lunar calendar with 12 months, each of 29 or 30 days, resulting in a year of 354 days (or 355 on a leap
            year).
            </para>
        <para>
            Year 1 in the Islamic calendar began on July 15th or 16th, 622 CE (Julian), thus
            Islamic years do not begin at the same time as Julian years. This calendar
            is not proleptic, as it does not allow dates before the first Islamic year.
            </para>
        <para>
            There are two basic forms of the Islamic calendar, the tabular and the
            observed. The observed form cannot easily be used by computers as it
            relies on human observation of the new moon. The tabular calendar, implemented here, is an
            arithmetic approximation of the observed form that follows relatively simple rules.
            </para>
        <para>You should choose an epoch based on which external system you wish
            to be compatible with. The epoch beginning on July 16th is the more common
            one for the tabular calendar, so using <see cref="F:NodaTime.Calendars.IslamicEpoch.Civil" />
            would usually be a logical choice. However, Windows uses July 15th, so
            if you need to be compatible with other Windows systems, you may wish to use
            <see cref="F:NodaTime.Calendars.IslamicEpoch.Astronomical" />. The fact that the Islamic calendar
            traditionally starts at dusk, a Julian day traditionally starts at noon,
            and all calendar systems in Noda Time start their days at midnight adds
            somewhat inevitable confusion to the mix, unfortunately.</para>
        <para>
            The tabular form of the calendar defines 12 months of alternately
            30 and 29 days. The last month is extended to 30 days in a leap year.
            Leap years occur according to a 30 year cycle. There are four recognised
            patterns of leap years in the 30 year cycle:
            </para>
        <list type="table">
          <listheader>
            <term>Origin</term>
            <description>Leap years</description>
          </listheader>
          <item>
            <term>Kūshyār ibn Labbān</term>
            <description>2, 5, 7, 10, 13, 15, 18, 21, 24, 26, 29</description>
          </item>
          <item>
            <term>al-Fazārī</term>
            <description>2, 5, 7, 10, 13, 16, 18, 21, 24, 26, 29</description>
          </item>
          <item>
            <term>Fātimid (also known as Misri or Bohra)</term>
            <description>2, 5, 8, 10, 13, 16, 19, 21, 24, 27, 29</description>
          </item>
          <item>
            <term>Habash al-Hasib</term>
            <description>2, 5, 8, 11, 13, 16, 19, 21, 24, 27, 30</description>
          </item>
        </list>
        <para>
            The leap year pattern to use is determined from the first parameter to this factory method.
            The second parameter determines which epoch is used - the "astronomical" or "Thursday" epoch
            (July 15th 622CE) or the "civil" or "Friday" epoch (July 16th 622CE).
            </para>
        <para>
            This implementation defines a day as midnight to midnight exactly as per
            the ISO calendar. This correct start of day is at sunset on the previous
            day, however this cannot readily be modelled and has been ignored.
            </para>
      </remarks>
      <param name="leapYearPattern">The pattern of years in the 30-year cycle to consider as leap years</param>
      <param name="epoch">The kind of epoch to use (astronomical or civil)</param>
      <returns>A suitable Islamic calendar reference; the same reference may be returned by several
            calls as the object is immutable and thread-safe.</returns>
    </member>
    <member name="M:NodaTime.CalendarSystem.CreateIdFromNameAndMinDaysInFirstWeek(System.String,System.Int32)">
      <summary>
            Creates an ID for a calendar system which only needs to be distinguished by its name and
            the minimum number of days in the first week of the week-year.
            </summary>
    </member>
    <member name="M:NodaTime.CalendarSystem.GetAbsoluteYear(System.Int32,NodaTime.Calendars.Era)">
      <summary>
            Returns the "absolute year" (the one used throughout most of the API, without respect to eras)
            from a year-of-era and an era.
            </summary>
      <remarks>
            For example, in the Gregorian and Julian calendar systems, the BCE era starts at year 1, which is
            equivalent to an "absolute year" of 0 (then BCE year 2 has an absolute year of -1, and so on).  The absolute
            year is the year that is used throughout the API; year-of-era is typically used primarily when formatting
            and parsing date values to and from text.
            </remarks>
      <param name="yearOfEra">The year within the era.</param>
      <param name="era">The era in which to consider the year</param>
      <returns>The absolute year represented by the specified year of era.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="yearOfEra" /> is out of the range of years for the given era.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="era" /> is not an era used in this calendar.</exception>
    </member>
    <member name="M:NodaTime.CalendarSystem.GetMaxYearOfEra(NodaTime.Calendars.Era)">
      <summary>
            Returns the maximum valid year-of-era in the given era.
            </summary>
      <param name="era">The era in which to find the greatest year</param>
      <returns>The maximum valid year in the given era.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="era" /> is not an era used in this calendar.</exception>
    </member>
    <member name="M:NodaTime.CalendarSystem.GetMinYearOfEra(NodaTime.Calendars.Era)">
      <summary>
            Returns the minimum valid year-of-era in the given era.
            </summary>
      <param name="era">The era in which to find the greatest year</param>
      <returns>The minimum valid year in the given eraera.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="era" /> is not an era used in this calendar.</exception>
    </member>
    <member name="M:NodaTime.CalendarSystem.GetEraIndex(NodaTime.Calendars.Era)">
      <summary>
            Convenience method to perform nullity and validity checking on the era, converting it to
            the index within the list of eras used in this calendar system.
            </summary>
    </member>
    <member name="M:NodaTime.CalendarSystem.GetLocalInstantFromWeekYearWeekAndDayOfWeek(System.Int32,System.Int32,NodaTime.IsoDayOfWeek)">
      <summary>
            Returns the local date corresponding to the given "week year", "week of week year", and "day of week"
            in this calendar system.
            </summary>
      <param name="weekYear">ISO-8601 week year of value to return</param>
      <param name="weekOfWeekYear">ISO-8601 week of week year of value to return</param>
      <param name="dayOfWeek">ISO-8601 day of week to return</param>
      <returns>The date corresponding to the given week year / week of week year / day of week.</returns>
    </member>
    <member name="M:NodaTime.CalendarSystem.GetLocalInstant(NodaTime.Calendars.Era,System.Int32,System.Int32,System.Int32)">
      <summary>
            Returns a local instant, at the start of the day formed from the given year of era, month, day, and era arguments.
            The set of given values must refer to a valid datetime.
            </summary>
      <param name="era">Era to use. This must be one of the eras used in this calendar</param>
      <param name="yearOfEra">Year of era to use</param>
      <param name="monthOfYear">Month to use</param>
      <param name="dayOfMonth">Day of month to use</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="era" /> is not an era used in this calendar.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The year of era, month of year and day of month values don't
            form a valid date.</exception>
      <returns>A <see cref="T:NodaTime.LocalInstant" /> with the given year, month, day and era.</returns>
    </member>
    <member name="M:NodaTime.CalendarSystem.GetLocalInstant(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Returns a local instant, formed from the given year, month, day,
            hour, minute, second, millisecond and ticks values.
            </summary>
      <param name="year">Absolute year (not year within era; may be negative)</param>
      <param name="monthOfYear">Month of year</param>
      <param name="dayOfMonth">Day of month</param>
      <param name="hourOfDay">Hour within the day (0-23)</param>
      <param name="minuteOfHour">Minute within the hour</param>
      <param name="secondOfMinute">Second within the minute</param>
      <param name="millisecondOfSecond">Millisecond within the second</param>
      <param name="tickOfMillisecond">Tick within the millisecond</param>
      <returns>A <see cref="T:NodaTime.LocalInstant" /> with the given values.</returns>
    </member>
    <member name="M:NodaTime.CalendarSystem.ToString">
      <summary>
            Converts this calendar system to text by simply returning its unique ID.
            </summary>
      <returns>The ID of this calendar system.</returns>
    </member>
    <member name="M:NodaTime.CalendarSystem.GetIsoDayOfWeek(NodaTime.LocalInstant)">
      <summary>
            Returns the IsoDayOfWeek corresponding to the day of week for the given local instant
            if this calendar uses ISO days of the week, or throws an InvalidOperationException otherwise.
            </summary>
      <param name="localInstant">The local instant to use to find the day of the week</param>
      <returns>The day of the week as an IsoDayOfWeek</returns>
    </member>
    <member name="M:NodaTime.CalendarSystem.GetDaysInMonth(System.Int32,System.Int32)">
      <summary>
            Returns the number of days in the given month within the given year.
            </summary>
      <param name="year">The year in which to consider the month</param>
      <param name="month">The month to determine the number of days in</param>
      <exception cref="T:System.ArgumentOutOfRangeException">The given year / month combination
            is invalid for this calendar.</exception>
      <returns>The number of days in the given month and year.</returns>
    </member>
    <member name="M:NodaTime.CalendarSystem.IsLeapYear(System.Int32)">
      <summary>
            Returns whether or not the given year is a leap year in this calendar.
            </summary>
      <param name="year">The year to consider.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">The given year is invalid for this calendar.
            Note that some implementations may return a value rather than throw this exception. Failure to throw an
            exception should not be treated as an indication that the year is valid.</exception>
      <returns>True if the given year is a leap year; false otherwise.</returns>
    </member>
    <member name="M:NodaTime.CalendarSystem.GetMaxMonth(System.Int32)">
      <summary>
            The maximum valid month (inclusive) within this calendar in the given year. It is assumed that
            all calendars start with month 1 and go up to this month number in any valid year.
            </summary>
      <param name="year">The year to consider.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">The given year is invalid for this calendar.
            Note that some implementations may return a month rather than throw this exception (for example, if all
            years have the same number of months in this calendar system). Failure to throw an exception should not be
            treated as an indication that the year is valid.</exception>
      <returns>The maximum month number within the given year.</returns>
    </member>
    <member name="M:NodaTime.CalendarSystem.GetMaxYearOfEra(System.Int32)">
      <summary>
            See <see cref="M:NodaTime.CalendarSystem.GetMaxYearOfEra(NodaTime.Calendars.Era)" /> - but this uses a pre-validated index.
            This default implementation returns the maximum year for this calendar, which is
            a valid implementation for single-era calendars.
            </summary>
    </member>
    <member name="M:NodaTime.CalendarSystem.GetMinYearOfEra(System.Int32)">
      <summary>
            See <see cref="M:NodaTime.CalendarSystem.GetMinYearOfEra(NodaTime.Calendars.Era)" /> - but this uses a pre-validated index.
            This default implementation returns 1, but can be overridden by derived classes.
            </summary>
    </member>
    <member name="M:NodaTime.CalendarSystem.GetAbsoluteYear(System.Int32,System.Int32)">
      <summary>
            See <see cref="M:NodaTime.CalendarSystem.GetAbsoluteYear(System.Int32,NodaTime.Calendars.Era)" /> - but this uses a pre-validated index.
            This default implementation validates that the year is between 1 and MaxYear inclusive,
            but then returns it as-is, expecting that there's no further work to be
            done. This is valid for single-era calendars; the method should be overridden for multi-era calendars.
            </summary>
    </member>
    <member name="P:NodaTime.CalendarSystem.Ids">
      <summary>
            Returns the IDs of all calendar systems available within Noda Time. The order of the keys is not guaranteed.
            </summary>
    </member>
    <member name="P:NodaTime.CalendarSystem.Iso">
      <summary>
            Returns a calendar system that follows the rules of the ISO-8601 standard,
            which is compatible with Gregorian for all modern dates.
            </summary>
      <remarks>
        <para>
            When ISO does not define a field, but it can be determined (such as AM/PM) it is included.
            </para>
        <para>
            With the exception of century related fields, the ISO calendar is exactly the
            same as the Gregorian calendar system. In the ISO system, centuries and year
            of century are zero based. For all years, the century is determined by
            dropping the last two digits of the year, ignoring sign. The year of century
            is the value of the last two year digits.
            </para>
      </remarks>
    </member>
    <member name="P:NodaTime.CalendarSystem.Id">
      <summary>
            Returns the unique identifier for this calendar system. This is provides full round-trip capability
            using <see cref="M:NodaTime.CalendarSystem.ForId(System.String)" /> to retrieve the calendar system from the identifier.
            </summary>
      <remarks>
        <para>
            A unique ID for a calendar is required when serializing types which include a <see cref="T:NodaTime.CalendarSystem" />.
            As of 2 Nov 2012 (ISO calendar) there are no ISO or RFC standards for naming a calendar system. As such,
            the identifiers provided here are specific to Noda Time, and are not guaranteed to interoperate with any other
            date and time API.
            </para>
        <list type="table">
          <listheader>
            <term>Calendar ID</term>
            <description>Equivalent factory method</description>
          </listheader>
          <item>
            <term>ISO</term>
            <description>
              <see cref="P:NodaTime.CalendarSystem.Iso" />
            </description>
          </item>
          <item>
            <term>Gregorian 1</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)" />(1)</description>
          </item>
          <item>
            <term>Gregorian 2</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)" />(2)</description>
          </item>
          <item>
            <term>Gregorian 3</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)" />(3)</description>
          </item>
          <item>
            <term>Gregorian 3</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)" />(4)</description>
          </item>
          <item>
            <term>Gregorian 5</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)" />(5)</description>
          </item>
          <item>
            <term>Gregorian 6</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)" />(6)</description>
          </item>
          <item>
            <term>Gregorian 7</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetGregorianCalendar(System.Int32)" />(7)</description>
          </item>
          <item>
            <term>Coptic 1</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)" />(1)</description>
          </item>
          <item>
            <term>Coptic 2</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)" />(2)</description>
          </item>
          <item>
            <term>Coptic 3</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)" />(3)</description>
          </item>
          <item>
            <term>Coptic 4</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)" />(4)</description>
          </item>
          <item>
            <term>Coptic 5</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)" />(5)</description>
          </item>
          <item>
            <term>Coptic 6</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)" />(6)</description>
          </item>
          <item>
            <term>Coptic 7</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetCopticCalendar(System.Int32)" />(7)</description>
          </item>
          <item>
            <term>Julian 1</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)" />(1)</description>
          </item>
          <item>
            <term>Julian 2</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)" />(2)</description>
          </item>
          <item>
            <term>Julian 3</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)" />(3)</description>
          </item>
          <item>
            <term>Julian 4</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)" />(4)</description>
          </item>
          <item>
            <term>Julian 5</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)" />(5)</description>
          </item>
          <item>
            <term>Julian 6</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)" />(6)</description>
          </item>
          <item>
            <term>Julian 7</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetJulianCalendar(System.Int32)" />(7)</description>
          </item>
          <item>
            <term>Hijri Civil-Indian</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)" />(IslamicLeapYearPattern.Indian, IslamicEpoch.Civil)</description>
          </item>
          <item>
            <term>Hijri Civil-Base15</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)" />(IslamicLeapYearPattern.Base15, IslamicEpoch.Civil)</description>
          </item>
          <item>
            <term>Hijri Civil-Base16</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)" />(IslamicLeapYearPattern.Base16, IslamicEpoch.Civil)</description>
          </item>
          <item>
            <term>Hijri Civil-HabashAlHasib</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)" />(IslamicLeapYearPattern.HabashAlHasib, IslamicEpoch.Civil)</description>
          </item>
          <item>
            <term>Hijri Astronomical-Indian</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)" />(IslamicLeapYearPattern.Indian, IslamicEpoch.Astronomical)</description>
          </item>
          <item>
            <term>Hijri Astronomical-Base15</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)" />(IslamicLeapYearPattern.Base15, IslamicEpoch.Astronomical)</description>
          </item>
          <item>
            <term>Hijri Astronomical-Base16</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)" />(IslamicLeapYearPattern.Base16, IslamicEpoch.Astronomical)</description>
          </item>
          <item>
            <term>Hijri Astronomical-HabashAlHasib</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)" />(IslamicLeapYearPattern.HabashAlHasib, IslamicEpoch.Astronomical)</description>
          </item>
          <item>
            <term>Persian</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetPersianCalendar" />
            </description>
          </item>
          <item>
            <term>Hebrew</term>
            <description>
              <see cref="M:NodaTime.CalendarSystem.GetHebrewCalendar(NodaTime.Calendars.HebrewMonthNumbering)" />
            </description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="P:NodaTime.CalendarSystem.Name">
      <summary>
            Returns the name of this calendar system. Each kind of calendar system has a unique name, but this
            does not usually provide enough information for round-tripping. (For example, the name of an
            Islamic calendar system does not indicate which kind of leap cycle it uses, and other calendars
            specify the minimum number of days in the first week of a year.)
            </summary>
    </member>
    <member name="P:NodaTime.CalendarSystem.UsesIsoDayOfWeek">
      <summary>
            Returns whether the day-of-week field refers to ISO days. If true, types such as <see cref="T:NodaTime.LocalDateTime" />
            can use the <see cref="T:NodaTime.IsoDayOfWeek" /> property to avoid using magic numbers.
            This defaults to true, but can be overridden by specific calendars.
            </summary>
    </member>
    <member name="P:NodaTime.CalendarSystem.MinYear">
      <summary>
            The minimum valid year (inclusive) within this calendar.
            </summary>
    </member>
    <member name="P:NodaTime.CalendarSystem.MaxYear">
      <summary>
            The maximum valid year (inclusive) within this calendar.
            </summary>
    </member>
    <member name="P:NodaTime.CalendarSystem.MinTicks">
      <summary>
            Returns the minimum tick number this calendar can handle.
            </summary>
    </member>
    <member name="P:NodaTime.CalendarSystem.MaxTicks">
      <summary>
            Returns the maximum tick number this calendar can handle.
            </summary>
    </member>
    <member name="P:NodaTime.CalendarSystem.Eras">
      <summary>
            Returns a read-only list of eras used in this calendar system.
            </summary>
    </member>
    <member name="T:NodaTime.AmbiguousTimeException">
      <summary>
            Exception thrown to indicate that the specified local date/time occurs twice
            in a particular time zone due to daylight saving time changes.
            </summary>
      <remarks>
        <para>
            This occurs for transitions where the clock goes backward (usually by
            an hour). For example, suppose the time zone goes backward
            at 2am, so the second after 01:59:59 becomes 01:00:00. In that case,
            times such as 01:30:00 occur twice.
            </para>
        <para>
            This exception is used to indicate such problems, as they're usually
            not the same as other <see cref="T:System.ArgumentOutOfRangeException" /> causes,
            such as entering "15" for a month number.
            </para>
        <para>
            In theory this isn't calendar-specific; the local value will be ambiguous in
            this time zone regardless of the calendar used. However, this exception is
            always created in conjunction with a specific calendar, which leads to a more
            natural way of examining its information and constructing an error message.
            </para>
      </remarks>
      <threadsafety>Any public static members of this type are thread safe. Any instance members are not guaranteed to be thread safe.
            See the thread safety section of the user guide for more information.
            </threadsafety>
    </member>
    <member name="M:NodaTime.AmbiguousTimeException.#ctor(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
      <summary>
            Constructs an instance from the given information.
            </summary>
      <remarks>
        <para>
            User code is unlikely to need to deliberately call this constructor except
            possibly for testing.
            </para>
        <para>
            The two mappings must have the same local time and time zone.
            </para>
      </remarks>
      <param name="earlierMapping">The earlier possible mapping</param>
      <param name="laterMapping">The later possible mapping</param>
    </member>
    <member name="P:NodaTime.AmbiguousTimeException.LocalDateTime">
      <summary>
            The local date and time which is ambiguous in the time zone.
            </summary>
    </member>
    <member name="P:NodaTime.AmbiguousTimeException.Zone">
      <summary>
            The time zone in which the local date and time is ambiguous.
            </summary>
    </member>
    <member name="P:NodaTime.AmbiguousTimeException.EarlierMapping">
      <summary>
            The earlier of the two occurrences of the local date and time within the time zone.
            </summary>
    </member>
    <member name="P:NodaTime.AmbiguousTimeException.LaterMapping">
      <summary>
            The later of the two occurrences of the local date and time within the time zone.
            </summary>
    </member>
    <member name="T:NodaTime.DateTimeZoneProviders">
      <summary>
            Static access to date/time zone providers built into Noda Time and for global configuration where this is unavoidable.
            All properties are thread-safe, and the providers returned by the read-only properties cache their results.
            </summary>
    </member>
    <member name="P:NodaTime.DateTimeZoneProviders.Tzdb">
      <summary>
            Gets a time zone provider which uses a <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource" />.
            The underlying source is <see cref="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.Default" />, which is initialized from
            resources within the NodaTime assembly.
            </summary>
    </member>
    <member name="P:NodaTime.DateTimeZoneProviders.Default">
      <summary>
            Gets the TZDB time zone provider.
            This always returns the same value as the <see cref="P:NodaTime.DateTimeZoneProviders.Tzdb" /> property.
            </summary>
      <remarks>This method is not available in the PCL version, as it was made obsolete in Noda Time 1.1.</remarks>
      <seealso cref="P:NodaTime.DateTimeZoneProviders.Tzdb" />
    </member>
    <member name="P:NodaTime.DateTimeZoneProviders.Bcl">
      <summary>
            Gets a time zone provider which uses a <see cref="T:NodaTime.TimeZones.BclDateTimeZoneSource" />.
            This property is not available on the PCL build of Noda Time.
            </summary>
    </member>
    <member name="P:NodaTime.DateTimeZoneProviders.Serialization">
      <summary>
            The <see cref="T:NodaTime.IDateTimeZoneProvider" /> to use to interpret a time zone ID read as part of
            XML or binary serialization.
            </summary>
      <remarks>
            This property defaults to <see cref="P:NodaTime.DateTimeZoneProviders.Tzdb" />. The mere existence of
            this property is unfortunate, but XML and binary serialization in .NET provide no simple way of configuring
            appropriate context. It is expected that any single application is unlikely to want to serialize
            <c>ZonedDateTime</c> values using different time zone providers.
            </remarks>
    </member>
    <member name="T:NodaTime.OffsetDateTime">
      <summary>
            A local date and time in a particular calendar system, combined with an offset from UTC. This is
            broadly similar to <see cref="T:System.DateTimeOffset" /> in the BCL.
            </summary>
      <remarks>
        <para>
            A value of this type unambiguously represents both a local time and an instant on the timeline,
            but does not have a well-defined time zone. This means you cannot reliably know what the local
            time would be five minutes later, for example. While this doesn't sound terribly useful, it's very common
            in text representations.
            </para>
      </remarks>
      <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="T:NodaTime.OffsetDateTime.Comparer">
      <summary>
            Base class for <see cref="T:NodaTime.OffsetDateTime" /> comparers.
            </summary>
      <remarks>
        <para>Use the static properties of this class to obtain instances.</para>
        <para>For the curious: this class only exists so that in the future, it can expose more functionality - probably
            implementing <see cref="T:System.Collections.Generic.IEqualityComparer`1" />. If we simply provided properties on OffsetDateTime of type
            <see cref="T:System.Collections.Generic.IComparer`1" /> we'd have no backward-compatible way of adding to the set of implemented interfaces.</para>
      </remarks>
    </member>
    <member name="M:NodaTime.OffsetDateTime.Comparer.#ctor">
      <summary>
            Internal constructor to prevent external classes from deriving from this.
            (That means we can add more abstract members in the future.)
            </summary>
    </member>
    <member name="M:NodaTime.OffsetDateTime.Comparer.Compare(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)">
      <summary>
            Compares two <see cref="T:NodaTime.OffsetDateTime" /> values and returns a value indicating whether one is less than, equal to, or greater than the other.
            </summary>
      <param name="x">The first value to compare.</param>
      <param name="y">The second value to compare.</param>
      <returns>A signed integer that indicates the relative values of <paramref name="x" /> and <paramref name="y" />, as shown in the following table.
              <list type="table"><listheader><term>Value</term><description>Meaning</description></listheader><item><term>Less than zero</term><description><paramref name="x" /> is less than <paramref name="y" />.</description></item><item><term>Zero</term><description><paramref name="x" /> is equals to <paramref name="y" />.</description></item><item><term>Greater than zero</term><description><paramref name="x" /> is greater than <paramref name="y" />.</description></item></list></returns>
    </member>
    <member name="P:NodaTime.OffsetDateTime.Comparer.Local">
      <summary>
            Returns a comparer which compares <see cref="T:NodaTime.OffsetDateTime" /> values by their local date/time, without reference to
            either the offset or the calendar system.
            </summary>
      <remarks>
        <para>For example, this comparer considers 2013-03-04T20:21:00+0100 to be later than 2013-03-04T19:21:00-0700 even though
            the second value represents a later instant in time.</para>
        <para>This property will return a reference to the same instance every time it is called.</para>
      </remarks>
    </member>
    <member name="P:NodaTime.OffsetDateTime.Comparer.Instant">
      <summary>
            Returns a comparer which compares <see cref="T:NodaTime.OffsetDateTime" /> values by the instant values obtained by applying the offset to
            the local date/time, ignoring the calendar system.
            </summary>
      <remarks>
        <para>For example, this comparer considers 2013-03-04T20:21:00+0100 to be earlier than 2013-03-04T19:21:00-0700 even though
            the second value has a local time which is earlier.</para>
        <para>This property will return a reference to the same instance every time it is called.</para>
      </remarks>
    </member>
    <member name="T:NodaTime.OffsetDateTime.LocalComparer">
      <summary>
            Implementation for <see cref="P:NodaTime.OffsetDateTime.Comparer.Local" /></summary>
    </member>
    <member name="M:NodaTime.OffsetDateTime.LocalComparer.Compare(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)">
      <inheritdoc />
    </member>
    <member name="T:NodaTime.OffsetDateTime.InstantComparer">
      <summary>
            Implementation for <see cref="P:NodaTime.OffsetDateTime.Comparer.Instant" />.
            </summary>
    </member>
    <member name="M:NodaTime.OffsetDateTime.InstantComparer.Compare(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)">
      <inheritdoc />
    </member>
    <member name="M:NodaTime.OffsetDateTime.#ctor(NodaTime.LocalDateTime,NodaTime.Offset)">
      <summary>
            Constructs a new offset date/time with the given local date and time, and the given offset from UTC.
            </summary>
      <param name="localDateTime">Local date and time to represent</param>
      <param name="offset">Offset from UTC</param>
    </member>
    <member name="M:NodaTime.OffsetDateTime.ToInstant">
      <summary>
            Converts this offset date and time to an instant in time by subtracting the offset from the local date and time.
            </summary>
      <returns>The instant represented by this offset date and time</returns>
    </member>
    <member name="M:NodaTime.OffsetDateTime.InFixedZone">
      <summary>
            Returns this value as a <see cref="T:NodaTime.ZonedDateTime" />.
            </summary>
      <remarks>
        <para>
            This method returns a <see cref="T:NodaTime.ZonedDateTime" /> with the same local date and time as this value, using a
            fixed time zone with the same offset as the offset for this value.
            </para>
        <para>
            Note that because the resulting <c>ZonedDateTime</c> has a fixed time zone, it is generally not useful to
            use this result for arithmetic operations, as the zone will not adjust to account for daylight savings.
            </para>
      </remarks>
      <returns>A zoned date/time with the same local time and a fixed time zone using the offset from this value.</returns>
    </member>
    <member name="M:NodaTime.OffsetDateTime.ToDateTimeOffset">
      <summary>
            Returns the BCL <see cref="T:System.DateTimeOffset" /> corresponding to this offset date and time.
            </summary>
      <returns>A DateTimeOffset with the same local date/time and offset as this. The <see cref="T:System.DateTime" /> part of
            the result always has a "kind" of Unspecified.</returns>
    </member>
    <member name="M:NodaTime.OffsetDateTime.FromDateTimeOffset(System.DateTimeOffset)">
      <summary>
            Builds an <see cref="T:NodaTime.OffsetDateTime" /> from a BCL <see cref="T:System.DateTimeOffset" /> by converting
            the <see cref="T:System.DateTime" /> part to a <see cref="P:NodaTime.OffsetDateTime.LocalDateTime" />, and the offset part to an <see cref="P:NodaTime.OffsetDateTime.Offset" />.
            </summary>
      <param name="dateTimeOffset">DateTimeOffset to convert</param>
      <returns>The converted offset date and time</returns>
    </member>
    <member name="M:NodaTime.OffsetDateTime.WithCalendar(NodaTime.CalendarSystem)">
      <summary>
            Creates a new OffsetDateTime representing the same physical date, time and offset, but in a different calendar.
            The returned OffsetDateTime is likely to have different date field values to this one.
            For example, January 1st 1970 in the Gregorian calendar was December 19th 1969 in the Julian calendar.
            </summary>
      <param name="calendarSystem">The calendar system to convert this local date to.</param>
      <returns>The converted OffsetDateTime.</returns>
    </member>
    <member name="M:NodaTime.OffsetDateTime.WithOffset(NodaTime.Offset)">
      <summary>
            Creates a new OffsetDateTime representing the instant in time in the same calendar,
            but with a different offset. The local date and time is adjusted accordingly.
            </summary>
      <param name="offset">The new offset to use.</param>
      <returns>The converted OffsetDateTime.</returns>
    </member>
    <member name="M:NodaTime.OffsetDateTime.GetHashCode">
      <summary>
            Returns a hash code for this local date.
            </summary>
      <returns>A hash code for this local date.</returns>
    </member>
    <member name="M:NodaTime.OffsetDateTime.Equals(System.Object)">
      <summary>
            Compares two <see cref="T:NodaTime.OffsetDateTime" /> values for equality. This requires
            that the local date/time values be the same (in the same calendar) and the offsets.
            </summary>
      <param name="obj">The object to compare this date with.</param>
      <returns>True if the given value is another offset date/time equal to this one; false otherwise.</returns>
    </member>
    <member name="M:NodaTime.OffsetDateTime.Equals(NodaTime.OffsetDateTime)">
      <summary>
            Compares two <see cref="T:NodaTime.OffsetDateTime" /> values for equality. This requires
            that the local date/time values be the same (in the same calendar) and the offsets.
            </summary>
      <param name="other">The value to compare this offset date/time with.</param>
      <returns>True if the given value is another offset date/time equal to this one; false otherwise.</returns>
    </member>
    <member name="M:NodaTime.OffsetDateTime.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            The value of the current instance in the default format pattern ("G"), using the current thread's
            culture to obtain a format provider.
            </returns>
    </member>
    <member name="M:NodaTime.OffsetDateTime.ToString(System.String,System.IFormatProvider)">
      <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
      <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
      <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("G").
            </param>
      <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:NodaTime.OffsetDateTime.op_Equality(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)">
      <summary>
            Implements the operator == (equality).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.OffsetDateTime.op_Inequality(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)">
      <summary>
            Implements the operator != (inequality).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.OffsetDateTime.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Private constructor only present for serialization.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to fetch data from.</param>
      <param name="context">The source for this deserialization.</param>
    </member>
    <member name="P:NodaTime.OffsetDateTime.Calendar">
      <summary>Gets the calendar system associated with this local date and time.</summary>
    </member>
    <member name="P:NodaTime.OffsetDateTime.Year">
      <summary>Gets the year of this offset date and time.</summary>
      <remarks>This returns the "absolute year", so, for the ISO calendar,
            a value of 0 means 1 BC, for example.</remarks>
    </member>
    <member name="P:NodaTime.OffsetDateTime.Month">
      <summary>Gets the month of this offset date and time within the year.</summary>
    </member>
    <member name="P:NodaTime.OffsetDateTime.Day">
      <summary>Gets the day of this offset date and time within the month.</summary>
    </member>
    <member name="P:NodaTime.OffsetDateTime.IsoDayOfWeek">
      <summary>
            Gets the week day of this offset date and time expressed as an <see cref="T:NodaTime.IsoDayOfWeek" /> value,
            for calendars which use ISO days of the week.
            </summary>
      <exception cref="T:System.InvalidOperationException">The underlying calendar doesn't use ISO days of the week.</exception>
      <seealso cref="P:NodaTime.OffsetDateTime.DayOfWeek" />
    </member>
    <member name="P:NodaTime.OffsetDateTime.DayOfWeek">
      <summary>
            Gets the week day of this offset date and time as a number.
            </summary>
      <remarks>
            For calendars using ISO week days, this gives 1 for Monday to 7 for Sunday.
            </remarks>
      <seealso cref="P:NodaTime.OffsetDateTime.IsoDayOfWeek" />
    </member>
    <member name="P:NodaTime.OffsetDateTime.WeekYear">
      <summary>
            Gets the "week year" of this offset date and time.
            </summary>
      <remarks>
        <para>
            The WeekYear is the year that matches with the <see cref="P:NodaTime.OffsetDateTime.WeekOfWeekYear" /> field.
            In the standard ISO8601 week algorithm, the first week of the year
            is that in which at least 4 days are in the year. As a result of this
            definition, day 1 of the first week may be in the previous year.
            The WeekYear allows you to query the effective year for that day.
            </para>
        <para>
            For example, January 1st 2011 was a Saturday, so only two days of that week
            (Saturday and Sunday) were in 2011. Therefore January 1st is part of
            week 52 of WeekYear 2010. Conversely, December 31st 2012 is a Monday,
            so is part of week 1 of WeekYear 2013.
            </para>
      </remarks>
    </member>
    <member name="P:NodaTime.OffsetDateTime.WeekOfWeekYear">
      <summary>Gets the week within the WeekYear. See <see cref="P:NodaTime.OffsetDateTime.WeekYear" /> for more details.</summary>
    </member>
    <member name="P:NodaTime.OffsetDateTime.YearOfCentury">
      <summary>Gets the year of this offset date and time within the century.</summary>
      <remarks>This always returns a value in the range 0 to 99 inclusive.</remarks>
    </member>
    <member name="P:NodaTime.OffsetDateTime.YearOfEra">
      <summary>Gets the year of this offset date and time within the era.</summary>
    </member>
    <member name="P:NodaTime.OffsetDateTime.Era">
      <summary>Gets the era of this offset date and time.</summary>
    </member>
    <member name="P:NodaTime.OffsetDateTime.DayOfYear">
      <summary>Gets the day of this offset date and time within the year.</summary>
    </member>
    <member name="P:NodaTime.OffsetDateTime.Hour">
      <summary>
            Gets the hour of day of this offset date and time, in the range 0 to 23 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.OffsetDateTime.ClockHourOfHalfDay">
      <summary>
            Gets the hour of the half-day of this date and time, in the range 1 to 12 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.OffsetDateTime.Minute">
      <summary>
            Gets the minute of this offset date and time, in the range 0 to 59 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.OffsetDateTime.Second">
      <summary>
            Gets the second of this offset date and time within the minute, in the range 0 to 59 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.OffsetDateTime.Millisecond">
      <summary>
            Gets the millisecond of this offset date and time within the second, in the range 0 to 999 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.OffsetDateTime.TickOfSecond">
      <summary>
            Gets the tick of this offset date and time within the second, in the range 0 to 9,999,999 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.OffsetDateTime.TickOfDay">
      <summary>
            Gets the tick of this offset date and time within the day, in the range 0 to 863,999,999,999 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.OffsetDateTime.LocalDateTime">
      <summary>
            Returns the local date and time represented within this offset date and time.
            </summary>
    </member>
    <member name="P:NodaTime.OffsetDateTime.Date">
      <summary>
            Gets the local date represented by this offset date and time. The returned <see cref="T:NodaTime.LocalDate" />
            will have the same calendar system and return the same values for each of the date-based calendar
            properties (Year, MonthOfYear and so on), but will not have any offset information.
            </summary>
    </member>
    <member name="P:NodaTime.OffsetDateTime.TimeOfDay">
      <summary>
            Gets the time portion of this offset date and time. The returned <see cref="T:NodaTime.LocalTime" /> will
            return the same values for each of the time-based properties (Hour, Minute and so on), but
            will not have any offset information.
            </summary>
    </member>
    <member name="P:NodaTime.OffsetDateTime.Offset">
      <summary>
            Returns the offset from UTC.
            </summary>
    </member>
    <member name="T:NodaTime.IDateTimeZoneProvider">
      <summary>
            Provides stable, performant time zone data.
            </summary>
      <remarks>
        <para>Consumers should be able to treat an <see cref="T:NodaTime.IDateTimeZoneProvider" /> like a cache: 
            lookups should be quick (after at most one lookup of a given ID), and the data for a given ID should always be
            the same (even if the specific instance returned is not).
            Consumers should not feel the need to cache data accessed through this interface.</para>
        <para>Implementations designed to work with any <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource" /> implementation (such as
            <see cref="T:NodaTime.TimeZones.DateTimeZoneCache" />) should not attempt to handle exceptions thrown by the source. A source-specific
            provider may do so, as it has more detailed knowledge of what can go wrong and how it can best be handled.</para>
      </remarks>
    </member>
    <member name="M:NodaTime.IDateTimeZoneProvider.GetSystemDefault">
      <summary>
            Gets the time zone from this provider that matches the system default time zone, if a matching time zone is
            available.
            </summary>
      <remarks>
        <para>
            Callers should be aware that this method will throw <see cref="T:NodaTime.TimeZones.DateTimeZoneNotFoundException" /> if no matching
            time zone is found. For the built-in Noda Time providers, this is unlikely to occur in practice (assuming
            the system is using a standard Windows time zone), but can occur even then, if no mapping is found. The TZDB
            source contains mappings for almost all Windows system time zones, but a few (such as "Mid-Atlantic Standard Time")
            are unmappable.
            </para>
        <para>
            If it is necessary to handle this case, callers can construct a
            <see cref="T:NodaTime.TimeZones.BclDateTimeZone" /> via <see cref="M:NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault" />, which returns a
            <see cref="T:NodaTime.DateTimeZone" /> that wraps the system local <see cref="T:System.TimeZoneInfo" />, and which always
            succeeds. Note that <c>BclDateTimeZone</c> is not available on the PCL build of Noda Time, so
            this fallback strategy can only be used with the desktop version.
            </para>
      </remarks>
      <exception cref="T:NodaTime.TimeZones.DateTimeZoneNotFoundException">The system default time zone is not mapped by
            this provider.</exception>
      <returns>
            The provider-specific representation of the system default time zone.
            </returns>
    </member>
    <member name="M:NodaTime.IDateTimeZoneProvider.GetZoneOrNull(System.String)">
      <summary>
            Returns the time zone for the given ID, if it's available.
            </summary>
      <remarks>
        <para>
            Note that this may return a <see cref="T:NodaTime.DateTimeZone" /> that has a different ID to that requested, if the ID
            provided is an alias.
            </para>
        <para>
            Note also that this method is not required to return the same <see cref="T:NodaTime.DateTimeZone" /> instance for
            successive requests for the same ID; however, all instances returned for a given ID must compare
            as equal.
            </para>
        <para>
            The fixed-offset timezones with IDs "UTC" and "UTC+/-Offset" are always available. These must
            return instances that are equal to those returned by <see cref="M:NodaTime.DateTimeZone.ForOffset(NodaTime.Offset)" />.
            </para>
      </remarks>
      <param name="id">The time zone ID to find.</param>
      <returns>The <see cref="T:NodaTime.DateTimeZone" /> for the given ID or null if the provider does not support
            the given ID.</returns>
    </member>
    <member name="P:NodaTime.IDateTimeZoneProvider.VersionId">
      <summary>
            The version ID of this provider.
            </summary>
    </member>
    <member name="P:NodaTime.IDateTimeZoneProvider.Ids">
      <summary>
            Gets the list of valid time zone ids advertised by this provider.
            </summary>
      <remarks>
        <para>
            This list will be sorted in ordinal lexicographic order. It cannot be modified by callers, and
            must not be modified by the provider either: client code can safely treat it as thread-safe
            and deeply immutable.
            </para>
        <para>
            In addition to the list returned here, providers always support the fixed-offset timezones with IDs "UTC"
            and "UTC+/-Offset". These may or may not be included explicitly in this list.
            </para>
      </remarks>
      <value>The <see cref="T:System.Collections.Generic.IEnumerable`1" /> of string ids.</value>
    </member>
    <member name="P:NodaTime.IDateTimeZoneProvider.Item(System.String)">
      <summary>
            Returns the time zone for the given ID.
            </summary>
      <remarks>
        <para>
            Unlike <see cref="M:NodaTime.IDateTimeZoneProvider.GetZoneOrNull(System.String)" />, this indexer will never return a null reference. If the ID is not
            supported by this provider, it will throw <see cref="T:NodaTime.TimeZones.DateTimeZoneNotFoundException" />.
            </para>
        <para>
            Note that this may return a <see cref="T:NodaTime.DateTimeZone" /> that has a different ID to that requested, if the ID
            provided is an alias.
            </para>
        <para>
            Note also that this method is not required to return the same <see cref="T:NodaTime.DateTimeZone" /> instance for
            successive requests for the same ID; however, all instances returned for a given ID must compare
            as equal.
            </para>
        <para>
            The fixed-offset timezones with IDs "UTC" and "UTC+/-Offset" are always available. These must
            return instances that are equal to those returned by <see cref="M:NodaTime.DateTimeZone.ForOffset(NodaTime.Offset)" />.
            </para>
      </remarks>
      <param name="id">The time zone id to find.</param>
      <returns>The <see cref="T:NodaTime.DateTimeZone" /> for the given ID.</returns>
      <exception cref="T:NodaTime.TimeZones.DateTimeZoneNotFoundException">This provider does not support the given ID.</exception>
    </member>
    <member name="T:NodaTime.PeriodBuilder">
      <summary>
            A mutable builder class for <see cref="T:NodaTime.Period" /> values. Each property can
            be set independently, and then a Period can be created from the result
            using the <see cref="M:NodaTime.PeriodBuilder.Build" /> method.
            </summary>
      <threadsafety>
            This type is not thread-safe without extra synchronization, but has no
            thread affinity.
            </threadsafety>
    </member>
    <member name="M:NodaTime.PeriodBuilder.#ctor">
      <summary>
            Creates a new period builder with an initially zero period.
            </summary>
    </member>
    <member name="M:NodaTime.PeriodBuilder.#ctor(NodaTime.Period)">
      <summary>
            Creates a new period builder with the values from an existing
            period. Calling this constructor instead of <see cref="M:NodaTime.Period.ToBuilder" />
            allows object initializers to be used.
            </summary>
      <param name="period">An existing period to copy values from.</param>
    </member>
    <member name="M:NodaTime.PeriodBuilder.Build">
      <summary>
            Builds a period from the properties in this builder.
            </summary>
      <returns>A period containing the values from this builder.</returns>
    </member>
    <member name="P:NodaTime.PeriodBuilder.Years">
      <summary>
            Gets or sets the number of years within the period.
            </summary>
    </member>
    <member name="P:NodaTime.PeriodBuilder.Months">
      <summary>
            Gets or sets the number of months within the period.
            </summary>
    </member>
    <member name="P:NodaTime.PeriodBuilder.Weeks">
      <summary>
            Gets or sets the number of weeks within the period.
            </summary>
    </member>
    <member name="P:NodaTime.PeriodBuilder.Days">
      <summary>
            Gets or sets the number of days within the period.
            </summary>
    </member>
    <member name="P:NodaTime.PeriodBuilder.Hours">
      <summary>
            Gets or sets the number of hours within the period.
            </summary>
    </member>
    <member name="P:NodaTime.PeriodBuilder.Minutes">
      <summary>
            Gets or sets the number of minutes within the period.
            </summary>
    </member>
    <member name="P:NodaTime.PeriodBuilder.Seconds">
      <summary>
            Gets or sets the number of seconds within the period.
            </summary>
    </member>
    <member name="P:NodaTime.PeriodBuilder.Milliseconds">
      <summary>
            Gets or sets the number of milliseconds within the period.
            </summary>
    </member>
    <member name="P:NodaTime.PeriodBuilder.Ticks">
      <summary>
            Gets or sets the number of ticks within the period.
            </summary>
    </member>
    <member name="P:NodaTime.PeriodBuilder.Item(NodaTime.PeriodUnits)">
      <summary>
            Gets or sets the value of a single unit.
            </summary>
      <param name="unit">A single value within the <see cref="T:NodaTime.PeriodUnits" /> enumeration.</param>
      <returns>The value of the given unit within this period builder, or zero if the unit is unset.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="unit" /> is not a single unit.</exception>
    </member>
    <member name="T:NodaTime.PeriodUnits">
      <summary>
            The units within a <see cref="T:NodaTime.Period" />. When a period is created to find the difference between two local values,
            the caller may specify which units are required - for example, you can ask for the difference between two dates
            in "years and weeks". Units are always applied largest-first in arithmetic.
            </summary>
    </member>
    <member name="F:NodaTime.PeriodUnits.None">
      <summary>
            Value indicating no units - an empty period.
            </summary>
    </member>
    <member name="F:NodaTime.PeriodUnits.Years">
      <summary>
            Years element within a <see cref="T:NodaTime.Period" /></summary>
    </member>
    <member name="F:NodaTime.PeriodUnits.Months">
      <summary>
            Months element within a <see cref="T:NodaTime.Period" /></summary>
    </member>
    <member name="F:NodaTime.PeriodUnits.Weeks">
      <summary>
            Weeks element within a <see cref="T:NodaTime.Period" /></summary>
    </member>
    <member name="F:NodaTime.PeriodUnits.Days">
      <summary>
            Days element within a <see cref="T:NodaTime.Period" /></summary>
    </member>
    <member name="F:NodaTime.PeriodUnits.AllDateUnits">
      <summary>
            Compound value representing the combination of <see cref="F:NodaTime.PeriodUnits.Years" />, <see cref="F:NodaTime.PeriodUnits.Months" />, <see cref="F:NodaTime.PeriodUnits.Weeks" /> and <see cref="F:NodaTime.PeriodUnits.Days" />.
            </summary>
    </member>
    <member name="F:NodaTime.PeriodUnits.YearMonthDay">
      <summary>
            Compound value representing the combination of <see cref="F:NodaTime.PeriodUnits.Years" />, <see cref="F:NodaTime.PeriodUnits.Months" /> and <see cref="F:NodaTime.PeriodUnits.Days" />.
            </summary>
    </member>
    <member name="F:NodaTime.PeriodUnits.Hours">
      <summary>
            Hours element within a <see cref="T:NodaTime.Period" /></summary>
    </member>
    <member name="F:NodaTime.PeriodUnits.Minutes">
      <summary>
            Minutes element within a <see cref="T:NodaTime.Period" /></summary>
    </member>
    <member name="F:NodaTime.PeriodUnits.Seconds">
      <summary>
            Seconds element within a <see cref="T:NodaTime.Period" /></summary>
    </member>
    <member name="F:NodaTime.PeriodUnits.Milliseconds">
      <summary>
            Milliseconds element within a <see cref="T:NodaTime.Period" /></summary>
    </member>
    <member name="F:NodaTime.PeriodUnits.Ticks">
      <summary>
            Tick element within a <see cref="T:NodaTime.Period" /></summary>
    </member>
    <member name="F:NodaTime.PeriodUnits.HourMinuteSecond">
      <summary>
            Compound value representing the combination of <see cref="F:NodaTime.PeriodUnits.Hours" />, <see cref="F:NodaTime.PeriodUnits.Minutes" /> and <see cref="F:NodaTime.PeriodUnits.Seconds" />.
            </summary>
    </member>
    <member name="F:NodaTime.PeriodUnits.AllTimeUnits">
      <summary>
            Compound value representing the combination of all time elements.
            </summary>
    </member>
    <member name="F:NodaTime.PeriodUnits.DateAndTime">
      <summary>
            Compound value representing the combination of all possible elements except weeks.
            </summary>
    </member>
    <member name="F:NodaTime.PeriodUnits.AllUnits">
      <summary>
            Compound value representing the combination of all possible elements.
            </summary>
    </member>
    <member name="T:NodaTime.IClock">
      <summary>
            Represents a clock which can return the current time as an <see cref="T:NodaTime.Instant" />.
            </summary>
      <remarks>
        <see cref="T:NodaTime.IClock" /> is intended for use anywhere you need to have access to the current time.
            Although it's not strictly incorrect to call <c>SystemClock.Instance.Now</c> directly,
            in the same way as you might call <see cref="P:System.DateTime.UtcNow" />, it's strongly discouraged
            as a matter of style for production code. We recommend providing an instance of <see cref="T:NodaTime.IClock" />
            to anything that needs it, which allows you to write tests using the fake clock in the NodaTime.Testing
            assembly (or your own implementation).
            </remarks>
      <seealso cref="T:NodaTime.SystemClock" />
      <seealso cref="T:NodaTime.Testing.FakeClock" />
      <threadsafety>All implementations in Noda Time are thread-safe; custom implementations
            should be thread-safe too. See the thread safety section of the user guide for more information.
            </threadsafety>
    </member>
    <member name="P:NodaTime.IClock.Now">
      <summary>
            Gets the current <see cref="T:NodaTime.Instant" /> on the time line according to this clock.
            </summary>
    </member>
    <member name="T:NodaTime.IsoDayOfWeek">
      <summary>
            Equates the days of the week with their numerical value according to
            ISO-8601. This corresponds with System.DayOfWeek except for Sunday, which
            is 7 in the ISO numbering and 0 in System.DayOfWeek.
            </summary>
    </member>
    <member name="F:NodaTime.IsoDayOfWeek.None">
      <summary>
            Value indicating no day of the week; this will never be returned
            by any IsoDayOfWeek property, and is not valid as an argument to
            any method.
            </summary>
    </member>
    <member name="F:NodaTime.IsoDayOfWeek.Monday">
      <summary>
            Value representing Monday (1).
            </summary>
    </member>
    <member name="F:NodaTime.IsoDayOfWeek.Tuesday">
      <summary>
            Value representing Tuesday (2).
            </summary>
    </member>
    <member name="F:NodaTime.IsoDayOfWeek.Wednesday">
      <summary>
            Value representing Wednesday (3).
            </summary>
    </member>
    <member name="F:NodaTime.IsoDayOfWeek.Thursday">
      <summary>
            Value representing Thursday (4).
            </summary>
    </member>
    <member name="F:NodaTime.IsoDayOfWeek.Friday">
      <summary>
            Value representing Friday (5).
            </summary>
    </member>
    <member name="F:NodaTime.IsoDayOfWeek.Saturday">
      <summary>
            Value representing Saturday (6).
            </summary>
    </member>
    <member name="F:NodaTime.IsoDayOfWeek.Sunday">
      <summary>
            Value representing Sunday (7).
            </summary>
    </member>
    <member name="T:NodaTime.LocalDate">
      <summary>
            LocalDate is an immutable struct representing a date within the calendar,
            with no reference to a particular time zone or time of day.
            </summary>
      <remarks>
        <para>Comparisons of dates can be handled in a way which is either calendar-sensitive or calendar-insensitive.
            Noda Time implements all the operators (and the <see cref="M:NodaTime.LocalDate.Equals(NodaTime.LocalDate)" /> method) such that all operators other than <see cref="M:NodaTime.LocalDate.op_Inequality(NodaTime.LocalDate,NodaTime.LocalDate)" />
            will return false if asked to compare two values in different calendar systems.
            </para>
        <para>
            However, the <see cref="M:NodaTime.LocalDate.CompareTo(NodaTime.LocalDate)" /> method (implementing <see cref="T:System.IComparable`1" />) is calendar-insensitive; it compares the two
            dates historically in terms of when they actually occurred, as if they're both converted to some "neutral" calendar system first.
            </para>
        <para>
            It's unclear at the time of this writing whether this is the most appropriate approach, and it may change in future versions. In general,
            it would be a good idea for users to avoid comparing dates in different calendar systems, and indeed most users are unlikely to ever explicitly
            consider which calendar system they're working in anyway.
            </para>
      </remarks>
      <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="M:NodaTime.LocalDate.#ctor(System.Int32,System.Int32,System.Int32)">
      <summary>
            Constructs an instance for the given year, month and day in the ISO calendar.
            </summary>
      <param name="year">The year. This is the "absolute year", so a value of 0 means 1 BC, for example.</param>
      <param name="month">The month of year.</param>
      <param name="day">The day of month.</param>
      <returns>The resulting date.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date.</exception>
    </member>
    <member name="M:NodaTime.LocalDate.#ctor(System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)">
      <summary>
            Constructs an instance for the given year, month and day in the specified calendar.
            </summary>
      <param name="year">The year. This is the "absolute year", so, for
            the ISO calendar, a value of 0 means 1 BC, for example.</param>
      <param name="month">The month of year.</param>
      <param name="day">The day of month.</param>
      <param name="calendar">Calendar system in which to create the date.</param>
      <returns>The resulting date.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date.</exception>
    </member>
    <member name="M:NodaTime.LocalDate.#ctor(NodaTime.Calendars.Era,System.Int32,System.Int32,System.Int32)">
      <summary>
            Constructs an instance for the given era, year of era, month and day in the ISO calendar.
            </summary>
      <param name="era">The era within which to create a date. Must be a valid era within the ISO calendar.</param>
      <param name="yearOfEra">The year of era.</param>
      <param name="month">The month of year.</param>
      <param name="day">The day of month.</param>
      <returns>The resulting date.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date.</exception>
    </member>
    <member name="M:NodaTime.LocalDate.#ctor(NodaTime.Calendars.Era,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)">
      <summary>
            Constructs an instance for the given era, year of era, month and day in the specified calendar.
            </summary>
      <param name="era">The era within which to create a date. Must be a valid era within the specified calendar.</param>
      <param name="yearOfEra">The year of era.</param>
      <param name="month">The month of year.</param>
      <param name="day">The day of month.</param>
      <param name="calendar">Calendar system in which to create the date.</param>
      <returns>The resulting date.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date.</exception>
    </member>
    <member name="M:NodaTime.LocalDate.AtMidnight">
      <summary>
            Gets a <see cref="T:NodaTime.LocalDateTime" /> at midnight on the date represented by this local date.
            </summary>
      <returns>The <see cref="T:NodaTime.LocalDateTime" /> representing midnight on this local date, in the same calendar
            system.</returns>
    </member>
    <member name="M:NodaTime.LocalDate.FromWeekYearWeekAndDay(System.Int32,System.Int32,NodaTime.IsoDayOfWeek)">
      <summary>
            Returns the local date corresponding to the given "week year", "week of week year", and "day of week"
            in the ISO calendar system.
            </summary>
      <param name="weekYear">ISO-8601 week year of value to return</param>
      <param name="weekOfWeekYear">ISO-8601 week of week year of value to return</param>
      <param name="dayOfWeek">ISO-8601 day of week to return</param>
      <returns>The date corresponding to the given week year / week of week year / day of week.</returns>
    </member>
    <member name="M:NodaTime.LocalDate.op_Addition(NodaTime.LocalDate,NodaTime.Period)">
      <summary>
            Adds the specified period to the date.
            </summary>
      <param name="date">The date to add the period to</param>
      <param name="period">The period to add. Must not contain any (non-zero) time units.</param>
      <returns>The sum of the given date and period</returns>
    </member>
    <member name="M:NodaTime.LocalDate.Add(NodaTime.LocalDate,NodaTime.Period)">
      <summary>
            Adds the specified period to the date. Friendly alternative to <c>operator+()</c>.
            </summary>
      <param name="date">The date to add the period to</param>
      <param name="period">The period to add. Must not contain any (non-zero) time units.</param>
      <returns>The sum of the given date and period</returns>
    </member>
    <member name="M:NodaTime.LocalDate.Plus(NodaTime.Period)">
      <summary>
            Adds the specified period to this date. Fluent alternative to <c>operator+()</c>.
            </summary>
      <param name="period">The period to add. Must not contain any (non-zero) time units.</param>
      <returns>The sum of this date and the given period</returns>
    </member>
    <member name="M:NodaTime.LocalDate.op_Addition(NodaTime.LocalDate,NodaTime.LocalTime)">
      <summary>
            Combines the given <see cref="T:NodaTime.LocalDate" /> and <see cref="T:NodaTime.LocalTime" /> components
            into a single <see cref="T:NodaTime.LocalDateTime" />.
            </summary>
      <param name="date">The date to add the time to</param>
      <param name="time">The time to add</param>
      <returns>The sum of the given date and time</returns>
    </member>
    <member name="M:NodaTime.LocalDate.op_Subtraction(NodaTime.LocalDate,NodaTime.Period)">
      <summary>
            Subtracts the specified period from the date.
            </summary>
      <param name="date">The date to subtract the period from</param>
      <param name="period">The period to subtract. Must not contain any (non-zero) time units.</param>
      <returns>The result of subtracting the given period from the date</returns>
    </member>
    <member name="M:NodaTime.LocalDate.Subtract(NodaTime.LocalDate,NodaTime.Period)">
      <summary>
            Subtracts the specified period from the date. Friendly alternative to <c>operator-()</c>.
            </summary>
      <param name="date">The date to subtract the period from</param>
      <param name="period">The period to subtract. Must not contain any (non-zero) time units.</param>
      <returns>The result of subtracting the given period from the date.</returns>
    </member>
    <member name="M:NodaTime.LocalDate.Minus(NodaTime.Period)">
      <summary>
            Subtracts the specified period from this date. Fluent alternative to <c>operator-()</c>.
            </summary>
      <param name="period">The period to subtract. Must not contain any (non-zero) time units.</param>
      <returns>The result of subtracting the given period from this date.</returns>
    </member>
    <member name="M:NodaTime.LocalDate.op_Equality(NodaTime.LocalDate,NodaTime.LocalDate)">
      <summary>
            Compares two <see cref="T:NodaTime.LocalDate" /> values for equality. This requires
            that the dates be the same, within the same calendar.
            </summary>
      <param name="lhs">The first value to compare</param>
      <param name="rhs">The second value to compare</param>
      <returns>True if the two dates are the same and in the same calendar; false otherwise</returns>
    </member>
    <member name="M:NodaTime.LocalDate.op_Inequality(NodaTime.LocalDate,NodaTime.LocalDate)">
      <summary>
            Compares two <see cref="T:NodaTime.LocalDate" /> values for inequality.
            </summary>
      <param name="lhs">The first value to compare</param>
      <param name="rhs">The second value to compare</param>
      <returns>False if the two dates are the same and in the same calendar; true otherwise</returns>
    </member>
    <member name="M:NodaTime.LocalDate.op_LessThan(NodaTime.LocalDate,NodaTime.LocalDate)">
      <summary>
            Compares two LocalDate values to see if the left one is strictly earlier than the right
            one.
            </summary>
      <remarks>
            This operator always returns false if the two operands have different calendars. See the top-level type
            documentation for more information about comparisons.
            </remarks>
      <param name="lhs">First operand of the comparison</param>
      <param name="rhs">Second operand of the comparison</param>
      <returns>true if the <paramref name="lhs" /> is strictly earlier than <paramref name="rhs" />, false otherwise.</returns>
    </member>
    <member name="M:NodaTime.LocalDate.op_LessThanOrEqual(NodaTime.LocalDate,NodaTime.LocalDate)">
      <summary>
            Compares two LocalDate values to see if the left one is earlier than or equal to the right
            one.
            </summary>
      <remarks>
            This operator always returns false if the two operands have different calendars. See the top-level type
            documentation for more information about comparisons.
            </remarks>
      <param name="lhs">First operand of the comparison</param>
      <param name="rhs">Second operand of the comparison</param>
      <returns>true if the <paramref name="lhs" /> is earlier than or equal to <paramref name="rhs" />, false otherwise.</returns>
    </member>
    <member name="M:NodaTime.LocalDate.op_GreaterThan(NodaTime.LocalDate,NodaTime.LocalDate)">
      <summary>
            Compares two LocalDate values to see if the left one is strictly later than the right
            one.
            </summary>
      <remarks>
            This operator always returns false if the two operands have different calendars. See the top-level type
            documentation for more information about comparisons.
            </remarks>
      <param name="lhs">First operand of the comparison</param>
      <param name="rhs">Second operand of the comparison</param>
      <returns>true if the <paramref name="lhs" /> is strictly later than <paramref name="rhs" />, false otherwise.</returns>
    </member>
    <member name="M:NodaTime.LocalDate.op_GreaterThanOrEqual(NodaTime.LocalDate,NodaTime.LocalDate)">
      <summary>
            Compares two LocalDate values to see if the left one is later than or equal to the right
            one.
            </summary>
      <remarks>
            This operator always returns false if the two operands have different calendars. See the top-level type
            documentation for more information about comparisons.
            </remarks>
      <param name="lhs">First operand of the comparison</param>
      <param name="rhs">Second operand of the comparison</param>
      <returns>true if the <paramref name="lhs" /> is later than or equal to <paramref name="rhs" />, false otherwise.</returns>
    </member>
    <member name="M:NodaTime.LocalDate.CompareTo(NodaTime.LocalDate)">
      <summary>
            Indicates whether this date is earlier, later or the same as another one.
            </summary>
      <remarks>
            The comparison is performed in terms of a calendar-independent notion of date;
            the calendar systems of both <see cref="T:NodaTime.LocalDate" /> values are ignored. When both values use the same calendar,
            this is absolutely natural. However, when comparing a value in one calendar with a value in another,
            this can lead to surprising results. For example, 1945 in the ISO calendar corresponds to around 1364
            in the Islamic calendar, so an Islamic date in year 1400 is "after" a date in 1945 in the ISO calendar.
            </remarks>
      <param name="other">The other date to compare this one with</param>
      <returns>A value less than zero if this date is earlier than <paramref name="other" />;
            zero if this date is the same as <paramref name="other" />; a value greater than zero if this date is
            later than <paramref name="other" />.</returns>
    </member>
    <member name="M:NodaTime.LocalDate.GetHashCode">
      <summary>
            Returns a hash code for this local date.
            </summary>
      <returns>A hash code for this local date.</returns>
    </member>
    <member name="M:NodaTime.LocalDate.Equals(System.Object)">
      <summary>
            Compares two <see cref="T:NodaTime.LocalDate" /> values for equality. This requires
            that the dates be the same, within the same calendar.
            </summary>
      <param name="obj">The object to compare this date with.</param>
      <returns>True if the given value is another local date equal to this one; false otherwise.</returns>
    </member>
    <member name="M:NodaTime.LocalDate.Equals(NodaTime.LocalDate)">
      <summary>
            Compares two <see cref="T:NodaTime.LocalDate" /> values for equality. This requires
            that the dates be the same, within the same calendar.
            </summary>
      <param name="other">The value to compare this date with.</param>
      <returns>True if the given value is another local date equal to this one; false otherwise.</returns>
    </member>
    <member name="M:NodaTime.LocalDate.WithCalendar(NodaTime.CalendarSystem)">
      <summary>
            Creates a new LocalDate representing the same physical date, but in a different calendar.
            The returned LocalDate is likely to have different field values to this one.
            For example, January 1st 1970 in the Gregorian calendar was December 19th 1969 in the Julian calendar.
            </summary>
      <param name="calendarSystem">The calendar system to convert this local date to.</param>
      <returns>The converted LocalDate</returns>
    </member>
    <member name="M:NodaTime.LocalDate.PlusYears(System.Int32)">
      <summary>
            Returns a new LocalDate representing the current value with the given number of years added.
            </summary>
      <remarks>
            If the resulting date is invalid, lower fields (typically the day of month) are reduced to find a valid value.
            For example, adding one year to February 29th 2012 will return February 28th 2013; subtracting one year from
            February 29th 2012 will return February 28th 2011.
            </remarks>
      <param name="years">The number of years to add</param>
      <returns>The current value plus the given number of years.</returns>
    </member>
    <member name="M:NodaTime.LocalDate.PlusMonths(System.Int32)">
      <summary>
            Returns a new LocalDate representing the current value with the given number of months added.
            </summary>
      <remarks>
        <para>
            This method does not try to maintain the year of the current value, so adding four months to a value in 
            October will result in a value in the following February.
            </para>
        <para>
            If the resulting date is invalid, the day of month is reduced to find a valid value.
            For example, adding one month to January 30th 2011 will return February 28th 2011; subtracting one month from
            March 30th 2011 will return February 28th 2011.
            </para>
      </remarks>
      <param name="months">The number of months to add</param>
      <returns>The current date plus the given number of months</returns>
    </member>
    <member name="M:NodaTime.LocalDate.PlusDays(System.Int32)">
      <summary>
            Returns a new LocalDate representing the current value with the given number of days added.
            </summary>
      <remarks>
        <para>
            This method does not try to maintain the month or year of the current value, so adding 3 days to a value of January 30th
            will result in a value of February 2nd.
            </para>
      </remarks>
      <param name="days">The number of days to add</param>
      <returns>The current value plus the given number of days.</returns>
    </member>
    <member name="M:NodaTime.LocalDate.PlusWeeks(System.Int32)">
      <summary>
            Returns a new LocalDate representing the current value with the given number of weeks added.
            </summary>
      <param name="weeks">The number of weeks to add</param>
      <returns>The current value plus the given number of weeks.</returns>
    </member>
    <member name="M:NodaTime.LocalDate.Next(NodaTime.IsoDayOfWeek)">
      <summary>
            Returns the next <see cref="T:NodaTime.LocalDate" /> falling on the specified <see cref="P:NodaTime.LocalDate.IsoDayOfWeek" />.
            This is a strict "next" - if this date on already falls on the target
            day of the week, the returned value will be a week later.
            </summary>
      <param name="targetDayOfWeek">The ISO day of the week to return the next date of.</param>
      <returns>The next <see cref="T:NodaTime.LocalDate" /> falling on the specified day of the week.</returns>
      <exception cref="T:System.InvalidOperationException">The underlying calendar doesn't use ISO days of the week.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="targetDayOfWeek" /> is not a valid day of the
            week (Monday to Sunday).</exception>
    </member>
    <member name="M:NodaTime.LocalDate.Previous(NodaTime.IsoDayOfWeek)">
      <summary>
            Returns the previous <see cref="T:NodaTime.LocalDate" /> falling on the specified <see cref="P:NodaTime.LocalDate.IsoDayOfWeek" />.
            This is a strict "previous" - if this date on already falls on the target
            day of the week, the returned value will be a week earlier.
            </summary>
      <param name="targetDayOfWeek">The ISO day of the week to return the previous date of.</param>
      <returns>The previous <see cref="T:NodaTime.LocalDate" /> falling on the specified day of the week.</returns>
      <exception cref="T:System.InvalidOperationException">The underlying calendar doesn't use ISO days of the week.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="targetDayOfWeek" /> is not a valid day of the
            week (Monday to Sunday).</exception>
    </member>
    <member name="M:NodaTime.LocalDate.At(NodaTime.LocalTime)">
      <summary>
            Combines this <see cref="T:NodaTime.LocalDate" /> with the given <see cref="T:NodaTime.LocalTime" />
            into a single <see cref="T:NodaTime.LocalDateTime" />.
            Fluent alternative to <c>operator+()</c>.
            </summary>
      <param name="time">The time to combine with this date.</param>
      <returns>The <see cref="T:NodaTime.LocalDateTime" /> representation of the given time on this date</returns>
    </member>
    <member name="M:NodaTime.LocalDate.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            The value of the current instance in the default format pattern ("D"), using the current thread's
            culture to obtain a format provider.
            </returns>
    </member>
    <member name="M:NodaTime.LocalDate.ToString(System.String,System.IFormatProvider)">
      <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
      <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
      <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("D").
            </param>
      <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:NodaTime.LocalDate.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Private constructor only present for serialization.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to fetch data from.</param>
      <param name="context">The source for this deserialization.</param>
    </member>
    <member name="P:NodaTime.LocalDate.Calendar">
      <summary>Gets the calendar system associated with this local date.</summary>
    </member>
    <member name="P:NodaTime.LocalDate.Year">
      <summary>Gets the year of this local date.</summary>
      <remarks>This returns the "absolute year", so, for the ISO calendar,
            a value of 0 means 1 BC, for example.</remarks>
    </member>
    <member name="P:NodaTime.LocalDate.Month">
      <summary>Gets the month of this local date within the year.</summary>
    </member>
    <member name="P:NodaTime.LocalDate.Day">
      <summary>Gets the day of this local date within the month.</summary>
    </member>
    <member name="P:NodaTime.LocalDate.IsoDayOfWeek">
      <summary>
            Gets the week day of this local date expressed as an <see cref="T:NodaTime.IsoDayOfWeek" /> value,
            for calendars which use ISO days of the week.
            </summary>
      <exception cref="T:System.InvalidOperationException">The underlying calendar doesn't use ISO days of the week.</exception>
      <seealso cref="P:NodaTime.LocalDate.DayOfWeek" />
    </member>
    <member name="P:NodaTime.LocalDate.DayOfWeek">
      <summary>
            Gets the week day of this local date as a number.
            </summary>
      <remarks>
            For calendars using ISO week days, this gives 1 for Monday to 7 for Sunday.
            </remarks>
      <seealso cref="P:NodaTime.LocalDate.IsoDayOfWeek" />
    </member>
    <member name="P:NodaTime.LocalDate.WeekYear">
      <summary>
            Gets the "week year" of this local date.
            </summary>
      <remarks>
        <para>
            The WeekYear is the year that matches with the <see cref="P:NodaTime.LocalDate.WeekOfWeekYear" /> field.
            In the standard ISO8601 week algorithm, the first week of the year
            is that in which at least 4 days are in the year. As a result of this
            definition, day 1 of the first week may be in the previous year.
            The WeekYear allows you to query the effective year for that day.
            </para>
        <para>
            For example, January 1st 2011 was a Saturday, so only two days of that week
            (Saturday and Sunday) were in 2011. Therefore January 1st is part of
            week 52 of WeekYear 2010. Conversely, December 31st 2012 is a Monday,
            so is part of week 1 of WeekYear 2013.
            </para>
      </remarks>
    </member>
    <member name="P:NodaTime.LocalDate.WeekOfWeekYear">
      <summary>Gets the week within the WeekYear. See <see cref="P:NodaTime.LocalDate.WeekYear" /> for more details.</summary>
    </member>
    <member name="P:NodaTime.LocalDate.YearOfCentury">
      <summary>Gets the year of this local date within the century.</summary>
      <remarks>This always returns a value in the range 0 to 99 inclusive.</remarks>
    </member>
    <member name="P:NodaTime.LocalDate.YearOfEra">
      <summary>Gets the year of this local date within the era.</summary>
    </member>
    <member name="P:NodaTime.LocalDate.Era">
      <summary>Gets the era of this local date.</summary>
    </member>
    <member name="P:NodaTime.LocalDate.DayOfYear">
      <summary>Gets the day of this local date within the year.</summary>
    </member>
    <member name="T:NodaTime.LocalTime">
      <summary>
            LocalTime is an immutable struct representing a time of day, with no reference
            to a particular calendar, time zone or date.
            </summary>
      <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="F:NodaTime.LocalTime.Midnight">
      <summary>
            Local time at midnight, i.e. 0 hours, 0 minutes, 0 seconds.
            </summary>
    </member>
    <member name="F:NodaTime.LocalTime.Noon">
      <summary>
            Local time at noon, i.e. 12 hours, 0 minutes, 0 seconds.
            </summary>
    </member>
    <member name="F:NodaTime.LocalTime.ticks">
      <summary>
            Ticks since midnight, in the range [0, 864,000,000,000).
            </summary>
    </member>
    <member name="M:NodaTime.LocalTime.On(NodaTime.LocalDate)">
      <summary>
            Combines this <see cref="T:NodaTime.LocalTime" /> with the given <see cref="T:NodaTime.LocalDate" />
            into a single <see cref="P:NodaTime.LocalTime.LocalDateTime" />.
            Fluent alternative to <c>operator+()</c>.
            </summary>
      <param name="date">The date to combine with this time</param>
      <returns>The <see cref="P:NodaTime.LocalTime.LocalDateTime" /> representation of the given time on this date</returns>
    </member>
    <member name="M:NodaTime.LocalTime.#ctor(System.Int32,System.Int32)">
      <summary>
            Creates a local time at the given hour and minute, with second, millisecond-of-second
            and tick-of-millisecond values of zero.
            </summary>
      <param name="hour">The hour of day.</param>
      <param name="minute">The minute of the hour.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid time.</exception>
      <returns>The resulting time.</returns>
    </member>
    <member name="M:NodaTime.LocalTime.#ctor(System.Int32,System.Int32,System.Int32)">
      <summary>
            Creates a local time at the given hour, minute and second,
            with millisecond-of-second and tick-of-millisecond values of zero.
            </summary>
      <param name="hour">The hour of day.</param>
      <param name="minute">The minute of the hour.</param>
      <param name="second">The second of the minute.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid time.</exception>
      <returns>The resulting time.</returns>
    </member>
    <member name="M:NodaTime.LocalTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Creates a local time at the given hour, minute, second and millisecond,
            with a tick-of-millisecond value of zero.
            </summary>
      <param name="hour">The hour of day.</param>
      <param name="minute">The minute of the hour.</param>
      <param name="second">The second of the minute.</param>
      <param name="millisecond">The millisecond of the second.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid time.</exception>
      <returns>The resulting time.</returns>
    </member>
    <member name="M:NodaTime.LocalTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Creates a local time at the given hour, minute, second, millisecond and tick within millisecond.
            </summary>
      <param name="hour">The hour of day.</param>
      <param name="minute">The minute of the hour.</param>
      <param name="second">The second of the minute.</param>
      <param name="millisecond">The millisecond of the second.</param>
      <param name="tickWithinMillisecond">The tick within the millisecond.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid time.</exception>
      <returns>The resulting time.</returns>
    </member>
    <member name="M:NodaTime.LocalTime.FromHourMinuteSecondTick(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Factory method for creating a local time from the hour of day, minute of hour, second of minute, and tick of second.
            </summary>
      <remarks>
            This is not a constructor overload as it would have the same signature as the one taking millisecond of second.
            </remarks>
      <param name="hour">The hour of day in the desired time, in the range [0, 23].</param>
      <param name="minute">The minute of hour in the desired time, in the range [0, 59].</param>
      <param name="second">The second of minute in the desired time, in the range [0, 59].</param>
      <param name="tickWithinSecond">The tick within the second in the desired time, in the range [0, 9999999].</param>
      <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid time.</exception>
      <returns>The resulting time.</returns>
    </member>
    <member name="M:NodaTime.LocalTime.FromTicksSinceMidnight(System.Int64)">
      <summary>
            Factory method for creating a local time from the number of ticks which have elapsed since midnight.
            </summary>
      <param name="ticks">The number of ticks, in the range [0, 863,999,999,999]</param>
      <returns>The resulting time.</returns>
    </member>
    <member name="M:NodaTime.LocalTime.FromMillisecondsSinceMidnight(System.Int32)">
      <summary>
            Factory method for creating a local time from the number of milliseconds which have elapsed since midnight.
            </summary>
      <param name="milliseconds">The number of milliseconds, in the range [0, 86,399,999]</param>
      <returns>The resulting time.</returns>
    </member>
    <member name="M:NodaTime.LocalTime.FromSecondsSinceMidnight(System.Int32)">
      <summary>
            Factory method for creating a local time from the number of seconds which have elapsed since midnight.
            </summary>
      <param name="seconds">The number of seconds, in the range [0, 86,399]</param>
      <returns>The resulting time.</returns>
    </member>
    <member name="M:NodaTime.LocalTime.#ctor(System.Int64)">
      <summary>
            Constructor only called from other parts of Noda Time - trusted to be within January 1st 1970 UTC.
            </summary>
    </member>
    <member name="M:NodaTime.LocalTime.op_Addition(NodaTime.LocalTime,NodaTime.Period)">
      <summary>
            Creates a new local time by adding a period to an existing time. The period must not contain
            any date-related units (days etc) with non-zero values.
            </summary>
      <param name="time">The time to add the period to</param>
      <param name="period">The period to add</param>
      <returns>The result of adding the period to the time, wrapping via midnight if necessary</returns>
    </member>
    <member name="M:NodaTime.LocalTime.Add(NodaTime.LocalTime,NodaTime.Period)">
      <summary>
            Adds the specified period to the time. Friendly alternative to <c>operator+()</c>.
            </summary>
      <param name="time">The time to add the period to</param>
      <param name="period">The period to add. Must not contain any (non-zero) date units.</param>
      <returns>The sum of the given time and period</returns>
    </member>
    <member name="M:NodaTime.LocalTime.Plus(NodaTime.Period)">
      <summary>
            Adds the specified period to this time. Fluent alternative to <c>operator+()</c>.
            </summary>
      <param name="period">The period to add. Must not contain any (non-zero) date units.</param>
      <returns>The sum of this time and the given period</returns>
    </member>
    <member name="M:NodaTime.LocalTime.op_Subtraction(NodaTime.LocalTime,NodaTime.Period)">
      <summary>
            Creates a new local time by subtracting a period from an existing time. The period must not contain
            any date-related units (days etc) with non-zero values.
            </summary>
      <param name="time">The time to subtract the period from</param>
      <param name="period">The period to subtract</param>
      <returns>The result of subtract the period from the time, wrapping via midnight if necessary</returns>
    </member>
    <member name="M:NodaTime.LocalTime.Subtract(NodaTime.LocalTime,NodaTime.Period)">
      <summary>
            Subtracts the specified period from the time. Friendly alternative to <c>operator-()</c>.
            </summary>
      <param name="time">The time to subtract the period from</param>
      <param name="period">The period to subtract. Must not contain any (non-zero) date units.</param>
      <returns>The result of subtracting the given period from the time.</returns>
    </member>
    <member name="M:NodaTime.LocalTime.Minus(NodaTime.Period)">
      <summary>
            Subtracts the specified period from this time. Fluent alternative to <c>operator-()</c>.
            </summary>
      <param name="period">The period to subtract. Must not contain any (non-zero) date units.</param>
      <returns>The result of subtracting the given period from this time.</returns>
    </member>
    <member name="M:NodaTime.LocalTime.op_Equality(NodaTime.LocalTime,NodaTime.LocalTime)">
      <summary>
            Compares two local times for equality, by checking whether they represent
            the exact same local time, down to the tick.
            </summary>
      <param name="lhs">The first value to compare</param>
      <param name="rhs">The second value to compare</param>
      <returns>True if the two times are the same; false otherwise</returns>
    </member>
    <member name="M:NodaTime.LocalTime.op_Inequality(NodaTime.LocalTime,NodaTime.LocalTime)">
      <summary>
            Compares two local times for inequality.
            </summary>
      <param name="lhs">The first value to compare</param>
      <param name="rhs">The second value to compare</param>
      <returns>False if the two times are the same; true otherwise</returns>
    </member>
    <member name="M:NodaTime.LocalTime.op_LessThan(NodaTime.LocalTime,NodaTime.LocalTime)">
      <summary>
            Compares two LocalTime values to see if the left one is strictly earlier than the right
            one.
            </summary>
      <param name="lhs">First operand of the comparison</param>
      <param name="rhs">Second operand of the comparison</param>
      <returns>true if the <paramref name="lhs" /> is strictly earlier than <paramref name="rhs" />, false otherwise.</returns>
    </member>
    <member name="M:NodaTime.LocalTime.op_LessThanOrEqual(NodaTime.LocalTime,NodaTime.LocalTime)">
      <summary>
            Compares two LocalTime values to see if the left one is earlier than or equal to the right
            one.
            </summary>
      <param name="lhs">First operand of the comparison</param>
      <param name="rhs">Second operand of the comparison</param>
      <returns>true if the <paramref name="lhs" /> is earlier than or equal to <paramref name="rhs" />, false otherwise.</returns>
    </member>
    <member name="M:NodaTime.LocalTime.op_GreaterThan(NodaTime.LocalTime,NodaTime.LocalTime)">
      <summary>
            Compares two LocalTime values to see if the left one is strictly later than the right
            one.
            </summary>
      <param name="lhs">First operand of the comparison</param>
      <param name="rhs">Second operand of the comparison</param>
      <returns>true if the <paramref name="lhs" /> is strictly later than <paramref name="rhs" />, false otherwise.</returns>
    </member>
    <member name="M:NodaTime.LocalTime.op_GreaterThanOrEqual(NodaTime.LocalTime,NodaTime.LocalTime)">
      <summary>
            Compares two LocalTime values to see if the left one is later than or equal to the right
            one.
            </summary>
      <param name="lhs">First operand of the comparison</param>
      <param name="rhs">Second operand of the comparison</param>
      <returns>true if the <paramref name="lhs" /> is later than or equal to <paramref name="rhs" />, false otherwise.</returns>
    </member>
    <member name="M:NodaTime.LocalTime.CompareTo(NodaTime.LocalTime)">
      <summary>
            Indicates whether this time is earlier, later or the same as another one.
            </summary>
      <param name="other">The other date/time to compare this one with</param>
      <returns>A value less than zero if this time is earlier than <paramref name="other" />;
            zero if this time is the same as <paramref name="other" />; a value greater than zero if this time is
            later than <paramref name="other" />.</returns>
    </member>
    <member name="M:NodaTime.LocalTime.GetHashCode">
      <summary>
            Returns a hash code for this local time.
            </summary>
      <returns>A hash code for this local time.</returns>
    </member>
    <member name="M:NodaTime.LocalTime.Equals(NodaTime.LocalTime)">
      <summary>
            Compares this local time with the specified one for equality,
            by checking whether the two values represent the exact same local time, down to the tick.
            </summary>
      <param name="other">The other local time to compare this one with</param>
      <returns>True if the specified time is equal to this one; false otherwise</returns>
    </member>
    <member name="M:NodaTime.LocalTime.Equals(System.Object)">
      <summary>
            Compares this local time with the specified reference. A local time is
            only equal to another local time with the same underlying tick value.
            </summary>
      <param name="obj">The object to compare this one with</param>
      <returns>True if the specified value is a local time is equal to this one; false otherwise</returns>
    </member>
    <member name="M:NodaTime.LocalTime.PlusHours(System.Int64)">
      <summary>
            Returns a new LocalTime representing the current value with the given number of hours added.
            </summary>
      <remarks>
            If the value goes past the start or end of the day, it wraps - so 11pm plus two hours is 1am, for example.
            </remarks>
      <param name="hours">The number of hours to add</param>
      <returns>The current value plus the given number of hours.</returns>
    </member>
    <member name="M:NodaTime.LocalTime.PlusMinutes(System.Int64)">
      <summary>
            Returns a new LocalTime representing the current value with the given number of minutes added.
            </summary>
      <remarks>
            If the value goes past the start or end of the day, it wraps - so 11pm plus 120 minutes is 1am, for example.
            </remarks>
      <param name="minutes">The number of minutes to add</param>
      <returns>The current value plus the given number of minutes.</returns>
    </member>
    <member name="M:NodaTime.LocalTime.PlusSeconds(System.Int64)">
      <summary>
            Returns a new LocalTime representing the current value with the given number of seconds added.
            </summary>
      <remarks>
            If the value goes past the start or end of the day, it wraps - so 11:59pm plus 120 seconds is 12:01am, for example.
            </remarks>
      <param name="seconds">The number of seconds to add</param>
      <returns>The current value plus the given number of seconds.</returns>
    </member>
    <member name="M:NodaTime.LocalTime.PlusMilliseconds(System.Int64)">
      <summary>
            Returns a new LocalTime representing the current value with the given number of milliseconds added.
            </summary>
      <param name="milliseconds">The number of milliseconds to add</param>
      <returns>The current value plus the given number of milliseconds.</returns>
    </member>
    <member name="M:NodaTime.LocalTime.PlusTicks(System.Int64)">
      <summary>
            Returns a new LocalTime representing the current value with the given number of ticks added.
            </summary>
      <param name="ticks">The number of ticks to add</param>
      <returns>The current value plus the given number of ticks.</returns>
    </member>
    <member name="M:NodaTime.LocalTime.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            The value of the current instance in the default format pattern ("T"), using the current thread's
            culture to obtain a format provider.
            </returns>
    </member>
    <member name="M:NodaTime.LocalTime.ToString(System.String,System.IFormatProvider)">
      <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
      <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
      <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("T").
            </param>
      <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:NodaTime.LocalTime.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Private constructor only present for serialization.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to fetch data from.</param>
      <param name="context">The source for this deserialization.</param>
    </member>
    <member name="P:NodaTime.LocalTime.Hour">
      <summary>
            Gets the hour of day of this local time, in the range 0 to 23 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.LocalTime.ClockHourOfHalfDay">
      <summary>
            Gets the hour of the half-day of this local time, in the range 1 to 12 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.LocalTime.Minute">
      <summary>
            Gets the minute of this local time, in the range 0 to 59 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.LocalTime.Second">
      <summary>
            Gets the second of this local time within the minute, in the range 0 to 59 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.LocalTime.Millisecond">
      <summary>
            Gets the millisecond of this local time within the second, in the range 0 to 999 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.LocalTime.TickOfSecond">
      <summary>
            Gets the tick of this local time within the second, in the range 0 to 9,999,999 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.LocalTime.TickOfDay">
      <summary>
            Gets the tick of this local time within the day, in the range 0 to 863,999,999,999 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.LocalTime.LocalDateTime">
      <summary>
            Returns a <see cref="T:NodaTime.LocalDateTime" /> with this local time, on January 1st 1970 in the ISO
            calendar.
            </summary>
    </member>
    <member name="T:NodaTime.NamespaceDoc">
      <summary>
        <para>
            The NodaTime namespace contains the core types for Noda Time, including the main public classes for time zone and calendar
            support which have implementations (and less frequently used types) in other namespaces. For formatting and parsing functionality, see the
            <see cref="N:NodaTime.Text" /> namespace.
            </para>
      </summary>
    </member>
    <member name="T:NodaTime.Offset">
      <summary>
            An offset from UTC in milliseconds. A positive value means that the local time is
            ahead of UTC (e.g. for Europe); a negative value means that the local time is behind
            UTC (e.g. for America).
            </summary>
      <remarks>
            Offsets are always strictly less than 24 hours (as either a positive or negative offset).
            </remarks>
      <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="F:NodaTime.Offset.Zero">
      <summary>
            An offset of zero ticks - effectively the permanent offset for UTC.
            </summary>
    </member>
    <member name="F:NodaTime.Offset.MinValue">
      <summary>
            The minimum permitted offset; one millisecond less than a standard day before UTC.
            </summary>
    </member>
    <member name="F:NodaTime.Offset.MaxValue">
      <summary>
            The maximum permitted offset; one millisecond less than a standard day after UTC.
            </summary>
    </member>
    <member name="M:NodaTime.Offset.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Offset" /> struct.
            </summary>
      <remarks>
            Offsets are constrained to the range (-24 hours, 24 hours).
            </remarks>
      <param name="milliseconds">The number of milliseconds in the offset.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
    </member>
    <member name="M:NodaTime.Offset.Max(NodaTime.Offset,NodaTime.Offset)">
      <summary>
            Returns the greater offset of the given two, i.e. the one which will give a later local
            time when added to an instant.
            </summary>
      <param name="x">The first offset</param>
      <param name="y">The second offset</param>
      <returns>The greater offset of <paramref name="x" /> and <paramref name="y" />.</returns>
    </member>
    <member name="M:NodaTime.Offset.Min(NodaTime.Offset,NodaTime.Offset)">
      <summary>
            Returns the lower offset of the given two, i.e. the one which will give an earlier local
            time when added to an instant.
            </summary>
      <param name="x">The first offset</param>
      <param name="y">The second offset</param>
      <returns>The lower offset of <paramref name="x" /> and <paramref name="y" />.</returns>
    </member>
    <member name="M:NodaTime.Offset.op_UnaryNegation(NodaTime.Offset)">
      <summary>
              Implements the unary operator - (negation).
            </summary>
      <param name="offset">The offset to negate.</param>
      <returns>A new <see cref="T:NodaTime.Offset" /> instance with a negated value.</returns>
    </member>
    <member name="M:NodaTime.Offset.Negate(NodaTime.Offset)">
      <summary>
            Returns the negation of the specified offset. This is the method form of the unary minus operator.
            </summary>
      <param name="offset">The offset to negate.</param>
      <returns>The negation of the specified offset.</returns>
    </member>
    <member name="M:NodaTime.Offset.op_UnaryPlus(NodaTime.Offset)">
      <summary>
            Implements the unary operator + .
            </summary>
      <param name="offset">The operand.</param>
      <remarks>There is no method form of this operator; the <see cref="M:NodaTime.Offset.Plus(NodaTime.Offset)" /> method is an instance
            method for addition, and is more useful than a method form of this would be.</remarks>
      <returns>The same <see cref="T:NodaTime.Offset" /> instance</returns>
    </member>
    <member name="M:NodaTime.Offset.op_Addition(NodaTime.Offset,NodaTime.Offset)">
      <summary>
            Implements the operator + (addition).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
      <returns>A new <see cref="T:NodaTime.Offset" /> representing the sum of the given values.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
    </member>
    <member name="M:NodaTime.Offset.Add(NodaTime.Offset,NodaTime.Offset)">
      <summary>
            Adds one Offset to another. Friendly alternative to <c>operator+()</c>.
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
      <returns>A new <see cref="T:NodaTime.Offset" /> representing the sum of the given values.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
    </member>
    <member name="M:NodaTime.Offset.Plus(NodaTime.Offset)">
      <summary>
            Returns the result of adding another Offset to this one, for a fluent alternative to <c>operator+()</c>.
            </summary>
      <param name="other">The offset to add</param>
      <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
      <returns>The result of adding the other offset to this one.</returns>
    </member>
    <member name="M:NodaTime.Offset.op_Subtraction(NodaTime.Offset,NodaTime.Offset)">
      <summary>
            Implements the operator - (subtraction).
            </summary>
      <param name="minuend">The left hand side of the operator.</param>
      <param name="subtrahend">The right hand side of the operator.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
      <returns>A new <see cref="T:NodaTime.Offset" /> representing the difference of the given values.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
    </member>
    <member name="M:NodaTime.Offset.Subtract(NodaTime.Offset,NodaTime.Offset)">
      <summary>
            Subtracts one Offset from another. Friendly alternative to <c>operator-()</c>.
            </summary>
      <param name="minuend">The left hand side of the operator.</param>
      <param name="subtrahend">The right hand side of the operator.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
      <returns>A new <see cref="T:NodaTime.Offset" /> representing the difference of the given values.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
    </member>
    <member name="M:NodaTime.Offset.Minus(NodaTime.Offset)">
      <summary>
            Returns the result of subtracting another Offset from this one, for a fluent alternative to <c>operator-()</c>.
            </summary>
      <param name="other">The offset to subtract</param>
      <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
      <returns>The result of subtracting the other offset from this one.</returns>
    </member>
    <member name="M:NodaTime.Offset.op_Equality(NodaTime.Offset,NodaTime.Offset)">
      <summary>
            Implements the operator == (equality).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.Offset.op_Inequality(NodaTime.Offset,NodaTime.Offset)">
      <summary>
            Implements the operator != (inequality).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.Offset.op_LessThan(NodaTime.Offset,NodaTime.Offset)">
      <summary>
            Implements the operator &lt; (less than).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if the left value is less than the right value, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.Offset.op_LessThanOrEqual(NodaTime.Offset,NodaTime.Offset)">
      <summary>
            Implements the operator &lt;= (less than or equal).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if the left value is less than or equal to the right value, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.Offset.op_GreaterThan(NodaTime.Offset,NodaTime.Offset)">
      <summary>
            Implements the operator &gt; (greater than).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if the left value is greater than the right value, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.Offset.op_GreaterThanOrEqual(NodaTime.Offset,NodaTime.Offset)">
      <summary>
              Implements the operator &gt;= (greater than or equal).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if the left value is greater than or equal to the right value, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.Offset.CompareTo(NodaTime.Offset)">
      <summary>
            Compares the current object with another object of the same type.
            </summary>
      <param name="other">An object to compare with this object.</param>
      <returns>
              A 32-bit signed integer that indicates the relative order of the objects being compared.
              The return value has the following meanings:
              <list type="table"><listheader><term>Value</term><description>Meaning</description></listheader><item><term>&lt; 0</term><description>This object is less than the <paramref name="other" /> parameter.</description></item><item><term>0</term><description>This object is equal to <paramref name="other" />.</description></item><item><term>&gt; 0</term><description>This object is greater than <paramref name="other" />.</description></item></list></returns>
    </member>
    <member name="M:NodaTime.Offset.Equals(NodaTime.Offset)">
      <summary>
              Indicates whether the current object is equal to another object of the same type.
            </summary>
      <param name="other">An object to compare with this object.</param>
      <returns>
              true if the current object is equal to the <paramref name="other" /> parameter;
              otherwise, false.
            </returns>
    </member>
    <member name="M:NodaTime.Offset.Equals(System.Object)">
      <summary>
              Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance;
              otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NodaTime.Offset.GetHashCode">
      <summary>
              Returns a hash code for this instance.
            </summary>
      <returns>
              A hash code for this instance, suitable for use in hashing algorithms and data
              structures like a hash table. 
            </returns>
    </member>
    <member name="M:NodaTime.Offset.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            The value of the current instance in the default format pattern ("g"), using the current thread's
            culture to obtain a format provider.
            </returns>
    </member>
    <member name="M:NodaTime.Offset.ToString(System.String,System.IFormatProvider)">
      <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
      <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
      <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("g").
            </param>
      <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:NodaTime.Offset.FromMilliseconds(System.Int32)">
      <summary>
            Returns the offset for the given milliseconds value, which may be negative.
            </summary>
      <param name="milliseconds">The int milliseconds value.</param>
      <returns>The <see cref="T:NodaTime.Offset" /> for the given milliseconds value</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
    </member>
    <member name="M:NodaTime.Offset.FromTicks(System.Int64)">
      <summary>
            Creates a new offset from the given number of ticks, which may be negative.
            </summary>
      <remarks>
            Offsets are only accurate to millisecond precision; the given number of ticks is simply divided
            by 10,000 to give the number of milliseconds - any remainder is truncated.
            </remarks>
      <param name="ticks">The number of ticks specifying the length of the new offset.</param>
      <returns>An offset representing the given number of ticks, to the (truncated) millisecond.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
    </member>
    <member name="M:NodaTime.Offset.FromHours(System.Int32)">
      <summary>
            Creates an offset with the specified number of hours, which may be negative.
            </summary>
      <param name="hours">The number of hours to represent in the new offset.</param>
      <returns>
            A new <see cref="T:NodaTime.Offset" /> representing the given value.
            </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
    </member>
    <member name="M:NodaTime.Offset.FromHoursAndMinutes(System.Int32,System.Int32)">
      <summary>
            Creates an offset with the specified number of hours and minutes.
            </summary>
      <remarks>
            The result simply takes the hours and minutes and converts each component into milliseconds
            separately. As a result, a negative offset should usually be obtained by making both arguments
            negative. For example, to obtain "three hours and ten minutes behind UTC" you might call
            <c>Offset.FromHoursAndMinutes(-3, -10)</c>.
            </remarks>
      <param name="hours">The number of hours to represent in the new offset.</param>
      <param name="minutes">The number of minutes to represent in the new offset.</param>
      <returns>
            A new <see cref="T:NodaTime.Offset" /> representing the given value.
            </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
    </member>
    <member name="M:NodaTime.Offset.ToTimeSpan">
      <summary>
            Converts this offset to a .NET standard <see cref="T:System.TimeSpan" /> value.
            </summary>
      <returns>An equivalent <see cref="T:System.TimeSpan" /> to this value.</returns>
    </member>
    <member name="M:NodaTime.Offset.FromTimeSpan(System.TimeSpan)">
      <summary>
            Converts the given <see cref="T:System.TimeSpan" /> to an offset, with fractional milliseconds truncated.
            </summary>
      <param name="timeSpan">The timespan to convert</param>
      <exception cref="T:System.ArgumentOutOfRangeException">The given time span falls outside the range of +/- 24 hours.</exception>
      <returns>A new offset for the same time as the given time span.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
    </member>
    <member name="M:NodaTime.Offset.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Private constructor only present for serialization.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to fetch data from.</param>
      <param name="context">The source for this deserialization.</param>
    </member>
    <member name="P:NodaTime.Offset.Milliseconds">
      <summary>
            Gets the total number of milliseconds in the offset, which may be negative.
            </summary>
    </member>
    <member name="P:NodaTime.Offset.Ticks">
      <summary>
            Returns the number of ticks represented by this offset, which may be negative.
            </summary>
      <remarks>
            Offsets are only accurate to millisecond precision; the number of milliseconds is simply multiplied
            by 10,000 to give the number of ticks.
            </remarks>
      <value>The number of ticks.</value>
    </member>
    <member name="T:NodaTime.LocalInstant">
      <summary>
            Represents a local date and time without reference to a calendar system,
            as the number of ticks since the Unix epoch which would represent that time
            of the same date in UTC. This needs a better description, and possibly a better name
            at some point...
            </summary>
    </member>
    <member name="M:NodaTime.LocalInstant.#ctor(System.Int64)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalInstant" /> struct.
            </summary>
      <param name="ticks">The number of ticks from the Unix Epoch.</param>
    </member>
    <member name="M:NodaTime.LocalInstant.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Convenience constructor for test purposes.
            </summary>
    </member>
    <member name="M:NodaTime.LocalInstant.ToDateTimeUnspecified">
      <summary>
            Constructs a <see cref="T:System.DateTime" /> from this LocalInstant which has a <see cref="P:System.DateTime.Kind" />
            of <see cref="F:System.DateTimeKind.Unspecified" /> and represents the same local date and time as this value.
            </summary>
      <remarks>
        <see cref="F:System.DateTimeKind.Unspecified" /> is slightly odd - it can be treated as UTC if you use <see cref="M:System.DateTime.ToLocalTime" />
            or as system local time if you use <see cref="M:System.DateTime.ToUniversalTime" />, but it's the only kind which allows
            you to construct a <see cref="T:System.DateTimeOffset" /> with an arbitrary offset, which makes it as close to
            the Noda Time non-system-specific "local" concept as exists in .NET.
            </remarks>
    </member>
    <member name="M:NodaTime.LocalInstant.FromDateTime(System.DateTime)">
      <summary>
            Converts a <see cref="T:System.DateTime" /> of any kind to a LocalDateTime in the ISO calendar. This does not perform
            any time zone conversions, so a DateTime with a <see cref="P:System.DateTime.Kind" /> of <see cref="F:System.DateTimeKind.Utc" />
            will still have the same day/hour/minute etc - it won't be converted into the local system time.
            </summary>
    </member>
    <member name="M:NodaTime.LocalInstant.op_Addition(NodaTime.LocalInstant,NodaTime.Duration)">
      <summary>
            Returns an instant after adding the given duration
            </summary>
    </member>
    <member name="M:NodaTime.LocalInstant.Add(NodaTime.LocalInstant,NodaTime.Duration)">
      <summary>
            Adds a duration to a local instant. Friendly alternative to <c>operator-()</c>.
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>A new <see cref="T:NodaTime.LocalInstant" /> representing the sum of the given values.</returns>
    </member>
    <member name="M:NodaTime.LocalInstant.op_Subtraction(NodaTime.LocalInstant,NodaTime.LocalInstant)">
      <summary>
            Returns the difference between two instants as a duration.
            </summary>
    </member>
    <member name="M:NodaTime.LocalInstant.Minus(NodaTime.Offset)">
      <summary>
            Subtracts the given time zone offset from this local instant, to give an <see cref="T:NodaTime.Instant" />.
            </summary>
      <remarks>
            This would normally be implemented as an operator, but as the corresponding "plus" operation
            on Instant cannot be written (as Instant is a public class and LocalInstant is an internal class)
            it makes sense to keep them both as methods for consistency.
            </remarks>
      <param name="offset">The offset between UTC and a time zone for this local instant</param>
      <returns>A new <see cref="T:NodaTime.Instant" /> representing the difference of the given values.</returns>
    </member>
    <member name="M:NodaTime.LocalInstant.op_Subtraction(NodaTime.LocalInstant,NodaTime.Duration)">
      <summary>
            Returns an instant after subtracting the given duration
            </summary>
    </member>
    <member name="M:NodaTime.LocalInstant.Subtract(NodaTime.LocalInstant,NodaTime.LocalInstant)">
      <summary>
            Subtracts one local instant from another. Friendly alternative to <c>operator-()</c>.
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>A new <see cref="T:NodaTime.Duration" /> representing the difference of the given values.</returns>
    </member>
    <member name="M:NodaTime.LocalInstant.Subtract(NodaTime.LocalInstant,NodaTime.Duration)">
      <summary>
            Subtracts a duration from a local instant. Friendly alternative to <c>operator-()</c>.
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>A new <see cref="T:NodaTime.LocalInstant" /> representing the difference of the given values.</returns>
    </member>
    <member name="M:NodaTime.LocalInstant.op_Equality(NodaTime.LocalInstant,NodaTime.LocalInstant)">
      <summary>
            Implements the operator == (equality).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.LocalInstant.op_Inequality(NodaTime.LocalInstant,NodaTime.LocalInstant)">
      <summary>
            Implements the operator != (inequality).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.LocalInstant.op_LessThan(NodaTime.LocalInstant,NodaTime.LocalInstant)">
      <summary>
            Implements the operator &lt; (less than).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if the left value is less than the right value, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.LocalInstant.op_LessThanOrEqual(NodaTime.LocalInstant,NodaTime.LocalInstant)">
      <summary>
            Implements the operator &lt;= (less than or equal).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if the left value is less than or equal to the right value, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.LocalInstant.op_GreaterThan(NodaTime.LocalInstant,NodaTime.LocalInstant)">
      <summary>
            Implements the operator &gt; (greater than).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if the left value is greater than the right value, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.LocalInstant.op_GreaterThanOrEqual(NodaTime.LocalInstant,NodaTime.LocalInstant)">
      <summary>
            Implements the operator &gt;= (greater than or equal).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if the left value is greater than or equal to the right value, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.LocalInstant.PlusTicks(System.Int64)">
      <summary>
            Convenience method to add the given number of ticks. Useful
            for assembling date and time parts.
            </summary>
    </member>
    <member name="M:NodaTime.LocalInstant.CompareTo(NodaTime.LocalInstant)">
      <summary>
            Compares the current object with another object of the same type.
            </summary>
      <param name="other">An object to compare with this object.</param>
      <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared.
            The return value has the following meanings:
            <list type="table"><listheader><term>Value</term><description>Meaning</description></listheader><item><term>&lt; 0</term><description>This object is less than the <paramref name="other" /> parameter.</description></item><item><term>0</term><description>This object is equal to <paramref name="other" />.</description></item><item><term>&gt; 0</term><description>This object is greater than <paramref name="other" />.</description></item></list></returns>
    </member>
    <member name="M:NodaTime.LocalInstant.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NodaTime.LocalInstant.GetHashCode">
      <summary>
            Returns a hash code for this instance.
            </summary>
      <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
    </member>
    <member name="M:NodaTime.LocalInstant.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="M:NodaTime.LocalInstant.Equals(NodaTime.LocalInstant)">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <param name="other">An object to compare with this object.</param>
      <returns>
            true if the current object is equal to the <paramref name="other" /> parameter;
            otherwise, false.
            </returns>
    </member>
    <member name="P:NodaTime.LocalInstant.Ticks">
      <summary>
            Ticks since the Unix epoch.
            </summary>
    </member>
    <member name="T:NodaTime.Period">
      <summary>
            Represents a period of time expressed in human chronological terms: hours, days,
            weeks, months and so on.
            </summary>
      <remarks>
        <para>
            A <see cref="T:NodaTime.Period" /> contains a set of properties such as <see cref="P:NodaTime.Period.Years" />, <see cref="P:NodaTime.Period.Months" />, and so on
            that return the number of each unit contained within this period. Note that these properties are not normalized in
            any way by default, and so a <see cref="T:NodaTime.Period" /> may contain values such as "2 hours and 90 minutes". The
            <see cref="M:NodaTime.Period.Normalize" /> method will convert equivalent periods into a standard representation.
            </para>
        <para>
            Periods can contain negative units as well as positive units ("+2 hours, -43 minutes, +10 seconds"), but do not
            differentiate between properties that are zero and those that are absent (i.e. a period created as "10 years"
            and one created as "10 years, zero months" are equal periods; the <see cref="P:NodaTime.Period.Months" /> property returns zero in
            both cases).
            </para>
        <para>
          <see cref="T:NodaTime.Period" /> equality is implemented by comparing each property's values individually.
            </para>
        <para>
            Periods operate on calendar-related types such as
            <see cref="T:NodaTime.LocalDateTime" /> whereas <see cref="T:NodaTime.Duration" /> operates on instants
            on the time line. (Note that although <see cref="T:NodaTime.ZonedDateTime" /> includes both concepts, it only supports
            duration-based arithmetic.)
            </para>
      </remarks>
      <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="T:NodaTime.Period.NormalizingPeriodEqualityComparer">
      <summary>
            Equality comparer which simply normalizes periods before comparing them.
            </summary>
    </member>
    <member name="F:NodaTime.Period.ValuesArraySize">
      <summary>
            In some cases, periods are represented as <c>long[]</c> arrays containing all possible units (years to
            ticks). This is the size of those arrays.
            </summary>
    </member>
    <member name="F:NodaTime.Period.Zero">
      <summary>
            A period containing only zero-valued properties.
            </summary>
    </member>
    <member name="M:NodaTime.Period.#ctor(System.Int64[])">
      <summary>
            Creates a new period from the given array.
            </summary>
      <param name="values">Values for each field</param>
    </member>
    <member name="M:NodaTime.Period.#ctor(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
      <summary>
            Creates a new period from the given values.
            </summary>
    </member>
    <member name="M:NodaTime.Period.#ctor(NodaTime.PeriodUnits,System.Int64)">
      <summary>
            Creates a new period with the given single value.
            </summary>
    </member>
    <member name="M:NodaTime.Period.FromYears(System.Int64)">
      <summary>
            Creates a period representing the specified number of years.
            </summary>
      <param name="years">The number of years in the new period</param>
      <returns>A period consisting of the given number of years.</returns>
    </member>
    <member name="M:NodaTime.Period.FromWeeks(System.Int64)">
      <summary>
            Creates a period representing the specified number of weeks.
            </summary>
      <param name="weeks">The number of weeks in the new period</param>
      <returns>A period consisting of the given number of weeks.</returns>
    </member>
    <member name="M:NodaTime.Period.FromMonths(System.Int64)">
      <summary>
            Creates a period representing the specified number of months.
            </summary>
      <param name="months">The number of months in the new period</param>
      <returns>A period consisting of the given number of months.</returns>
    </member>
    <member name="M:NodaTime.Period.FromDays(System.Int64)">
      <summary>
            Creates a period representing the specified number of days.
            </summary>
      <param name="days">The number of days in the new period</param>
      <returns>A period consisting of the given number of days.</returns>
    </member>
    <member name="M:NodaTime.Period.FromHours(System.Int64)">
      <summary>
            Creates a period representing the specified number of hours.
            </summary>
      <param name="hours">The number of hours in the new period</param>
      <returns>A period consisting of the given number of hours.</returns>
    </member>
    <member name="M:NodaTime.Period.FromMinutes(System.Int64)">
      <summary>
            Creates a period representing the specified number of minutes.
            </summary>
      <param name="minutes">The number of minutes in the new period</param>
      <returns>A period consisting of the given number of minutes.</returns>
    </member>
    <member name="M:NodaTime.Period.FromSeconds(System.Int64)">
      <summary>
            Creates a period representing the specified number of seconds.
            </summary>
      <param name="seconds">The number of seconds in the new period</param>
      <returns>A period consisting of the given number of seconds.</returns>
    </member>
    <member name="M:NodaTime.Period.FromMillseconds(System.Int64)">
      <summary>
            Creates a period representing the specified number of milliseconds.
            </summary>
      <remarks>This method is not available in the PCL version, as it was made obsolete in Noda Time 1.1.</remarks>
      <param name="milliseconds">The number of milliseconds in the new period</param>
      <returns>A period consisting of the given number of milliseconds.</returns>
    </member>
    <member name="M:NodaTime.Period.FromMilliseconds(System.Int64)">
      <summary>
            Creates a period representing the specified number of milliseconds.
            </summary>
      <param name="milliseconds">The number of milliseconds in the new period</param>
      <returns>A period consisting of the given number of milliseconds.</returns>
    </member>
    <member name="M:NodaTime.Period.FromTicks(System.Int64)">
      <summary>
            Creates a period representing the specified number of ticks.
            </summary>
      <param name="ticks">The number of ticks in the new period</param>
      <returns>A period consisting of the given number of ticks.</returns>
    </member>
    <member name="M:NodaTime.Period.op_Addition(NodaTime.Period,NodaTime.Period)">
      <summary>
            Adds two periods together, by simply adding the values for each property.
            </summary>
      <param name="left">The first period to add</param>
      <param name="right">The second period to add</param>
      <returns>The sum of the two periods. The units of the result will be the union of those in both
            periods.</returns>
    </member>
    <member name="M:NodaTime.Period.CreateComparer(NodaTime.LocalDateTime)">
      <summary>
            Creates an <see cref="T:System.Collections.Generic.IComparer`1" /> for periods, using the given "base" local date/time.
            </summary>
      <remarks>
            Certain periods can't naturally be compared without more context - how "one month" compares to
            "30 days" depends on where you start. In order to compare two periods, the returned comparer
            effectively adds both periods to the "base" specified by <paramref name="baseDateTime" /> and compares
            the results. In some cases this arithmetic isn't actually required - when two periods can be
            converted to durations, the comparer uses that conversion for efficiency.
            </remarks>
      <param name="baseDateTime">The base local date/time to use for comparisons.</param>
      <returns>The new comparer.</returns>
    </member>
    <member name="M:NodaTime.Period.ToArray">
      <summary>
            Returns the property values in this period as an array.
            </summary>
    </member>
    <member name="M:NodaTime.Period.AddValuesTo(System.Int64[])">
      <summary>
            Adds all the values in this period to the given array of values (which is assumed to be of the right
            length).
            </summary>
    </member>
    <member name="M:NodaTime.Period.SubtractValuesFrom(System.Int64[])">
      <summary>
            Subtracts all the values in this period from the given array of values (which is assumed to be of the right
            length).
            </summary>
    </member>
    <member name="M:NodaTime.Period.op_Subtraction(NodaTime.Period,NodaTime.Period)">
      <summary>
            Subtracts one period from another, by simply subtracting each property value.
            </summary>
      <param name="minuend">The period to subtract the second operand from</param>
      <param name="subtrahend">The period to subtract the first operand from</param>
      <returns>The result of subtracting all the values in the second operand from the values in the first. The
            units of the result will be the union of both periods, even if the subtraction caused some properties to
            become zero (so "2 weeks, 1 days" minus "2 weeks" is "zero weeks, 1 days", not "1 days").</returns>
    </member>
    <member name="M:NodaTime.Period.Between(NodaTime.LocalDateTime,NodaTime.LocalDateTime,NodaTime.PeriodUnits)">
      <summary>
            Returns the period between a start and an end date/time, using only the given units.
            </summary>
      <remarks>
            If <paramref name="end" /> is before <paramref name="start" />, each property in the returned period
            will be negative. If the given set of units cannot exactly reach the end point (e.g. finding
            the difference between 1am and 3:15am in hours) the result will be such that adding it to <paramref name="start" />
            will give a value between <paramref name="start" /> and <paramref name="end" />. In other words,
            any rounding is "towards start"; this is true whether the resulting period is negative or positive.
            </remarks>
      <param name="start">Start date/time</param>
      <param name="end">End date/time</param>
      <param name="units">Units to use for calculations</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="units" /> is empty or contained unknown values.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="start" /> and <paramref name="end" /> use different calendars.</exception>
      <returns>The period between the given date/times, using the given units.</returns>
    </member>
    <member name="M:NodaTime.Period.AddTo(NodaTime.LocalInstant,NodaTime.CalendarSystem,System.Int32)">
      <summary>
            Adds the contents of this period to the given local instant in the given calendar system.
            </summary>
    </member>
    <member name="M:NodaTime.Period.Between(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
      <summary>
            Returns the exact difference between two date/times.
            </summary>
      <remarks>
            If <paramref name="end" /> is before <paramref name="start" />, each property in the returned period
            will be negative.
            </remarks>
      <param name="start">Start date/time</param>
      <param name="end">End date/time</param>
      <returns>The period between the two date and time values, using all units.</returns>
    </member>
    <member name="M:NodaTime.Period.Between(NodaTime.LocalDate,NodaTime.LocalDate,NodaTime.PeriodUnits)">
      <summary>
            Returns the period between a start and an end date, using only the given units.
            </summary>
      <remarks>
            If <paramref name="end" /> is before <paramref name="start" />, each property in the returned period
            will be negative. If the given set of units cannot exactly reach the end point (e.g. finding
            the difference between 12th February and 15th March in months) the result will be such that adding it to <paramref name="start" />
            will give a value between <paramref name="start" /> and <paramref name="end" />. In other words,
            any rounding is "towards start"; this is true whether the resulting period is negative or positive.
            </remarks>
      <param name="start">Start date</param>
      <param name="end">End date</param>
      <param name="units">Units to use for calculations</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="units" /> contains time units, is empty or contains unknown values.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="start" /> and <paramref name="end" /> use different calendars.</exception>
      <returns>The period between the given dates, using the given units.</returns>
    </member>
    <member name="M:NodaTime.Period.Between(NodaTime.LocalDate,NodaTime.LocalDate)">
      <summary>
            Returns the exact difference between two dates.
            </summary>
      <remarks>
            If <paramref name="end" /> is before <paramref name="start" />, each property in the returned period
            will be negative.
            </remarks>
      <param name="start">Start date</param>
      <param name="end">End date</param>
      <returns>The period between the two dates, using year, month and day units.</returns>
    </member>
    <member name="M:NodaTime.Period.Between(NodaTime.LocalTime,NodaTime.LocalTime,NodaTime.PeriodUnits)">
      <summary>
            Returns the period between a start and an end time, using only the given units.
            </summary>
      <remarks>
            If <paramref name="end" /> is before <paramref name="start" />, each property in the returned period
            will be negative. If the given set of units cannot exactly reach the end point (e.g. finding
            the difference between 3am and 4.30am in hours) the result will be such that adding it to <paramref name="start" />
            will give a value between <paramref name="start" /> and <paramref name="end" />. In other words,
            any rounding is "towards start"; this is true whether the resulting period is negative or positive.
            </remarks>
      <param name="start">Start time</param>
      <param name="end">End time</param>
      <param name="units">Units to use for calculations</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="units" /> contains date units, is empty or contains unknown values.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="start" /> and <paramref name="end" /> use different calendars.</exception>
      <returns>The period between the given times, using the given units.</returns>
    </member>
    <member name="M:NodaTime.Period.Between(NodaTime.LocalTime,NodaTime.LocalTime)">
      <summary>
            Returns the exact difference between two times.
            </summary>
      <remarks>
            If <paramref name="end" /> is before <paramref name="start" />, each property in the returned period
            will be negative.
            </remarks>
      <param name="start">Start time</param>
      <param name="end">End time</param>
      <returns>The period between the two times, using the time period units.</returns>
    </member>
    <member name="M:NodaTime.Period.ToDuration">
      <summary>
            For periods that do not contain a non-zero number of years or months, returns a duration for this period
            assuming a standard 7-day week, 24-hour day, 60-minute hour etc.
            </summary>
      <exception cref="T:System.InvalidOperationException">The month or year property in the period is non-zero.</exception>
      <exception cref="T:System.OverflowException">The period doesn't have years or months, but the calculation
            overflows the bounds of <see cref="T:NodaTime.Duration" />. In some cases this may occur even though the theoretical
            result would be valid due to balancing positive and negative values, but for simplicity there is
            no attempt to work around this - in realistic periods, it shouldn't be a problem.</exception>
      <returns>The duration of the period.</returns>
    </member>
    <member name="M:NodaTime.Period.ToBuilder">
      <summary>
            Creates a <see cref="T:NodaTime.PeriodBuilder" /> from this instance. The new builder
            is populated with the values from this period, but is then detached from it:
            changes made to the builder are not reflected in this period.
            </summary>
      <returns>A builder with the same values and units as this period.</returns>
    </member>
    <member name="M:NodaTime.Period.Normalize">
      <summary>
            Returns a normalized version of this period, such that equivalent (but potentially non-equal) periods are
            changed to the same representation.
            </summary>
      <remarks>
            Months and years are unchanged
            (as they can vary in length), but weeks are multiplied by 7 and added to the
            Days property, and all time properties are normalized to their natural range
            (where ticks are "within a millisecond"), adding to the larger property where
            necessary. So for example, a period of 25 hours becomes a period of 1 day
            and 1 hour. Aside from months and years, either all the properties
            end up positive, or they all end up negative.
            </remarks>
      <exception cref="T:System.OverflowException">The period doesn't have years or months, but it contains more than
            <see cref="F:System.Int64.MaxValue" /> ticks when the combined weeks/days/time portions are considered. Such a period
            could never be useful anyway, however.
            In some cases this may occur even though the theoretical result would be valid due to balancing positive and
            negative values, but for simplicity there is no attempt to work around this - in realistic periods, it
            shouldn't be a problem.</exception>
      <returns>The normalized period.</returns>
      <seealso cref="P:NodaTime.Period.NormalizingEqualityComparer" />
    </member>
    <member name="M:NodaTime.Period.GetSingleField(NodaTime.Fields.PeriodFieldSet,NodaTime.PeriodUnits)">
      <summary>
            Returns the PeriodField for the given unit value, or null if the values does
            not represent a single unit.
            </summary>
    </member>
    <member name="M:NodaTime.Period.GetFieldForIndex(NodaTime.Fields.PeriodFieldSet,System.Int32)">
      <summary>
            Returns the PeriodField for the given index, in the range 0-8 inclusive.
            </summary>
    </member>
    <member name="M:NodaTime.Period.ToString">
      <summary>
            Returns this string formatted according to the <see cref="F:NodaTime.Text.PeriodPattern.RoundtripPattern" />.
            </summary>
      <returns>A formatted representation of this period.</returns>
    </member>
    <member name="M:NodaTime.Period.Equals(System.Object)">
      <summary>
            Compares the given object for equality with this one, as per <see cref="M:NodaTime.Period.Equals(NodaTime.Period)" />.
            </summary>
      <param name="other">The value to compare this one with.</param>
      <returns>true if the other object is a period equal to this one, consistent with <see cref="M:NodaTime.Period.Equals(NodaTime.Period)" /></returns>
    </member>
    <member name="M:NodaTime.Period.GetHashCode">
      <summary>
            Returns the hash code for this period, consistent with <see cref="M:NodaTime.Period.Equals(NodaTime.Period)" />.
            </summary>
      <returns>The hash code for this period.</returns>
    </member>
    <member name="M:NodaTime.Period.Equals(NodaTime.Period)">
      <summary>
            Compares the given period for equality with this one.
            </summary>
      <remarks>
            Periods are equal if they contain the same values for the same properties.
            However, no normalization takes place, so "one hour" is not equal to "sixty minutes".
            </remarks>
      <param name="other">The period to compare this one with.</param>
      <returns>True if this period has the same values for the same properties as the one specified.</returns>
    </member>
    <member name="M:NodaTime.Period.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Private constructor only present for serialization.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to fetch data from.</param>
      <param name="context">The source for this deserialization.</param>
    </member>
    <member name="P:NodaTime.Period.NormalizingEqualityComparer">
      <summary>
            Returns an equality comparer which compares periods by first normalizing them - so 24 hours is deemed equal to 1 day, and so on.
            Note that as per the <see cref="M:NodaTime.Period.Normalize" /> method, years and months are unchanged by normalization - so 12 months does not
            equal 1 year.
            </summary>
    </member>
    <member name="P:NodaTime.Period.HasTimeComponent">
      <summary>
            Returns whether or not this period contains any non-zero-valued time-based properties (hours or lower).
            </summary>
    </member>
    <member name="P:NodaTime.Period.HasDateComponent">
      <summary>
            Returns whether or not this period contains any non-zero date-based properties (days or higher).
            </summary>
    </member>
    <member name="P:NodaTime.Period.TotalStandardTicks">
      <summary>
            Gets the total number of ticks duration for the 'standard' properties (all bar years and months).
            </summary>
    </member>
    <member name="P:NodaTime.Period.Years">
      <summary>
            Gets the number of years within this period.
            </summary>
      <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
    </member>
    <member name="P:NodaTime.Period.Months">
      <summary>
            Gets the number of months within this period.
            </summary>
      <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
    </member>
    <member name="P:NodaTime.Period.Weeks">
      <summary>
            Gets the number of weeks within this period.
            </summary>
      <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
    </member>
    <member name="P:NodaTime.Period.Days">
      <summary>
            Gets the number of days within this period.
            </summary>
      <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
    </member>
    <member name="P:NodaTime.Period.Hours">
      <summary>
            Gets the number of hours within this period.
            </summary>
      <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
    </member>
    <member name="P:NodaTime.Period.Minutes">
      <summary>
            Gets the number of minutes within this period.
            </summary>
      <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
    </member>
    <member name="P:NodaTime.Period.Seconds">
      <summary>
            Gets the number of seconds within this period.
            </summary>
      <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
    </member>
    <member name="P:NodaTime.Period.Milliseconds">
      <summary>
            Gets the number of milliseconds within this period.
            </summary>
      <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
    </member>
    <member name="P:NodaTime.Period.Ticks">
      <summary>
            Gets the number of ticks within this period.
            </summary>
      <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
    </member>
    <member name="T:NodaTime.SkippedTimeException">
      <summary>
            Exception thrown to indicate that the specified local time doesn't
            exist in a particular time zone due to daylight saving time changes.    
            </summary>
      <remarks>
        <para>
            This normally occurs for spring transitions, where the clock goes forward
            (usually by an hour). For example, suppose the time zone goes forward
            at 2am, so the second after 01:59:59 becomes 03:00:00. In that case,
            local times such as 02:30:00 never occur.
            </para>
        <para>
            This exception is used to indicate such problems, as they're usually
            not the same as other <see cref="T:System.ArgumentOutOfRangeException" /> causes,
            such as entering "15" for a month number.
            </para>
        <para>
            Note that it is possible (though extremely rare) for a whole day to be skipped due to a time zone transition,
            so this exception may also be thrown in cases where no local time is valid for a particular local date. (For
            example, Samoa skipped December 30th 2011 entirely, transitioning from UTC-10 to UTC+14 at midnight.)
            </para>
      </remarks>
      <threadsafety>Any public static members of this type are thread safe. Any instance members are not guaranteed to be thread safe.
            See the thread safety section of the user guide for more information.
            </threadsafety>
    </member>
    <member name="M:NodaTime.SkippedTimeException.#ctor(NodaTime.LocalDateTime,NodaTime.DateTimeZone)">
      <summary>
            Creates a new instance for the given local date/time and time zone.
            </summary>
      <remarks>
            User code is unlikely to need to deliberately call this constructor except
            possibly for testing.
            </remarks>
      <param name="localDateTime">The local date/time which is skipped in the specified time zone.</param>
      <param name="zone">The time zone in which the local date/time does not exist.</param>
    </member>
    <member name="P:NodaTime.SkippedTimeException.LocalDateTime">
      <summary>
            The local date/time which is invalid in the time zone
            </summary>
    </member>
    <member name="P:NodaTime.SkippedTimeException.Zone">
      <summary>
            The time zone in which the local date/time is invalid
            </summary>
    </member>
    <member name="T:NodaTime.SystemClock">
      <summary>
            Singleton implementation of <see cref="T:NodaTime.IClock" /> which reads the current system time.
            It is recommended that for anything other than throwaway code, this is only referenced
            in a single place in your code: where you provide a value to inject into the rest of
            your application, which should only depend on the interface.
            </summary>
      <threadsafety>This type has no state, and is thread-safe. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="F:NodaTime.SystemClock.Instance">
      <summary>
            The singleton instance of <see cref="T:NodaTime.SystemClock" />.
            </summary>
      <value>The singleton instance of <see cref="T:NodaTime.SystemClock" />.</value>
    </member>
    <member name="M:NodaTime.SystemClock.#ctor">
      <summary>
            Constructor present to prevent external construction.
            </summary>
    </member>
    <member name="P:NodaTime.SystemClock.Now">
      <summary>
            Gets the current time as an <see cref="T:NodaTime.Instant" />.
            </summary>
      <value>The current time in ticks as an <see cref="T:NodaTime.Instant" />.</value>
    </member>
    <member name="T:NodaTime.LocalDateTime">
      <summary>
            A date and time in a particular calendar system. A LocalDateTime value does not represent an
            instant on the time line, because it has no associated time zone: "November 12th 2009 7pm, ISO calendar"
            occurred at different instants for different people around the world.
            </summary>
      <remarks>
        <para>
            This type defaults to using the IsoCalendarSystem unless a different calendar system is
            specified.
            </para>
        <para>Comparisons of values can be handled in a way which is either calendar-sensitive or calendar-insensitive.
            Noda Time implements all the operators (and the <see cref="M:NodaTime.LocalDateTime.Equals(NodaTime.LocalDateTime)" /> method) such that all operators other than <see cref="M:NodaTime.LocalDateTime.op_Inequality(NodaTime.LocalDateTime,NodaTime.LocalDateTime)" />
            will return false if asked to compare two values in different calendar systems.
            </para>
        <para>
            However, the <see cref="M:NodaTime.LocalDateTime.CompareTo(NodaTime.LocalDateTime)" /> method (implementing <see cref="T:System.IComparable`1" />) is calendar-insensitive; it compares the two
            values historically in terms of when they actually occurred, as if they're both converted to some "neutral" calendar system first.
            </para>
        <para>
            It's unclear at the time of this writing whether this is the most appropriate approach, and it may change in future versions. In general,
            it would be a good idea for users to avoid comparing dates in different calendar systems, and indeed most users are unlikely to ever explicitly
            consider which calendar system they're working in anyway.
            </para>
      </remarks>
      <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="M:NodaTime.LocalDateTime.#ctor(NodaTime.LocalInstant)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime" /> struct using the ISO
            calendar system.
            </summary>
      <param name="localInstant">The local instant.</param>
      <returns>The resulting date/time.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.#ctor(NodaTime.LocalInstant,NodaTime.CalendarSystem)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime" /> struct.
            </summary>
      <param name="localInstant">The local instant.</param>
      <param name="calendar">The calendar system.</param>
      <returns>The resulting date/time.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime" /> struct using the ISO calendar system.
            </summary>
      <param name="year">The year. This is the "absolute year",
            so a value of 0 means 1 BC, for example.</param>
      <param name="month">The month of year.</param>
      <param name="day">The day of month.</param>
      <param name="hour">The hour.</param>
      <param name="minute">The minute.</param>
      <returns>The resulting date/time.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date/time.</exception>
    </member>
    <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime" /> struct.
            </summary>
      <param name="year">The year. This is the "absolute year", so, for
            the ISO calendar, a value of 0 means 1 BC, for example.</param>
      <param name="month">The month of year.</param>
      <param name="day">The day of month.</param>
      <param name="hour">The hour.</param>
      <param name="minute">The minute.</param>
      <param name="calendar">The calendar.</param>
      <returns>The resulting date/time.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date/time.</exception>
    </member>
    <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime" /> struct using the ISO calendar system.
            </summary>
      <param name="year">The year. This is the "absolute year",
            so a value of 0 means 1 BC, for example.</param>
      <param name="month">The month of year.</param>
      <param name="day">The day of month.</param>
      <param name="hour">The hour.</param>
      <param name="minute">The minute.</param>
      <param name="second">The second.</param>
      <returns>The resulting date/time.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date/time.</exception>
    </member>
    <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime" /> struct.
            </summary>
      <param name="year">The year. This is the "absolute year", so, for
            the ISO calendar, a value of 0 means 1 BC, for example.</param>
      <param name="month">The month of year.</param>
      <param name="day">The day of month.</param>
      <param name="hour">The hour.</param>
      <param name="minute">The minute.</param>
      <param name="second">The second.</param>
      <param name="calendar">The calendar.</param>
      <returns>The resulting date/time.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date/time.</exception>
    </member>
    <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime" /> struct using the ISO calendar system.
            </summary>
      <param name="year">The year. This is the "absolute year",
            so a value of 0 means 1 BC, for example.</param>
      <param name="month">The month of year.</param>
      <param name="day">The day of month.</param>
      <param name="hour">The hour.</param>
      <param name="minute">The minute.</param>
      <param name="second">The second.</param>
      <param name="millisecond">The millisecond.</param>
      <returns>The resulting date/time.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date/time.</exception>
    </member>
    <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime" /> struct.
            </summary>
      <param name="year">The year. This is the "absolute year", so, for
            the ISO calendar, a value of 0 means 1 BC, for example.</param>
      <param name="month">The month of year.</param>
      <param name="day">The day of month.</param>
      <param name="hour">The hour.</param>
      <param name="minute">The minute.</param>
      <param name="second">The second.</param>
      <param name="millisecond">The millisecond.</param>
      <param name="calendar">The calendar.</param>
      <returns>The resulting date/time.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date/time.</exception>
    </member>
    <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime" /> struct.
            </summary>
      <param name="year">The year. This is the "absolute year",
            so a value of 0 means 1 BC, for example.</param>
      <param name="month">The month of year.</param>
      <param name="day">The day of month.</param>
      <param name="hour">The hour.</param>
      <param name="minute">The minute.</param>
      <param name="second">The second.</param>
      <param name="millisecond">The millisecond.</param>
      <param name="tickWithinMillisecond">The tick within millisecond.</param>
      <returns>The resulting date/time.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date/time.</exception>
    </member>
    <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime" /> struct.
            </summary>
      <param name="year">The year. This is the "absolute year", so, for
            the ISO calendar, a value of 0 means 1 BC, for example.</param>
      <param name="month">The month of year.</param>
      <param name="day">The day of month.</param>
      <param name="hour">The hour.</param>
      <param name="minute">The minute.</param>
      <param name="second">The second.</param>
      <param name="millisecond">The millisecond.</param>
      <param name="tickWithinMillisecond">The tick within millisecond.</param>
      <param name="calendar">The calendar.</param>
      <returns>The resulting date/time.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date/time.</exception>
    </member>
    <member name="M:NodaTime.LocalDateTime.ToDateTimeUnspecified">
      <summary>
            Constructs a <see cref="T:System.DateTime" /> from this value which has a <see cref="P:System.DateTime.Kind" />
            of <see cref="F:System.DateTimeKind.Unspecified" />.
            </summary>
      <remarks>
        <see cref="F:System.DateTimeKind.Unspecified" /> is slightly odd - it can be treated as UTC if you use <see cref="M:System.DateTime.ToLocalTime" />
            or as system local time if you use <see cref="M:System.DateTime.ToUniversalTime" />, but it's the only kind which allows
            you to construct a <see cref="T:System.DateTimeOffset" /> with an arbitrary offset, which makes it as close to
            the Noda Time non-system-specific "local" concept as exists in .NET.
            </remarks>
      <returns>A <see cref="T:System.DateTime" /> value for the same date and time as this value.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.FromDateTime(System.DateTime)">
      <summary>
            Converts a <see cref="T:System.DateTime" /> of any kind to a LocalDateTime in the ISO calendar. This does not perform
            any time zone conversions, so a DateTime with a <see cref="P:System.DateTime.Kind" /> of <see cref="F:System.DateTimeKind.Utc" />
            will still have the same day/hour/minute etc - it won't be converted into the local system time.
            </summary>
      <param name="dateTime">Value to convert into a Noda Time local date and time</param>
      <returns>A new <see cref="T:NodaTime.LocalDateTime" /> with the same values as the specified <c>DateTime</c>.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.Equals(NodaTime.LocalDateTime)">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <param name="other">An object to compare with this object.</param>
      <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.op_Equality(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
      <summary>
            Implements the operator == (equality).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.op_Inequality(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
      <summary>
            Implements the operator != (inequality).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.op_LessThan(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
      <summary>
            Compares two LocalDateTime values to see if the left one is strictly earlier than the right
            one.
            </summary>
      <remarks>
            This operator always returns false if the two operands have different calendars. See the top-level type
            documentation for more information about comparisons.
            </remarks>
      <param name="lhs">First operand of the comparison</param>
      <param name="rhs">Second operand of the comparison</param>
      <returns>true if the <paramref name="lhs" /> is strictly earlier than <paramref name="rhs" />, false otherwise.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.op_LessThanOrEqual(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
      <summary>
            Compares two LocalDateTime values to see if the left one is earlier than or equal to the right
            one.
            </summary>
      <remarks>
            This operator always returns false if the two operands have different calendars. See the top-level type
            documentation for more information about comparisons.
            </remarks>
      <param name="lhs">First operand of the comparison</param>
      <param name="rhs">Second operand of the comparison</param>
      <returns>true if the <paramref name="lhs" /> is earlier than or equal to <paramref name="rhs" />, false otherwise.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.op_GreaterThan(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
      <summary>
            Compares two LocalDateTime values to see if the left one is strictly later than the right
            one.
            </summary>
      <remarks>
            This operator always returns false if the two operands have different calendars. See the top-level type
            documentation for more information about comparisons.
            </remarks>
      <param name="lhs">First operand of the comparison</param>
      <param name="rhs">Second operand of the comparison</param>
      <returns>true if the <paramref name="lhs" /> is strictly later than <paramref name="rhs" />, false otherwise.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.op_GreaterThanOrEqual(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
      <summary>
            Compares two LocalDateTime values to see if the left one is later than or equal to the right
            one.
            </summary>
      <remarks>
            This operator always returns false if the two operands have different calendars. See the top-level type
            documentation for more information about comparisons.
            </remarks>
      <param name="lhs">First operand of the comparison</param>
      <param name="rhs">Second operand of the comparison</param>
      <returns>true if the <paramref name="lhs" /> is later than or equal to <paramref name="rhs" />, false otherwise.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.CompareTo(NodaTime.LocalDateTime)">
      <summary>
            Indicates whether this date/time is earlier, later or the same as another one.
            </summary>
      <remarks>
            The comparison is performed in terms of a calendar-independent notion of dates and times;
            the calendar systems of both <see cref="T:NodaTime.LocalDateTime" /> values are ignored. When both values use the same calendar,
            this is absolutely natural. However, when comparing a value in one calendar with a value in another,
            this can lead to surprising results. For example, 1945 in the ISO calendar corresponds to around 1364
            in the Islamic calendar, so an Islamic date in year 1400 is "after" a date in 1945 in the ISO calendar.
            </remarks>
      <param name="other">The other local date/time to compare with this value.</param>
      <returns>A value less than zero if this date/time is earlier than <paramref name="other" />;
            zero if this date/time is the same as <paramref name="other" />; a value greater than zero if this date/time is
            later than <paramref name="other" />.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.op_Addition(NodaTime.LocalDateTime,NodaTime.Period)">
      <summary>
            Adds a period to a local date/time. Fields are added in the order provided by the period.
            This is a convenience operator over the <see cref="M:NodaTime.LocalDateTime.Plus(NodaTime.Period)" /> method.
            </summary>
      <param name="localDateTime">Initial local date and time</param>
      <param name="period">Period to add</param>
      <returns>The resulting local date and time</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.Add(NodaTime.LocalDateTime,NodaTime.Period)">
      <summary>
            Add the specified period to the date and time. Friendly alternative to <c>operator+()</c>.
            </summary>
      <param name="localDateTime">Initial local date and time</param>
      <param name="period">Period to add</param>
      <returns>The resulting local date and time</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.Plus(NodaTime.Period)">
      <summary>
            Adds a period to this local date/time. Fields are added in the order provided by the period.
            </summary>
      <param name="period">Period to add</param>
      <returns>The resulting local date and time</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.op_Subtraction(NodaTime.LocalDateTime,NodaTime.Period)">
      <summary>
            Subtracts a period from a local date/time. Fields are subtracted in the order provided by the period.
            This is a convenience operator over the <see cref="M:NodaTime.LocalDateTime.Minus(NodaTime.Period)" /> method.
            </summary>
      <param name="localDateTime">Initial local date and time</param>
      <param name="period">Period to subtract</param>
      <returns>The resulting local date and time</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.Subtract(NodaTime.LocalDateTime,NodaTime.Period)">
      <summary>
            Subtracts the specified period from the date and time. Friendly alternative to <c>operator-()</c>.
            </summary>
      <param name="localDateTime">Initial local date and time</param>
      <param name="period">Period to subtract</param>
      <returns>The resulting local date and time</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.Minus(NodaTime.Period)">
      <summary>
            Subtracts a period from a local date/time. Fields are subtracted in the order provided by the period.
            This is a convenience operator over the <see cref="M:NodaTime.LocalDateTime.Minus(NodaTime.Period)" /> method.
            </summary>
      <param name="period">Period to subtract</param>
      <returns>The resulting local date and time</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.GetHashCode">
      <summary>
            Returns a hash code for this instance.
            </summary>
      <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.WithCalendar(NodaTime.CalendarSystem)">
      <summary>
            Creates a new LocalDateTime representing the same physical date and time, but in a different calendar.
            The returned LocalDateTime is likely to have different date field values to this one.
            For example, January 1st 1970 in the Gregorian calendar was December 19th 1969 in the Julian calendar.
            </summary>
      <param name="calendarSystem">The calendar system to convert this local date to.</param>
      <returns>The converted LocalDateTime.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.PlusYears(System.Int32)">
      <summary>
            Returns a new LocalDateTime representing the current value with the given number of years added.
            </summary>
      <remarks>
            If the resulting date is invalid, lower fields (typically the day of month) are reduced to find a valid value.
            For example, adding one year to February 29th 2012 will return February 28th 2013; subtracting one year from
            February 29th 2012 will return February 28th 2011.
            </remarks>
      <param name="years">The number of years to add</param>
      <returns>The current value plus the given number of years.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.PlusMonths(System.Int32)">
      <summary>
            Returns a new LocalDateTime representing the current value with the given number of months added.
            </summary>
      <remarks>
        <para>
            This method does not try to maintain the year of the current value, so adding four months to a value in 
            October will result in a value in the following February.
            </para>
        <para>
            If the resulting date is invalid, the day of month is reduced to find a valid value.
            For example, adding one month to January 30th 2011 will return February 28th 2011; subtracting one month from
            March 30th 2011 will return February 28th 2011.
            </para>
      </remarks>
      <param name="months">The number of months to add</param>
      <returns>The current value plus the given number of months.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.PlusDays(System.Int32)">
      <summary>
            Returns a new LocalDateTime representing the current value with the given number of days added.
            </summary>
      <remarks>
        <para>
            This method does not try to maintain the month or year of the current value, so adding 3 days to a value on January 30th
            will result in a value on February 2nd.
            </para>
      </remarks>
      <param name="days">The number of days to add</param>
      <returns>The current value plus the given number of days.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.PlusWeeks(System.Int32)">
      <summary>
            Returns a new LocalDateTime representing the current value with the given number of weeks added.
            </summary>
      <param name="weeks">The number of weeks to add</param>
      <returns>The current value plus the given number of weeks.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.PlusHours(System.Int64)">
      <summary>
            Returns a new LocalDateTime representing the current value with the given number of hours added.
            </summary>
      <param name="hours">The number of hours to add</param>
      <returns>The current value plus the given number of hours.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.PlusMinutes(System.Int64)">
      <summary>
            Returns a new LocalDateTime representing the current value with the given number of minutes added.
            </summary>
      <param name="minutes">The number of minutes to add</param>
      <returns>The current value plus the given number of minutes.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.PlusSeconds(System.Int64)">
      <summary>
            Returns a new LocalDateTime representing the current value with the given number of seconds added.
            </summary>
      <param name="seconds">The number of seconds to add</param>
      <returns>The current value plus the given number of seconds.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.PlusMilliseconds(System.Int64)">
      <summary>
            Returns a new LocalDateTime representing the current value with the given number of milliseconds added.
            </summary>
      <param name="milliseconds">The number of milliseconds to add</param>
      <returns>The current value plus the given number of milliseconds.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.PlusTicks(System.Int64)">
      <summary>
            Returns a new LocalDateTime representing the current value with the given number of ticks added.
            </summary>
      <param name="ticks">The number of ticks to add</param>
      <returns>The current value plus the given number of ticks.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.Next(NodaTime.IsoDayOfWeek)">
      <summary>
            Returns the next <see cref="T:NodaTime.LocalDateTime" /> falling on the specified <see cref="P:NodaTime.LocalDateTime.IsoDayOfWeek" />,
            at the same time of day as this value.
            This is a strict "next" - if this value on already falls on the target
            day of the week, the returned value will be a week later.
            </summary>
      <param name="targetDayOfWeek">The ISO day of the week to return the next date of.</param>
      <returns>The next <see cref="T:NodaTime.LocalDateTime" /> falling on the specified day of the week.</returns>
      <exception cref="T:System.InvalidOperationException">The underlying calendar doesn't use ISO days of the week.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="targetDayOfWeek" /> is not a valid day of the
            week (Monday to Sunday).</exception>
    </member>
    <member name="M:NodaTime.LocalDateTime.Previous(NodaTime.IsoDayOfWeek)">
      <summary>
            Returns the previous <see cref="T:NodaTime.LocalDateTime" /> falling on the specified <see cref="P:NodaTime.LocalDateTime.IsoDayOfWeek" />,
            at the same time of day as this value.
            This is a strict "previous" - if this value on already falls on the target
            day of the week, the returned value will be a week earlier.
            </summary>
      <param name="targetDayOfWeek">The ISO day of the week to return the previous date of.</param>
      <returns>The previous <see cref="T:NodaTime.LocalDateTime" /> falling on the specified day of the week.</returns>
      <exception cref="T:System.InvalidOperationException">The underlying calendar doesn't use ISO days of the week.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="targetDayOfWeek" /> is not a valid day of the
            week (Monday to Sunday).</exception>
    </member>
    <member name="M:NodaTime.LocalDateTime.WithOffset(NodaTime.Offset)">
      <summary>
            Returns an <see cref="T:NodaTime.OffsetDateTime" /> for this local date/time with the given offset.
            </summary>
      <remarks>This method is purely a convenient alternative to calling the <see cref="T:NodaTime.OffsetDateTime" /> constructor directly.</remarks>
      <param name="offset">The offset to apply.</param>
      <returns>The result of this local date/time offset by the given amount.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.InUtc">
      <summary>
            Returns the mapping of this local date/time within <see cref="P:NodaTime.DateTimeZone.Utc" />.
            </summary>
      <remarks>As UTC is a fixed time zone, there is no chance that this local date/time is ambiguous or skipped.</remarks>
      <returns>The result of mapping this local date/time in UTC.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.InZoneStrictly(NodaTime.DateTimeZone)">
      <summary>
            Returns the mapping of this local date/time within the given <see cref="T:NodaTime.DateTimeZone" />,
            with "strict" rules applied such that an exception is thrown if either the mapping is
            ambiguous or the time is skipped.
            </summary>
      <remarks>
            See <see cref="M:NodaTime.LocalDateTime.InZoneLeniently(NodaTime.DateTimeZone)" /> and <see cref="M:NodaTime.LocalDateTime.InZone(NodaTime.DateTimeZone,NodaTime.TimeZones.ZoneLocalMappingResolver)" /> for alternative ways to map a local time to a
            specific instant.
            This is solely a convenience method for calling <see cref="M:NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)" />.
            </remarks>
      <param name="zone">The time zone in which to map this local date/time.</param>
      <exception cref="T:NodaTime.SkippedTimeException">This local date/time is skipped in the given time zone.</exception>
      <exception cref="T:NodaTime.AmbiguousTimeException">This local date/time is ambiguous in the given time zone.</exception>
      <returns>The result of mapping this local date/time in the given time zone.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.InZoneLeniently(NodaTime.DateTimeZone)">
      <summary>
            Returns the mapping of this local date/time within the given <see cref="T:NodaTime.DateTimeZone" />,
            with "lenient" rules applied such that ambiguous values map to the
            later of the alternatives, and "skipped" values map to the start of the zone interval
            after the "gap".
            </summary>
      <remarks>
            See <see cref="M:NodaTime.LocalDateTime.InZoneStrictly(NodaTime.DateTimeZone)" /> and <see cref="M:NodaTime.LocalDateTime.InZone(NodaTime.DateTimeZone,NodaTime.TimeZones.ZoneLocalMappingResolver)" /> for alternative ways to map a local time to a
            specific instant.
            This is solely a convenience method for calling <see cref="M:NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)" />.
            </remarks>
      <param name="zone">The time zone in which to map this local date/time.</param>
      <returns>The result of mapping this local date/time in the given time zone.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.InZone(NodaTime.DateTimeZone,NodaTime.TimeZones.ZoneLocalMappingResolver)">
      <summary>
            Resolves this local date and time into a <see cref="T:NodaTime.ZonedDateTime" /> in the given time zone, following
            the given <see cref="T:NodaTime.TimeZones.ZoneLocalMappingResolver" /> to handle ambiguity and skipped times.
            </summary>
      <remarks>
            See <see cref="M:NodaTime.LocalDateTime.InZoneStrictly(NodaTime.DateTimeZone)" /> and <see cref="M:NodaTime.LocalDateTime.InZoneLeniently(NodaTime.DateTimeZone)" /> for alternative ways to map a local time
            to a specific instant.
            This is a convenience method for calling <see cref="M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)" />.
            </remarks>
      <param name="zone">The time zone to map this local date and time into</param>
      <param name="resolver">The resolver to apply to the mapping.</param>
      <returns>The result of resolving the mapping.</returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            The value of the current instance in the default format pattern ("G"), using the current thread's
            culture to obtain a format provider.
            </returns>
    </member>
    <member name="M:NodaTime.LocalDateTime.ToString(System.String,System.IFormatProvider)">
      <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
      <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
      <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("G").
            </param>
      <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:NodaTime.LocalDateTime.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Private constructor only present for serialization.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to fetch data from.</param>
      <param name="context">The source for this deserialization.</param>
    </member>
    <member name="P:NodaTime.LocalDateTime.Calendar">
      <summary>Gets the calendar system associated with this local date and time.</summary>
    </member>
    <member name="P:NodaTime.LocalDateTime.CenturyOfEra">
      <summary>Gets the century within the era of this local date and time.</summary>
    </member>
    <member name="P:NodaTime.LocalDateTime.Year">
      <summary>Gets the year of this local date and time.</summary>
      <remarks>This returns the "absolute year", so, for the ISO calendar,
            a value of 0 means 1 BC, for example.</remarks>
    </member>
    <member name="P:NodaTime.LocalDateTime.YearOfCentury">
      <summary>Gets the year of this local date and time within its century.</summary>
      <remarks>This always returns a value in the range 0 to 99 inclusive.</remarks>
    </member>
    <member name="P:NodaTime.LocalDateTime.YearOfEra">
      <summary>Gets the year of this local date and time within its era.</summary>
    </member>
    <member name="P:NodaTime.LocalDateTime.Era">
      <summary>Gets the era of this local date and time.</summary>
    </member>
    <member name="P:NodaTime.LocalDateTime.WeekYear">
      <summary>
            Gets the "week year" of this local date and time.
            </summary>
      <remarks>
        <para>
            The WeekYear is the year that matches with the <see cref="P:NodaTime.LocalDateTime.WeekOfWeekYear" /> field.
            In the standard ISO8601 week algorithm, the first week of the year
            is that in which at least 4 days are in the year. As a result of this
            definition, day 1 of the first week may be in the previous year.
            The WeekYear allows you to query the effective year for that day.
            </para>
        <para>
            For example, January 1st 2011 was a Saturday, so only two days of that week
            (Saturday and Sunday) were in 2011. Therefore January 1st is part of
            week 52 of WeekYear 2010. Conversely, December 31st 2012 is a Monday,
            so is part of week 1 of WeekYear 2013.
            </para>
      </remarks>
    </member>
    <member name="P:NodaTime.LocalDateTime.Month">
      <summary>
            Gets the month of this local date and time within the year.
            </summary>
    </member>
    <member name="P:NodaTime.LocalDateTime.WeekOfWeekYear">
      <summary>
            Gets the week within the WeekYear. See <see cref="P:NodaTime.LocalDateTime.WeekYear" /> for more details.
            </summary>
    </member>
    <member name="P:NodaTime.LocalDateTime.DayOfYear">
      <summary>
            Gets the day of this local date and time within the year.
            </summary>
    </member>
    <member name="P:NodaTime.LocalDateTime.Day">
      <summary>
            Gets the day of this local date and time within the month.
            </summary>
    </member>
    <member name="P:NodaTime.LocalDateTime.IsoDayOfWeek">
      <summary>
            Gets the week day of this local date and time expressed as an <see cref="T:NodaTime.IsoDayOfWeek" /> value,
            for calendars which use ISO days of the week.
            </summary>
      <exception cref="T:System.InvalidOperationException">The underlying calendar doesn't use ISO days of the week.</exception>
      <seealso cref="P:NodaTime.LocalDateTime.DayOfWeek" />
    </member>
    <member name="P:NodaTime.LocalDateTime.DayOfWeek">
      <summary>
            Gets the week day of this local date and time as a number.
            </summary>
      <remarks>
            For calendars using ISO week days, this gives 1 for Monday to 7 for Sunday.
            </remarks>
      <seealso cref="P:NodaTime.LocalDateTime.IsoDayOfWeek" />
    </member>
    <member name="P:NodaTime.LocalDateTime.Hour">
      <summary>
            Gets the hour of day of this local date and time, in the range 0 to 23 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.LocalDateTime.ClockHourOfHalfDay">
      <summary>
            Gets the hour of the half-day of this local date and time, in the range 1 to 12 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.LocalDateTime.Minute">
      <summary>
            Gets the minute of this local date and time, in the range 0 to 59 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.LocalDateTime.Second">
      <summary>
            Gets the second of this local date and time within the minute, in the range 0 to 59 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.LocalDateTime.Millisecond">
      <summary>
            Gets the millisecond of this local date and time within the second, in the range 0 to 999 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.LocalDateTime.TickOfSecond">
      <summary>
            Gets the tick of this local time within the second, in the range 0 to 9,999,999 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.LocalDateTime.TickOfDay">
      <summary>
            Gets the tick of this local date and time within the day, in the range 0 to 863,999,999,999 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.LocalDateTime.TimeOfDay">
      <summary>
            Gets the time portion of this local date and time as a <see cref="T:NodaTime.LocalTime" />.
            </summary>
    </member>
    <member name="P:NodaTime.LocalDateTime.Date">
      <summary>
            Gets the date portion of this local date and time as a <see cref="T:NodaTime.LocalDate" /> in the same calendar system as this value.
            </summary>
    </member>
    <member name="T:NodaTime.DateTimeZone">
      <summary>
            Represents a time zone - a mapping between UTC and local time. A time zone maps UTC instants to local times
             - or, equivalently, to the offset from UTC at any particular instant.
            </summary>
      <remarks>
        <para>
            The mapping is unambiguous in the "UTC to local" direction, but
            the reverse is not true: when the offset changes, usually due to a Daylight Saving transition,
            the change either creates a gap (a period of local time which never occurs in the time zone)
            or an ambiguity (a period of local time which occurs twice in the time zone). Mapping back from
            local time to an instant requires consideration of how these problematic times will be handled.
            </para>
        <para>
            Noda Time provides various options when mapping local time to a specific instant:
            <list type="bullet"><item><description><see cref="M:NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)" /> will throw an exception if the mapping from local time is either ambiguous
                or impossible, i.e. if there is anything other than one instant which maps to the given local time.</description></item><item><description><see cref="M:NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)" /> will never throw an exception due to ambiguous or skipped times,
                resolving to the later option of ambiguous matches or the start of the zone interval after the gap for
                skipped times.</description></item><item><description><see cref="M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)" /> will apply a <see cref="T:NodaTime.TimeZones.ZoneLocalMappingResolver" /> to the result of
                a mapping.</description></item><item><description><see cref="M:NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime)" /> will return a <see cref="T:NodaTime.TimeZones.ZoneLocalMapping" />
                with complete information about whether the given local time occurs zero times, once or twice. This is the most
                fine-grained approach, which is the fiddliest to use but puts the caller in the most control.</description></item></list></para>
        <para>
            Noda Time has two built-in sources of time zone data available: a copy of the
            <a href="http://www.iana.org/time-zones">tz database</a> (also known as the IANA Time Zone database, or zoneinfo
            or Olson database), and the ability to convert .NET's own <see cref="T:System.TimeZoneInfo" /> format into a "native" Noda
            Time zone. Which of these is most appropriate for you to use will very much depend on your exact needs. The
            zoneinfo database is widely used outside Windows, and has more historical data than the Windows-provided
            information, but if you need to interoperate with other Windows systems by specifying time zone IDs, you may
            wish to stick to the Windows time zones.
            </para>
        <para>
            To obtain a <see cref="T:NodaTime.DateTimeZone" /> for a given timezone ID, use one of the methods on
            <see cref="T:NodaTime.IDateTimeZoneProvider" /> (and see <see cref="T:NodaTime.DateTimeZoneProviders" /> for access to the built-in
            providers). The UTC timezone is also available via the <see cref="P:NodaTime.DateTimeZone.Utc" /> property on this class.
            </para>
        <para>
            To obtain a <see cref="T:NodaTime.DateTimeZone" /> representing the system default time zone, you can either call
            <see cref="M:NodaTime.IDateTimeZoneProvider.GetSystemDefault" /> on a provider to obtain the <see cref="T:NodaTime.DateTimeZone" /> that
            the provider considers matches the system default time zone, or you can construct a
            <c>BclDateTimeZone</c> via <c>BclDateTimeZone.ForSystemDefault</c>, which returns a
            <see cref="T:NodaTime.DateTimeZone" /> that wraps the system local <see cref="T:System.TimeZoneInfo" />. The latter will always
            succeed, but has access only to that information available via the .NET time zone; the former may contain more
            complete data, but may (in uncommon cases) fail to find a matching <see cref="T:NodaTime.DateTimeZone" />.
            Note that <c>BclDateTimeZone</c> is not available on the PCL build of Noda Time, so this fallback strategy can
            only be used with the desktop version.
            </para>
        <para>Note that Noda Time does not require that <see cref="T:NodaTime.DateTimeZone" /> instances be singletons.
            As far as reasonably possible, implementations should implement <see cref="T:System.IEquatable`1" /> in such a way
            that equivalent time zones compare as equal.</para>
      </remarks>
      <threadsafety>
            All time zone implementations within Noda Time are immutable and thread-safe.
            See the thread safety section of the user guide for more information.
            It is expected that third party implementations will be immutable and thread-safe as well:
            code within Noda Time assumes that it can hand out time zones to any thread without any concerns. If you
            implement a non-thread-safe time zone, you will need to use it extremely carefully. We'd recommend that you
            avoid this if possible.
            </threadsafety>
    </member>
    <member name="F:NodaTime.DateTimeZone.UtcId">
      <summary>
            The ID of the UTC (Coordinated Universal Time) time zone. This ID is always valid, whatever provider is
            used. If the provider has its own mapping for UTC, that will be returned by <see cref="M:NodaTime.TimeZones.DateTimeZoneCache.GetZoneOrNull(System.String)" />, but otherwise
            the value of the <see cref="P:NodaTime.DateTimeZone.Utc" /> property will be returned.
            </summary>
    </member>
    <member name="M:NodaTime.DateTimeZone.ForOffset(NodaTime.Offset)">
      <summary>
            Returns a fixed time zone with the given offset.
            </summary>
      <remarks>
        <para>
            The returned time zone will have an ID of "UTC" if the offset is zero, or "UTC+/-Offset"
            otherwise. In the former case, the returned instance will be equal to <see cref="P:NodaTime.DateTimeZone.Utc" />.
            </para>
        <para>
            Note also that this method is not required to return the same <see cref="T:NodaTime.DateTimeZone" /> instance for
            successive requests for the same offset; however, all instances returned for a given offset will compare
            as equal.
            </para>
      </remarks>
      <param name="offset">The offset for the returned time zone</param>
      <returns>A fixed time zone with the given offset.</returns>
    </member>
    <member name="M:NodaTime.DateTimeZone.#ctor(System.String,System.Boolean,NodaTime.Offset,NodaTime.Offset)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.DateTimeZone" /> class.
            </summary>
      <param name="id">The unique id of this time zone.</param>
      <param name="isFixed">Set to <c>true</c> if this time zone has no transitions.</param>
      <param name="minOffset">Minimum offset applied within this zone</param>
      <param name="maxOffset">Maximum offset applied within this zone</param>
    </member>
    <member name="M:NodaTime.DateTimeZone.GetUtcOffset(NodaTime.Instant)">
      <summary>
            Returns the offset from UTC, where a positive duration indicates that local time is
            later than UTC. In other words, local time = UTC + offset.
            </summary>
      <remarks>
            This is mostly a convenience method for calling <c>GetZoneInterval(instant).WallOffset</c>,
            although it can also be overridden for more efficiency.
            </remarks>
      <param name="instant">The instant for which to calculate the offset.</param>
      <returns>
            The offset from UTC at the specified instant.
            </returns>
    </member>
    <member name="M:NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)">
      <summary>
            Gets the zone interval for the given instant; the range of time around the instant in which the same Offset
            applies (with the same split between standard time and daylight saving time, and with the same offset).
            </summary>
      <remarks>
            This will always return a valid zone interval, as time zones cover the whole of time.
            </remarks>
      <param name="instant">The <see cref="T:NodaTime.Instant" /> to query.</param>
      <returns>The defined <see cref="T:NodaTime.TimeZones.ZoneInterval" />.</returns>
      <seealso cref="M:NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)" />
    </member>
    <member name="M:NodaTime.DateTimeZone.GetZoneIntervalPair(NodaTime.LocalInstant)">
      <summary>
            Finds all zone intervals for the given local instant. Usually there's one (i.e. only a single
            instant is mapped to the given local instant within the time zone) but during DST transitions
            there can be either 0 (the given local instant doesn't exist, e.g. local time skipped from 1am to
            2am, but you gave us 1.30am) or 2 (the given local instant is ambiguous, e.g. local time skipped
            from 2am to 1am, but you gave us 1.30am).
            </summary>
      <remarks>
            This method is implemented in terms of GetZoneInterval(Instant) within DateTimeZone,
            and should work for any zone. However, internal derived classes may override this method
            for optimization purposes, e.g. if the zone interval is always ambiguous with
            a fixed value.
            </remarks>
      <param name="localInstant">The local instant to find matching zone intervals for</param>
      <returns>The struct containing up to two ZoneInterval references.</returns>
    </member>
    <member name="M:NodaTime.DateTimeZone.AtStartOfDay(NodaTime.LocalDate)">
      <summary>
            Returns the earliest valid <see cref="T:NodaTime.ZonedDateTime" /> with the given local date.
            </summary>
      <remarks>
            If midnight exists unambiguously on the given date, it is returned.
            If the given date has an ambiguous start time (e.g. the clocks go back from 1am to midnight)
            then the earlier ZonedDateTime is returned. If the given date has no midnight (e.g. the clocks
            go forward from midnight to 1am) then the earliest valid value is returned; this will be the instant
            of the transition.
            </remarks>
      <param name="date">The local date to map in this time zone.</param>
      <exception cref="T:NodaTime.SkippedTimeException">The entire day was skipped due to a very large time zone transition.
            (This is extremely rare.)</exception>
      <returns>The <see cref="T:NodaTime.ZonedDateTime" /> representing the earliest time in the given date, in this time zone.</returns>
    </member>
    <member name="M:NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime)">
      <summary>
            Returns complete information about how the given <see cref="T:NodaTime.LocalDateTime" /> is mapped in this time zone.
            </summary>
      <remarks>
        <para>
            Mapping a local date/time to a time zone can give an unambiguous, ambiguous or impossible result, depending on
            time zone transitions. Use the return value of this method to handle these cases in an appropriate way for
            your use case.
            </para>
        <para>
            As an alternative, consider <see cref="M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)" />, which uses a caller-provided strategy to
            convert the <see cref="T:NodaTime.TimeZones.ZoneLocalMapping" /> returned here to a <see cref="T:NodaTime.ZonedDateTime" />.
            </para>
      </remarks>
      <param name="localDateTime">The local date and time to map in this time zone.</param>
      <returns>A mapping of the given local date and time to zero, one or two zoned date/time values.</returns>
    </member>
    <member name="M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)">
      <summary>
            Maps the given <see cref="T:NodaTime.LocalDateTime" /> to the corresponding <see cref="T:NodaTime.ZonedDateTime" />, following
            the given <see cref="T:NodaTime.TimeZones.ZoneLocalMappingResolver" /> to handle ambiguity and skipped times.
            </summary>
      <remarks>
        <para>
            This is a convenience method for calling <see cref="M:NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime)" /> and passing the result to the resolver.
            Common options for resolvers are provided in the static <see cref="T:NodaTime.TimeZones.Resolvers" /> class.
            </para>
        <para>
            See <see cref="M:NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)" /> and <see cref="M:NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)" /> for alternative ways to map a local time to a
            specific instant.
            </para>
      </remarks>
      <param name="localDateTime">The local date and time to map in this time zone.</param>
      <param name="resolver">The resolver to apply to the mapping.</param>
      <returns>The result of resolving the mapping.</returns>
    </member>
    <member name="M:NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)">
      <summary>
            Maps the given <see cref="T:NodaTime.LocalDateTime" /> to the corresponding <see cref="T:NodaTime.ZonedDateTime" />, if and only if
            that mapping is unambiguous in this time zone.  Otherwise, <see cref="T:NodaTime.SkippedTimeException" /> or
            <see cref="T:NodaTime.AmbiguousTimeException" /> is thrown, depending on whether the mapping is ambiguous or the local
            date/time is skipped entirely.
            </summary>
      <remarks>
            See <see cref="M:NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)" /> and <see cref="M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)" /> for alternative ways to map a local time to a
            specific instant.
            </remarks>
      <param name="localDateTime">The local date and time to map into this time zone.</param>
      <exception cref="T:NodaTime.SkippedTimeException">The given local date/time is skipped in this time zone.</exception>
      <exception cref="T:NodaTime.AmbiguousTimeException">The given local date/time is ambiguous in this time zone.</exception>
      <returns>The unambiguous matching <see cref="T:NodaTime.ZonedDateTime" /> if it exists.</returns>
    </member>
    <member name="M:NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)">
      <summary>
            Maps the given <see cref="T:NodaTime.LocalDateTime" /> to the corresponding <see cref="T:NodaTime.ZonedDateTime" /> in a lenient
            manner: ambiguous values map to the later of the alternatives, and "skipped" values map to the start of the
            zone interval after the "gap".
            </summary>
      <remarks>
            See <see cref="M:NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)" /> and <see cref="M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)" /> for alternative ways to map a local time to a
            specific instant.
            </remarks>
      <param name="localDateTime">The local date/time to map.</param>
      <returns>The unambiguous mapping if there is one, the later result if the mapping is ambiguous,
            or the start of the later zone interval if the given local date/time is skipped.</returns>
    </member>
    <member name="M:NodaTime.DateTimeZone.GetEarlierMatchingInterval(NodaTime.TimeZones.ZoneInterval,NodaTime.LocalInstant)">
      <summary>
            Returns the interval before this one, if it contains the given local instant, or null otherwise.
            </summary>
    </member>
    <member name="M:NodaTime.DateTimeZone.GetLaterMatchingInterval(NodaTime.TimeZones.ZoneInterval,NodaTime.LocalInstant)">
      <summary>
            Returns the next interval after this one, if it contains the given local instant, or null otherwise.
            </summary>
    </member>
    <member name="M:NodaTime.DateTimeZone.ToString">
      <summary>
            Returns the ID of this time zone.
            </summary>
      <returns>
            The ID of this time zone.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:NodaTime.DateTimeZone.BuildFixedZoneCache">
      <summary>
            Creates a fixed time zone for offsets -23.5 to +23.5 at every half hour,
            fixing the 0 offset as DateTimeZone.Utc.
            </summary>
    </member>
    <member name="M:NodaTime.DateTimeZone.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NodaTime.DateTimeZone.Equals(NodaTime.DateTimeZone)">
      <summary>
            Determines whether the specified <see cref="T:NodaTime.DateTimeZone" /> is equal to this instance.
            </summary>
      <remarks>
            This implementation performs initial checks which would be common to all child implementations,
            and then delegates to <see cref="M:NodaTime.DateTimeZone.EqualsImpl(NodaTime.DateTimeZone)" />.
            </remarks>
      <param name="obj">The <see cref="T:NodaTime.DateTimeZone" /> to compare with this instance.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:NodaTime.DateTimeZone" /> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NodaTime.DateTimeZone.EqualsImpl(NodaTime.DateTimeZone)">
      <summary>
            Implements equality in derived classes.
            </summary>
      <param name="zone">The zone to compare with this one. This is guaranteed (when called by <see cref="M:NodaTime.DateTimeZone.Equals(NodaTime.DateTimeZone)" />) to
            be a non-null reference of the same type as this instance.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:NodaTime.DateTimeZone" /> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NodaTime.DateTimeZone.GetHashCode">
      <summary>
            Returns a hash code for this instance.
            </summary>
      <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
    </member>
    <member name="M:NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Instant,NodaTime.Instant)">
      <summary>
            Returns all the zone intervals which occur for any instant in the interval [<paramref name="start" />, <paramref name="end" />).
            </summary>
      <remarks>
        <para>This method is simply a convenience method for calling <see cref="M:NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)" /> without
            explicitly constructing the interval beforehand.
            </para>
      </remarks>
      <param name="start">Inclusive start point of the interval for which to retrieve zone intervals.</param>
      <param name="end">Exclusive end point of the interval for which to retrieve zone intervals.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="end" /> is earlier than <paramref name="start" />.</exception>
      <returns>A sequence of zone intervals covering the given interval.</returns>
      <seealso cref="M:NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)" />
    </member>
    <member name="M:NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)">
      <summary>
            Returns all the zone intervals which occur for any instant in the given interval.
            </summary>
      <remarks>
        <para>The zone intervals are returned in chronological order. This method is equivalent to calling <see cref="M:NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)" /> for every
            instant in the interval and then collapsing to a set of distinct zone intervals.
            The first and last zone intervals are likely to also cover instants outside the given interval;
            the zone intervals returned are not truncated to match the start and end points.
            </para>
      </remarks>
      <param name="interval">Interval to find zone intervals for.</param>
      <returns>A sequence of zone intervals covering the given interval.</returns>
      <seealso cref="M:NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)" />
    </member>
    <member name="P:NodaTime.DateTimeZone.Utc">
      <summary>
            Gets the UTC (Coordinated Universal Time) time zone. This is a single instance which is not
            provider-specific; it is guaranteed to have the ID "UTC", but may or may not be the instance returned by
            e.g. <c>DateTimeZoneProviders.Tzdb["UTC"]</c>.
            </summary>
      <value>A UTC <see cref="T:NodaTime.DateTimeZone" />.</value>
    </member>
    <member name="P:NodaTime.DateTimeZone.Id">
      <summary>
            The provider's ID for the time zone.
            </summary>
      <remarks>
        <para>
            This identifies the time zone within the current time zone provider; a different provider may
            provide a different time zone with the same ID, or may not provide a time zone with that ID at all.
            </para>
      </remarks>
    </member>
    <member name="P:NodaTime.DateTimeZone.IsFixed">
      <summary>
            Indicates whether the time zone is fixed, i.e. contains no transitions.
            </summary>
      <remarks>
            This is used as an optimization. If the time zone has no transitions but returns <c>false</c>
            for this then the behavior will be correct but the system will have to do extra work. However
            if the time zone has transitions and this returns <c>true</c> then the transitions will never
            be examined.
            </remarks>
    </member>
    <member name="P:NodaTime.DateTimeZone.MinOffset">
      <summary>
            Returns the least (most negative) offset within this time zone, over all time.
            </summary>
    </member>
    <member name="P:NodaTime.DateTimeZone.MaxOffset">
      <summary>
            Returns the greatest (most positive) offset within this time zone, over all time.
            </summary>
    </member>
    <member name="T:NodaTime.Duration">
      <summary>
            Represents a fixed (and calendar-independent) length of time.
            </summary>
      <remarks>
        <para>
            A duration is a length of time defined by an integral number of 'ticks', where a tick is equal to 100
            nanoseconds. There are 10,000 ticks in a millisecond.
            Although durations are usually used with a positive number of ticks, negative durations are valid, and may occur
            naturally when e.g. subtracting an earlier <see cref="T:NodaTime.Instant" /> from a later one.
            </para>
        <para>
            A duration represents a fixed length of elapsed time along the time line that occupies the same amount of
            time regardless of when it is applied.  In contrast, <see cref="T:NodaTime.Period" /> represents a period of time in
            calendrical terms (hours, days, and so on) that may vary in elapsed time when applied.
            </para>
        <para>
            In general, use <see cref="T:NodaTime.Duration" /> to represent durations applied to global types like <see cref="T:NodaTime.Instant" />
            and <see cref="T:NodaTime.ZonedDateTime" />; use <c>Period</c> to represent a period applied to local types like
            <see cref="T:NodaTime.LocalDateTime" />.
            </para>
      </remarks>
      <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="F:NodaTime.Duration.Zero">
      <summary>
            Represents the zero <see cref="T:NodaTime.Duration" /> value. 
            This field is read-only.
            </summary>
    </member>
    <member name="F:NodaTime.Duration.Epsilon">
      <summary>
            Represents the <see cref="T:NodaTime.Duration" /> value equals to 1 tick; the smallest amount by which an instant can vary.
            This field is read-only.
            </summary>
    </member>
    <member name="F:NodaTime.Duration.OneStandardWeek">
      <summary>
            Represents the <see cref="T:NodaTime.Duration" /> value equals to number of ticks in 1 standard week (7 days).
            This field is constant.
            </summary>
      <remarks>
            The value of this constant is 6,048,000,000,000 ticks.
            </remarks>
    </member>
    <member name="F:NodaTime.Duration.OneStandardDay">
      <summary>
            Represents the <see cref="T:NodaTime.Duration" /> value equals to number of ticks in 1 day.
            This field is constant.
            </summary>
      <remarks>
            The value of this constant is 864 billion ticks; that is, 864,000,000,000 ticks.
            </remarks>
    </member>
    <member name="F:NodaTime.Duration.OneHour">
      <summary>
            Represents the <see cref="T:NodaTime.Duration" /> value equals to number of ticks in 1 hour.
            This field is constant.
            </summary>
      <remarks>
            The value of this constant is 36 billion ticks; that is, 36,000,000,000 ticks.
            </remarks>
    </member>
    <member name="F:NodaTime.Duration.OneMinute">
      <summary>
            Represents the <see cref="T:NodaTime.Duration" /> value equals to number of ticks in 1 minute.
            This field is constant.
            </summary>
      <remarks>
            The value of this constant is 600 million ticks; that is, 600,000,000 ticks.
            </remarks>
    </member>
    <member name="F:NodaTime.Duration.OneSecond">
      <summary>
            Represents the <see cref="T:NodaTime.Duration" /> value equals to number of ticks in 1 second.
            This field is constant.
            </summary>
      <remarks>
            The value of this constant is 10 million ticks; that is, 10,000,000 ticks.
            </remarks>
    </member>
    <member name="F:NodaTime.Duration.OneMillisecond">
      <summary>
            Represents the <see cref="T:NodaTime.Duration" /> value equals to number of ticks in 1 millisecond.
            This field is constant.
            </summary>
      <remarks>
            The value of this constant is 10 thousand ticks; that is, 10,000 ticks.
            </remarks>
    </member>
    <member name="M:NodaTime.Duration.#ctor(System.Int64)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Duration" /> struct.
            </summary>
      <param name="ticks">The number of ticks.</param>
    </member>
    <member name="M:NodaTime.Duration.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NodaTime.Duration.GetHashCode">
      <summary>
            Returns a hash code for this instance.
            </summary>
      <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
    </member>
    <member name="M:NodaTime.Duration.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            The value of the current instance in the default format pattern ("o"), using the current thread's
            culture to obtain a format provider.
            </returns>
    </member>
    <member name="M:NodaTime.Duration.ToString(System.String,System.IFormatProvider)">
      <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
      <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
      <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("o").
            </param>
      <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:NodaTime.Duration.op_Addition(NodaTime.Duration,NodaTime.Duration)">
      <summary>
            Implements the operator + (addition).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>A new <see cref="T:NodaTime.Duration" /> representing the sum of the given values.</returns>
    </member>
    <member name="M:NodaTime.Duration.Add(NodaTime.Duration,NodaTime.Duration)">
      <summary>
            Adds one duration to another. Friendly alternative to <c>operator+()</c>.
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>A new <see cref="T:NodaTime.Duration" /> representing the sum of the given values.</returns>
    </member>
    <member name="M:NodaTime.Duration.Plus(NodaTime.Duration)">
      <summary>
            Returns the result of adding another duration to this one, for a fluent alternative to <c>operator+()</c>.
            </summary>
      <param name="other">The duration to add</param>
      <returns>A new <see cref="T:NodaTime.Duration" /> representing the result of the addition.</returns>
    </member>
    <member name="M:NodaTime.Duration.op_Subtraction(NodaTime.Duration,NodaTime.Duration)">
      <summary>
            Implements the operator - (subtraction).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>A new <see cref="T:NodaTime.Duration" /> representing the difference of the given values.</returns>
    </member>
    <member name="M:NodaTime.Duration.Subtract(NodaTime.Duration,NodaTime.Duration)">
      <summary>
            Subtracts one duration from another. Friendly alternative to <c>operator-()</c>.
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>A new <see cref="T:NodaTime.Duration" /> representing the difference of the given values.</returns>
    </member>
    <member name="M:NodaTime.Duration.Minus(NodaTime.Duration)">
      <summary>
            Returns the result of subtracting another duration from this one, for a fluent alternative to <c>operator-()</c>.
            </summary>
      <param name="other">The duration to subtract</param>
      <returns>A new <see cref="T:NodaTime.Duration" /> representing the result of the subtraction.</returns>
    </member>
    <member name="M:NodaTime.Duration.op_Division(NodaTime.Duration,System.Int64)">
      <summary>
            Implements the operator / (division).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>A new <see cref="T:NodaTime.Duration" /> representing the result of dividing <paramref name="left" /> by
            <paramref name="right" />.</returns>
    </member>
    <member name="M:NodaTime.Duration.Divide(NodaTime.Duration,System.Int64)">
      <summary>
            Divides a duration by a number. Friendly alternative to <c>operator/()</c>.
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>A new <see cref="T:NodaTime.Duration" /> representing the result of dividing <paramref name="left" /> by
            <paramref name="right" />.</returns>
    </member>
    <member name="M:NodaTime.Duration.op_Multiply(NodaTime.Duration,System.Int64)">
      <summary>
            Implements the operator * (multiplication).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>A new <see cref="T:NodaTime.Duration" /> representing the result of multiplying <paramref name="left" /> by
            <paramref name="right" />.</returns>
    </member>
    <member name="M:NodaTime.Duration.op_Multiply(System.Int64,NodaTime.Duration)">
      <summary>
            Implements the operator * (multiplication).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>A new <see cref="T:NodaTime.Duration" /> representing the result of multiplying <paramref name="left" /> by
            <paramref name="right" />.</returns>
    </member>
    <member name="M:NodaTime.Duration.Multiply(NodaTime.Duration,System.Int64)">
      <summary>
            Multiplies a duration by a number. Friendly alternative to <c>operator*()</c>.
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>A new <see cref="T:NodaTime.Duration" /> representing the product of the given values.</returns>
    </member>
    <member name="M:NodaTime.Duration.Multiply(System.Int64,NodaTime.Duration)">
      <summary>
            Multiplies a duration by a number. Friendly alternative to <c>operator*()</c>.
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>A new <see cref="T:NodaTime.Duration" /> representing the product of the given values.</returns>
    </member>
    <member name="M:NodaTime.Duration.op_Equality(NodaTime.Duration,NodaTime.Duration)">
      <summary>
            Implements the operator == (equality).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.Duration.op_Inequality(NodaTime.Duration,NodaTime.Duration)">
      <summary>
            Implements the operator != (inequality).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.Duration.op_LessThan(NodaTime.Duration,NodaTime.Duration)">
      <summary>
            Implements the operator &lt; (less than).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if the left value is less than the right value, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.Duration.op_LessThanOrEqual(NodaTime.Duration,NodaTime.Duration)">
      <summary>
            Implements the operator &lt;= (less than or equal).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if the left value is less than or equal to the right value, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.Duration.op_GreaterThan(NodaTime.Duration,NodaTime.Duration)">
      <summary>
            Implements the operator &gt; (greater than).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if the left value is greater than the right value, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.Duration.op_GreaterThanOrEqual(NodaTime.Duration,NodaTime.Duration)">
      <summary>
            Implements the operator &gt;= (greater than or equal).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if the left value is greater than or equal to the right value, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.Duration.op_UnaryNegation(NodaTime.Duration)">
      <summary>
            Implements the unary negation operator.
            </summary>
      <param name="duration">Duration to negate</param>
      <returns>The negative value of this duration</returns>
    </member>
    <member name="M:NodaTime.Duration.Negate(NodaTime.Duration)">
      <summary>
            Implements a friendly alternative to the unary negation operator.
            </summary>
      <param name="duration">Duration to negate</param>
      <returns>The negative value of this duration</returns>
    </member>
    <member name="M:NodaTime.Duration.CompareTo(NodaTime.Duration)">
      <summary>
            Compares the current object with another object of the same type.
            </summary>
      <param name="other">An object to compare with this object.</param>
      <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared.
            The return value has the following meanings:
            <list type="table"><listheader><term>Value</term><description>Meaning</description></listheader><item><term>&lt; 0</term><description>This object is less than the <paramref name="other" /> parameter.</description></item><item><term>0</term><description>This object is equal to <paramref name="other" />.</description></item><item><term>&gt; 0</term><description>This object is greater than <paramref name="other" />.</description></item></list></returns>
    </member>
    <member name="M:NodaTime.Duration.Equals(NodaTime.Duration)">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <param name="other">An object to compare with this object.</param>
      <returns>
            true if the current object is equal to the <paramref name="other" /> parameter;
            otherwise, false.
            </returns>
    </member>
    <member name="M:NodaTime.Duration.FromStandardWeeks(System.Int64)">
      <summary>
            Returns a <see cref="T:NodaTime.Duration" /> that represents the given number of weeks, assuming a 'standard' week
            consisting of seven 24-hour days.
            </summary>
      <param name="weeks">The number of weeks.</param>
      <returns>A <see cref="T:NodaTime.Duration" /> representing the given number of weeks.</returns>
    </member>
    <member name="M:NodaTime.Duration.FromStandardDays(System.Int64)">
      <summary>
            Returns a <see cref="T:NodaTime.Duration" /> that represents the given number of days, assuming a 'standard' 24-hour
            day.
            </summary>
      <param name="days">The number of days.</param>
      <returns>A <see cref="T:NodaTime.Duration" /> representing the given number of days.</returns>
    </member>
    <member name="M:NodaTime.Duration.FromHours(System.Int64)">
      <summary>
            Returns a <see cref="T:NodaTime.Duration" /> that represents the given number of hours.
            </summary>
      <param name="hours">The number of hours.</param>
      <returns>A <see cref="T:NodaTime.Duration" /> representing the given number of hours.</returns>
    </member>
    <member name="M:NodaTime.Duration.FromMinutes(System.Int64)">
      <summary>
            Returns a <see cref="T:NodaTime.Duration" /> that represents the given number of minutes.
            </summary>
      <param name="minutes">The number of minutes.</param>
      <returns>A <see cref="T:NodaTime.Duration" /> representing the given number of minutes.</returns>
    </member>
    <member name="M:NodaTime.Duration.FromSeconds(System.Int64)">
      <summary>
            Returns a <see cref="T:NodaTime.Duration" /> that represents the given number of seconds.
            </summary>
      <param name="seconds">The number of seconds.</param>
      <returns>A <see cref="T:NodaTime.Duration" /> representing the given number of seconds.</returns>
    </member>
    <member name="M:NodaTime.Duration.FromMilliseconds(System.Int64)">
      <summary>
            Returns a <see cref="T:NodaTime.Duration" /> that represents the given number of milliseconds.
            </summary>
      <param name="milliseconds">The number of milliseconds.</param>
      <returns>A <see cref="T:NodaTime.Duration" /> representing the given number of milliseconds.</returns>
    </member>
    <member name="M:NodaTime.Duration.FromTicks(System.Int64)">
      <summary>
            Returns a <see cref="T:NodaTime.Duration" /> that represents the given number of ticks.
            </summary>
      <param name="ticks">The number of ticks.</param>
      <returns>A <see cref="T:NodaTime.Duration" /> representing the given number of ticks.</returns>
    </member>
    <member name="M:NodaTime.Duration.FromTimeSpan(System.TimeSpan)">
      <summary>
            Returns a <see cref="T:NodaTime.Duration" /> that represents the same number of ticks as the
            given <see cref="T:System.TimeSpan" />.
            </summary>
      <param name="timeSpan">The TimeSpan value to convert</param>
      <returns>A new Duration with the same number of ticks as the given TimeSpan.</returns>
    </member>
    <member name="M:NodaTime.Duration.ToTimeSpan">
      <summary>
            Returns a <see cref="T:System.TimeSpan" /> that represents the same number of ticks as this
            <see cref="T:NodaTime.Duration" />.
            </summary>
      <returns>A new TimeSpan with the same number of ticks as this Duration.</returns>
    </member>
    <member name="M:NodaTime.Duration.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Private constructor only present for serialization.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to fetch data from.</param>
      <param name="context">The source for this deserialization.</param>
    </member>
    <member name="P:NodaTime.Duration.Ticks">
      <summary>
            The total number of ticks in the duration.
            </summary>
      <remarks>
            This property effectively represents all of the information within a Duration value; a duration
            is simply a number of ticks.
            </remarks>
    </member>
    <member name="T:NodaTime.Instant">
      <summary>
            Represents an instant on the global timeline.
            </summary>
      <remarks>
        <para>
            An instant is defined by an integral number of 'ticks' since the Unix epoch (typically described as January 1st
            1970, midnight, UTC, ISO calendar), where a tick is equal to 100 nanoseconds. There are 10,000 ticks in a
            millisecond.
            </para>
        <para>
            An <see cref="T:NodaTime.Instant" /> has no concept of a particular time zone or calendar: it simply represents a point in
            time that can be globally agreed-upon.
            </para>
      </remarks>
      <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="F:NodaTime.Instant.MinValue">
      <summary>
            Represents the smallest possible <see cref="T:NodaTime.Instant" />.
            </summary>
      <remarks>
            Within Noda Time, this is also used to represent 'the beginning of time'.
            </remarks>
    </member>
    <member name="F:NodaTime.Instant.MaxValue">
      <summary>
            Represents the largest possible <see cref="T:NodaTime.Instant" />.
            </summary>
      <remarks>
            Within Noda Time, this is also used to represent 'the end of time'.
            </remarks>
    </member>
    <member name="M:NodaTime.Instant.#ctor(System.Int64)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Instant" /> struct.
            </summary>
      <remarks>
            Note that while the Noda Time <see cref="T:NodaTime.Instant" /> type and BCL <see cref="T:System.DateTime" /> and
            <see cref="T:System.DateTimeOffset" /> types are all defined in terms of a number of ticks, they use different
            origins: the Noda Time types count ticks from the Unix epoch (the start of 1970 AD), while the BCL types
            count from the start of 1 AD. This constructor requires the former; to convert from a number-of-ticks since
            the BCL epoch, construct a <see cref="T:System.DateTime" /> first, then use <see cref="M:NodaTime.Instant.FromDateTimeUtc(System.DateTime)" />.
            </remarks>
      <param name="ticks">The number of ticks since the Unix epoch. Negative values represent instants before the
            Unix epoch.</param>
    </member>
    <member name="M:NodaTime.Instant.CompareTo(NodaTime.Instant)">
      <summary>
            Compares the current object with another object of the same type.
            </summary>
      <param name="other">An object to compare with this object.</param>
      <returns>
              A 32-bit signed integer that indicates the relative order of the objects being compared.
              The return value has the following meanings:
              <list type="table"><listheader><term>Value</term><description>Meaning</description></listheader><item><term>&lt; 0</term><description>This object is less than the <paramref name="other" /> parameter.</description></item><item><term>0</term><description>This object is equal to <paramref name="other" />.</description></item><item><term>&gt; 0</term><description>This object is greater than <paramref name="other" />.</description></item></list></returns>
    </member>
    <member name="M:NodaTime.Instant.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NodaTime.Instant.GetHashCode">
      <summary>
              Returns a hash code for this instance.
            </summary>
      <returns>
              A hash code for this instance, suitable for use in hashing algorithms and data
              structures like a hash table. 
            </returns>
    </member>
    <member name="M:NodaTime.Instant.PlusTicks(System.Int64)">
      <summary>
            Returns a new value of this instant with the given number of ticks added to it.
            </summary>
      <param name="ticksToAdd">The ticks to add to this instant to create the return value.</param>
      <returns>The result of adding the given number of ticks to this instant.</returns>
    </member>
    <member name="M:NodaTime.Instant.op_Addition(NodaTime.Instant,NodaTime.Duration)">
      <summary>
            Implements the operator + (addition) for <see cref="T:NodaTime.Instant" /> + <see cref="T:NodaTime.Duration" />.
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>A new <see cref="T:NodaTime.Instant" /> representing the sum of the given values.</returns>
    </member>
    <member name="M:NodaTime.Instant.Plus(NodaTime.Offset)">
      <summary>
            Adds the given offset to this instant, to return a <see cref="T:NodaTime.LocalInstant" />.
            </summary>
      <remarks>
            This was previously an operator+ implementation, but operators can't be internal.
            </remarks>
      <param name="offset">The right hand side of the operator.</param>
      <returns>A new <see cref="T:NodaTime.LocalInstant" /> representing the sum of the given values.</returns>
    </member>
    <member name="M:NodaTime.Instant.Add(NodaTime.Instant,NodaTime.Duration)">
      <summary>
            Adds a duration to an instant. Friendly alternative to <c>operator+()</c>.
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>A new <see cref="T:NodaTime.Instant" /> representing the sum of the given values.</returns>
    </member>
    <member name="M:NodaTime.Instant.Plus(NodaTime.Duration)">
      <summary>
            Returns the result of adding a duration to this instant, for a fluent alternative to <c>operator+()</c>.
            </summary>
      <param name="duration">The duration to add</param>
      <returns>A new <see cref="T:NodaTime.Instant" /> representing the result of the addition.</returns>
    </member>
    <member name="M:NodaTime.Instant.op_Subtraction(NodaTime.Instant,NodaTime.Instant)">
      <summary>
              Implements the operator - (subtraction) for <see cref="T:NodaTime.Instant" /> - <see cref="T:NodaTime.Instant" />.
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>A new <see cref="T:NodaTime.Instant" /> representing the difference of the given values.</returns>
    </member>
    <member name="M:NodaTime.Instant.op_Subtraction(NodaTime.Instant,NodaTime.Duration)">
      <summary>
            Implements the operator - (subtraction) for <see cref="T:NodaTime.Instant" /> - <see cref="T:NodaTime.Duration" />.
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>A new <see cref="T:NodaTime.Instant" /> representing the difference of the given values.</returns>
    </member>
    <member name="M:NodaTime.Instant.Subtract(NodaTime.Instant,NodaTime.Instant)">
      <summary>
              Subtracts one instant from another. Friendly alternative to <c>operator-()</c>.
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>A new <see cref="T:NodaTime.Duration" /> representing the difference of the given values.</returns>
    </member>
    <member name="M:NodaTime.Instant.Minus(NodaTime.Instant)">
      <summary>
            Returns the result of subtracting another instant from this one, for a fluent alternative to <c>operator-()</c>.
            </summary>
      <param name="other">The other instant to subtract</param>
      <returns>A new <see cref="T:NodaTime.Instant" /> representing the result of the subtraction.</returns>
    </member>
    <member name="M:NodaTime.Instant.Subtract(NodaTime.Instant,NodaTime.Duration)">
      <summary>
            Subtracts a duration from an instant. Friendly alternative to <c>operator-()</c>.
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>A new <see cref="T:NodaTime.Instant" /> representing the difference of the given values.</returns>
    </member>
    <member name="M:NodaTime.Instant.Minus(NodaTime.Duration)">
      <summary>
            Returns the result of subtracting a duration from this instant, for a fluent alternative to <c>operator-()</c>.
            </summary>
      <param name="duration">The duration to subtract</param>
      <returns>A new <see cref="T:NodaTime.Instant" /> representing the result of the subtraction.</returns>
    </member>
    <member name="M:NodaTime.Instant.op_Equality(NodaTime.Instant,NodaTime.Instant)">
      <summary>
              Implements the operator == (equality).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.Instant.op_Inequality(NodaTime.Instant,NodaTime.Instant)">
      <summary>
              Implements the operator != (inequality).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.Instant.op_LessThan(NodaTime.Instant,NodaTime.Instant)">
      <summary>
              Implements the operator &lt; (less than).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if the left value is less than the right value, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.Instant.op_LessThanOrEqual(NodaTime.Instant,NodaTime.Instant)">
      <summary>
              Implements the operator &lt;= (less than or equal).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if the left value is less than or equal to the right value, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.Instant.op_GreaterThan(NodaTime.Instant,NodaTime.Instant)">
      <summary>
              Implements the operator &gt; (greater than).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if the left value is greater than the right value, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.Instant.op_GreaterThanOrEqual(NodaTime.Instant,NodaTime.Instant)">
      <summary>
              Implements the operator &gt;= (greater than or equal).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if the left value is greater than or equal to the right value, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.Instant.FromUtc(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Returns a new instant corresponding to the given UTC date and time in the ISO calendar.
            In most cases applications should use <see cref="T:NodaTime.ZonedDateTime" /> to represent a date
            and time, but this method is useful in some situations where an <see cref="T:NodaTime.Instant" /> is
            required, such as time zone testing.
            </summary>
      <param name="year">The year. This is the "absolute year",
            so a value of 0 means 1 BC, for example.</param>
      <param name="monthOfYear">The month of year.</param>
      <param name="dayOfMonth">The day of month.</param>
      <param name="hourOfDay">The hour.</param>
      <param name="minuteOfHour">The minute.</param>
      <returns>An <see cref="T:NodaTime.Instant" /> value representing the given date and time in UTC and the ISO calendar.</returns>
    </member>
    <member name="M:NodaTime.Instant.FromUtc(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Returns a new instant corresponding to the given UTC date and
            time in the ISO calendar. In most cases applications should 
            use <see cref="T:NodaTime.ZonedDateTime" />
            to represent a date and time, but this method is useful in some 
            situations where an Instant is required, such as time zone testing.
            </summary>
      <param name="year">The year. This is the "absolute year",
            so a value of 0 means 1 BC, for example.</param>
      <param name="monthOfYear">The month of year.</param>
      <param name="dayOfMonth">The day of month.</param>
      <param name="hourOfDay">The hour.</param>
      <param name="minuteOfHour">The minute.</param>
      <param name="secondOfMinute">The second.</param>
      <returns>An <see cref="T:NodaTime.Instant" /> value representing the given date and time in UTC and the ISO calendar.</returns>
    </member>
    <member name="M:NodaTime.Instant.Max(NodaTime.Instant,NodaTime.Instant)">
      <summary>
            Returns the later instant of the given two.
            </summary>
      <param name="x">The first instant to compare.</param>
      <param name="y">The second instant to compare.</param>
      <returns>The later instant of <paramref name="x" /> or <paramref name="y" />.</returns>
    </member>
    <member name="M:NodaTime.Instant.Min(NodaTime.Instant,NodaTime.Instant)">
      <summary>
            Returns the earlier instant of the given two.
            </summary>
      <param name="x">The first instant to compare.</param>
      <param name="y">The second instant to compare.</param>
      <returns>The earlier instant of <paramref name="x" /> or <paramref name="y" />.</returns>
    </member>
    <member name="M:NodaTime.Instant.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            The value of the current instance in the default format pattern ("g"), using the current thread's
            culture to obtain a format provider.
            </returns>
    </member>
    <member name="M:NodaTime.Instant.ToString(System.String,System.IFormatProvider)">
      <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
      <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
      <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("g").
            </param>
      <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:NodaTime.Instant.Equals(NodaTime.Instant)">
      <summary>
            Indicates whether the value of this instant is equal to the value of the specified instant.
            </summary>
      <param name="other">The value to compare with this instance.</param>
      <returns>
            true if the value of this instant is equal to the value of the <paramref name="other" /> parameter;
            otherwise, false.
            </returns>
    </member>
    <member name="M:NodaTime.Instant.ToDateTimeUtc">
      <summary>
            Constructs a <see cref="T:System.DateTime" /> from this Instant which has a <see cref="P:System.DateTime.Kind" />
            of <see cref="F:System.DateTimeKind.Utc" /> and represents the same instant of time as this value.
            </summary>
      <returns>A <see cref="T:System.DateTime" /> representing the same instant in time as this value, with a kind of "universal".</returns>
    </member>
    <member name="M:NodaTime.Instant.ToDateTimeOffset">
      <summary>
            Constructs a <see cref="T:System.DateTimeOffset" /> from this Instant which has an offset of zero.
            </summary>
      <returns>A <see cref="T:System.DateTimeOffset" /> representing the same instant in time as this value.</returns>
    </member>
    <member name="M:NodaTime.Instant.FromDateTimeOffset(System.DateTimeOffset)">
      <summary>
            Converts a <see cref="T:System.DateTimeOffset" /> into a new Instant representing the same instant in time. Note that
            the offset information is not preserved in the returned Instant.
            </summary>
      <returns>An <see cref="T:NodaTime.Instant" /> value representing the same instant in time as the given <see cref="T:System.DateTimeOffset" />.</returns>
      <param name="dateTimeOffset">Date and time value with an offset.</param>
    </member>
    <member name="M:NodaTime.Instant.FromDateTimeUtc(System.DateTime)">
      <summary>
            Converts a <see cref="T:System.DateTime" /> into a new Instant representing the same instant in time.
            </summary>
      <returns>An <see cref="T:NodaTime.Instant" /> value representing the same instant in time as the given universal <see cref="T:System.DateTime" />.</returns>
      <param name="dateTime">Date and time value which must have a <see cref="P:System.DateTime.Kind" /> of <see cref="F:System.DateTimeKind.Utc" /></param>
      <exception cref="T:System.ArgumentException">
        <paramref name="dateTime" /> is not of <see cref="P:System.DateTime.Kind" /><see cref="F:System.DateTimeKind.Utc" />.</exception>
    </member>
    <member name="M:NodaTime.Instant.FromSecondsSinceUnixEpoch(System.Int64)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Instant" /> struct based
            on a number of seconds since the Unix epoch of (ISO) January 1st 1970, midnight, UTC.
            </summary>
      <param name="seconds">Number of seconds since the Unix epoch. May be negative (for instants before the epoch).</param>
      <returns>An <see cref="T:NodaTime.Instant" /> at exactly the given number of seconds since the Unix epoch.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The constructed instant would be out of the range representable in Noda Time.</exception>
    </member>
    <member name="M:NodaTime.Instant.FromMillisecondsSinceUnixEpoch(System.Int64)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Instant" /> struct based
            on a number of milliseconds since the Unix epoch of (ISO) January 1st 1970, midnight, UTC.
            </summary>
      <param name="milliseconds">Number of milliseconds since the Unix epoch. May be negative (for instants before the epoch).</param>
      <returns>An <see cref="T:NodaTime.Instant" /> at exactly the given number of milliseconds since the Unix epoch.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The constructed instant would be out of the range representable in Noda Time.</exception>
    </member>
    <member name="M:NodaTime.Instant.FromTicksSinceUnixEpoch(System.Int64)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Instant" /> struct based
            on a number of ticks since the Unix epoch of (ISO) January 1st 1970, midnight, UTC.
            </summary>
      <remarks>This is equivalent to calling the constructor directly, but indicates
            intent more explicitly.</remarks>
      <returns>An <see cref="T:NodaTime.Instant" /> at exactly the given number of ticks since the Unix epoch.</returns>
      <param name="ticks">Number of ticks since the Unix epoch. May be negative (for instants before the epoch).</param>
    </member>
    <member name="M:NodaTime.Instant.InUtc">
      <summary>
            Returns the <see cref="T:NodaTime.ZonedDateTime" /> representing the same point in time as this instant, in the UTC time
            zone and ISO-8601 calendar. This is a shortcut for calling <see cref="M:NodaTime.Instant.InZone(NodaTime.DateTimeZone)" /> with an
            argument of <see cref="P:NodaTime.DateTimeZone.Utc" />.
            </summary>
      <returns>A <see cref="T:NodaTime.ZonedDateTime" /> for the same instant, in the UTC time zone
            and the ISO-8601 calendar</returns>
    </member>
    <member name="M:NodaTime.Instant.InZone(NodaTime.DateTimeZone)">
      <summary>
            Returns the <see cref="T:NodaTime.ZonedDateTime" /> representing the same point in time as this instant, in the
            specified time zone and ISO-8601 calendar.
            </summary>
      <param name="zone">The time zone in which to represent this instant.</param>
      <returns>A <see cref="T:NodaTime.ZonedDateTime" /> for the same instant, in the given time zone
            and the ISO-8601 calendar</returns>
    </member>
    <member name="M:NodaTime.Instant.InZone(NodaTime.DateTimeZone,NodaTime.CalendarSystem)">
      <summary>
            Returns the <see cref="T:NodaTime.ZonedDateTime" /> representing the same point in time as this instant, in the
            specified time zone and calendar system.
            </summary>
      <param name="zone">The time zone in which to represent this instant.</param>
      <param name="calendar">The calendar system in which to represent this instant.</param>
      <returns>A <see cref="T:NodaTime.ZonedDateTime" /> for the same instant, in the given time zone
            and calendar</returns>
    </member>
    <member name="M:NodaTime.Instant.WithOffset(NodaTime.Offset)">
      <summary>
            Returns the <see cref="T:NodaTime.OffsetDateTime" /> representing the same point in time as this instant, with
            the specified UTC offset in the ISO calendar system.
            </summary>
      <param name="offset">The offset from UTC with which to represent this instant.</param>
      <returns>An <see cref="T:NodaTime.OffsetDateTime" /> for the same instant, with the given offset
            in the ISO calendar system</returns>
    </member>
    <member name="M:NodaTime.Instant.WithOffset(NodaTime.Offset,NodaTime.CalendarSystem)">
      <summary>
            Returns the <see cref="T:NodaTime.OffsetDateTime" /> representing the same point in time as this instant, with
            the specified UTC offset and calendar system.
            </summary>
      <param name="offset">The offset from UTC with which to represent this instant.</param>
      <param name="calendar">The calendar system in which to represent this instant.</param>
      <returns>An <see cref="T:NodaTime.OffsetDateTime" /> for the same instant, with the given offset
            and calendar</returns>
    </member>
    <member name="M:NodaTime.Instant.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Private constructor only present for serialization.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to fetch data from.</param>
      <param name="context">The source for this deserialization.</param>
    </member>
    <member name="P:NodaTime.Instant.Ticks">
      <summary>
            The number of ticks since the Unix epoch. Negative values represent instants before the Unix epoch.
            </summary>
      <remarks>
            A tick is equal to 100 nanoseconds. There are 10,000 ticks in a millisecond.
            </remarks>
    </member>
    <member name="T:NodaTime.Interval">
      <summary>
            An interval between two instants in time (start and end).
            </summary>
      <remarks>
        <para>
            The interval includes the start instant and excludes the end instant, unless the end instant
            is <see cref="F:NodaTime.Instant.MaxValue" /> in which case it's deemed to be inclusive.
            (An interval stretching to infinity includes the end of time.)
            </para>
        <para>
            The end may equal the start (resulting in an empty interval), but will not be before the start.
            </para>
      </remarks>
      <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="F:NodaTime.Interval.start">
      <summary>The start of the interval.</summary>
    </member>
    <member name="F:NodaTime.Interval.end">
      <summary>The end of the interval. This will never be earlier than the start.</summary>
    </member>
    <member name="M:NodaTime.Interval.#ctor(NodaTime.Instant,NodaTime.Instant)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Interval" /> struct.
            The interval includes the <paramref name="start" /> instant and excludes the
            <paramref name="end" /> instant. The end may equal the start (resulting in an empty interval), but must not be before the start.
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="end" /> is earlier than <paramref name="start" />.</exception>
      <param name="start">The start <see cref="T:NodaTime.Instant" />.</param>
      <param name="end">The end <see cref="T:NodaTime.Instant" />.</param>
    </member>
    <member name="M:NodaTime.Interval.Contains(NodaTime.Instant)">
      <summary>
            Returns whether or not this interval contains the given instant.
            </summary>
      <remarks>
            The interval is considered to include the <see cref="P:NodaTime.Interval.Start" /> instant but
            not the <see cref="P:NodaTime.Interval.End" /> instant - unless the end is <see cref="F:NodaTime.Instant.MaxValue" />, in
            which case it's considered to be infinite from the start point onwards.
            </remarks>
      <param name="instant">Instant to test.</param>
      <returns>True if this interval contains the given instant; false otherwise.</returns>
    </member>
    <member name="M:NodaTime.Interval.Equals(NodaTime.Interval)">
      <summary>
            Indicates whether the value of this interval is equal to the value of the specified interval.
            </summary>
      <param name="other">The value to compare with this instance.</param>
      <returns>
            true if the value of this instant is equal to the value of the <paramref name="other" /> parameter;
            otherwise, false.
            </returns>
    </member>
    <member name="M:NodaTime.Interval.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NodaTime.Interval.GetHashCode">
      <summary>
            Returns the hash code for this instance.
            </summary>
      <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:NodaTime.Interval.ToString">
      <summary>
            Returns a string representation of this interval, in extended ISO-8601 format: the format
            is "start/end" where each instant uses a format of "yyyy'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFF'Z'".
            </summary>
      <returns>A string representation of this interval.</returns>
    </member>
    <member name="M:NodaTime.Interval.op_Equality(NodaTime.Interval,NodaTime.Interval)">
      <summary>
            Implements the operator ==.
            </summary>
      <param name="left">The left.</param>
      <param name="right">The right.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:NodaTime.Interval.op_Inequality(NodaTime.Interval,NodaTime.Interval)">
      <summary>
            Implements the operator !=.
            </summary>
      <param name="left">The left.</param>
      <param name="right">The right.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:NodaTime.Interval.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Private constructor only present for serialization.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to fetch data from.</param>
      <param name="context">The source for this deserialization.</param>
    </member>
    <member name="P:NodaTime.Interval.Start">
      <summary>
            Gets the start instant - the inclusive lower bound of the interval.
            </summary>
      <remarks>
            This will never be later than <see cref="P:NodaTime.Interval.End" />, though it may be equal to it.
            </remarks>
      <value>The start <see cref="T:NodaTime.Instant" />.</value>
    </member>
    <member name="P:NodaTime.Interval.End">
      <summary>
            Gets the end instant - the exclusive upper bound of the interval.
            </summary>
      <remarks>
            This will never be earlier than <see cref="P:NodaTime.Interval.Start" />, though it may be equal to it.
            If this value is <see cref="F:NodaTime.Instant.MaxValue" />, it is treated as an inclusive
            upper bound: an interval stretching to infinity includes the end of time.
            </remarks>
      <value>The end <see cref="T:NodaTime.Instant" />.</value>
    </member>
    <member name="P:NodaTime.Interval.Duration">
      <summary>
            Returns the duration of the interval.
            </summary>
      <remarks>
            This will always be a non-negative duration, though it may be zero.
            </remarks>
      <value>The duration of the interval.</value>
    </member>
    <member name="T:NodaTime.NodaConstants">
      <summary>
            Useful constants, mostly along the lines of "number of milliseconds in an hour".
            </summary>
    </member>
    <member name="F:NodaTime.NodaConstants.TicksPerMillisecond">
      <summary>
            A constant for the number of ticks in a millisecond. The value of this constant is 10,000.
            </summary>
    </member>
    <member name="F:NodaTime.NodaConstants.TicksPerSecond">
      <summary>
            A constant for the number of ticks in a second. The value of this constant is 10,000,000.
            </summary>
    </member>
    <member name="F:NodaTime.NodaConstants.TicksPerMinute">
      <summary>
            A constant for the number of ticks in a minute. The value of this constant is 600,000,000.
            </summary>
    </member>
    <member name="F:NodaTime.NodaConstants.TicksPerHour">
      <summary>
            A constant for the number of ticks in an hour. The value of this constant is 36,000,000,000.
            </summary>
    </member>
    <member name="F:NodaTime.NodaConstants.TicksPerStandardDay">
      <summary>
            A constant for the number of ticks in a standard 24-hour day.
            The value of this constant is 864,000,000,000.
            </summary>
    </member>
    <member name="F:NodaTime.NodaConstants.TicksPerStandardWeek">
      <summary>
            A constant for the number of ticks in a standard week of seven 24-hour days.
            The value of this constant is 6,048,000,000,000.
            </summary>
    </member>
    <member name="F:NodaTime.NodaConstants.MillisecondsPerSecond">
      <summary>
            A constant for the number of milliseconds per second.
            The value of this constant is 1000.
            </summary>
    </member>
    <member name="F:NodaTime.NodaConstants.MillisecondsPerMinute">
      <summary>
            A constant for the number of milliseconds per minute.
            The value of this constant is 60,000.
            </summary>
    </member>
    <member name="F:NodaTime.NodaConstants.MillisecondsPerHour">
      <summary>
            A constant for the number of milliseconds per hour.
            The value of this constant is 3,600,000.
            </summary>
    </member>
    <member name="F:NodaTime.NodaConstants.MillisecondsPerStandardDay">
      <summary>
            A constant for the number of milliseconds per standard 24-hour day.
            The value of this constant is 86,400,000.
            </summary>
    </member>
    <member name="F:NodaTime.NodaConstants.MillisecondsPerStandardWeek">
      <summary>
            A constant for the number of milliseconds per standard week of seven 24-hour days.
            The value of this constant is 604,800,000.
            </summary>
    </member>
    <member name="F:NodaTime.NodaConstants.SecondsPerMinute">
      <summary>
            A constant for the number of seconds per minute.
            The value of this constant is 60.
            </summary>
    </member>
    <member name="F:NodaTime.NodaConstants.SecondsPerHour">
      <summary>
            A constant for the number of seconds per hour.
            The value of this constant is 3,600.
            </summary>
    </member>
    <member name="F:NodaTime.NodaConstants.SecondsPerStandardDay">
      <summary>
            A constant for the number of seconds per standard 24-hour day.
            The value of this constant is 86,400.
            </summary>
    </member>
    <member name="F:NodaTime.NodaConstants.SecondsPerWeek">
      <summary>
            A constant for the number of seconds per standard week of seven 24-hour days.
            The value of this constant is 604,800.
            </summary>
    </member>
    <member name="F:NodaTime.NodaConstants.MinutesPerHour">
      <summary>
            A constant for the number of minutes per hour.
            The value of this constant is 60.
            </summary>
    </member>
    <member name="F:NodaTime.NodaConstants.MinutesPerStandardDay">
      <summary>
            A constant for the number of minutes per standard 24-hour day.
            The value of this constant is 1,440.
            </summary>
    </member>
    <member name="F:NodaTime.NodaConstants.MinutesPerStandardWeek">
      <summary>
            A constant for the number of minutes per standard week of seven 24-hour days.
            The value of this constant is 10,080.
            </summary>
    </member>
    <member name="F:NodaTime.NodaConstants.HoursPerStandardDay">
      <summary>
            A constant for the number of hours in a standard day. Note that the number of hours
            in a day can vary due to daylight saving effects.
            The value of this constant is 24.
            </summary>
    </member>
    <member name="F:NodaTime.NodaConstants.HoursPerStandardWeek">
      <summary>
            A constant for the number of hours in a standard week of seven 24-hour days.
            The value of this constant is 168.
            </summary>
    </member>
    <member name="F:NodaTime.NodaConstants.DaysPerStandardWeek">
      <summary>
            Number of days in a standard Gregorian week.
            The value of this constant is 7.
            </summary>
    </member>
    <member name="F:NodaTime.NodaConstants.UnixEpoch">
      <summary>
            The instant at the Unix epoch of midnight 1st January 1970 UTC.
            </summary>
      <remarks>
            This value is not only the Unix epoch, but the Noda Time epoch, as it represents the value
            with a <see cref="P:NodaTime.Instant.Ticks" /> property of 0.
            </remarks>
    </member>
    <member name="F:NodaTime.NodaConstants.BclEpoch">
      <summary>
            The instant at the BCL epoch of midnight 1st January 0001 UTC.
            </summary>
    </member>
    <member name="T:NodaTime.ZonedDateTime">
      <summary>
            A <see cref="T:NodaTime.LocalDateTime" /> in a specific time zone and with a particular offset to distinguish
            between otherwise-ambiguous instants. A <see cref="T:NodaTime.ZonedDateTime" /> is global, in that it maps to a single
            <see cref="T:NodaTime.Instant" />.
            </summary>
      <remarks>
        <para>Although <see cref="T:NodaTime.ZonedDateTime" /> includes both local and global concepts, it only supports
            duration-based - and not calendar-based - arithmetic. This avoids ambiguities
            and skipped date/time values becoming a problem within a series of calculations; instead,
            these can be considered just once, at the point of conversion to a <see cref="T:NodaTime.ZonedDateTime" />.
            </para>
        <para>Comparisons of values can be handled in a way which is either calendar and zone sensitive or insensitive.
            Noda Time implements all the operators (and the <see cref="M:NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime)" /> method) such that all operators other than <see cref="M:NodaTime.ZonedDateTime.op_Inequality(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)" />
            will return false if asked to compare two values in different calendar systems or time zones.
            </para>
        <para>
            However, the <see cref="M:NodaTime.ZonedDateTime.CompareTo(NodaTime.ZonedDateTime)" /> method (implementing <see cref="T:System.IComparable`1" />) is calendar and zone insensitive; it compares the two
            global instants in terms of when they actually occurred.
            </para>
        <para>
            It's unclear at the time of this writing whether this is the most appropriate approach, and it may change in future versions. In general,
            it would be a good idea for users to avoid comparing dates in different calendar systems, and indeed most users are unlikely to ever explicitly
            consider which calendar system they're working in anyway.
            </para>
      </remarks>
      <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="T:NodaTime.ZonedDateTime.Comparer">
      <summary>
            Base class for <see cref="T:NodaTime.ZonedDateTime" /> comparers.
            </summary>
      <remarks>
        <para>Use the static properties of this class to obtain instances.</para>
        <para>For the curious: this class only exists so that in the future, it can expose more functionality - probably
            implementing <see cref="T:System.Collections.Generic.IEqualityComparer`1" />. If we simply provided properties on ZonedDateTime of type
            <see cref="T:System.Collections.Generic.IComparer`1" /> we'd have no backward-compatible way of adding to the set of implemented interfaces.</para>
      </remarks>
    </member>
    <member name="M:NodaTime.ZonedDateTime.Comparer.#ctor">
      <summary>
            Internal constructor to prevent external classes from deriving from this.
            (That means we can add more abstract members in the future.)
            </summary>
    </member>
    <member name="M:NodaTime.ZonedDateTime.Comparer.Compare(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
      <summary>
            Compares two <see cref="T:NodaTime.ZonedDateTime" /> values and returns a value indicating whether one is less than, equal to, or greater than the other.
            </summary>
      <param name="x">The first value to compare.</param>
      <param name="y">The second value to compare.</param>
      <returns>A signed integer that indicates the relative values of <paramref name="x" /> and <paramref name="y" />, as shown in the following table.
              <list type="table"><listheader><term>Value</term><description>Meaning</description></listheader><item><term>Less than zero</term><description><paramref name="x" /> is less than <paramref name="y" />.</description></item><item><term>Zero</term><description><paramref name="x" /> is equals to <paramref name="y" />.</description></item><item><term>Greater than zero</term><description><paramref name="x" /> is greater than <paramref name="y" />.</description></item></list></returns>
    </member>
    <member name="P:NodaTime.ZonedDateTime.Comparer.Local">
      <summary>
            Returns a comparer which compares <see cref="T:NodaTime.ZonedDateTime" /> values by their local date/time, without reference to
            the time zone, offset or the calendar system.
            </summary>
      <remarks>
        <para>For example, this comparer considers 2013-03-04T20:21:00 (Europe/London) to be later than
            2013-03-04T19:21:00 (America/Los_Angeles) even though the second value represents a later instant in time.</para>
        <para>This property will return a reference to the same instance every time it is called.</para>
      </remarks>
    </member>
    <member name="P:NodaTime.ZonedDateTime.Comparer.Instant">
      <summary>
            Returns a comparer which compares <see cref="T:NodaTime.ZonedDateTime" /> values by the instants obtained by applying the offset to
            the local date/time, ignoring the calendar system.
            </summary>
      <remarks>
        <para>For example, this comparer considers 2013-03-04T20:21:00 (Europe/London) to be earlier than
            2013-03-04T19:21:00 (America/Los_Angeles) even though the second value has a local time which is earlier; the time zones
            mean that the first value occurred earlier in the universal time line.</para>
        <para>This comparer behaves the same way as the <see cref="M:NodaTime.ZonedDateTime.CompareTo(NodaTime.ZonedDateTime)" /> method; it is provided for symmetry with <see cref="P:NodaTime.ZonedDateTime.Comparer.Local" />.</para>
        <para>This property will return a reference to the same instance every time it is called.</para>
      </remarks>
    </member>
    <member name="T:NodaTime.ZonedDateTime.LocalComparer">
      <summary>
            Implementation for <see cref="P:NodaTime.ZonedDateTime.Comparer.Local" />.
            </summary>
    </member>
    <member name="M:NodaTime.ZonedDateTime.LocalComparer.Compare(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
      <inheritdoc />
    </member>
    <member name="T:NodaTime.ZonedDateTime.InstantComparer">
      <summary>
            Implementation for <see cref="P:NodaTime.ZonedDateTime.Comparer.Instant" />.
            </summary>
    </member>
    <member name="M:NodaTime.ZonedDateTime.InstantComparer.Compare(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
      <inheritdoc />
    </member>
    <member name="M:NodaTime.ZonedDateTime.#ctor(NodaTime.LocalDateTime,NodaTime.Offset,NodaTime.DateTimeZone)">
      <summary>
            Internal constructor used by other code that has already validated and 
            computed the appropriate field values. No further validation is performed.
            </summary>
    </member>
    <member name="M:NodaTime.ZonedDateTime.#ctor(NodaTime.Instant,NodaTime.DateTimeZone,NodaTime.CalendarSystem)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.ZonedDateTime" /> struct.
            </summary>
      <param name="instant">The instant.</param>
      <param name="zone">The time zone.</param>
      <param name="calendar">The calendar system.</param>
    </member>
    <member name="M:NodaTime.ZonedDateTime.#ctor(NodaTime.Instant,NodaTime.DateTimeZone)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.ZonedDateTime" /> struct in the specified time zone
            and the ISO calendar.
            </summary>
      <param name="instant">The instant.</param>
      <param name="zone">The time zone.</param>
    </member>
    <member name="M:NodaTime.ZonedDateTime.#ctor(NodaTime.LocalDateTime,NodaTime.DateTimeZone,NodaTime.Offset)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.ZonedDateTime" /> struct in the specified time zone
            from a given local time and offset. The offset is validated to be correct as part of initialization.
            In most cases a local time can only map to a single instant anyway, but the offset is included here for cases
            where the local time is ambiguous, usually due to daylight saving transitions.
            </summary>
      <param name="localDateTime">The local date and time.</param>
      <param name="zone">The time zone.</param>
      <param name="offset">The offset between UTC and local time at the desired instant.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="offset" /> is not a valid offset at the given
            local date and time.</exception>
    </member>
    <member name="M:NodaTime.ZonedDateTime.ToInstant">
      <summary>
            Converts this value to the instant it represents on the time line.
            </summary>
      <remarks>
            This is always an unambiguous conversion. Any difficulties due to daylight saving
            transitions or other changes in time zone are handled when converting from a
            <see cref="T:NodaTime.LocalDateTime" /> to a <see cref="T:NodaTime.ZonedDateTime" />; the <c>ZonedDateTime</c> remembers
            the actual offset from UTC to local time, so it always knows the exact instant represented.
            </remarks>
      <returns>The instant corresponding to this value.</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.WithZone(NodaTime.DateTimeZone)">
      <summary>
            Creates a new <see cref="T:NodaTime.ZonedDateTime" /> representing the same instant in time, in the
            same calendar but a different time zone.
            </summary>
      <param name="targetZone">The target time zone to convert to.</param>
      <returns>A new value in the target time zone.</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime)">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
      <param name="other">An object to compare with this object.</param>
      <returns>True if the specified value is the same instant in the same time zone; false otherwise.</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.Equals(System.Object)">
      <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
      <returns>
            true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
      <param name="obj">Another object to compare to.</param>
      <filterpriority>2</filterpriority>
      <returns>True if the specified value is a <see cref="T:NodaTime.ZonedDateTime" /> representing the same instant in the same time zone; false otherwise.</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.GetHashCode">
      <summary>
            Computes the hash code for this instance.
            </summary>
      <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:NodaTime.ZonedDateTime.op_Equality(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
      <summary>
            Implements the operator ==.
            </summary>
      <param name="left">The first value to compare</param>
      <param name="right">The second value to compare</param>
      <returns>True if the two operands are equal according to <see cref="M:NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime)" />; false otherwise</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.op_Inequality(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
      <summary>
            Implements the operator !=.
            </summary>
      <param name="left">The first value to compare</param>
      <param name="right">The second value to compare</param>
      <returns>False if the two operands are equal according to <see cref="M:NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime)" />; true otherwise</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.op_LessThan(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
      <summary>
            Compares two <see cref="T:NodaTime.ZonedDateTime" /> values to see if the left one is strictly earlier than the right
            one.
            </summary>
      <remarks>
            This operator always returns false if the two operands have different calendars or time zones.
            See the top-level type documentation for more information about comparisons.
            </remarks>
      <param name="lhs">First operand of the comparison</param>
      <param name="rhs">Second operand of the comparison</param>
      <returns>true if the <paramref name="lhs" /> is strictly earlier than <paramref name="rhs" />, false otherwise.</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.op_LessThanOrEqual(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
      <summary>
            Compares two <see cref="T:NodaTime.ZonedDateTime" /> values to see if the left one is earlier than or equal to the right
            one.
            </summary>
      <remarks>
            This operator always returns false if the two operands have different calendars or time zones.
            See the top-level type documentation for more information about comparisons.
            </remarks>
      <param name="lhs">First operand of the comparison</param>
      <param name="rhs">Second operand of the comparison</param>
      <returns>true if the <paramref name="lhs" /> is earlier than or equal to <paramref name="rhs" />, false otherwise.</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.op_GreaterThan(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
      <summary>
            Compares two <see cref="T:NodaTime.ZonedDateTime" /> values to see if the left one is strictly later than the right
            one.
            </summary>
      <remarks>
            This operator always returns false if the two operands have different calendars or time zones.
            See the top-level type documentation for more information about comparisons.
            </remarks>
      <param name="lhs">First operand of the comparison</param>
      <param name="rhs">Second operand of the comparison</param>
      <returns>true if the <paramref name="lhs" /> is strictly later than <paramref name="rhs" />, false otherwise.</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.op_GreaterThanOrEqual(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
      <summary>
            Compares two <see cref="T:NodaTime.ZonedDateTime" /> values to see if the left one is later than or equal to the right
            one.
            </summary>
      <remarks>
            This operator always returns false if the two operands have different calendars or time zones.
            See the top-level type documentation for more information about comparisons.
            </remarks>
      <param name="lhs">First operand of the comparison</param>
      <param name="rhs">Second operand of the comparison</param>
      <returns>true if the <paramref name="lhs" /> is later than or equal to <paramref name="rhs" />, false otherwise.</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.CompareTo(NodaTime.ZonedDateTime)">
      <summary>
            Indicates whether this date/time is earlier, later or the same as another one.
            </summary>
      <remarks>
            This is purely done in terms of the instant represented; the calendar system and time zone are ignored.
            </remarks>
      <param name="other">The other zoned date/time to compare this one with</param>
      <returns>A value less than zero if the instant represented by this zoned date/time is earlier than the one in
            <paramref name="other" />; zero if the instant is the same as the one in <paramref name="other" />;
            a value greater than zero if the instant is later than the one in <paramref name="other" />.</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.op_Addition(NodaTime.ZonedDateTime,NodaTime.Duration)">
      <summary>
            Returns a new <see cref="T:NodaTime.ZonedDateTime" /> with the time advanced by the given duration. Note that
            due to daylight saving time changes this may not advance the local time by the same amount.
            </summary>
      <remarks>
            The returned value retains the calendar system and time zone of the <see cref="T:NodaTime.ZonedDateTime" />.
            </remarks>
      <param name="zonedDateTime">The <see cref="T:NodaTime.ZonedDateTime" /> to add the duration to.</param>
      <param name="duration">The duration to add.</param>
      <returns>A new value with the time advanced by the given duration, in the same calendar system and time zone.</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.Add(NodaTime.ZonedDateTime,NodaTime.Duration)">
      <summary>
            Adds a duration to a zoned date and time. Friendly alternative to <c>operator+()</c>.
            </summary>
      <param name="zonedDateTime">The value to add the duration to.</param>
      <param name="duration">The duration to add</param>
      <returns>A new value with the time advanced by the given duration, in the same calendar system and time zone.</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.Plus(NodaTime.Duration)">
      <summary>
            Returns the result of adding a duration to this zoned date and time, for a fluent alternative to <c>operator+()</c>.
            </summary>
      <param name="duration">The duration to add</param>
      <returns>A new <see cref="T:NodaTime.ZonedDateTime" /> representing the result of the addition.</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.Subtract(NodaTime.ZonedDateTime,NodaTime.Duration)">
      <summary>
            Subtracts a duration from a zoned date and time. Friendly alternative to <c>operator-()</c>.
            </summary>
      <param name="zonedDateTime">The value to subtract the duration from.</param>
      <param name="duration">The duration to subtract.</param>
      <returns>A new value with the time "rewound" by the given duration, in the same calendar system and time zone.</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.Minus(NodaTime.Duration)">
      <summary>
            Returns the result of subtracting a duration from this zoned date and time, for a fluent alternative to <c>operator-()</c>.
            </summary>
      <param name="duration">The duration to subtract</param>
      <returns>A new <see cref="T:NodaTime.ZonedDateTime" /> representing the result of the subtraction.</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.op_Subtraction(NodaTime.ZonedDateTime,NodaTime.Duration)">
      <summary>
            Returns a new ZonedDateTime with the duration subtracted. Note that
            due to daylight saving time changes this may not change the local time by the same amount.
            </summary>
      <remarks>
            The returned value retains the calendar system and time zone of the <see cref="T:NodaTime.ZonedDateTime" />.
            </remarks>
      <param name="zonedDateTime">The value to subtract the duration from.</param>
      <param name="duration">The duration to subtract.</param>
      <returns>A new value with the time "rewound" by the given duration, in the same calendar system and time zone.</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.GetZoneInterval">
      <summary>
            Returns the <see cref="T:NodaTime.TimeZones.ZoneInterval" /> containing this value, in the time zone this
            value refers to.
            </summary>
      <remarks>
            This is simply a convenience method - it is logically equivalent to converting this
            value to an <see cref="T:NodaTime.Instant" /> and then asking the appropriate <see cref="T:NodaTime.DateTimeZone" />
            for the <c>ZoneInterval</c> containing that instant.
            </remarks>
      <returns>The <c>ZoneInterval</c> containing this value.</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.IsDaylightSavingTime">
      <summary>
            Indicates whether or not this <see cref="T:NodaTime.ZonedDateTime" /> is in daylight saving time
            for its time zone. This is determined by checking the <see cref="P:NodaTime.TimeZones.ZoneInterval.Savings" /> property
            of the zone interval containing this value.
            </summary>
      <seealso cref="M:NodaTime.ZonedDateTime.GetZoneInterval" />
      <returns>
        <code>true</code> if the zone interval containing this value has a non-zero savings
            component; <code>false</code> otherwise.</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            The value of the current instance in the default format pattern ("G"), using the current thread's
            culture to obtain a format provider.
            </returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.ToString(System.String,System.IFormatProvider)">
      <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
      <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
      <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("G").
            </param>
      <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:NodaTime.ZonedDateTime.ToDateTimeOffset">
      <summary>
            Constructs a <see cref="T:System.DateTimeOffset" /> value with the same local time and offset from
            UTC as this value.
            </summary>
      <remarks>
            An offset does not convey as much information as a time zone; a <see cref="T:System.DateTimeOffset" />
            represents an instant in time along with an associated local time, but it doesn't allow you
            to find out what the local time would be for another instant.
            </remarks>
      <returns>A <see cref="T:System.DateTimeOffset" /> representation of this value.</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.FromDateTimeOffset(System.DateTimeOffset)">
      <summary>
            Returns a new <see cref="T:NodaTime.ZonedDateTime" /> representing the same instant in time as the given
            <see cref="T:System.DateTimeOffset" />.
            The time zone used will be a fixed time zone, which uses the same offset throughout time.
            </summary>
      <param name="dateTimeOffset">Date and time value with an offset.</param>
      <returns>A <see cref="T:NodaTime.ZonedDateTime" /> value representing the same instant in time as the given <see cref="T:System.DateTimeOffset" />.</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.ToDateTimeUtc">
      <summary>
            Constructs a <see cref="T:System.DateTime" /> from this <see cref="T:NodaTime.ZonedDateTime" /> which has a
            <see cref="P:System.DateTime.Kind" /> of <see cref="F:System.DateTimeKind.Utc" /> and represents the same instant of time as
            this value rather than the same local time.
            </summary>
      <returns>A <see cref="T:System.DateTime" /> representation of this value with a "universal" kind, with the same
            instant of time as this value.</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.ToDateTimeUnspecified">
      <summary>
            Constructs a <see cref="T:System.DateTime" /> from this <see cref="T:NodaTime.ZonedDateTime" /> which has a
            <see cref="P:System.DateTime.Kind" /> of <see cref="F:System.DateTimeKind.Unspecified" /> and represents the same local time as
            this value rather than the same instant in time.
            </summary>
      <remarks>
        <see cref="F:System.DateTimeKind.Unspecified" /> is slightly odd - it can be treated as UTC if you use <see cref="M:System.DateTime.ToLocalTime" />
            or as system local time if you use <see cref="M:System.DateTime.ToUniversalTime" />, but it's the only kind which allows
            you to construct a <see cref="T:System.DateTimeOffset" /> with an arbitrary offset.
            </remarks>
      <returns>A <see cref="T:System.DateTime" /> representation of this value with an "unspecified" kind, with the same
            local date and time as this value.</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.ToOffsetDateTime">
      <summary>
            Constructs an <see cref="T:NodaTime.OffsetDateTime" /> with the same local date and time, and the same offset
            as this zoned date and time, effectively just "removing" the time zone itself.
            </summary>
      <returns>An OffsetDateTime with the same local date/time and offset as this value.</returns>
    </member>
    <member name="M:NodaTime.ZonedDateTime.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Private constructor only present for serialization.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to fetch data from.</param>
      <param name="context">The source for this deserialization.</param>
    </member>
    <member name="P:NodaTime.ZonedDateTime.Offset">
      <summary>Gets the offset of the local representation of this value from UTC.</summary>
    </member>
    <member name="P:NodaTime.ZonedDateTime.Zone">
      <summary>Gets the time zone associated with this value.</summary>
    </member>
    <member name="P:NodaTime.ZonedDateTime.LocalInstant">
      <summary>Gets the local instant associated with this value.</summary>
    </member>
    <member name="P:NodaTime.ZonedDateTime.LocalDateTime">
      <summary>
            Gets the local date and time represented by this zoned date and time. The returned
            <see cref="T:NodaTime.LocalDateTime" /> will have the same calendar system and return the same values for
            each of the calendar properties (Year, MonthOfYear and so on), but will not be associated with any
            particular time zone.
            </summary>
    </member>
    <member name="P:NodaTime.ZonedDateTime.Calendar">
      <summary>Gets the calendar system associated with this zoned date and time.</summary>
    </member>
    <member name="P:NodaTime.ZonedDateTime.Date">
      <summary>
            Gets the local date represented by this zoned date and time. The returned <see cref="T:NodaTime.LocalDate" />
            will have the same calendar system and return the same values for each of the date-based calendar
            properties (Year, MonthOfYear and so on), but will not be associated with any particular time zone.
            </summary>
    </member>
    <member name="P:NodaTime.ZonedDateTime.TimeOfDay">
      <summary>
            Gets the time portion of this zoned date and time. The returned <see cref="T:NodaTime.LocalTime" /> will
            return the same values for each of the time-based properties (Hour, Minute and so on), but
            will not be associated with any particular time zone.
            </summary>
    </member>
    <member name="P:NodaTime.ZonedDateTime.Era">
      <summary>Gets the era for this zoned date and time.</summary>
    </member>
    <member name="P:NodaTime.ZonedDateTime.CenturyOfEra">
      <summary>Gets the century within the era of this zoned date and time.</summary>
    </member>
    <member name="P:NodaTime.ZonedDateTime.Year">
      <summary>Gets the year of this zoned date and time.</summary>
      <remarks>This returns the "absolute year", so, for the ISO calendar,
            a value of 0 means 1 BC, for example.</remarks>
    </member>
    <member name="P:NodaTime.ZonedDateTime.YearOfCentury">
      <summary>Gets the year of this zoned date and time within its century.</summary>
      <remarks>This always returns a value in the range 0 to 99 inclusive.</remarks>
    </member>
    <member name="P:NodaTime.ZonedDateTime.YearOfEra">
      <summary>Gets the year of this zoned date and time within its era.</summary>
    </member>
    <member name="P:NodaTime.ZonedDateTime.WeekYear">
      <summary>
            Gets the "week year" of this date and time.
            </summary>
      <remarks>
        <para>
            The WeekYear is the year that matches with the <see cref="P:NodaTime.ZonedDateTime.WeekOfWeekYear" /> field.
            In the standard ISO-8601 week algorithm, the first week of the year
            is that in which at least 4 days are in the year. As a result of this
            definition, day 1 of the first week may be in the previous year.
            The WeekYear allows you to query the effective year for that day.
            </para>
        <para>
            For example, January 1st 2011 was a Saturday, so only two days of that week
            (Saturday and Sunday) were in 2011. Therefore January 1st is part of
            week 52 of WeekYear 2010. Conversely, December 31st 2012 is a Monday,
            so is part of week 1 of WeekYear 2013.
            </para>
      </remarks>
    </member>
    <member name="P:NodaTime.ZonedDateTime.Month">
      <summary>Gets the month of this zoned date and time within the year.</summary>
    </member>
    <member name="P:NodaTime.ZonedDateTime.WeekOfWeekYear">
      <summary>Gets the week within the WeekYear. See <see cref="P:NodaTime.ZonedDateTime.WeekYear" /> for more details.</summary>
    </member>
    <member name="P:NodaTime.ZonedDateTime.DayOfYear">
      <summary>Gets the day of this zoned date and time within the year.</summary>
    </member>
    <member name="P:NodaTime.ZonedDateTime.Day">
      <summary>
            Gets the day of this zoned date and time within the month.
            </summary>
    </member>
    <member name="P:NodaTime.ZonedDateTime.IsoDayOfWeek">
      <summary>
            Gets the week day of this zoned date and time expressed as an <see cref="T:NodaTime.IsoDayOfWeek" /> value,
            for calendars which use ISO days of the week.
            </summary>
      <exception cref="T:System.InvalidOperationException">The underlying calendar doesn't use ISO days of the week.</exception>
      <seealso cref="P:NodaTime.ZonedDateTime.DayOfWeek" />
    </member>
    <member name="P:NodaTime.ZonedDateTime.DayOfWeek">
      <summary>
            Gets the week day of this zoned date and time as a number.
            </summary>
      <remarks>
            For calendars using ISO week days, this gives 1 for Monday to 7 for Sunday.
            </remarks>
      <seealso cref="P:NodaTime.ZonedDateTime.IsoDayOfWeek" />
    </member>
    <member name="P:NodaTime.ZonedDateTime.Hour">
      <summary>
            Gets the hour of day of this zoned date and time, in the range 0 to 23 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.ZonedDateTime.ClockHourOfHalfDay">
      <summary>
            Gets the hour of the half-day of this zoned date and time, in the range 1 to 12 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.ZonedDateTime.Minute">
      <summary>
            Gets the minute of this zoned date and time, in the range 0 to 59 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.ZonedDateTime.Second">
      <summary>
            Gets the second of this zoned date and time within the minute, in the range 0 to 59 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.ZonedDateTime.Millisecond">
      <summary>
            Gets the millisecond of this zoned date and time within the second, in the range 0 to 999 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.ZonedDateTime.TickOfSecond">
      <summary>
            Gets the tick of this zoned date and time within the second, in the range 0 to 9,999,999 inclusive.
            </summary>
    </member>
    <member name="P:NodaTime.ZonedDateTime.TickOfDay">
      <summary>
            Gets the tick of this zoned date and time within the day, in the range 0 to 863,999,999,999 inclusive.
            </summary>
    </member>
    <member name="T:NodaTime.Utility.BclConversions">
      <summary>
            Conversion methods which don't naturally fit into any other types - for example, for
            enums which can't specify any other code. In most cases, conversions to and from BCL types
            are provided within the type itself - such as <see cref="M:NodaTime.LocalDateTime.ToDateTimeUnspecified" />
            and <see cref="M:NodaTime.LocalDateTime.FromDateTime(System.DateTime)" />.
            </summary>
      <remarks>
            Many of the methods within this class could be expressed as extension methods - but currently
            Noda Time always builds against .NET 2. In a future version, there may be multiple build targets,
            allowing these to become extension methods for the builds which use .NET 3.5 and higher.
            </remarks>
      <threadsafety>All members of this type are thread-safe. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="M:NodaTime.Utility.BclConversions.ToDayOfWeek(NodaTime.IsoDayOfWeek)">
      <summary>
            Converts from the Noda Time <see cref="T:NodaTime.IsoDayOfWeek" /> enum to the equivalent BCL
            <see cref="T:System.DayOfWeek" /> value. Other than Sunday, the BCL and ISO values are the same -
            but ISO 8601 defines Sunday as day 7, and the BCL defines it as day 0.
            </summary>
      <param name="isoDayOfWeek">ISO day of week value to convert.</param>
      <returns>The ISO day of week value equivalent to the one passed in.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="isoDayOfWeek" /> parameter
            is not a valid day of the week.</exception>
    </member>
    <member name="M:NodaTime.Utility.BclConversions.ToIsoDayOfWeek(System.DayOfWeek)">
      <summary>
            Converts from the BCL <see cref="T:System.DayOfWeek" /> enum to the equivalent Noda Time <see cref="T:NodaTime.IsoDayOfWeek" /> value.
            Other than Sunday, the BCL and ISO values are the same - but ISO 8601 defines
            Sunday as day 7, and the BCL defines it as day 0.
            </summary>
      <param name="dayOfWeek">ISO day of week value to convert.</param>
      <returns>The BCL day of week value equivalent to the one passed in.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="dayOfWeek" /> parameter
            is not a valid day of the week.</exception>
    </member>
    <member name="T:NodaTime.Utility.HashCodeHelper">
      <summary>
            Provides method to help with generating hash codes for structures and classes. This handles
            value types, nullable type, and objects.
            </summary>
      <remarks>
            The basic usage pattern is:
            <example><code>
               public override int GetHashCode()
               {
                   int hash = HashCodeHelper.Initialize();
                   hash = HashCodeHelper.Hash(hash, Field1);
                   hash = HashCodeHelper.Hash(hash, Field1);
                   hash = HashCodeHelper.Hash(hash, Field1);
                   ...
                   return hash;
               }
            </code></example></remarks>
    </member>
    <member name="F:NodaTime.Utility.HashCodeHelper.HashcodeMultiplier">
      <summary>
            The multiplier for each value.
            </summary>
    </member>
    <member name="F:NodaTime.Utility.HashCodeHelper.HashcodeInitializer">
      <summary>
            The initial hash value.
            </summary>
    </member>
    <member name="M:NodaTime.Utility.HashCodeHelper.Initialize">
      <summary>
            Returns the initial value for a hash code.
            </summary>
      <returns>The initial interger value.</returns>
    </member>
    <member name="M:NodaTime.Utility.HashCodeHelper.Hash``1(System.Int32,``0)">
      <summary>
            Adds the hash value for the given value to the current hash and returns the new value.
            </summary>
      <typeparam name="T">The type of the value being hashed.</typeparam>
      <param name="code">The previous hash code.</param>
      <param name="value">The value to hash.</param>
      <returns>The new hash code.</returns>
    </member>
    <member name="M:NodaTime.Utility.HashCodeHelper.MakeHash(System.Int32,System.Int32)">
      <summary>
            Adds the hash value for a int to the current hash value and returns the new value.
            </summary>
      <param name="code">The previous hash code.</param>
      <param name="value">The value to add to the hash code.</param>
      <returns>The new hash code.</returns>
    </member>
    <member name="T:NodaTime.Utility.InvalidNodaDataException">
      <summary>
            Exception thrown when data read by Noda Time (such as serialized time zone data) is invalid. This includes
            data which is truncated, i.e. we expect more data than we can read.
            </summary>
      <remarks>
            This type only exists as <c>InvalidDataException</c> doesn't exist in the Portable Class Library.
            Unfortunately, <c>InvalidDataException</c> itself is sealed, so we can't derive from it for the sake
            of backward compatibility.
            </remarks>
      <threadsafety>Any public static members of this type are thread safe. Any instance members are not guaranteed to be thread safe.
            See the thread safety section of the user guide for more information.
            </threadsafety>
    </member>
    <member name="M:NodaTime.Utility.InvalidNodaDataException.#ctor(System.String)">
      <summary>
            Creates an instance with the given message.
            </summary>
      <param name="message">The message for the exception.</param>
    </member>
    <member name="M:NodaTime.Utility.InvalidNodaDataException.#ctor(System.String,System.Exception)">
      <summary>
            Creates an instance with the given message.
            </summary>
      <param name="message">The message for the exception.</param>
      <param name="innerException">Underlying cause of the error.</param>
    </member>
    <member name="T:NodaTime.Utility.Cache`2">
      <summary>
            Implements a thread-safe cache of a fixed size, with a single computation function.
            (That happens to be all we need at the time of writing.)
            </summary>
      <remarks>
            For simplicity's sake, eviction is currently on a least-recently-added basis (not LRU). This
            may change in the future.
            </remarks>
      <typeparam name="TKey">Type of key</typeparam>
      <typeparam name="TValue">Type of value</typeparam>
    </member>
    <member name="M:NodaTime.Utility.Cache`2.GetOrAdd(`0)">
      <summary>
            Fetches a value from the cache, populating it if necessary.
            </summary>
      <param name="key">Key to fetch</param>
      <returns>The value associated with the key.</returns>
    </member>
    <member name="M:NodaTime.Utility.Cache`2.Clear">
      <summary>
            Clears the cache.
            </summary>
    </member>
    <member name="P:NodaTime.Utility.Cache`2.Count">
      <summary>
            Returns the number of entries currently in the cache, primarily for diagnostic purposes.
            </summary>
    </member>
    <member name="P:NodaTime.Utility.Cache`2.Keys">
      <summary>
            Returns a copy of the keys in the cache as a list, for diagnostic purposes.
            </summary>
    </member>
    <member name="T:NodaTime.Utility.NamespaceDoc">
      <summary>
        <para>
            The NodaTime.Utility namespace contains helper classes which don't really fit anywhere else...
            </para>
      </summary>
    </member>
    <member name="T:NodaTime.Utility.NodaReadOnlyDictionary`2">
      <summary>
            Implementation of IDictionary{,} which delegates to an underlying dictionary for read, but 
            doesn't support any mutation operations.
            </summary>
      <remarks>The "Noda" prefix is to avoid any confusion with the BCL ReadOnlyDictionary type
            introduced in .NET 4.5.</remarks>
      <typeparam name="TKey">Key type</typeparam>
      <typeparam name="TValue">Value type</typeparam>
    </member>
    <member name="T:NodaTime.Utility.ReferenceEqualityComparer`1">
      <summary>
            An equality comparer which compares references for equality and uses the "original" object hash code
            for hash codes.
            </summary>
    </member>
    <member name="T:NodaTime.Utility.Preconditions">
      <summary>
            Helper static methods for argument/state validation.
            </summary>
    </member>
    <member name="M:NodaTime.Utility.Preconditions.CheckNotNull``1(``0,System.String)">
      <summary>
            Returns the given argument after checking whether it's null. This is useful for putting
            nullity checks in parameters which are passed to base class constructors.
            </summary>
    </member>
    <member name="T:NodaTime.TimeZones.BclDateTimeZone">
      <summary>
            Representation of a time zone converted from a <see cref="T:System.TimeZoneInfo" /> from the Base Class Library.
            </summary>
      <remarks>
            Note that although this class implements <see cref="T:System.IEquatable`1" /> by virtue of extending
            <see cref="T:NodaTime.DateTimeZone" />, the implementation here will always throw <c>NotImplementedException</c> when asked
            to compare two different <c>BclDateTimeZone</c> instances.
            </remarks>
      <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="T:NodaTime.TimeZones.BclDateTimeZone.AdjustmentInterval">
      <summary>
            Interval covered by an adjustment rule. The start instant is that of the
            first transition reported by this rule, and the seam covers the gap between
            two adjustment rules.
            </summary>
    </member>
    <member name="T:NodaTime.TimeZones.BclDateTimeZone.BclZoneIntervalMap">
      <summary>
            The core part of working out zone intervals; separated into its own type to allow for caching.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.BclDateTimeZone.BclZoneIntervalMap.GetZoneInterval(NodaTime.Instant)">
      <summary>
            Returns the zone interval for the given instant in time. See <see cref="T:NodaTime.ZonedDateTime" /> for more details.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.BclDateTimeZone.systemDefault">
      <summary>
            This is used to cache the last result of a call to <see cref="M:NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault" />, but it doesn't
            matter if it's out of date - we'll just create another wrapper if necessary. It's not *that* expensive to make
            a few more wrappers than we need.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.BclDateTimeZone.LastValidTick">
      <summary>
            This is the last valid tick where we would be able to construct a LocalDateTime.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.BclDateTimeZone.GetZoneInterval(NodaTime.Instant)">
      <inheritdoc />
    </member>
    <member name="M:NodaTime.TimeZones.BclDateTimeZone.FromTimeZoneInfo(System.TimeZoneInfo)">
      <summary>
            Creates a new <see cref="T:NodaTime.TimeZones.BclDateTimeZone" /> from a <see cref="T:System.TimeZoneInfo" /> from the Base Class Library.
            </summary>
      <param name="bclZone">The original time zone to take information from.</param>
      <returns>A <see cref="T:NodaTime.TimeZones.BclDateTimeZone" /> wrapping the given <c>TimeZoneInfo</c>.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.BclDateTimeZone.ComputeHeadInterval(System.TimeZoneInfo,System.TimeZoneInfo.AdjustmentRule)">
      <summary>
            Work out the period of standard time (if any) before the first adjustment rule is applied.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.BclDateTimeZone.GetRecurrences(System.TimeZoneInfo,System.TimeZoneInfo.AdjustmentRule,NodaTime.TimeZones.ZoneRecurrence@,NodaTime.TimeZones.ZoneRecurrence@)">
      <summary>
            Converts the two adjustment rules in <paramref name="rule" /> into two ZoneRecurrences,
            storing them in the out parameters.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault">
      <summary>
            Returns a time zone converted from the BCL representation of the system local time zone.
            </summary>
      <remarks>
        <para>
            This method is approximately equivalent to calling <see cref="M:NodaTime.IDateTimeZoneProvider.GetSystemDefault" /> with
            an implementation that wraps <see cref="T:NodaTime.TimeZones.BclDateTimeZoneSource" /> (e.g.
            <see cref="P:NodaTime.DateTimeZoneProviders.Bcl" />), with the exception that it will succeed even if the current local
            time zone was not one of the set of system time zones captured when the source was created (which, while
            highly unlikely, might occur either because the local time zone is not a system time zone, or because the
            system time zones have themselves changed).
            </para>
        <para>
            This method will retain a reference to the returned <c>BclDateTimeZone</c>, and will attempt to return it if
            called repeatedly (assuming that the local time zone has not changed) rather than creating a new instance,
            though this behaviour is not guaranteed.
            </para>
      </remarks>
      <returns>A <see cref="T:NodaTime.TimeZones.BclDateTimeZone" /> wrapping the "local" (system) time zone as returned by
            <see cref="P:System.TimeZoneInfo.Local" />.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.BclDateTimeZone.EqualsImpl(NodaTime.DateTimeZone)">
      <inheritdoc />
      <remarks>
            This implementation always throws <c>NotImplementedException</c>.
            </remarks>
      <exception cref="T:System.NotImplementedException">Always.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.BclDateTimeZone.GetHashCode">
      <inheritdoc />
    </member>
    <member name="P:NodaTime.TimeZones.BclDateTimeZone.OriginalZone">
      <summary>
            Returns the original <see cref="T:System.TimeZoneInfo" /> from which this was created.
            </summary>
    </member>
    <member name="P:NodaTime.TimeZones.BclDateTimeZone.DisplayName">
      <summary>
            Returns the display name associated with the time zone, as provided by the Base Class Library.
            </summary>
    </member>
    <member name="T:NodaTime.TimeZones.BclDateTimeZoneSource">
      <summary>
            Provides an implementation of <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource" /> that loads data from the BCL
            <see cref="T:System.TimeZoneInfo" /> class.
            </summary>
      <remarks>
        <para>
            All calls to <see cref="M:NodaTime.TimeZones.BclDateTimeZoneSource.ForId(System.String)" /> return instances of <see cref="T:NodaTime.TimeZones.BclDateTimeZone" />, including for fixed-offset IDs
            (i.e. "UTC" and "UTC+/-Offset").
            </para>
        <para>
            This class is not available in the PCL version.
            </para>
      </remarks>
      <threadsafety>This type maintains no state, and all members are thread-safe. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="M:NodaTime.TimeZones.BclDateTimeZoneSource.GetIds">
      <summary>
            Returns the IDs of all system time zones.
            </summary>
      <returns>The IDs available from this source.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.BclDateTimeZoneSource.GetTimeZoneInfoLocalIdOrEmpty">
      <summary>
            Returns an enumerable containing a singleton element of the Id of the local time zone
            (<c>TimeZoneInfo.Local.Id</c>), unless the local time zone is not available, or not a system time zone, in
            which case returns an empty enumerable.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.BclDateTimeZoneSource.ForId(System.String)">
      <summary>
            Creates a new instance of <see cref="T:NodaTime.TimeZones.BclDateTimeZone" /> from the <see cref="T:System.TimeZoneInfo" /> with the given
            ID. The ID must be a known system time zone ID.
            </summary>
      <param name="id">The ID of the system time zone to convert</param>
      <exception cref="T:System.ArgumentException">The given zone doesn't exist.</exception>
      <returns>The Noda Time representation of the given BCL time zone</returns>
    </member>
    <member name="M:NodaTime.TimeZones.BclDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo)">
      <summary>
            Maps the BCL ID to "our" ID as an identity projection.
            </summary>
      <param name="timeZone">The BCL time zone, which must be a known system time zone.</param>
      <returns>
            The ID for the given BCL time zone for this source; that is, the value of the <c>Id</c> property of the
            passed-in <see cref="T:System.TimeZoneInfo" />.
            </returns>
    </member>
    <member name="P:NodaTime.TimeZones.BclDateTimeZoneSource.VersionId">
      <inheritdoc />
      <remarks>
            This source returns a string such as "TimeZoneInfo: 3.5.0.0" corresponding to the version of the assembly
            containing <see cref="T:System.TimeZoneInfo" />.
            </remarks>
    </member>
    <member name="T:NodaTime.TimeZones.CachedDateTimeZone">
      <summary>
             Provides a <see cref="T:NodaTime.DateTimeZone" /> wrapper class that implements a simple cache to
             speed up the lookup of transitions.
            </summary>
      <remarks>
        <para>
            The cache supports multiple caching strategies which are implemented in nested subclasses of
            this one. Until we have a better sense of what the usage behavior is, we cannot tune the
            cache. It is possible that we may support multiple strategies selectable at runtime so the
            user can tune the performance based on their knowledge of how they are using the system.
            </para>
        <para>
            In fact, only one cache type is currently implemented: an MRU cache existed before
            the GetZoneIntervalPair call was created in DateTimeZone, but as it wasn't being used, it
            was more effort than it was worth to update. The mechanism is still available for future
            expansion though.
            </para>
      </remarks>
    </member>
    <member name="M:NodaTime.TimeZones.CachedDateTimeZone.#ctor(NodaTime.DateTimeZone,NodaTime.TimeZones.IZoneIntervalMap)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.CachedDateTimeZone" /> class.
            </summary>
      <param name="timeZone">The time zone to cache.</param>
      <param name="map">The caching map</param>
    </member>
    <member name="M:NodaTime.TimeZones.CachedDateTimeZone.ForZone(NodaTime.DateTimeZone)">
      <summary>
            Returns a cached time zone for the given time zone.
            </summary>
      <remarks>
            If the time zone is already cached or it is fixed then it is returned unchanged.
            </remarks>
      <param name="timeZone">The time zone to cache.</param>
      <returns>The cached time zone.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.CachedDateTimeZone.GetZoneInterval(NodaTime.Instant)">
      <summary>
            Delegates fetching a zone interval to the caching map.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.CachedDateTimeZone.WriteLegacy(NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter)">
      <summary>
            Writes the time zone to the specified writer.
            </summary>
      <param name="writer">The writer to write to.</param>
    </member>
    <member name="M:NodaTime.TimeZones.CachedDateTimeZone.ReadLegacy(NodaTime.TimeZones.IO.LegacyDateTimeZoneReader,System.String)">
      <summary>
            Reads the zone from the specified reader.
            </summary>
      <param name="reader">The reader.</param>
      <param name="id">The id.</param>
      <returns>
      </returns>
    </member>
    <member name="P:NodaTime.TimeZones.CachedDateTimeZone.TimeZone">
      <summary>
            Gets the cached time zone.
            </summary>
      <value>The time zone.</value>
    </member>
    <member name="T:NodaTime.TimeZones.CachingZoneIntervalMap">
      <summary>
            Helper methods for creating IZoneIntervalMaps which cache results.
            </summary>
    </member>
    <member name="T:NodaTime.TimeZones.CachingZoneIntervalMap.CacheType">
      <summary>
            The type of cache to build.
            </summary>
    </member>
    <member name="T:NodaTime.TimeZones.CachingZoneIntervalMap.HashArrayCache">
      <summary>
            This provides a simple cache based on two hash tables (one for local instants, another
            for instants).
            </summary>
      <remarks>
            Each hash table entry is either entry or contains a node with enough
            information for a particular "period" of about 40 days - so multiple calls for time
            zone information within the same few years are likely to hit the cache. Note that
            a single "period" may include a daylight saving change (or conceivably more than one);
            a node therefore has to contain enough intervals to completely represent that period.
            
            If another call is made which maps to the same cache entry number but is for a different
            period, the existing hash entry is simply overridden.
            </remarks>
    </member>
    <member name="M:NodaTime.TimeZones.CachingZoneIntervalMap.HashArrayCache.HashCacheNode.CreateNode(System.Int32,NodaTime.TimeZones.IZoneIntervalMap)">
      <summary>
            Creates a hash table node with all the information for this period.
            We start off by finding the interval for the start of the period, and
            then repeatedly check whether that interval ends after the end of the
            period - at which point we're done. If not, find the next interval, create
            a new node referring to that interval and the previous interval, and keep going.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.CachingZoneIntervalMap.HashArrayCache.HashCacheNode.#ctor(NodaTime.TimeZones.ZoneInterval,System.Int32,NodaTime.TimeZones.CachingZoneIntervalMap.HashArrayCache.HashCacheNode)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.CachingZoneIntervalMap.HashArrayCache.HashCacheNode" /> class.
            </summary>
      <param name="interval">The zone interval.</param>
      <param name="period">
      </param>
      <param name="previous">The previous <see cref="T:NodaTime.TimeZones.CachingZoneIntervalMap.HashArrayCache.HashCacheNode" /> node.</param>
    </member>
    <member name="M:NodaTime.TimeZones.CachingZoneIntervalMap.HashArrayCache.GetZoneInterval(NodaTime.Instant)">
      <summary>
            Gets the zone offset period for the given instant. Null is returned if no period is
            defined by the time zone for the given instant.
            </summary>
      <param name="instant">The Instant to test.</param>
      <returns>The defined ZoneOffsetPeriod or null.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.CachingZoneIntervalMap.CacheMap(NodaTime.TimeZones.IZoneIntervalMap,NodaTime.TimeZones.CachingZoneIntervalMap.CacheType)">
      <summary>
            Returns a caching map for the given input map.
            </summary>
    </member>
    <member name="T:NodaTime.TimeZones.DateTimeZoneCache">
      <summary>
            Provides an implementation of <see cref="T:NodaTime.IDateTimeZoneProvider" /> that caches results from an
            <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource" />.
            </summary>
      <remarks>
            The process of loading or creating time zones may be an expensive operation. This class implements an
            unlimited-size non-expiring cache over a time zone source, and adapts an implementation of the
            <c>IDateTimeZoneSource</c> interface to an <c>IDateTimeZoneProvider</c>.
            </remarks>
      <seealso cref="T:NodaTime.DateTimeZoneProviders" />
      <threadsafety>All members of this type are thread-safe as long as the underlying <c>IDateTimeZoneSource</c>
            implementation is thread-safe.</threadsafety>
    </member>
    <member name="M:NodaTime.TimeZones.DateTimeZoneCache.#ctor(NodaTime.TimeZones.IDateTimeZoneSource)">
      <summary>
            Creates a provider backed by the given <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource" />.
            </summary>
      <remarks>
            Note that the source will never be consulted for requests for the fixed-offset timezones "UTC" and
            "UTC+/-Offset" (a standard implementation will be returned instead). This is true even if these IDs are
            advertised by the source.
            </remarks>
      <param name="source">The <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource" /> for this provider.</param>
      <exception cref="T:NodaTime.TimeZones.InvalidDateTimeZoneSourceException">
        <paramref name="source" /> violates its contract.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.DateTimeZoneCache.GetSystemDefault">
      <inheritdoc />
    </member>
    <member name="M:NodaTime.TimeZones.DateTimeZoneCache.GetZoneOrNull(System.String)">
      <inheritdoc />
    </member>
    <member name="P:NodaTime.TimeZones.DateTimeZoneCache.VersionId">
      <summary>
            The version ID of this provider. This is simply the <see cref="P:NodaTime.TimeZones.IDateTimeZoneSource.VersionId" /> returned by
            the underlying source.
            </summary>
    </member>
    <member name="P:NodaTime.TimeZones.DateTimeZoneCache.Ids">
      <inheritdoc />
    </member>
    <member name="P:NodaTime.TimeZones.DateTimeZoneCache.Item(System.String)">
      <inheritdoc />
    </member>
    <member name="T:NodaTime.TimeZones.DateTimeZoneNotFoundException">
      <summary>
            Exception thrown when time zone is requested from an <see cref="T:NodaTime.IDateTimeZoneProvider" />,
            but the specified ID is invalid for that provider.
            </summary>
      <remarks>
            This type only exists as <c>TimeZoneNotFoundException</c> doesn't exist in the Portable Class Library.
            By creating an exception which derives from <c>TimeZoneNotFoundException</c> on the desktop version
            and <c>Exception</c> on the PCL version, we achieve reasonable consistency while remaining
            backwardly compatible with Noda Time v1 (which was desktop-only, and threw <c>TimeZoneNotFoundException</c>).
            </remarks>
      <threadsafety>Any public static members of this type are thread safe. Any instance members are not guaranteed to be thread safe.
            See the thread safety section of the user guide for more information.
            </threadsafety>
    </member>
    <member name="M:NodaTime.TimeZones.DateTimeZoneNotFoundException.#ctor(System.String)">
      <summary>
            Creates an instance with the given message.
            </summary>
      <param name="message">The message for the exception.</param>
    </member>
    <member name="T:NodaTime.TimeZones.AmbiguousTimeResolver">
      <summary>
            Chooses between two <see cref="T:NodaTime.ZonedDateTime" /> values that resolve to the same <see cref="T:NodaTime.LocalDateTime" />.
            </summary>
      <remarks>
        <para>
            This delegate is used by <see cref="M:NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver,NodaTime.TimeZones.SkippedTimeResolver)" /> when handling an ambiguous local time,
            due to clocks moving backward in a time zone transition (usually due to an autumnal daylight saving transition).
            </para>
        <para>
            The returned value should be one of the two parameter values, based on the policy of the specific
            implementation. Alternatively, it can throw an <see cref="T:NodaTime.AmbiguousTimeException" /> to implement a policy of
            "reject ambiguous times."
            </para>
        <para>See the <see cref="T:NodaTime.TimeZones.Resolvers" /> class for predefined implementations.</para>
        <para>
            Implementations of this delegate can reasonably
            assume that the target local date and time really is ambiguous; the behaviour when the local date and time
            can be unambiguously mapped into the target time zone (or when it's skipped) is undefined.
            </para>
      </remarks>
      <param name="earlier">The earlier of the ambiguous matches for the original local date and time</param>
      <param name="later">The later of the ambiguous matches for the original local date and time</param>
      <exception cref="T:NodaTime.AmbiguousTimeException">The implementation rejects requests to map ambiguous times.</exception>
      <returns>
            A <see cref="T:NodaTime.ZonedDateTime" /> in the target time zone; typically, one of the two input parameters.
            </returns>
    </member>
    <member name="T:NodaTime.TimeZones.SkippedTimeResolver">
      <summary>
            Resolves a <see cref="T:NodaTime.LocalDateTime" /> to a <see cref="T:NodaTime.ZonedDateTime" /> in the situation
            where the requested local time does not exist in the target time zone.
            </summary>
      <remarks>
        <para>
            This delegate is used by <see cref="M:NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver,NodaTime.TimeZones.SkippedTimeResolver)" /> when handling the situation where the
            requested local time does not exist, due to clocks moving forward in a time zone transition (usually due to a
            spring daylight saving transition).
            </para>
        <para>
            The returned value will necessarily represent a different local date and time to the target one, but
            the exact form of mapping is up to the delegate implementation. For example, it could return a value
            as close to the target local date and time as possible, or the time immediately after the transition.
            Alternatively, it can throw a <see cref="T:NodaTime.SkippedTimeException" /> to implement a policy of "reject
            skipped times."
            </para>
        <para>See the <see cref="T:NodaTime.TimeZones.Resolvers" /> class for predefined implementations.</para>
        <para>
            Implementations of this delegate can reasonably
            assume that the target local date and time really is skipped; the behaviour when the local date and time
            can be directly mapped into the target time zone is undefined.
            </para>
      </remarks>
      <param name="localDateTime">The local date and time to map to the given time zone</param>
      <param name="zone">The target time zone</param>
      <param name="intervalBefore">The zone interval directly before the target local date and time would have occurred</param>
      <param name="intervalAfter">The zone interval directly after the target local date and time would have occurred</param>
      <exception cref="T:NodaTime.SkippedTimeException">The implementation rejects requests to map skipped times.</exception>
      <returns>A <see cref="T:NodaTime.ZonedDateTime" /> in the target time zone.</returns>
    </member>
    <member name="T:NodaTime.TimeZones.ZoneLocalMappingResolver">
      <summary>
            Resolves the result of attempting to map a local date and time to a target time zone.
            </summary>
      <remarks>
        <para>
            This delegate is consumed by <see cref="M:NodaTime.LocalDateTime.InZone(NodaTime.DateTimeZone,NodaTime.TimeZones.ZoneLocalMappingResolver)" /> and <see cref="M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)" />,
            among others. It provides the strategy for converting a <see cref="T:NodaTime.TimeZones.ZoneLocalMapping" /> (the result of attempting
            to map a local date and time to a target time zone) to a <see cref="T:NodaTime.ZonedDateTime" />.
            </para>
        <para>See the <see cref="T:NodaTime.TimeZones.Resolvers" /> class for predefined implementations and a way of combining
            separate <see cref="T:NodaTime.TimeZones.SkippedTimeResolver" /> and <see cref="T:NodaTime.TimeZones.AmbiguousTimeResolver" /> values.</para>
      </remarks>
      <param name="mapping">The intermediate result of mapping a local time to a target time zone.</param>
      <exception cref="T:NodaTime.AmbiguousTimeException">The implementation rejects requests to map ambiguous times.</exception>
      <exception cref="T:NodaTime.SkippedTimeException">The implementation rejects requests to map skipped times.</exception>
      <returns>A <see cref="T:NodaTime.ZonedDateTime" /> in the target time zone.</returns>
    </member>
    <member name="T:NodaTime.TimeZones.TzdbZoneLocation">
      <summary>
            A location entry generated from the "zone.tab" file in a TZDB release. This can be used to provide
            users with a choice of time zone, although it is not internationalized.
            </summary>
      <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="M:NodaTime.TimeZones.TzdbZoneLocation.#ctor(System.Int32,System.Int32,System.String,System.String,System.String,System.String)">
      <summary>
            Creates a new location.
            </summary>
      <remarks>This constructor is only public for the sake of testability. Non-test code should
            usually obtain locations from a <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource" />.
            </remarks>
      <param name="latitudeSeconds">Latitude of the location, in seconds.</param>
      <param name="longitudeSeconds">Longitude of the location, in seconds.</param>
      <param name="countryName">English country name of the location, in degrees. Must not be null.</param>
      <param name="countryCode">ISO-3166 country code of the location. Must not be null.</param>
      <param name="zoneId">Time zone identifier of the location. Must not be null.</param>
      <param name="comment">Optional comment. Must not be null, but may be empty.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">The latitude or longitude is invalid.</exception>
    </member>
    <member name="P:NodaTime.TimeZones.TzdbZoneLocation.Latitude">
      <summary>
            Latitude in degrees; positive for North, negative for South.
            </summary>
      <remarks>The value will be in the range [-90, 90].</remarks>
    </member>
    <member name="P:NodaTime.TimeZones.TzdbZoneLocation.Longitude">
      <summary>
            Longitude in degrees; positive for East, negative for West.
            </summary>
      <remarks>The value will be in the range [-180, 180].</remarks>
    </member>
    <member name="P:NodaTime.TimeZones.TzdbZoneLocation.CountryName">
      <summary>
            The English name of the country containing the location.
            </summary>
      <remarks>This will never be null.</remarks>
    </member>
    <member name="P:NodaTime.TimeZones.TzdbZoneLocation.CountryCode">
      <summary>
            The ISO-3166 2-letter country code for the country containing the location.
            </summary>
      <remarks>This will never be null.</remarks>
    </member>
    <member name="P:NodaTime.TimeZones.TzdbZoneLocation.ZoneId">
      <summary>
            The ID of the time zone for this location.
            </summary>
      <remarks>This will never be null, and if this mapping was fetched
            from a <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource" />, it will always be a valid ID within that source.
            </remarks>
    </member>
    <member name="P:NodaTime.TimeZones.TzdbZoneLocation.Comment">
      <summary>
            The comment (in English) for the mapping, if any.
            </summary>
      <remarks>
            This is usually used to differentiate between locations in the same country.
            This will return an empty string if no comment was provided in the original data.
            </remarks>
    </member>
    <member name="T:NodaTime.TimeZones.IZoneIntervalMap">
      <summary>
            The core part of a DateTimeZone: mapping an Instant to an Interval.
            Separating this out into an interface allows for flexible caching.
            </summary>
      <remarks>
            Benchmarking shows that a delegate may be slightly faster here, but the difference
            isn't very significant even for very fast calls (cache hits). The interface ends up
            feeling slightly cleaner elsewhere in the code.
            </remarks>
    </member>
    <member name="T:NodaTime.TimeZones.NamespaceDoc">
      <summary>
        <para>
            The NodaTime.TimeZones namespace contains types related to time zones beyond the core
            <see cref="T:NodaTime.DateTimeZone" /> class in the NodaTime namespace. Most users will have no need
            to refer to the types in this namespace.
            </para>
      </summary>
    </member>
    <member name="T:NodaTime.TimeZones.Resolvers">
      <summary>
            Commonly-used implementations of the delegates used in resolving a <see cref="T:NodaTime.LocalDateTime" /> to a
            <see cref="T:NodaTime.ZonedDateTime" />, and a method to combine two "partial" resolvers into a full one.
            </summary>
      <remarks>
        <para>
            This class contains predefined implementations of <see cref="T:NodaTime.TimeZones.ZoneLocalMappingResolver" />,
            <see cref="T:NodaTime.TimeZones.AmbiguousTimeResolver" />, and <see cref="T:NodaTime.TimeZones.SkippedTimeResolver" />, along with
            <see cref="M:NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver,NodaTime.TimeZones.SkippedTimeResolver)" />, which produces a <c>ZoneLocalMappingResolver</c> from instances of the
            other two.
            </para>
      </remarks>
      <threadsafety>All members of this class are thread-safe, as are the values returned by them.</threadsafety>
    </member>
    <member name="F:NodaTime.TimeZones.Resolvers.ReturnEarlier">
      <summary>
            An <see cref="T:NodaTime.TimeZones.AmbiguousTimeResolver" /> which returns the earlier of the two matching times.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.Resolvers.ReturnLater">
      <summary>
            An <see cref="T:NodaTime.TimeZones.AmbiguousTimeResolver" /> which returns the later of the two matching times.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.Resolvers.ThrowWhenAmbiguous">
      <summary>
            An <see cref="T:NodaTime.TimeZones.AmbiguousTimeResolver" /> which simply throws an <see cref="T:NodaTime.AmbiguousTimeException" />.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.Resolvers.ReturnEndOfIntervalBefore">
      <summary>
            A <see cref="T:NodaTime.TimeZones.SkippedTimeResolver" /> which returns the final tick of the time zone interval
            before the "gap".
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.Resolvers.ReturnStartOfIntervalAfter">
      <summary>
            A <see cref="T:NodaTime.TimeZones.SkippedTimeResolver" /> which returns the first tick of the time zone interval
            after the "gap".
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.Resolvers.ThrowWhenSkipped">
      <summary>
            A <see cref="T:NodaTime.TimeZones.SkippedTimeResolver" /> which simply throws a <see cref="T:NodaTime.SkippedTimeException" />.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.Resolvers.StrictResolver">
      <summary>
            A <see cref="T:NodaTime.TimeZones.ZoneLocalMappingResolver" /> which only ever succeeds in the (usual) case where the result
            of the mapping is unambiguous.
            </summary>
      <remarks>
            If the mapping is ambiguous or skipped, this throws <see cref="T:NodaTime.SkippedTimeException" /> or
            <see cref="T:NodaTime.AmbiguousTimeException" />, as appropriate. This resolver combines
            <see cref="F:NodaTime.TimeZones.Resolvers.ThrowWhenAmbiguous" /> and <see cref="F:NodaTime.TimeZones.Resolvers.ThrowWhenSkipped" />.
            </remarks>
      <seealso cref="M:NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)" />
    </member>
    <member name="F:NodaTime.TimeZones.Resolvers.LenientResolver">
      <summary>
            A <see cref="T:NodaTime.TimeZones.ZoneLocalMappingResolver" /> which never throws an exception due to ambiguity or skipped time.
            </summary>
      <remarks>
            Ambiguity is handled by returning the later occurrence, and skipped times are mapped to the start of the zone interval
            after the gap. This resolver combines <see cref="F:NodaTime.TimeZones.Resolvers.ReturnLater" /> and <see cref="F:NodaTime.TimeZones.Resolvers.ReturnStartOfIntervalAfter" />.
            </remarks>
      <seealso cref="M:NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)" />
    </member>
    <member name="M:NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver,NodaTime.TimeZones.SkippedTimeResolver)">
      <summary>
            Combines an <see cref="T:NodaTime.TimeZones.AmbiguousTimeResolver" /> and a <see cref="T:NodaTime.TimeZones.SkippedTimeResolver" /> to create a
            <see cref="T:NodaTime.TimeZones.ZoneLocalMappingResolver" />.
            </summary>
      <remarks>
            The <c>ZoneLocalMappingResolver</c> created by this method operates in the obvious way: unambiguous mappings
            are returned directly, ambiguous mappings are delegated to the given <c>AmbiguousTimeResolver</c>, and
            "skipped" mappings are delegated to the given <c>SkippedTimeResolver</c>.
            </remarks>
      <param name="ambiguousTimeResolver">Resolver to use for ambiguous mappings.</param>
      <param name="skippedTimeResolver">Resolver to use for "skipped" mappings.</param>
      <returns>The logical combination of the two resolvers.</returns>
    </member>
    <member name="T:NodaTime.TimeZones.InvalidDateTimeZoneSourceException">
      <summary>
            Exception thrown to indicate that a time zone source has violated the contract of <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource" />.
            This exception is primarily intended to be thrown from <see cref="T:NodaTime.TimeZones.DateTimeZoneCache" />, and only in the face of a buggy
            source; user code should not usually need to be aware of this or catch it.
            </summary>
      <threadsafety>Any public static members of this type are thread safe. Any instance members are not guaranteed to be thread safe.
            See the thread safety section of the user guide for more information.
            </threadsafety>
    </member>
    <member name="M:NodaTime.TimeZones.InvalidDateTimeZoneSourceException.#ctor(System.String)">
      <summary>
            Creates a new instance with the given message.
            </summary>
      <param name="message">The message for the exception.</param>
    </member>
    <member name="T:NodaTime.TimeZones.Transition">
      <summary>
            A transition between two offsets, usually for daylight saving reasons. This type only knows about
            the old offset, the new offset, and the transition point.
            </summary>
      <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="M:NodaTime.TimeZones.Transition.op_Equality(NodaTime.TimeZones.Transition,NodaTime.TimeZones.Transition)">
      <summary>
            Implements the operator == (equality).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.Transition.op_Inequality(NodaTime.TimeZones.Transition,NodaTime.TimeZones.Transition)">
      <summary>
            Implements the operator != (inequality).
            </summary>
      <param name="left">The left hand side of the operator.</param>
      <param name="right">The right hand side of the operator.</param>
      <returns>
        <c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.Transition.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NodaTime.TimeZones.Transition.GetHashCode">
      <summary>
            Returns a hash code for this instance.
            </summary>
      <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
    </member>
    <member name="M:NodaTime.TimeZones.Transition.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="P:NodaTime.TimeZones.Transition.NewOffset">
      <summary>
            The offset from the time when this transition occurs until the next transition.
            </summary>
    </member>
    <member name="T:NodaTime.TimeZones.DaylightSavingsDateTimeZone">
      <summary>
            Provides a basic daylight savings time zone. A DST time zone has a simple recurrence
            where an extra offset is applied between two dates of a year.
            </summary>
      <remarks>
            IMPORTANT: This class *accepts* recurrences which start from a particular year
            rather than being infinite back to the start of time, but *treats* them as if
            they were infinite. This makes various calculations easier, but this zone should
            only be used as part of a PrecalculatedDateTimeZone which will only ask it for
            values within the right portion of the timeline.
            </remarks>
    </member>
    <member name="M:NodaTime.TimeZones.DaylightSavingsDateTimeZone.#ctor(System.String,NodaTime.Offset,NodaTime.TimeZones.ZoneRecurrence,NodaTime.TimeZones.ZoneRecurrence)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.DaylightSavingsDateTimeZone" /> class.
            </summary>
      <remarks>
            At least one of the recurrences (it doesn't matter which) must be a "standard", i.e. not have any savings
            applied. The other may still not have any savings (e.g. for America/Resolute) or (for BCL compatibility) may
            even have negative daylight savings.
            </remarks>
      <param name="id">The id.</param>
      <param name="standardOffset">The standard offset.</param>
      <param name="startRecurrence">The start recurrence.</param>
      <param name="endRecurrence">The end recurrence.</param>
    </member>
    <member name="M:NodaTime.TimeZones.DaylightSavingsDateTimeZone.GetZoneInterval(NodaTime.Instant)">
      <summary>
            Gets the zone interval for the given instant.
            </summary>
      <param name="instant">The Instant to test.</param>
      <returns>The ZoneInterval in effect at the given instant.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The instant falls outside the bounds
            of the recurrence rules of the zone.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.DaylightSavingsDateTimeZone.FindMatchingRecurrence(NodaTime.Instant)">
      <summary>
            Finds the recurrence containing the given instant, if any.
            </summary>
      <returns>The recurrence containing the given instant, or null if
            the instant occurs before the start of the earlier recurrence.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.DaylightSavingsDateTimeZone.NextTransition(NodaTime.Instant)">
      <summary>
            Returns the transition occurring strictly after the specified instant
            </summary>
      <param name="instant">The instant after which to consider transitions.</param>
    </member>
    <member name="M:NodaTime.TimeZones.DaylightSavingsDateTimeZone.PreviousTransition(NodaTime.Instant)">
      <summary>
            Returns the transition occurring strictly before the specified instant.
            </summary>
      <param name="instant">The instant before which to consider transitions.</param>
      <returns>
            The instant of the previous transition, or null if there are no further transitions.
            </returns>
    </member>
    <member name="M:NodaTime.TimeZones.DaylightSavingsDateTimeZone.GetUtcOffset(NodaTime.Instant)">
      <summary>
            Returns the offset from UTC, where a positive duration indicates that local time is later
            than UTC. In other words, local time = UTC + offset.
            </summary>
      <param name="instant">The instant for which to calculate the offset.</param>
      <returns>
            The offset from UTC at the specified instant.
            </returns>
    </member>
    <member name="M:NodaTime.TimeZones.DaylightSavingsDateTimeZone.Write(NodaTime.TimeZones.IO.IDateTimeZoneWriter)">
      <summary>
            Writes the time zone to the specified writer.
            </summary>
      <param name="writer">The writer to write to.</param>
    </member>
    <member name="M:NodaTime.TimeZones.DaylightSavingsDateTimeZone.WriteLegacy(NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter)">
      <summary>
            Writes the time zone to the specified legacy writer.
            </summary>
      <param name="writer">The writer to write to.</param>
    </member>
    <member name="T:NodaTime.TimeZones.FixedDateTimeZone">
      <summary>
            Basic <see cref="T:NodaTime.DateTimeZone" /> implementation that has a fixed name key and offset i.e.
            no daylight savings.
            </summary>
      <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="M:NodaTime.TimeZones.FixedDateTimeZone.#ctor(NodaTime.Offset)">
      <summary>
            Creates a new fixed time zone.
            </summary>
      <param name="offset">The <see cref="P:NodaTime.TimeZones.FixedDateTimeZone.Offset" /> from UTC.</param>
    </member>
    <member name="M:NodaTime.TimeZones.FixedDateTimeZone.#ctor(System.String,NodaTime.Offset)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.FixedDateTimeZone" /> class.
            </summary>
      <param name="id">The id.</param>
      <param name="offset">The offset.</param>
    </member>
    <member name="M:NodaTime.TimeZones.FixedDateTimeZone.MakeId(NodaTime.Offset)">
      <summary>
            Makes the id for this time zone. The format is "UTC+/-Offset".
            </summary>
      <param name="offset">The offset.</param>
      <returns>The generated id string.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.FixedDateTimeZone.GetFixedZoneOrNull(System.String)">
      <summary>
            Returns a fixed time zone for the given ID, which must be "UTC" or "UTC[offset]" where "[offset]" can be parsed
            using the "general" offset pattern.
            </summary>
      <param name="id">ID </param>
      <returns>The parsed time zone, or null if the ID doesn't match.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.FixedDateTimeZone.GetZoneInterval(NodaTime.Instant)">
      <summary>
            Gets the zone interval for the given instant. This implementation always returns the same interval.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.FixedDateTimeZone.GetZoneIntervalPair(NodaTime.LocalInstant)">
      <summary>
            Gets the zone interval pair for the given instant. This implementation always returns the same unambiguous interval pair.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.FixedDateTimeZone.GetUtcOffset(NodaTime.Instant)">
      <summary>
            Returns the offset from UTC, where a positive duration indicates that local time is later
            than UTC. In other words, local time = UTC + offset.
            </summary>
      <param name="instant">The instant for which to calculate the offset.</param>
      <returns>
            The offset from UTC at the specified instant.
            </returns>
    </member>
    <member name="M:NodaTime.TimeZones.FixedDateTimeZone.Write(NodaTime.TimeZones.IO.IDateTimeZoneWriter)">
      <summary>
            Writes the time zone to the specified writer.
            </summary>
      <param name="writer">The writer.</param>
    </member>
    <member name="M:NodaTime.TimeZones.FixedDateTimeZone.Read(NodaTime.TimeZones.IO.IDateTimeZoneReader,System.String)">
      <summary>
            Reads a fixed time zone from the specified reader.
            </summary>
      <param name="reader">The reader.</param>
      <param name="id">The id.</param>
      <returns>The fixed time zone.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.FixedDateTimeZone.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="P:NodaTime.TimeZones.FixedDateTimeZone.Offset">
      <summary>
            Returns the fixed offset for this time zone.
            </summary>
      <returns>The fixed offset for this time zone.</returns>
    </member>
    <member name="T:NodaTime.TimeZones.IDateTimeZoneSource">
      <summary>
            Provides the interface for objects that can retrieve time zone definitions given an ID.
            </summary>
      <remarks>
        <para>
            The interface presumes that the available time zones are static; there is no mechanism for 
            updating the list of available time zones. Any time zone ID that is returned in <see cref="M:NodaTime.TimeZones.IDateTimeZoneSource.GetIds" /> 
            must be resolved by <see cref="M:NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)" /> for the life of the source.
            </para>
        <para>
            Implementations need not cache time zones or the available time zone IDs. 
            Caching is typically provided by <see cref="T:NodaTime.TimeZones.DateTimeZoneCache" />, which most consumers should use instead of
            consuming <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource" /> directly in order to get better performance.
            </para>
        <para>
            It is expected that any exceptions thrown are implementation-specific; nothing is explicitly
            specified in the interface. Typically this would be unusual to the point that callers would not
            try to catch them; any implementation which may break in ways that are sensible to catch should advertise
            this clearly, so that clients will know to handle the exceptions appropriately. No wrapper exception
            type is provided by Noda Time to handle this situation, and code in Noda Time does not try to catch
            such exceptions.
            </para>
      </remarks>
      <threadsafety>Implementations are not required to be thread-safe.</threadsafety>
    </member>
    <member name="M:NodaTime.TimeZones.IDateTimeZoneSource.GetIds">
      <summary>
            Returns an unordered enumeration of the IDs available from this source.
            </summary>
      <remarks>
        <para>
            Every value in this enumeration must return a valid time zone from <see cref="M:NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)" /> for the life of the source.
            The enumeration may be empty, but must not be null, and must not contain any elements which are null.  It
            should not contain duplicates: this is not enforced, and while it may not have a significant impact on
            clients in some cases, it is generally unfriendly.  The built-in implementations never return duplicates.
            </para>
        <para>
            The source is not required to provide the IDs in any particular order, although they should be distinct.
            </para>
        <para>
            Note that this list may optionally contain any of the fixed-offset timezones (with IDs "UTC" and
            "UTC+/-Offset"), but there is no requirement they be included.
            </para>
      </remarks>
      <returns>The IDs available from this source.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)">
      <summary>
            Returns the time zone definition associated with the given ID.
            </summary>
      <remarks>
        <para>
            Note that this is permitted to return a <see cref="T:NodaTime.DateTimeZone" /> that has a different ID to that
            requested, if the ID provided is an alias.
            </para>
        <para>
            Note also that this method is not required to return the same <see cref="T:NodaTime.DateTimeZone" /> instance for
            successive requests for the same ID; however, all instances returned for a given ID must compare as equal.
            </para>
        <para>
            It is advised that sources should document their behaviour regarding any fixed-offset timezones
            (i.e. "UTC" and "UTC+/-Offset") that are included in the list returned by <see cref="M:NodaTime.TimeZones.IDateTimeZoneSource.GetIds" />.
            (These IDs will not be requested by <see cref="T:NodaTime.TimeZones.DateTimeZoneCache" />, but any users calling
            into the source directly may care.)
            </para>
        <para>
            The source need not attempt to cache time zones; caching is typically provided by
            <see cref="T:NodaTime.TimeZones.DateTimeZoneCache" />.
            </para>
      </remarks>
      <param name="id">The ID of the time zone to return. This must be one of the IDs
            returned by <see cref="M:NodaTime.TimeZones.IDateTimeZoneSource.GetIds" />.</param>
      <returns>The <see cref="T:NodaTime.DateTimeZone" /> for the given ID.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="id" /> is not supported by this source.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.IDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo)">
      <summary>
            Returns this source's corresponding ID for the given BCL time zone.
            </summary>
      <param name="timeZone">The BCL time zone, which must be a known system time zone.</param>
      <returns>
            The ID for the given system time zone for this source, or null if the system time
            zone has no mapping in this source.
            </returns>
    </member>
    <member name="P:NodaTime.TimeZones.IDateTimeZoneSource.VersionId">
      <summary>
            Returns an appropriate version ID for diagnostic purposes, which must not be null.
            This doesn't have any specific format; it's solely for diagnostic purposes.
            The included sources return strings of the format "source identifier: source version" indicating where the
            information comes from and which version of the source information has been loaded.
            </summary>
    </member>
    <member name="T:NodaTime.TimeZones.ZoneEqualityComparer">
      <summary>
            Equality comparer for time zones, comparing specific aspects of the zone intervals within
            a time zone for a specific interval of the time line.
            </summary>
      <remarks>
            The default behaviour of this comparator is to consider two time zones to be equal if they share the same wall
            offsets at all points within a given time interval, regardless of other aspects of each
            <see cref="T:NodaTime.TimeZones.ZoneInterval" /> within the two time zones. This behaviour can be changed using the
            <see cref="M:NodaTime.TimeZones.ZoneEqualityComparer.WithOptions(NodaTime.TimeZones.ZoneEqualityComparer.Options)" /> method.
            </remarks>
    </member>
    <member name="T:NodaTime.TimeZones.ZoneEqualityComparer.Options">
      <summary>
            Options to use when comparing time zones for equality. Each option makes the comparison more restrictive.
            </summary>
      <remarks>
        <para>
            By default, the comparer only compares the wall offset (total of standard offset and any daylight saving offset)
            at every instant within the interval over which the comparer operates. In practice, this is done by comparing each
            <see cref="T:NodaTime.TimeZones.ZoneInterval" /> which includes an instant within the interval (using <see cref="M:NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)" />).
            For most purposes, this is all that's required: from the simple perspective of a time zone being just a function from instants to local time,
            the default option of <see cref="F:NodaTime.TimeZones.ZoneEqualityComparer.Options.OnlyMatchWallOffset" /> effectively checks that the function gives the same result across the two time
            zones being compared, for any given instant within the interval.
            </para>
        <para>
            It's possible for a time zone to have a transition from one <c>ZoneInterval</c> to another which doesn't adjust the offset: it
            might just change the name, or the balance between standard offset to daylight saving offset. (As an example, at midnight local
            time on October 27th 1968, the Europe/London time zone went from a standard offset of 0 and a daylight saving offset of 1 hour
            to a standard offset of 1 and a daylight saving offset of 0... which left the clocks unchanged.) This transition is irrelevant
            to the default options, so the two zone intervals involved are effectively coalesced.
            </para>
        <para>
            The options available change what sort of comparison is performed - which can also change which zone intervals can be coalesced. For
            example, by specifying just the <see cref="F:NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchAllTransitions" /> option, you would indicate that even though you don't care about the name within a zone
            interval or how the wall offset is calculated, you do care about the fact that there was a transition at all, and when it occurred.
            With that option enabled, zone intervals are never coalesced and the transition points within the operating interval are checked.
            </para>
        <para>Similarly, the <see cref="F:NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchStartAndEndTransitions" /> option is the only one where instants outside the operating interval are
            relevant. For example, consider a comparer which operates over the interval [2000-01-01T00:00:00Z, 2011-01-01T00:00:00Z). Normally,
            anything that happens before the year 2000 (UTC) would be irrelevant - but with this option enabled, the transitions of the first and last zone
            intervals are part of the comparison... so if one time zone has a zone interval 1999-09-01T00:00:00Z to 2000-03-01T00:00:00Z and the other has
            a zone interval 1999-10-15T00:00:00Z to 2000-03-01T00:00:Z, the two zones would be considered unequal, despite the fact that the only instants observing
            the difference occur outside the operating interval.
            </para>
      </remarks>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneEqualityComparer.ZoneIntervalEqualityComparer.EqualExceptStartAndEnd(NodaTime.TimeZones.ZoneInterval,NodaTime.TimeZones.ZoneInterval)">
      <summary>
            Compares the parts of two zone intervals which are deemed "interesting" by the options.
            The wall offset is always compared, regardless of options, but the start/end points are
            never compared.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneEqualityComparer.CheckOption(NodaTime.TimeZones.ZoneEqualityComparer.Options,NodaTime.TimeZones.ZoneEqualityComparer.Options)">
      <summary>
            Checks whether the given set of options includes the candidate one. This would be an extension method, but
            that causes problems on Mono at the moment.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneEqualityComparer.#ctor(NodaTime.Interval,NodaTime.TimeZones.ZoneEqualityComparer.Options)">
      <summary>
            Creates a new comparer for the given interval, with the given comparison options.
            </summary>
      <param name="interval">The interval within the time line to use for comparisons.</param>
      <param name="options">The options to use when comparing time zones.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">The specified options are invalid.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneEqualityComparer.ForInterval(NodaTime.Interval)">
      <summary>
            Returns a <see cref="T:NodaTime.TimeZones.ZoneEqualityComparer" /> for the given interval with the default options.
            </summary>
      <remarks>
            The default behaviour of this comparator is to consider two time zones to be equal if they share the same wall
            offsets at all points within a given interval.
            To specify non-default options, call the <see cref="M:NodaTime.TimeZones.ZoneEqualityComparer.WithOptions(NodaTime.TimeZones.ZoneEqualityComparer.Options)" /> method on the result
            of this method.</remarks>
      <param name="interval">The interval over which to compare time zones.</param>
      <returns>A ZoneEqualityComparer for the given interval with the default options.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneEqualityComparer.WithOptions(NodaTime.TimeZones.ZoneEqualityComparer.Options)">
      <summary>
            Returns a comparer operating over the same interval as this one, but with the given
            set of options.
            </summary>
      <remarks>
            This method does not modify the comparer on which it's called.
            </remarks>
      <param name="options">New set of options, which must consist of flags defined within the <see cref="T:NodaTime.TimeZones.ZoneEqualityComparer.Options" /> enum.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">The specified options are invalid.</exception>
      <returns>A comparer operating over the same interval as this one, but with the given set of options.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneEqualityComparer.Equals(NodaTime.DateTimeZone,NodaTime.DateTimeZone)">
      <summary>
            Compares two time zones for equality according to the options and interval provided to this comparer.
            </summary>
      <param name="x">The first <see cref="T:NodaTime.DateTimeZone" /> to compare.</param>
      <param name="y">The second <see cref="T:NodaTime.DateTimeZone" /> to compare.</param>
      <returns>
        <c>true</c> if the specified time zones are equal under the options and interval of this comparer; otherwise, <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneEqualityComparer.GetHashCode(NodaTime.DateTimeZone)">
      <summary>
            Returns a hash code for the specified time zone.
            </summary>
      <remarks>
            The hash code generated by any instance of <c>ZoneEqualityComparer</c> will be equal to the hash code
            generated by any other instance constructed with the same options and interval, for the same time zone (or equal ones).
            Two instances of <c>ZoneEqualityComparer</c> with different options or intervals may (but may not) produce
            different hash codes for the same zone.
            </remarks>
      <param name="obj">The time zone to compute a hash code for.</param>
      <returns>A hash code for the specified object.</returns>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneEqualityComparer.IntervalForTest">
      <summary>
            Returns the interval over which this comparer operates.
            </summary>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneEqualityComparer.OptionsForTest">
      <summary>
            Returns the options used by this comparer.
            </summary>
    </member>
    <member name="T:NodaTime.TimeZones.ZoneInterval">
      <summary>
            Represents a range of time for which a particular Offset applies.
            </summary>
      <threadsafety>This type is an immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneInterval.#ctor(System.String,NodaTime.Instant,NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
      <summary>
              Initializes a new instance of the <see cref="T:NodaTime.TimeZones.ZoneInterval" /> class.
            </summary>
      <param name="name">The name of this offset period (e.g. PST or PDT).</param>
      <param name="start">The first <see cref="T:NodaTime.Instant" /> that the <paramref name="wallOffset" /> applies.</param>
      <param name="end">The last <see cref="T:NodaTime.Instant" /> (exclusive) that the <paramref name="wallOffset" /> applies.</param>
      <param name="wallOffset">The <see cref="P:NodaTime.TimeZones.ZoneInterval.WallOffset" /> from UTC for this period including any daylight savings.</param>
      <param name="savings">The <see cref="P:NodaTime.TimeZones.ZoneInterval.WallOffset" /> daylight savings contribution to the offset.</param>
      <exception cref="T:System.ArgumentException">If <c><paramref name="start" /> &gt;= <paramref name="end" /></c>.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneInterval.WithStart(NodaTime.Instant)">
      <summary>
            Returns a copy of this zone interval, but with the given start instant.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneInterval.WithEnd(NodaTime.Instant)">
      <summary>
            Returns a copy of this zone interval, but with the given end instant.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneInterval.Contains(NodaTime.Instant)">
      <summary>
              Determines whether this period contains the given Instant in its range.
            </summary>
      <remarks>
            Usually this is half-open, i.e. the end is exclusive, but an interval with an end point of "the end of time" 
            is deemed to be inclusive at the end.
            </remarks>
      <param name="instant">The instant to test.</param>
      <returns>
        <c>true</c> if this period contains the given Instant in its range; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneInterval.Contains(NodaTime.LocalInstant)">
      <summary>
              Determines whether this period contains the given LocalInstant in its range.
            </summary>
      <param name="localInstant">The local instant to test.</param>
      <returns>
        <c>true</c> if this period contains the given LocalInstant in its range; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneInterval.Equals(NodaTime.TimeZones.ZoneInterval)">
      <summary>
              Indicates whether the current object is equal to another object of the same type.
            </summary>
      <returns>
              true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
      <param name="other">An object to compare with this object.
            </param>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneInterval.Equals(System.Object)">
      <summary>
              Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <returns>
        <c>true</c> if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, <c>false</c>.
            </returns>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneInterval.GetHashCode">
      <summary>
              Serves as a hash function for a particular type.
            </summary>
      <returns>
              A hash code for the current <see cref="T:System.Object" />.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneInterval.ToString">
      <summary>
              Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
              A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneInterval.StandardOffset">
      <summary>
              Gets the standard offset for this period. This is the offset without any daylight savings
              contributions.
            </summary>
      <remarks>
              This is effectively <c>Offset - Savings</c>.
            </remarks>
      <value>The base Offset.</value>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneInterval.Duration">
      <summary>
              Gets the duration of this period.
            </summary>
      <remarks>
              This is effectively <c>End - Start</c>.
            </remarks>
      <value>The Duration of this period.</value>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneInterval.End">
      <summary>
              Gets the last Instant (exclusive) that the Offset applies.
            </summary>
      <value>The last Instant (exclusive) that the Offset applies.</value>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneInterval.LocalEnd">
      <summary>
              Gets the end time as a LocalInstant.
            </summary>
      <remarks>
              This is effectively <c>End + Offset</c>.
            </remarks>
      <value>The ending LocalInstant.</value>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneInterval.LocalStart">
      <summary>
              Gets the start time as a LocalInstant.
            </summary>
      <remarks>
              This is effectively <c>Start + Offset</c>.
            </remarks>
      <value>The starting LocalInstant.</value>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneInterval.IsoLocalStart">
      <summary>
            Returns the local start time of the interval, as LocalDateTime
            in the ISO calendar.
            </summary>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneInterval.IsoLocalEnd">
      <summary>
            Returns the local start time of the interval, as LocalDateTime
            in the ISO calendar. This does not include any daylight saving 
            </summary>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneInterval.Name">
      <summary>
              Gets the name of this offset period (e.g. PST or PDT).
            </summary>
      <value>The name of this offset period (e.g. PST or PDT).</value>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneInterval.WallOffset">
      <summary>
              Gets the offset from UTC for this period. This includes any daylight savings value.
            </summary>
      <value>The offset from UTC for this period.</value>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneInterval.Savings">
      <summary>
              Gets the daylight savings value for this period.
            </summary>
      <value>The savings value.</value>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneInterval.Start">
      <summary>
              Gets the first Instant that the Offset applies.
            </summary>
      <value>The first Instant that the Offset applies.</value>
    </member>
    <member name="T:NodaTime.TimeZones.ZoneIntervalPair">
      <summary>
            A pair of possibly null ZoneInterval values. This is the result of fetching a time zone
            interval by LocalInstant, as the result could be 0, 1 or 2 matching ZoneIntervals.
            This is a sort of light-weight version of ZoneLocalMapping, used when we won't need to
            know the details of the gaps and it's handy to use a struct instead of creating a new object.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneIntervalPair.Equals(System.Object)">
      <summary>
              Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <returns>
        <c>true</c> if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, <c>false</c>.
            </returns>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneIntervalPair.Equals(NodaTime.TimeZones.ZoneIntervalPair)">
      <summary>
              Indicates whether the current object is equal to another object of the same type.
            </summary>
      <returns>
              true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
      <param name="other">An object to compare with this object.
            </param>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneIntervalPair.GetHashCode">
      <summary>
              Serves as a hash function for a particular type.
            </summary>
      <returns>
              A hash code for the current <see cref="T:System.Object" />.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneIntervalPair.EarlyInterval">
      <summary>
            The earlier of the two zone intervals matching the original local instant, or null
            if there were no matches. If there is a single match (the most common case) this
            value will be non-null, and LateInterval will be null.
            </summary>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneIntervalPair.LateInterval">
      <summary>
            The later of the two zone intervals matching the original local instant, or null
            if there were no matches. If there is a single match (the most common case) this
            value will be null, and EarlyInterval will be non-null.
            </summary>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneIntervalPair.MatchingIntervals">
      <summary>
            Returns the number of intervals contained within this pair - 0 for a "gap",
            1 for an unambiguous match, 2 for an ambiguous match.
            </summary>
    </member>
    <member name="T:NodaTime.TimeZones.ZoneLocalMapping">
      <summary>
            The result of mapping a <see cref="T:NodaTime.LocalDateTime" /> within a time zone, i.e. finding out
            at what "global" time the "local" time occurred.
            </summary>
      <remarks>
        <para>
            This class is used as the return type of <see cref="M:NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime)" />. It allows for
            finely-grained handling of the three possible results:
            </para>
        <list type="bullet">
          <item>
            <term>Unambiguous mapping</term>
            <description>The local time occurs exactly once in the target time zone.</description>
          </item>
          <item>
            <term>Ambiguous mapping</term>
            <description>
                  The local time occurs twice in the target time zone, due to the offset from UTC
                  changing. This usually occurs for an autumnal daylight saving transition, where the clocks
                  are put back by an hour. If the clocks change from 2am to 1am for example, then 1:30am occurs
                  twice - once before the transition and once afterwards.
                </description>
          </item>
          <item>
            <term>Impossible mapping</term>
            <description>
                  The local time does not occur at all in the target time zone, due to the offset from UTC
                  changing. This usually occurs for a vernal (spring-time) daylight saving transition, where the clocks
                  are put forward by an hour. If the clocks change from 1am to 2am for example, then 1:30am is
                  skipped entirely.
                </description>
          </item>
        </list>
      </remarks>
      <threadsafety>This type is an immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneLocalMapping.Single">
      <summary>
            Returns the single <see cref="T:NodaTime.ZonedDateTime" /> which maps to the original
            <see cref="T:NodaTime.LocalDateTime" /> in the mapped <see cref="T:NodaTime.DateTimeZone" />.
            </summary>
      <exception cref="T:NodaTime.SkippedTimeException">The local date/time was skipped in the time zone.</exception>
      <exception cref="T:NodaTime.AmbiguousTimeException">The local date/time was ambiguous in the time zone.</exception>
      <returns>The unambiguous result of mapping the local date/time in the time zone.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneLocalMapping.First">
      <summary>
            Returns a <see cref="T:NodaTime.ZonedDateTime" /> which maps to the original <see cref="T:NodaTime.LocalDateTime" />
            in the mapped <see cref="T:NodaTime.DateTimeZone" />: either the single result if the mapping is unambiguous,
            or the earlier result if the local date/time occurs twice in the time zone due to a time zone
            offset change such as an autumnal daylight saving transition.
            </summary>
      <exception cref="T:NodaTime.SkippedTimeException">The local date/time was skipped in the time zone.</exception>
      <returns>The unambiguous result of mapping a local date/time in a time zone.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneLocalMapping.Last">
      <summary>
            Returns a <see cref="T:NodaTime.ZonedDateTime" /> which maps to the original <see cref="T:NodaTime.LocalDateTime" />
            in the mapped <see cref="T:NodaTime.DateTimeZone" />: either the single result if the mapping is unambiguous,
            or the later result if the local date/time occurs twice in the time zone due to a time zone
            offset change such as an autumnal daylight saving transition.
            </summary>
      <exception cref="T:NodaTime.SkippedTimeException">The local date/time was skipped in the time zone.</exception>
      <returns>The unambiguous result of mapping a local date/time in a time zone.</returns>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneLocalMapping.Count">
      <summary>
            Returns the number of results within this mapping: the number of distinct
            <see cref="T:NodaTime.ZonedDateTime" /> values which map to the original <see cref="T:NodaTime.LocalDateTime" />.
            </summary>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneLocalMapping.Zone">
      <summary>
            Returns the <see cref="T:NodaTime.DateTimeZone" /> in which this mapping was performed.
            </summary>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneLocalMapping.LocalDateTime">
      <summary>
            Returns the <see cref="T:NodaTime.LocalDateTime" /> which was mapped with in the time zone.
            </summary>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneLocalMapping.EarlyInterval">
      <summary>
            Returns the earlier <see cref="T:NodaTime.TimeZones.ZoneInterval" /> within this mapping. For unambiguous
            mappings, this is the same as <see cref="P:NodaTime.TimeZones.ZoneLocalMapping.LateInterval" />; for ambiguous mappings,
            this is the interval during which the mapped local time first occurs; for impossible
            mappings, this is the interval before which the mapped local time occurs.
            </summary>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneLocalMapping.LateInterval">
      <summary>
            Returns the later <see cref="T:NodaTime.TimeZones.ZoneInterval" /> within this mapping. For unambiguous
            mappings, this is the same as <see cref="P:NodaTime.TimeZones.ZoneLocalMapping.EarlyInterval" />; for ambiguous mappings,
            this is the interval during which the mapped local time last occurs; for impossible
            mappings, this is the interval after which the mapped local time occurs.
            </summary>
    </member>
    <member name="T:NodaTime.TimeZones.ZoneYearOffset">
      <summary>
            Defines an offset within a year as an expression that can be used to reference multiple
            years.
            </summary>
      <remarks>
        <para>
            A year offset defines a way of determining an offset into a year based on certain criteria.
            The most basic is the month of the year and the day of the month. If only these two are
            supplied then the offset is always the same day of each year. The only exception is if the
            day is February 29th, then it only refers to those years that have a February 29th.
            </para>
        <para>
            If the day of the week is specified then the offset determined by the month and day are
            adjusted to the nearest day that falls on the given day of the week. If the month and day
            fall on that day of the week then nothing changes. Otherwise the offset is moved forward or
            backward up to 6 days to make the day fall on the correct day of the week. The direction the
            offset is moved is determined by the <see cref="P:NodaTime.TimeZones.ZoneYearOffset.AdvanceDayOfWeek" /> property.
            </para>
        <para>
            Finally the <see cref="P:NodaTime.TimeZones.ZoneYearOffset.Mode" /> property deterines whether the <see cref="P:NodaTime.TimeZones.ZoneYearOffset.TimeOfDay" /> value
            is added to the calculated offset to generate an offset within the day.
            </para>
        <para>
            Immutable, thread safe
            </para>
      </remarks>
    </member>
    <member name="F:NodaTime.TimeZones.ZoneYearOffset.StartOfYear">
      <summary>
            An offset that specifies the beginning of the year.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneYearOffset.#ctor(NodaTime.TimeZones.TransitionMode,System.Int32,System.Int32,System.Int32,System.Boolean,NodaTime.LocalTime)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.ZoneYearOffset" /> class.
            </summary>
      <param name="mode">The transition mode.</param>
      <param name="monthOfYear">The month year offset.</param>
      <param name="dayOfMonth">The day of month. Negatives count from end of month.</param>
      <param name="dayOfWeek">The day of week. 0 means not set.</param>
      <param name="advance">if set to <c>true</c> [advance].</param>
      <param name="timeOfDay">The tick within the day.</param>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneYearOffset.#ctor(NodaTime.TimeZones.TransitionMode,System.Int32,System.Int32,System.Int32,System.Boolean,NodaTime.LocalTime,System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.ZoneYearOffset" /> class.
            </summary>
      <param name="mode">The transition mode.</param>
      <param name="monthOfYear">The month year offset.</param>
      <param name="dayOfMonth">The day of month. Negatives count from end of month.</param>
      <param name="dayOfWeek">The day of week. 0 means not set.</param>
      <param name="advance">if set to <c>true</c> [advance].</param>
      <param name="timeOfDay">The time of day at which the transition occurs.</param>
      <param name="addDay">Whether to add an extra day (for 24:00 handling).</param>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneYearOffset.VerifyFieldValue(System.Int64,System.Int64,System.String,System.Int64,System.Boolean)">
      <summary>
            Verifies the input value against the valid range of the calendar field.
            </summary>
      <remarks>
            If this becomes more widely required, move to Preconditions.
            </remarks>
      <param name="minimum">The minimum valid value.</param>
      <param name="maximum">The maximum valid value (inclusive).</param>
      <param name="name">The name of the field for the error message.</param>
      <param name="value">The value to check.</param>
      <param name="allowNegated">if set to <c>true</c> all the range of value to be the negative as well.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">If the given value is not in the valid range of the given calendar field.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneYearOffset.Equals(NodaTime.TimeZones.ZoneYearOffset)">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <param name="other">An object to compare with this object.</param>
      <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneYearOffset.NormalizeModeCharacter(System.Char)">
      <summary>
            Normalizes the transition mode characater.
            </summary>
      <param name="modeCharacter">The character to normalize.</param>
      <returns>The <see cref="T:NodaTime.TimeZones.TransitionMode" />.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneYearOffset.MakeInstant(System.Int32,NodaTime.Offset,NodaTime.Offset)">
      <summary>
            Returns an <see cref="T:NodaTime.Instant" /> that represents the point in the given year that this
            object defines. If the exact point is not valid then the nearest point that matches the
            definition is returned.
            </summary>
      <param name="year">The year to calculate for.</param>
      <param name="standardOffset">The standard offset.</param>
      <param name="savings">The daylight savings adjustment.</param>
      <returns>The <see cref="T:NodaTime.Instant" /> of the point in the given year.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneYearOffset.Next(NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
      <summary>
            Returns the given instant adjusted one year forward taking into account leap years and other
            adjustments like day of week.
            </summary>
      <param name="instant">The instant to adjust.</param>
      <param name="standardOffset">The standard offset.</param>
      <param name="savings">The daylight savings adjustment.</param>
      <returns>The adjusted <see cref="T:NodaTime.LocalInstant" />.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneYearOffset.Previous(NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
      <summary>
            Returns the given instant adjusted one year backward taking into account leap years and other
            adjustments like day of week.
            </summary>
      <param name="instant">The instant to adjust.</param>
      <param name="standardOffset">The standard offset.</param>
      <param name="savings">The daylight savings adjustment.</param>
      <returns>The adjusted <see cref="T:NodaTime.LocalInstant" />.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneYearOffset.Write(NodaTime.TimeZones.IO.IDateTimeZoneWriter)">
      <summary>
            Writes this object to the given <see cref="T:NodaTime.TimeZones.IO.IDateTimeZoneWriter" />.
            </summary>
      <param name="writer">Where to send the output.</param>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneYearOffset.WriteLegacy(NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter)">
      <summary>
            Writes this object to the given <see cref="T:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter" />.
            </summary>
      <param name="writer">Where to send the output.</param>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneYearOffset.GetOffset(NodaTime.Offset,NodaTime.Offset)">
      <summary>
            Returns the offset to use for this object's <see cref="T:NodaTime.TimeZones.TransitionMode" />.
            </summary>
      <param name="standardOffset">The standard offset.</param>
      <param name="savings">The daylight savings adjustment.</param>
      <returns>The base time offset as a <see cref="T:NodaTime.Duration" />.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneYearOffset.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneYearOffset.GetHashCode">
      <summary>
            Returns a hash code for this instance.
            </summary>
      <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneYearOffset.Mode">
      <summary>
            Gets the method by which offsets are added to Instants to get LocalInstants.
            </summary>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneYearOffset.AdvanceDayOfWeek">
      <summary>
            Gets a value indicating whether [advance day of week].
            </summary>
    </member>
    <member name="P:NodaTime.TimeZones.ZoneYearOffset.TimeOfDay">
      <summary>
            Gets the time of day when the rule takes effect.
            </summary>
    </member>
    <member name="T:NodaTime.TimeZones.PrecalculatedDateTimeZone">
      <summary>
            Most time zones have a relatively small set of transitions at their start until they finally 
            settle down to either a fixed time zone or a daylight savings time zone. This provides the
            container for the initial zone intervals and a pointer to the time zone that handles all of
            the rest until the end of time.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.PrecalculatedDateTimeZone.tailZoneStart">
      <summary>
            The first instant covered by the tail zone, or Instant.MaxValue if there's no tail zone.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.#ctor(System.String,NodaTime.TimeZones.ZoneInterval[],NodaTime.DateTimeZone)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.PrecalculatedDateTimeZone" /> class.
            </summary>
      <param name="id">The id.</param>
      <param name="periods">The periods.</param>
      <param name="tailZone">The tail zone.</param>
    </member>
    <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.ValidatePeriods(NodaTime.TimeZones.ZoneInterval[],NodaTime.DateTimeZone)">
      <summary>
            Validates that all the periods before the tail zone make sense. We have to start at the beginning of time,
            and then have adjoining periods. This is only called in the constructors.
            </summary>
      <remarks>This is only called from the constructors, but is internal to make it easier to test.</remarks>
      <exception cref="T:System.ArgumentException">The periods specified are invalid.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.GetZoneInterval(NodaTime.Instant)">
      <summary>
            Gets the zone offset period for the given instant.
            </summary>
      <param name="instant">The Instant to find.</param>
      <returns>The ZoneInterval including the given instant.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.IsCachable">
      <summary>
            Returns true if this time zone is worth caching. Small time zones or time zones with
            lots of quick changes do not work well with <see cref="T:NodaTime.TimeZones.CachedDateTimeZone" />.
            </summary>
      <returns>
        <c>true</c> if this instance is cachable; otherwise, <c>false</c>.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.Write(NodaTime.TimeZones.IO.IDateTimeZoneWriter)">
      <summary>
            Writes the time zone to the specified writer.
            </summary>
      <param name="writer">The writer to write to.</param>
    </member>
    <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.Read(NodaTime.TimeZones.IO.IDateTimeZoneReader,System.String)">
      <summary>
            Reads a time zone from the specified reader.
            </summary>
      <param name="reader">The reader.</param>
      <param name="id">The id.</param>
      <returns>The time zone.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.WriteLegacy(NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter)">
      <summary>
            Writes the time zone to the specified writer.
            </summary>
      <param name="writer">The writer to write to.</param>
    </member>
    <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.ReadLegacy(NodaTime.TimeZones.IO.LegacyDateTimeZoneReader,System.String)">
      <summary>
            Reads a time zone from the specified reader.
            </summary>
      <param name="reader">The reader.</param>
      <param name="id">The id.</param>
      <returns>The time zone.</returns>
    </member>
    <member name="T:NodaTime.TimeZones.ZoneRecurrence">
      <summary>
            Extends <see cref="T:NodaTime.TimeZones.ZoneYearOffset" /> with a name and savings.
            </summary>
      <remarks>
        <para>
            This represents a recurring transition from or to a daylight savings time. The name is the
            name of the time zone during this period (e.g. PST or PDT). The savings is usually 0 or the
            daylight offset. This is also used to support some of the tricky transitions that occurred
            before that calendars were "standardized."
            </para>
        <para>
            Immutable, thread safe.
            </para>
      </remarks>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneRecurrence.#ctor(System.String,NodaTime.Offset,NodaTime.TimeZones.ZoneYearOffset,System.Int32,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.ZoneRecurrence" /> class.
            </summary>
      <param name="name">The name of the time zone period e.g. PST.</param>
      <param name="savings">The savings for this period.</param>
      <param name="yearOffset">The year offset of when this period starts in a year.</param>
      <param name="fromYear">The first year in which this recurrence is valid</param>
      <param name="toYear">The last year in which this recurrence is valid</param>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneRecurrence.WithName(System.String)">
      <summary>
            Returns a new recurrence which has the same values as this, but a different name.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneRecurrence.Equals(NodaTime.TimeZones.ZoneRecurrence)">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <param name="other">An object to compare with this object.</param>
      <returns>
            true if the current object is equal to the <paramref name="other" /> parameter;
            otherwise, false.
            </returns>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneRecurrence.Next(NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
      <summary>
            Returns the given instant adjusted one year forward taking into account leap years and other
            adjustments like day of week.
            </summary>
      <remarks>
            If the given instant is before the starting year, the year of the given instant is
            adjusted to the beginning of the starting year. The first transition after the
            adjusted instant is determined. If the next adjustment is after the ending year, this
            method returns null; otherwise the next transition is returned.
            </remarks>
      <param name="instant">The <see cref="T:NodaTime.Instant" /> lower bound for the next transition.</param>
      <param name="standardOffset">The <see cref="T:NodaTime.Offset" /> standard offset.</param>
      <param name="previousSavings">The <see cref="T:NodaTime.Offset" /> savings adjustment at the given Instant.</param>
      <returns>The next transition, or null if there is no next transition.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneRecurrence.Previous(NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
      <summary>
            Returns the given instant adjusted one year backward taking into account leap years and other
            adjustments like day of week.
            </summary>
      <param name="instant">The <see cref="T:NodaTime.Instant" /> lower bound for the next trasnition.</param>
      <param name="standardOffset">The <see cref="T:NodaTime.Offset" /> standard offset.</param>
      <param name="previousSavings">The <see cref="T:NodaTime.Offset" /> savings adjustment at the given Instant.</param>
      <returns>The previous transition, or null if there is no previous transition.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneRecurrence.NextOrFail(NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
      <summary>
            Piggy-backs onto Next, but fails with an InvalidOperationException if there's no such transition.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneRecurrence.PreviousOrFail(NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
      <summary>
            Piggy-backs onto Previous, but fails with a descriptive InvalidOperationException if there's no such transition.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneRecurrence.Write(NodaTime.TimeZones.IO.IDateTimeZoneWriter)">
      <summary>
            Writes this object to the given <see cref="T:NodaTime.TimeZones.IO.DateTimeZoneWriter" />.
            </summary>
      <param name="writer">Where to send the output.</param>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneRecurrence.Read(NodaTime.TimeZones.IO.IDateTimeZoneReader)">
      <summary>
            Reads a recurrence from the specified reader.
            </summary>
      <param name="reader">The reader.</param>
      <returns>The recurrence read from the reader.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneRecurrence.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneRecurrence.GetHashCode">
      <summary>
            Returns a hash code for this instance.
            </summary>
      <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneRecurrence.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneRecurrence.ToStartOfTime">
      <summary>
            Returns either "this" (if this zone recurrence already has a from year of int.MinValue)
            or a new zone recurrence which is identical but with a from year of int.MinValue.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.ZoneRecurrence.ToInfinity">
      <summary>
            Returns either "this" (if this zone recurrence is already infinite)
            or a new zone recurrence which is identical but with a from year of int.MinValue
            and an end year of int.MaxValue.
            </summary>
    </member>
    <member name="T:NodaTime.TimeZones.TransitionMode">
      <summary>
            Specifies how transitions are calculated. Whether relative to UTC, the time zones standard
            offset, or the wall (or daylight savings) offset.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.TransitionMode.Utc">
      <summary>
            Calculate transitions against UTC.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.TransitionMode.Wall">
      <summary>
            Calculate transitions against wall offset.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.TransitionMode.Standard">
      <summary>
            Calculate transitions against standard offset.
            </summary>
    </member>
    <member name="T:NodaTime.TimeZones.TzdbDateTimeZoneSource">
      <summary>
            Provides an implementation of <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource" /> that loads data originating from the
            <a href="http://www.iana.org/time-zones">tz database</a> (also known as the IANA Time Zone database, or zoneinfo
            or Olson database).
            </summary>
      <remarks>
            All calls to <see cref="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.ForId(System.String)" /> for fixed-offset IDs advertised by the source (i.e. "UTC" and "UTC+/-Offset")
            will return zones equal to those returned by <see cref="M:NodaTime.DateTimeZone.ForOffset(NodaTime.Offset)" />.
            </remarks>
      <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="F:NodaTime.TimeZones.TzdbDateTimeZoneSource.source">
      <summary>
            Original source data - we delegate to this to create actual DateTimeZone instances,
            and for windows mappings.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.TzdbDateTimeZoneSource.timeZoneIdMap">
      <summary>
            Map from ID (possibly an alias) to canonical ID. This is a read-only wrapper,
            and can be returned directly to clients.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.TzdbDateTimeZoneSource.aliases">
      <summary>
            Lookup from canonical ID to aliases.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.TzdbDateTimeZoneSource.version">
      <summary>
            Composite version ID including TZDB and Windows mapping version strings.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.TzdbDateTimeZoneSource.zoneLocations">
      <summary>
            List of zone locations, if any. This is a read-only wrapper, and can be
            returned directly to clients. It may be null, if the underlying data source
            has no location data.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource" /> class from a resource within
            the NodaTime assembly.
            </summary>
      <remarks>For backwards compatibility, this will use the blob time zone data when given the same
            base name which would previously have loaded the now-obsolete resource data.</remarks>
      <param name="baseName">The root name of the resource file.</param>
      <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data within the resource is invalid.</exception>
      <exception cref="T:System.Resources.MissingManifestResourceException">The resource set cannot be found.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor(System.String,System.Reflection.Assembly)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource" /> class.
            </summary>
      <remarks>For backwards compatibility, this will use the blob time zone data when given the same
            base name which would previously have loaded the now-obsolete resource data from the Noda Time assembly
            itself.</remarks>
      <param name="baseName">The root name of the resource file.</param>
      <param name="assembly">The assembly to search for the time zone resources.</param>
      <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data within the resource is invalid.</exception>
      <exception cref="T:System.Resources.MissingManifestResourceException">The resource set cannot be found.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor(System.Resources.ResourceSet)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource" /> class.
            </summary>
      <param name="source">The <see cref="T:System.Resources.ResourceSet" /> to search for the time zone resources.</param>
      <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data within the resource set is invalid.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.#ctor(System.Resources.ResourceManager)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource" /> class.
            </summary>
      <param name="manager">The <see cref="T:System.Resources.ResourceManager" /> to search for the time zone resources.</param>
      <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data within the resource manager is invalid.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.FromStream(System.IO.Stream)">
      <summary>
            Creates an instance from a stream in the custom Noda Time format. The stream must be readable.
            </summary>
      <remarks>
        <para>
            The stream is not closed by this method, but will be read from
            without rewinding. A successful call will read the stream to the end.
            </para>
        <para>
            See the user guide for instructions on how to generate an updated time zone database file from a copy of the
            (textual) tz database.
            </para>
      </remarks>
      <param name="stream">The stream containing time zone data</param>
      <returns>A <c>TzdbDateTimeZoneSource</c> providing information from the given stream.</returns>
      <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The stream contains invalid time zone data, or data which cannot
            be read by this version of Noda Time.</exception>
      <exception cref="T:System.IO.IOException">Reading from the stream failed.</exception>
      <exception cref="T:System.InvalidOperationException">The supplied stream doesn't support reading.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.ForId(System.String)">
      <inheritdoc />
    </member>
    <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.GetIds">
      <inheritdoc />
    </member>
    <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.MapTimeZoneId(System.TimeZoneInfo)">
      <inheritdoc />
      <param name="zone">The BCL time zone, which must be a known system time zone.</param>
    </member>
    <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.GuessZoneIdByTransitionsUncached(System.TimeZoneInfo)">
      <summary>
            In cases where we can't get a zone mapping, either because we haven't kept
            up to date with the standard names or because the system language isn't English,
            try to work out the TZDB mapping by the transitions within the next few years.
            We only do this for the PCL, where we can't ask a TimeZoneInfo for its ID. Unfortunately
            this means we may sometimes return a mapping for zones which shouldn't be mapped at all, but that's
            probably okay and we return null if we don't get a 70% hit rate anyway. We look at all
            transitions in all primary mappings for the next year.
            Heuristically, this seems to be good enough to get the right results in most cases.
            </summary>
      <remarks>This method is not PCL-only as we would like to test it frequently. It will
            never actually be called in the non-PCL release though.</remarks>
      <param name="zone">Zone to resolve in a best-effort fashion.</param>
    </member>
    <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.Validate">
      <summary>
            Validates that the data within this source is consistent with itself.
            </summary>
      <remarks>
            Source data is not validated automatically when it's loaded, but any source
            loaded from data produced by <c>NodaTime.TzdbCompiler</c> (including the data shipped with Noda Time)
            will already have been validated via this method when it was originally produced. This method should
            only normally be called explicitly if you have data from a source you're unsure of.
            </remarks>
      <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The source data is invalid. The source may not function
            correctly.</exception>
    </member>
    <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.Default">
      <summary>
            The <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource" /> initialised from resources within the NodaTime assembly.
            </summary>
    </member>
    <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.VersionId">
      <inheritdoc />
      <remarks>
        <para>
            This source returns a string such as "TZDB: 2013b (mapping: 8274)" corresponding to the versions of the tz
            database and the CLDR Windows zones mapping file.
            </para>
        <para>
            Note that there is no need to parse this string to extract any of the above information, as it is available
            directly from the <see cref="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion" /> and <see cref="P:NodaTime.TimeZones.Cldr.WindowsZones.Version" /> properties.
            </para>
      </remarks>
    </member>
    <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.Aliases">
      <summary>
            Returns a lookup from canonical time zone ID (e.g. "Europe/London") to a group of aliases for that time zone
            (e.g. {"Europe/Belfast", "Europe/Guernsey", "Europe/Jersey", "Europe/Isle_of_Man", "GB", "GB-Eire"}).
            </summary>
      <remarks>
            The group of values for a key never contains the canonical ID, only aliases. Any time zone
            ID which is itself an alias or has no aliases linking to it will not be present in the lookup.
            The aliases within a group are returned in alphabetical (ordinal) order.
            </remarks>
      <returns>A lookup from canonical ID to the aliases of that ID.</returns>
    </member>
    <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.CanonicalIdMap">
      <summary>
            Returns a read-only map from time zone ID to the canonical ID. For example, the key "Europe/Jersey"
            would be associated with the value "Europe/London".
            </summary>
      <remarks>
        <para>This map contains an entry for every ID returned by <see cref="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.GetIds" />, where
            canonical IDs map to themselves.</para>
        <para>The returned map is read-only; any attempts to call a mutating method will throw
            <see cref="T:System.NotSupportedException" />.</para>
      </remarks>
      <returns>A map from time zone ID to the canonical ID.</returns>
    </member>
    <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.ZoneLocations">
      <summary>
            Returns a read-only list of zone locations known to this source.
            </summary>
      <remarks>
        <para>
            Every zone location's time zone ID is guaranteed to be valid within this source (assuming the source
            has been validated).
            </para>
        <para>
            The legacy resource format does not include location information,
            and this property will throw an exception if the information is requested. It is expected
            that callers who wish to use newer features will not be attempting to use legacy formats
            for time zone data.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">This is a legacy resource-based data source which does
            not include location information.</exception>
    </member>
    <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion">
      <summary>
            Returns just the TZDB version (e.g. "2013a") of the source data.
            </summary>
    </member>
    <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.WindowsMapping">
      <summary>
            Gets the Windows time zone mapping information provided in the CLDR
            supplemental "windowsZones.xml" file.
            </summary>
    </member>
    <member name="T:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader">
      <summary>
            Implementation of <see cref="T:NodaTime.TimeZones.IO.IDateTimeZoneReader" /> which maintains the legacy "resource" format.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadCount">
      <summary>
            Reads a non-negative integer value from the stream.
            </summary>
      <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteCount(System.Int32)" />.
            </remarks>
      <returns>The integer value from the stream.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadSignedCount">
      <summary>
            Always throws NotSupportedException
            </summary>
      <returns>The integer read from the stream</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadOffset">
      <summary>
            Reads an offset value from the stream.
            </summary>
      <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteOffset(NodaTime.Offset)" />.
            </remarks>
      <returns>The offset value from the stream.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadTicks">
      <summary>
            Reads a long ticks value from the stream.
            </summary>
      <remarks>
            The value must have been written by LegacyDateTimeZoneWriter.WriteTicks.
            </remarks>
      <returns>The long ticks value from the stream.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadBoolean">
      <summary>
            Reads a boolean value from the stream.
            </summary>
      <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteBoolean(System.Boolean)" />.
            </remarks>
      <returns>The boolean value.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadDictionary">
      <summary>
            Reads a string to string dictionary value from the stream.
            </summary>
      <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteDictionary(System.Collections.Generic.IDictionary{System.String,System.String})" />.
            </remarks>
      <returns>The <see cref="T:System.Collections.Generic.IDictionary`2" /> value from the stream.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadZoneIntervalTransition(System.Nullable{NodaTime.Instant})">
      <summary>
            Reads an <see cref="T:NodaTime.Instant" /> value from the stream.
            </summary>
      <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteZoneIntervalTransition(System.Nullable{NodaTime.Instant},NodaTime.Instant)" />.
            The <paramref name="previous" /> parameter is ignored by this implementation.
            </remarks>
      <param name="previous">The previous transition written (usually for a given timezone), or null if there is
            no previous transition.</param>
      <returns>The <see cref="T:NodaTime.Instant" /> value from the stream.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadString">
      <summary>
            Reads a string value from the stream.
            </summary>
      <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteString(System.String)" />.
            </remarks>
      <returns>The string value from the stream.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadTimeZone(System.String)">
      <summary>
            Reads an <see cref="T:NodaTime.DateTimeZone" /> value from the stream.
            </summary>
      <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteTimeZone(NodaTime.DateTimeZone)" />.
            </remarks>
      <returns>The <see cref="T:NodaTime.DateTimeZone" /> value from the stream.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadInt16">
      <summary>
              Reads a signed 16 bit integer value from the stream and returns it as an int.
            </summary>
      <returns>The 16 bit int value.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadInt32">
      <summary>
            Reads a signed 32 bit integer value from the stream and returns it as an int.
            </summary>
      <returns>The 32 bit int value.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadInt64">
      <summary>
            Reads a signed 64 bit integer value from the stream and returns it as an long.
            </summary>
      <returns>The 64 bit long value.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneReader.ReadByte">
      <inheritdoc />
    </member>
    <member name="T:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter">
      <summary>
            Implementation of <see cref="T:NodaTime.TimeZones.IO.IDateTimeZoneWriter" /> which maintains the legacy "resource" format.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.#ctor(System.IO.Stream,System.Collections.Generic.IList{System.String})">
      <summary>
            Constructs a LegacyDateTimeZoneWriter.
            </summary>
      <param name="output">Where to send the serialized output.</param>
      <param name="stringPool">String pool to add strings to, or null for no pool</param>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteCount(System.Int32)">
      <summary>
            Writes the given non-negative integer value to the stream.
            </summary>
      <param name="value">The value to write.</param>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteSignedCount(System.Int32)">
      <summary>
            Always throws NotSupportedException
            </summary>
      <param name="count">The value to write.</param>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteOffset(NodaTime.Offset)">
      <summary>
            Writes the offset value to the stream.
            </summary>
      <param name="offset">The value to write.</param>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteTicks(System.Int64)">
      <summary>
            Writes the long ticks value to the stream.
            </summary>
      <param name="value">The value to write.</param>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteBoolean(System.Boolean)">
      <summary>
            Writes a boolean value to the stream.
            </summary>
      <param name="value">The value to write.</param>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteDictionary(System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Writes the given dictionary of string to string to the stream.
            </summary>
      <param name="dictionary">The <see cref="T:System.Collections.Generic.IDictionary`2" /> to write.</param>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteZoneIntervalTransition(System.Nullable{NodaTime.Instant},NodaTime.Instant)">
      <summary>
            Writes the <see cref="T:NodaTime.Instant" /> value to the stream.
            </summary>
      <remarks>
            The <paramref name="previous" /> parameter is ignored by this implementation.
            </remarks>
      <param name="previous">The previous transition written (usually for a given timezone), or null if there is
            no previous transition.</param>
      <param name="value">The value to write.</param>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteString(System.String)">
      <summary>
            Writes the string value to the stream.
            </summary>
      <param name="value">The value to write.</param>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteTimeZone(NodaTime.DateTimeZone)">
      <summary>
            Writes the <see cref="T:NodaTime.DateTimeZone" /> value to the stream.
            </summary>
      <param name="value">The value to write.</param>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteInt16(System.Int16)">
      <summary>
            Writes the given 16 bit integer value to the stream.
            </summary>
      <param name="value">The value to write.</param>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteInt32(System.Int32)">
      <summary>
            Writes the given 32 bit integer value to the stream.
            </summary>
      <param name="value">The value to write.</param>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteInt64(System.Int64)">
      <summary>
            Writes the given 64 bit integer value to the stream.
            </summary>
      <param name="value">The value to write.</param>
    </member>
    <member name="M:NodaTime.TimeZones.IO.LegacyDateTimeZoneWriter.WriteByte(System.Byte)">
      <inheritdoc />
    </member>
    <member name="T:NodaTime.TimeZones.IO.DateTimeZoneReader">
      <summary>
            Implementation of <see cref="T:NodaTime.TimeZones.IO.IDateTimeZoneReader" /> for the most recent version
            of the "blob" format of time zone data. If the format changes, this class will be
            renamed (e.g. to DateTimeZoneReaderV0) and the new implementation will replace it.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadCount">
      <summary>
            Reads a non-negative integer value from the stream.
            </summary>
      <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteCount(System.Int32)" />.
            </remarks>
      <returns>The integer value from the stream.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadSignedCount">
      <summary>
            Reads a (possibly-negative) integer value from the stream.
            </summary>
      <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteSignedCount(System.Int32)" />.
            </remarks>
      <returns>The integer value from the stream.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadVarint">
      <summary>
            Reads a base-128 varint value from the stream.
            </summary>
      <remarks>
            The value must have been written by DateTimeZoneWriter.WriteVarint, which
            documents the format.
            </remarks>
      <returns>The integer value from the stream.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadOffset">
      <summary>
            Reads an offset value from the stream.
            </summary>
      <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteOffset(NodaTime.Offset)" />.
            </remarks>
      <returns>The offset value from the stream.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadDictionary">
      <summary>
            Reads a string to string dictionary value from the stream.
            </summary>
      <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteDictionary(System.Collections.Generic.IDictionary{System.String,System.String})" />.
            </remarks>
      <returns>The <see cref="T:System.Collections.Generic.IDictionary`2" /> value from the stream.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadZoneIntervalTransition(System.Nullable{NodaTime.Instant})">
      <summary>
            Reads an instant representing a zone interval transition from the stream.
            </summary>
      <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteZoneIntervalTransition(System.Nullable{NodaTime.Instant},NodaTime.Instant)" />.
            </remarks>
      <param name="previous">The previous transition written (usually for a given timezone), or null if there is
            no previous transition.</param>
      <returns>The instant read from the stream</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadString">
      <summary>
            Reads a string value from the stream.
            </summary>
      <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteString(System.String)" />.
            </remarks>
      <returns>The string value from the stream.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadInt16">
      <summary>
            Reads a signed 16 bit integer value from the stream and returns it as an int.
            </summary>
      <returns>The 16 bit int value.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadInt32">
      <summary>
            Reads a signed 32 bit integer value from the stream and returns it as an int.
            </summary>
      <returns>The 32 bit int value.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadInt64">
      <summary>
            Reads a signed 64 bit integer value from the stream and returns it as an long.
            </summary>
      <returns>The 64 bit long value.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadByte">
      <summary>
            Reads a signed 8 bit integer value from the stream and returns it as an int.
            </summary>
      <returns>The 8 bit int value.</returns>
      <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data in the stream has been exhausted.</exception>
      <inheritdoc />
    </member>
    <member name="T:NodaTime.TimeZones.IO.DateTimeZoneWriter">
      <summary>
            Implementation of <see cref="T:NodaTime.TimeZones.IO.IDateTimeZoneWriter" /> for the most recent version
            of the "blob" format of time zone data. If the format changes, this class will be
            renamed (e.g. to DateTimeZoneWriterV0) and the new implementation will replace it.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.#ctor(System.IO.Stream,System.Collections.Generic.IList{System.String})">
      <summary>
            Constructs a DateTimeZoneWriter.
            </summary>
      <param name="output">Where to send the serialized output.</param>
      <param name="stringPool">String pool to add strings to, or null for no pool</param>
    </member>
    <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteCount(System.Int32)">
      <summary>
            Writes the given non-negative integer value to the stream.
            </summary>
      <param name="value">The value to write.</param>
    </member>
    <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteSignedCount(System.Int32)">
      <summary>
            Writes the given (possibly-negative) integer value to the stream.
            </summary>
      <remarks>
            Unlike <see cref="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteCount(System.Int32)" />, this can encode negative numbers. It does, however, use a slightly less
            efficient encoding for positive numbers.
            </remarks>
      <param name="count">The value to write.</param>
    </member>
    <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteVarint(System.UInt32)">
      <summary>
            Writes the given integer value to the stream as a base-128 varint.
            </summary>
      <remarks>
            The format is a simple 7-bit encoding: while the value is greater than 127 (i.e.
            has more than 7 significant bits) we repeatedly write the least-significant 7 bits
            with the top bit of the byte set as a continuation bit, then shift the value right
            7 bits.
            </remarks>
      <param name="value">The value to write.</param>
    </member>
    <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteOffset(NodaTime.Offset)">
      <summary>
            Writes the offset value to the stream.
            </summary>
      <param name="offset">The value to write.</param>
    </member>
    <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteDictionary(System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Writes the given dictionary of string to string to the stream.
            </summary>
      <param name="dictionary">The <see cref="T:System.Collections.Generic.IDictionary`2" /> to write.</param>
    </member>
    <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteString(System.String)">
      <summary>
            Writes the string value to the stream.
            </summary>
      <param name="value">The value to write.</param>
    </member>
    <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteInt16(System.Int16)">
      <summary>
            Writes the given 16 bit integer value to the stream.
            </summary>
      <param name="value">The value to write.</param>
    </member>
    <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteInt32(System.Int32)">
      <summary>
            Writes the given 32 bit integer value to the stream.
            </summary>
      <param name="value">The value to write.</param>
    </member>
    <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteInt64(System.Int64)">
      <summary>
            Writes the given 64 bit integer value to the stream.
            </summary>
      <param name="value">The value to write.</param>
    </member>
    <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteByte(System.Byte)">
      <inheritdoc />
    </member>
    <member name="T:NodaTime.TimeZones.IO.IDateTimeZoneReader">
      <summary>
            Interface for reading time-related data from a binary stream.
            This is similar to <see cref="T:System.IO.BinaryReader" />, but heavily
            oriented towards our use cases. 
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneReader.ReadCount">
      <summary>
            Reads a non-negative integer from the stream, which must have been written
            by a call to <see cref="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteCount(System.Int32)" />.
            </summary>
      <returns>The integer read from the stream</returns>
      <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data was invalid.</exception>
      <exception cref="T:System.IO.IOException">The stream could not be read.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneReader.ReadSignedCount">
      <summary>
            Reads a non-negative integer from the stream, which must have been written
            by a call to <see cref="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteSignedCount(System.Int32)" />.
            </summary>
      <returns>The integer read from the stream</returns>
      <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data was invalid.</exception>
      <exception cref="T:System.IO.IOException">The stream could not be read.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneReader.ReadString">
      <summary>
            Reads a string from the stream.
            </summary>
      <returns>The string read from the stream; will not be null</returns>
      <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data was invalid.</exception>
      <exception cref="T:System.IO.IOException">The stream could not be read.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneReader.ReadByte">
      <summary>
            Reads a signed 8 bit integer value from the stream and returns it as an int.
            </summary>
      <returns>The 8 bit int value.</returns>
      <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data in the stream has been exhausted.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneReader.ReadOffset">
      <summary>
            Reads an offset from the stream.
            </summary>
      <returns>The offset read from the stream</returns>
      <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data was invalid.</exception>
      <exception cref="T:System.IO.IOException">The stream could not be read.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneReader.ReadZoneIntervalTransition(System.Nullable{NodaTime.Instant})">
      <summary>
            Reads an instant representing a zone interval transition from the stream.
            </summary>
      <param name="previous">The previous transition written (usually for a given timezone), or null if there is
            no previous transition.</param>
      <returns>The instant read from the stream</returns>
      <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data was invalid.</exception>
      <exception cref="T:System.IO.IOException">The stream could not be read.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneReader.ReadDictionary">
      <summary>
            Reads a string-to-string dictionary from the stream.
            </summary>
      <returns>The dictionary read from the stream</returns>
      <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data was invalid.</exception>
      <exception cref="T:System.IO.IOException">The stream could not be read.</exception>
    </member>
    <member name="T:NodaTime.TimeZones.IO.IDateTimeZoneWriter">
      <summary>
            Interface for writing time-related data to a binary stream.
            This is similar to <see cref="T:System.IO.BinaryWriter" />, but heavily
            oriented towards our use cases.
            </summary>
      <remarks>
        <para>It is expected that the code reading data written by an implementation
            will be able to identify which implementation to use. Initially we have two
            implementations: one for reading the data from the legacy resource format,
            and one for reading the data from the first version of the newer blob format.
            When the legacy resource format is retired, it's possible that we will only
            have one implementation moving forward - but the interface will allow us to
            evolve the details of the binary structure independently of the code in the
            time zone implementations which knows how to write/read in terms of this interface
            and <see cref="T:NodaTime.TimeZones.IO.IDateTimeZoneReader" />.
            </para>
      </remarks>
    </member>
    <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteCount(System.Int32)">
      <summary>
            Writes a non-negative integer to the stream. This is optimized towards
            cases where most values will be small.
            </summary>
      <param name="count">The integer to write to the stream.</param>
      <exception cref="T:System.IO.IOException">The value couldn't be written to the stream.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> is negative.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteSignedCount(System.Int32)">
      <summary>
            Writes a possibly-negative integer to the stream. This is optimized for
            values of small magnitudes.
            </summary>
      <param name="count">The integer to write to the stream.</param>
      <exception cref="T:System.IO.IOException">The value couldn't be written to the stream.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteString(System.String)">
      <summary>
            Writes a string to the stream.
            </summary>
      <remarks>Other than the legacy resource writer, callers can reasonably expect that
            these values will be pooled in some fashion, so should not apply their own pooling.</remarks>
      <param name="value">The string to write to the stream.</param>
      <exception cref="T:System.IO.IOException">The value couldn't be written to the stream.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteOffset(NodaTime.Offset)">
      <summary>
            Writes an offset to the stream.
            </summary>
      <param name="offset">The offset to write to the stream.</param>
      <exception cref="T:System.IO.IOException">The value couldn't be written to the stream.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteZoneIntervalTransition(System.Nullable{NodaTime.Instant},NodaTime.Instant)">
      <summary>
            Writes an instant representing a zone interval transition to the stream.
            </summary>
      <remarks>
            This method takes a previously-written transition. Depending on the implementation, this value may be
            required by the reader in order to reconstruct the next transition, so it should be deterministic for any
            given value.
            </remarks>
      <param name="previous">The previous transition written (usually for a given timezone), or null if there is
            no previous transition.</param>
      <param name="value">The transition to write to the stream.</param>
      <exception cref="T:System.IO.IOException">The value couldn't be written to the stream.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteDictionary(System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Writes a string-to-string dictionary to the stream.
            </summary>
      <param name="dictionary">
      </param>
      <exception cref="T:System.IO.IOException">The value couldn't be written to the stream.</exception>
    </member>
    <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteByte(System.Byte)">
      <summary>
            Writes the given 8 bit integer value to the stream.
            </summary>
      <param name="value">The value to write.</param>
    </member>
    <member name="T:NodaTime.TimeZones.IO.ITzdbDataSource">
      <summary>
            Provides the raw data exposed by <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource" />. It would
            be simpler to use inheritance in this case with static factory methods, but
            there are already public constructors exposed - so to delegate to different
            implementations, we need a separate hierarchy :(
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.IO.ITzdbDataSource.CreateZone(System.String,System.String)">
      <summary>
            Creates the <see cref="T:NodaTime.DateTimeZone" /> for the given canonical ID, which will definitely
            be one of the values of the TzdbAliases dictionary.
            </summary>
      <param name="id">ID for the returned zone, which may be an alias.</param>
      <param name="canonicalId">Canonical ID for zone data</param>
    </member>
    <member name="P:NodaTime.TimeZones.IO.ITzdbDataSource.TzdbVersion">
      <summary>
            Returns the TZDB version string.
            </summary>
    </member>
    <member name="P:NodaTime.TimeZones.IO.ITzdbDataSource.TzdbIdMap">
      <summary>
            Returns the TZDB ID dictionary (alias to canonical ID). This needn't be read-only; it won't be
            exposed directly.
            </summary>
    </member>
    <member name="P:NodaTime.TimeZones.IO.ITzdbDataSource.WindowsMapping">
      <summary>
            Returns the Windows mapping dictionary. (As the type is immutable, it can be exposed directly
            to callers.)
            </summary>
    </member>
    <member name="P:NodaTime.TimeZones.IO.ITzdbDataSource.ZoneLocations">
      <summary>
            Returns the zone locations for the source, or null if no location data is available.
            This needn't be read-only; it won't be exposed directly.
            </summary>
    </member>
    <member name="P:NodaTime.TimeZones.IO.ITzdbDataSource.WindowsAdditionalStandardNameToIdMapping">
      <summary>
            Additional mappings from Windows standard name to TZDB ID. Primarily used in
            the PCL build, where we can't get at the system ID. Returns null when no data
            is available (legacy resource format).
            </summary>
    </member>
    <member name="T:NodaTime.TimeZones.IO.TzdbResourceData">
      <summary>
            Matching class for TzdbResourceWriter in the NodaTime.TzdbCompiler project. This
            knows how to read TZDB information from a .NET resource file.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.IO.TzdbResourceData.WindowsToPosixMapKey">
      <summary>
            The resource key for the Windows to TZDB ID mapping dictionary.
            This resource key contains hyphens, so cannot conflict with a time zone name.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.IO.TzdbResourceData.WindowsToPosixMapVersionKey">
      <summary>
            The resource key for the Windows to TZDB ID mapping version string.
            This resource key contains hyphens, so cannot conflict with a time zone name.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.IO.TzdbResourceData.IdMapKey">
      <summary>
            The resource key for the timezone ID alias dictionary.
            This resource key contains hyphens, so cannot conflict with a time zone name.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.IO.TzdbResourceData.VersionKey">
      <summary>
            The resource key for the TZDB version ID.
            This resource key contains hyphens, so cannot conflict with a time zone name.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.IO.TzdbResourceData.CreateZone(System.String,System.String)">
      <inheritdoc />
    </member>
    <member name="M:NodaTime.TimeZones.IO.TzdbResourceData.LoadDictionary(System.Resources.ResourceSet,System.String)">
      <summary>
            Loads a dictionary of string to string with the given name from the given resource manager.
            </summary>
      <param name="source">The <see cref="T:System.Resources.ResourceSet" /> to load from.</param>
      <param name="name">The resource name.</param>
      <returns>The <see cref="T:System.Collections.Generic.IDictionary`2" /> or null if there is no such resource.</returns>
    </member>
    <member name="M:NodaTime.TimeZones.IO.TzdbResourceData.NormalizeAsResourceName(System.String)">
      <summary>
            Normalizes the given name into a valid resource name by replacing invalid
            characters with alternatives. This is used to ensure a valid resource name is
            used for each time zone resource.
            </summary>
      <param name="name">The name to normalize.</param>
      <returns>The normalized name.</returns>
    </member>
    <member name="P:NodaTime.TimeZones.IO.TzdbResourceData.TzdbVersion">
      <inheritdoc />
    </member>
    <member name="P:NodaTime.TimeZones.IO.TzdbResourceData.TzdbIdMap">
      <inheritdoc />
    </member>
    <member name="P:NodaTime.TimeZones.IO.TzdbResourceData.WindowsMapping">
      <inheritdoc />
    </member>
    <member name="P:NodaTime.TimeZones.IO.TzdbResourceData.ZoneLocations">
      <summary>
            Always returns null - the resource data does not include zone locations.
            </summary>
    </member>
    <member name="T:NodaTime.TimeZones.IO.TzdbStreamData.Builder">
      <summary>
            Mutable builder class used during parsing.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.IO.TzdbStreamData.CreateZone(System.String,System.String)">
      <inheritdoc />
    </member>
    <member name="P:NodaTime.TimeZones.IO.TzdbStreamData.TzdbVersion">
      <inheritdoc />
    </member>
    <member name="P:NodaTime.TimeZones.IO.TzdbStreamData.TzdbIdMap">
      <inheritdoc />
    </member>
    <member name="P:NodaTime.TimeZones.IO.TzdbStreamData.WindowsMapping">
      <inheritdoc />
    </member>
    <member name="P:NodaTime.TimeZones.IO.TzdbStreamData.ZoneLocations">
      <inheritdoc />
    </member>
    <member name="P:NodaTime.TimeZones.IO.TzdbStreamData.WindowsAdditionalStandardNameToIdMapping">
      <inheritdoc />
    </member>
    <member name="T:NodaTime.TimeZones.IO.TzdbStreamField">
      <summary>
            An unparsed field within a stream.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.IO.TzdbStreamField.CreateStream">
      <summary>
            Creates a new read-only stream over the data for this field.
            </summary>
    </member>
    <member name="T:NodaTime.TimeZones.IO.TzdbStreamFieldId">
      <summary>
            Enumeration of the fields which can occur in a TZDB stream file.
            This enables the file to be self-describing to a reasonable extent.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.IO.TzdbStreamFieldId.StringPool">
      <summary>
            String pool. Format is: number of strings (WriteCount) followed by that many string values.
            The indexes into the resultant list are used for other strings in the file, in some fields.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.IO.TzdbStreamFieldId.TimeZone">
      <summary>
            Repeated field of time zones. Format is: zone ID, then zone as written by DateTimeZoneWriter.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.IO.TzdbStreamFieldId.TzdbVersion">
      <summary>
            Single field giving the version of the TZDB source data. A string value which does *not* use the string pool.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.IO.TzdbStreamFieldId.TzdbIdMap">
      <summary>
            Single field giving the mapping of ID to canonical ID, as written by DateTimeZoneWriter.WriteDictionary.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.IO.TzdbStreamFieldId.CldrSupplementalWindowsZones">
      <summary>
            Single field containing mapping data as written by WindowsZones.Write.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.IO.TzdbStreamFieldId.WindowsAdditionalStandardNameToIdMapping">
      <summary>
            Single field giving the mapping of Windows StandardName to TZDB canonical ID,
            for time zones where TimeZoneInfo.Id != TimeZoneInfo.StandardName,
            as written by DateTimeZoneWriter.WriteDictionary.
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.IO.TzdbStreamFieldId.ZoneLocations">
      <summary>
            Single field providing all zone locations. The format is simply a count, and then that many copies of
            TzdbZoneLocation data.
            </summary>
    </member>
    <member name="T:NodaTime.TimeZones.Cldr.MapZone">
      <summary>
            Represents a single <c>&lt;mapZone&gt;</c> element in the CLDR Windows zone mapping file. 
            </summary>
      <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="F:NodaTime.TimeZones.Cldr.MapZone.PrimaryTerritory">
      <summary>
            Identifier used for the primary territory of each Windows time zone. A zone mapping with
            this territory will always have a single entry. The value of this constant is "001".
            </summary>
    </member>
    <member name="F:NodaTime.TimeZones.Cldr.MapZone.FixedOffsetTerritory">
      <summary>
            Identifier used for the "fixed offset" territory. A zone mapping with
            this territory will always have a single entry. The value of this constant is "ZZ".
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.Cldr.MapZone.#ctor(System.String,System.String,System.Collections.Generic.IList{System.String})">
      <summary>
            Creates a new mapping entry.
            </summary>
      <remarks>
            This constructor is only public for the sake of testability.
            </remarks>
      <param name="windowsId">Windows system time zone identifier. Must not be null.</param>
      <param name="territory">Territory code. Must not be null.</param>
      <param name="tzdbIds">List of territory codes. Must not be null, and must not
            contains null values.</param>
    </member>
    <member name="M:NodaTime.TimeZones.Cldr.MapZone.#ctor(System.String,System.String,System.Collections.ObjectModel.ReadOnlyCollection{System.String})">
      <summary>
            Private constructor to avoid unnecessary list copying (and validation) when deserializing.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.Cldr.MapZone.Read(NodaTime.TimeZones.IO.IDateTimeZoneReader)">
      <summary>
            Reads a mapping from a reader.
            </summary>
    </member>
    <member name="M:NodaTime.TimeZones.Cldr.MapZone.Write(NodaTime.TimeZones.IO.IDateTimeZoneWriter)">
      <summary>
            Writes this mapping to a writer.
            </summary>
      <param name="writer">
      </param>
    </member>
    <member name="P:NodaTime.TimeZones.Cldr.MapZone.WindowsId">
      <summary>
            Gets the Windows system time zone identifier for this mapping, such as "Central Standard Time".
            </summary>
      <remarks>
        <para>
            Most Windows system time zone identifiers use the name for the "standard" part of the zone as
            the overall identifier. Don't be fooled: just because a time zone includes "standard" in its identifier
            doesn't mean that it doesn't observe daylight saving time.
            </para>
      </remarks>
    </member>
    <member name="P:NodaTime.TimeZones.Cldr.MapZone.Territory">
      <summary>
            Gets the territory code for this mapping.
            </summary>
      <remarks>
            This is typically either "001" to indicate that it's the primary territory for this ID, or
            "ZZ" to indicate a fixed-offset ID, or a different two-character capitalized code
            which indicates the geographical territory.
            </remarks>
    </member>
    <member name="P:NodaTime.TimeZones.Cldr.MapZone.TzdbIds">
      <summary>
            Gets a read-only non-empty collection of TZDB zone identifiers for this mapping, such as
            "America/Chicago" and "America/Matamoros" (both of which are TZDB zones associated with the "Central Standard Time"
            Windows system time zone).
            </summary>
      <remarks>
            For the primary and fixed-offset territory IDs ("001" and "ZZ") this always
            contains exactly one time zone ID.
            </remarks>
    </member>
    <member name="T:NodaTime.TimeZones.Cldr.NamespaceDoc">
      <summary>
        <para>
            The NodaTime.TimeZones.Cldr namespace contains types related to time zone information provided
            by the Unicode CLDR (Common Locale Data Repository) project.
            </para>
      </summary>
    </member>
    <member name="T:NodaTime.TimeZones.Cldr.WindowsZones">
      <summary>
            Representation of the <c>&lt;windowsZones&gt;</c> element of CLDR supplemental data.
            </summary>
      <remarks>
            See <a href="http://cldr.unicode.org/development/development-process/design-proposals/extended-windows-olson-zid-mapping">the CLDR design proposal</a>
            for more details of the structure of the file from which data is taken.
            </remarks>
      <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="P:NodaTime.TimeZones.Cldr.WindowsZones.Version">
      <summary>
            Gets the version of the Windows zones mapping data read from the original file.
            </summary>
      <remarks>
        <para>
            As with other IDs, this should largely be treated as an opaque string, but the current method for
            generating this from the mapping file extracts a number from an element such as <c>&lt;version number="$Revision: 7825 $"/&gt;</c>.
            This is a Subversion revision number, but that association should only be used for diagnostic curiosity, and never
            assumed in code.
            </para>
        <para>
            This property will never return a null value.
            </para>
      </remarks>
    </member>
    <member name="P:NodaTime.TimeZones.Cldr.WindowsZones.TzdbVersion">
      <summary>
            Gets the TZDB version this Windows zone mapping data was created from.
            </summary>
      <remarks>
        <para>
            The CLDR mapping file usually lags behind the TZDB file somewhat - partly because the
            mappings themselves don't always change when the time zone data does. For example, it's entirely
            reasonable for a <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource" /> with a <see cref="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion">TzdbVersion</see> of
            "2013b" to be supply a <c>WindowsZones</c> object with a <c>TzdbVersion</c> of "2012f".
            </para>
        <para>
            This property will never return a null value, but will be "Unknown" if the data
            is loaded from the legacy resource format.
            </para>
      </remarks>
    </member>
    <member name="P:NodaTime.TimeZones.Cldr.WindowsZones.WindowsVersion">
      <summary>
            Gets the Windows time zone database version this Windows zone mapping data was created from.
            </summary>
      <remarks>
        <para>
            At the time of this writing, this is populated (by CLDR) from the registry key
            HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones\TzVersion,
            so "7dc0101" for example.
            </para>
        <para>
            This property will never return a null value, but will be "Unknown" if the data
            is loaded from the legacy resource format.
            </para>
      </remarks>
    </member>
    <member name="P:NodaTime.TimeZones.Cldr.WindowsZones.MapZones">
      <summary>
            Gets an immutable collection of mappings from Windows system time zones to
            TZDB time zones.
            </summary>
      <remarks>
        <para>
            Each mapping consists of a single Windows time zone ID and a single
            territory to potentially multiple TZDB IDs that are broadly equivalent to that Windows zone/territory
            pair.
            </para>
        <para>
            Mappings for a single Windows system time zone can appear multiple times
            in this list, in different territories. For example, "Central Standard Time"
            maps to different TZDB zones in different countries (the US, Canada, Mexico) and
            even within a single territory there can be multiple zones. Every Windows system time zone covered within
            this collection has a "primary" entry with a territory code of "001" (which is the value of
            <see cref="F:NodaTime.TimeZones.Cldr.MapZone.PrimaryTerritory" />) and a single corresponding TZDB zone. 
            </para>
        <para>This collection is not guaranteed to cover every Windows time zone. Some zones may be unmappable
            (such as "Mid-Atlantic Standard Time") and there can be a delay between a new Windows time zone being introduced
            and it appearing in CLDR, ready to be used by Noda Time. (There's also bound to be a delay between it appearing
            in CLDR and being used in your production system.) In practice however, you're unlikely to wish to use a time zone
            which isn't covered here.</para>
        <para>
            If the data is loaded from the legacy resource format, this will only include the primary mappings.
            </para>
      </remarks>
    </member>
    <member name="P:NodaTime.TimeZones.Cldr.WindowsZones.PrimaryMapping">
      <summary>
            Gets an immutable dictionary of primary mappings, from Windows system time zone ID
            to TZDB zone ID. This corresponds to the "001" territory which is present for every zone
            within the mapping file.
            </summary>
    </member>
    <member name="T:NodaTime.Text.DurationPattern">
      <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.Duration" /> values.
            </summary>
      <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
    </member>
    <member name="M:NodaTime.Text.DurationPattern.Parse(System.String)">
      <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
      <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
      <param name="text">The text value to parse.</param>
      <returns>The result of parsing, which may be successful or unsuccessful.</returns>
    </member>
    <member name="M:NodaTime.Text.DurationPattern.Format(NodaTime.Duration)">
      <summary>
            Formats the given duration as text according to the rules of this pattern.
            </summary>
      <param name="value">The duration to format.</param>
      <returns>The duration formatted according to this pattern.</returns>
    </member>
    <member name="M:NodaTime.Text.DurationPattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo)">
      <summary>
            Creates a pattern for the given pattern text and format info.
            </summary>
      <param name="patternText">Pattern text to create the pattern for</param>
      <param name="formatInfo">Localization information</param>
      <returns>A pattern for parsing and formatting offsets.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.DurationPattern.Create(System.String,System.Globalization.CultureInfo)">
      <summary>
            Creates a pattern for the given pattern text and culture.
            </summary>
      <remarks>
            See the user guide for the available pattern text options.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <param name="cultureInfo">The culture to use in the pattern</param>
      <returns>A pattern for parsing and formatting offsets.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.DurationPattern.CreateWithCurrentCulture(System.String)">
      <summary>
            Creates a pattern for the given pattern text in the current thread's current culture.
            </summary>
      <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <returns>A pattern for parsing and formatting offsets.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.DurationPattern.CreateWithInvariantCulture(System.String)">
      <summary>
            Creates a pattern for the given pattern text in the invariant culture.
            </summary>
      <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <returns>A pattern for parsing and formatting offsets.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.DurationPattern.WithCulture(System.Globalization.CultureInfo)">
      <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
      <param name="cultureInfo">The culture to use in the new pattern.</param>
      <returns>A new pattern with the given culture.</returns>
    </member>
    <member name="P:NodaTime.Text.DurationPattern.RoundtripPattern">
      <summary>
            General pattern for durations using the invariant culture, with a format string of "-D:hh:mm:ss.FFFFFFF".
            This pattern round-trips.
            </summary>
    </member>
    <member name="P:NodaTime.Text.DurationPattern.PatternText">
      <summary>
            Returns the pattern text for this pattern, as supplied on creation.
            </summary>
    </member>
    <member name="P:NodaTime.Text.DurationPattern.FormatInfo">
      <summary>
            Returns the localization information used in this pattern.
            </summary>
    </member>
    <member name="T:NodaTime.Text.DurationPatternParser.DurationParseBucket">
      <summary>
            Provides a container for the interim parsed pieces of an <see cref="T:NodaTime.Offset" /> value.
            </summary>
    </member>
    <member name="M:NodaTime.Text.DurationPatternParser.DurationParseBucket.CalculateValue(NodaTime.Text.Patterns.PatternFields,System.String)">
      <summary>
            Calculates the value from the parsed pieces.
            </summary>
    </member>
    <member name="M:NodaTime.Text.DurationPatternParser.GetPositiveTicks(NodaTime.Duration)">
      <summary>
            Returns the absolute number of ticks in a duration, as a ulong in order to handle long.MinValue sensibly.
            </summary>
    </member>
    <member name="T:NodaTime.Text.OffsetDateTimePattern">
      <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.OffsetDateTime" /> values.
            </summary>
      <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
    </member>
    <member name="T:NodaTime.Text.OffsetDateTimePattern.Patterns">
      <summary>
            Class whose existence is solely to avoid type initialization order issues, most of which stem
            from needing NodaFormatInfo.InvariantInfo...
            </summary>
    </member>
    <member name="M:NodaTime.Text.OffsetDateTimePattern.Parse(System.String)">
      <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
      <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
      <param name="text">The text value to parse.</param>
      <returns>The result of parsing, which may be successful or unsuccessful.</returns>
    </member>
    <member name="M:NodaTime.Text.OffsetDateTimePattern.Format(NodaTime.OffsetDateTime)">
      <summary>
            Formats the given zoned date/time as text according to the rules of this pattern.
            </summary>
      <param name="value">The zoned date/time to format.</param>
      <returns>The zoned date/time formatted according to this pattern.</returns>
    </member>
    <member name="M:NodaTime.Text.OffsetDateTimePattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo,NodaTime.OffsetDateTime)">
      <summary>
            Creates a pattern for the given pattern text, format info, and template value.
            </summary>
      <param name="patternText">Pattern text to create the pattern for</param>
      <param name="formatInfo">The format info to use in the pattern</param>
      <param name="templateValue">Template value to use for unspecified fields</param>
      <returns>A pattern for parsing and formatting zoned date/times.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.OffsetDateTimePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.OffsetDateTime)">
      <summary>
            Creates a pattern for the given pattern text, culture, and template value.
            </summary>
      <remarks>
            See the user guide for the available pattern text options.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <param name="cultureInfo">The culture to use in the pattern</param>
      <param name="templateValue">Template value to use for unspecified fields</param>
      <returns>A pattern for parsing and formatting local date/times.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.OffsetDateTimePattern.CreateWithInvariantCulture(System.String)">
      <summary>
            Creates a pattern for the given pattern text in the invariant culture, using the default
            template value of midnight January 1st 2000 at an offset of 0.
            </summary>
      <remarks>
            See the user guide for the available pattern text options.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <returns>A pattern for parsing and formatting local date/times.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.OffsetDateTimePattern.CreateWithCurrentCulture(System.String)">
      <summary>
            Creates a pattern for the given pattern text in the current culture, using the default
            template value of midnight January 1st 2000 at an offset of 0.
            </summary>
      <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <returns>A pattern for parsing and formatting local date/times.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.OffsetDateTimePattern.WithPatternText(System.String)">
      <summary>
            Creates a pattern for the same original localization information as this pattern, but with the specified
            pattern text.
            </summary>
      <param name="newPatternText">The pattern text to use in the new pattern.</param>
      <returns>A new pattern with the given pattern text.</returns>
    </member>
    <member name="M:NodaTime.Text.OffsetDateTimePattern.WithFormatInfo(NodaTime.Globalization.NodaFormatInfo)">
      <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            localization information.
            </summary>
      <param name="newFormatInfo">The localization information to use in the new pattern.</param>
      <returns>A new pattern with the given localization information.</returns>
    </member>
    <member name="M:NodaTime.Text.OffsetDateTimePattern.WithCulture(System.Globalization.CultureInfo)">
      <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
      <param name="cultureInfo">The culture to use in the new pattern.</param>
      <returns>A new pattern with the given culture.</returns>
    </member>
    <member name="M:NodaTime.Text.OffsetDateTimePattern.WithTemplateValue(NodaTime.OffsetDateTime)">
      <summary>
            Creates a pattern for the same original pattern text and culture as this pattern, but with
            the specified template value.
            </summary>
      <param name="newTemplateValue">The template value to use in the new pattern.</param>
      <returns>A new pattern with the given template value.</returns>
    </member>
    <member name="P:NodaTime.Text.OffsetDateTimePattern.GeneralIsoPattern">
      <summary>
            Returns an invariant offset date/time pattern based on ISO-8601 (down to the second), including offset from UTC.
            The calendar system is not parsed or formatted as part of this pattern. It corresponds to a custom pattern of
            "yyyy'-'MM'-'dd'T'HH':'mm':'sso&lt;G&gt;". This pattern is available as the "G"
            standard pattern (even though it is invariant).
            </summary>
    </member>
    <member name="P:NodaTime.Text.OffsetDateTimePattern.ExtendedIsoPattern">
      <summary>
            Returns an invariant offset date/time pattern based on ISO-8601 (down to the tick), including offset from UTC.
            The calendar system is not parsed or formatted as part of this pattern. It corresponds to a custom pattern of
            "yyyy'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFFo&lt;G&gt;". This will round-trip any values
            in the ISO calendar, and is available as the "o" standard pattern.
            </summary>
    </member>
    <member name="P:NodaTime.Text.OffsetDateTimePattern.Rfc3339Pattern">
      <summary>
            Returns an invariant offset date/time pattern based on RFC 3339 (down to the tick), including offset from UTC
            as hours and minutes only. The minutes part of the offset is always included, but any sub-minute component
            of the offset is lost. An offset of zero is formatted as 'Z', but all of 'Z', '+00:00' and '-00:00' are parsed
            the same way. The RFC 3339 meaning of '-00:00' is not supported by Noda Time.
            Note that parsing is case-sensitive (so 'T' and 'Z' must be upper case).
            The calendar system is not parsed or formatted as part of this pattern. It corresponds to a custom pattern of
            "yyyy'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFFo&lt;Z+HH:mm&gt;".
            </summary>
    </member>
    <member name="P:NodaTime.Text.OffsetDateTimePattern.FullRoundtripPattern">
      <summary>
            Returns an invariant offset date/time pattern based on ISO-8601 (down to the tick)
            including offset from UTC and calendar ID. It corresponds to a custom pattern of
            "yyyy'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFFo&lt;G&gt; '('c')'". This will round-trip any value in any calendar,
            and is available as the "r" standard pattern.
            </summary>
    </member>
    <member name="P:NodaTime.Text.OffsetDateTimePattern.PatternText">
      <summary>
            Returns the pattern text for this pattern, as supplied on creation.
            </summary>
    </member>
    <member name="P:NodaTime.Text.OffsetDateTimePattern.FormatInfo">
      <summary>
            Returns the localization information used in this pattern.
            </summary>
    </member>
    <member name="P:NodaTime.Text.OffsetDateTimePattern.TemplateValue">
      <summary>
            Returns the value used as a template for parsing: any field values unspecified
            in the pattern are taken from the template.
            </summary>
    </member>
    <member name="T:NodaTime.Text.IPartialPattern`1">
      <summary>
            Internal interface supporting partial parsing and formatting. This is used
            when one pattern is embedded within another.
            </summary>
      <typeparam name="T">The type of value to be parsed or formatted.</typeparam>
    </member>
    <member name="M:NodaTime.Text.IPartialPattern`1.ParsePartial(NodaTime.Text.ValueCursor)">
      <summary>
            Parses a value from the current position in the cursor. This will
            not fail if the pattern ends before the cursor does - that's expected
            in most cases.
            </summary>
      <param name="cursor">The cursor to parse from.</param>
      <returns>The result of parsing from the cursor.</returns>
    </member>
    <member name="M:NodaTime.Text.IPartialPattern`1.FormatPartial(`0,System.Text.StringBuilder)">
      <summary>
            Formats the given value by appending to an existing StringBuilder.
            </summary>
      <param name="value">The value to format.</param>
      <param name="builder">The builder to append to.</param>
    </member>
    <member name="T:NodaTime.Text.ZonedDateTimePattern">
      <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.ZonedDateTime" /> values.
            </summary>
      <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
    </member>
    <member name="T:NodaTime.Text.ZonedDateTimePattern.Patterns">
      <summary>
            Class whose existence is solely to avoid type initialization order issues, most of which stem
            from needing NodaFormatInfo.InvariantInfo...
            </summary>
    </member>
    <member name="M:NodaTime.Text.ZonedDateTimePattern.Parse(System.String)">
      <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
      <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
      <param name="text">The text value to parse.</param>
      <returns>The result of parsing, which may be successful or unsuccessful.</returns>
    </member>
    <member name="M:NodaTime.Text.ZonedDateTimePattern.Format(NodaTime.ZonedDateTime)">
      <summary>
            Formats the given zoned date/time as text according to the rules of this pattern.
            </summary>
      <param name="value">The zoned date/time to format.</param>
      <returns>The zoned date/time formatted according to this pattern.</returns>
    </member>
    <member name="M:NodaTime.Text.ZonedDateTimePattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo,NodaTime.TimeZones.ZoneLocalMappingResolver,NodaTime.IDateTimeZoneProvider,NodaTime.ZonedDateTime)">
      <summary>
            Creates a pattern for the given pattern text, format info, template value, mapping resolver and time zone provider.
            </summary>
      <param name="patternText">Pattern text to create the pattern for</param>
      <param name="formatInfo">The format info to use in the pattern</param>
      <param name="templateValue">Template value to use for unspecified fields</param>
      <param name="resolver">Resolver to apply when mapping local date/time values into the zone.</param>
      <param name="zoneProvider">Time zone provider, used when parsing text which contains a time zone identifier.</param>
      <returns>A pattern for parsing and formatting zoned date/times.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.ZonedDateTimePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.TimeZones.ZoneLocalMappingResolver,NodaTime.IDateTimeZoneProvider,NodaTime.ZonedDateTime)">
      <summary>
            Creates a pattern for the given pattern text, culture, resolver, time zone provider, and template value.
            </summary>
      <remarks>
            See the user guide for the available pattern text options.
            If <paramref name="zoneProvider" /> is null, the resulting pattern can be used for formatting
            but not parsing.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <param name="cultureInfo">The culture to use in the pattern</param>
      <param name="resolver">Resolver to apply when mapping local date/time values into the zone.</param>
      <param name="zoneProvider">Time zone provider, used when parsing text which contains a time zone identifier.</param>
      <param name="templateValue">Template value to use for unspecified fields</param>
      <returns>A pattern for parsing and formatting zoned date/times.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.ZonedDateTimePattern.CreateWithInvariantCulture(System.String,NodaTime.IDateTimeZoneProvider)">
      <summary>
            Creates a pattern for the given pattern text and time zone provider, using a strict resolver, the invariant
            culture, and a default template value of midnight January 1st 2000 UTC.
            </summary>
      <remarks>
            The resolver is only used if the pattern text doesn't include an offset.
            If <paramref name="zoneProvider" /> is null, the resulting pattern can be used for formatting
            but not parsing.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <param name="zoneProvider">Time zone provider, used when parsing text which contains a time zone identifier.</param>
      <returns>A pattern for parsing and formatting zoned date/times.</returns>
    </member>
    <member name="M:NodaTime.Text.ZonedDateTimePattern.CreateWithCurrentCulture(System.String,NodaTime.IDateTimeZoneProvider)">
      <summary>
            Creates a pattern for the given pattern text and time zone provider, using a strict resolver, the current
            culture, and a default template value of midnight January 1st 2000 UTC.
            </summary>
      <remarks>
            The resolver is only used if the pattern text doesn't include an offset.
            If <paramref name="zoneProvider" /> is null, the resulting pattern can be used for formatting
            but not parsing. Note that the current culture is captured at the time this method is called
            - it is not captured at the point of parsing or formatting values.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <param name="zoneProvider">Time zone provider, used when parsing text which contains a time zone identifier.</param>
      <returns>A pattern for parsing and formatting zoned date/times.</returns>
    </member>
    <member name="M:NodaTime.Text.ZonedDateTimePattern.WithPatternText(System.String)">
      <summary>
            Creates a pattern for the same original localization information as this pattern, but with the specified
            pattern text.
            </summary>
      <param name="newPatternText">The pattern text to use in the new pattern.</param>
      <returns>A new pattern with the given pattern text.</returns>
    </member>
    <member name="M:NodaTime.Text.ZonedDateTimePattern.WithFormatInfo(NodaTime.Globalization.NodaFormatInfo)">
      <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            localization information.
            </summary>
      <param name="newFormatInfo">The localization information to use in the new pattern.</param>
      <returns>A new pattern with the given localization information.</returns>
    </member>
    <member name="M:NodaTime.Text.ZonedDateTimePattern.WithCulture(System.Globalization.CultureInfo)">
      <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
      <param name="cultureInfo">The culture to use in the new pattern.</param>
      <returns>A new pattern with the given culture.</returns>
    </member>
    <member name="M:NodaTime.Text.ZonedDateTimePattern.WithResolver(NodaTime.TimeZones.ZoneLocalMappingResolver)">
      <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            resolver.
            </summary>
      <param name="newResolver">The new local mapping resolver to use.</param>
      <returns>A new pattern with the given resolver.</returns>
    </member>
    <member name="M:NodaTime.Text.ZonedDateTimePattern.WithZoneProvider(NodaTime.IDateTimeZoneProvider)">
      <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            time zone provider.
            </summary>
      <remarks>
            If <paramref name="newZoneProvider" /> is null, the resulting pattern can be used for formatting
            but not parsing.
            </remarks>
      <param name="newZoneProvider">The new time zone provider to use.</param>
      <returns>A new pattern with the given time zone provider.</returns>
    </member>
    <member name="M:NodaTime.Text.ZonedDateTimePattern.WithTemplateValue(NodaTime.ZonedDateTime)">
      <summary>
            Creates a pattern like this one, but with the specified template value.
            </summary>
      <param name="newTemplateValue">The template value for the new pattern, used to fill in unspecified fields.</param>
      <returns>A new pattern with the given template value.</returns>
    </member>
    <member name="P:NodaTime.Text.ZonedDateTimePattern.GeneralFormatOnlyIsoPattern">
      <summary>
            Returns an zoned local date/time pattern based on ISO-8601 (down to the second) including offset from UTC and zone ID.
            It corresponds to a custom pattern of "yyyy'-'MM'-'dd'T'HH':'mm':'ss z '('o&lt;g&gt;')'" and is available
            as the 'G' standard pattern.
            </summary>
      <remarks>
            The calendar system is not formatted as part of this pattern, and it cannot be used for parsing as no time zone
            provider is included. Call <see cref="M:NodaTime.Text.ZonedDateTimePattern.WithZoneProvider(NodaTime.IDateTimeZoneProvider)" /> on the value of this property to obtain a
            pattern which can be used for parsing.
            </remarks>
    </member>
    <member name="P:NodaTime.Text.ZonedDateTimePattern.ExtendedFormatOnlyIsoPattern">
      <summary>
            Returns an invariant zoned date/time pattern based on ISO-8601 (down to the tick) including offset from UTC and zone ID.
            It corresponds to a custom pattern of "yyyy'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFF z '('o&lt;g&gt;')'" and is available
            as the 'F' standard pattern.
            </summary>
      <remarks>
            The calendar system is not formatted as part of this pattern, and it cannot be used for parsing as no time zone
            provider is included. Call <see cref="M:NodaTime.Text.ZonedDateTimePattern.WithZoneProvider(NodaTime.IDateTimeZoneProvider)" /> on the value of this property to obtain a
            pattern which can be used for parsing.
            </remarks>
    </member>
    <member name="P:NodaTime.Text.ZonedDateTimePattern.PatternText">
      <summary>
            Returns the pattern text for this pattern, as supplied on creation.
            </summary>
    </member>
    <member name="P:NodaTime.Text.ZonedDateTimePattern.FormatInfo">
      <summary>
            Returns the localization information used in this pattern.
            </summary>
    </member>
    <member name="P:NodaTime.Text.ZonedDateTimePattern.TemplateValue">
      <summary>
            Returns the value used as a template for parsing: any field values unspecified
            in the pattern are taken from the template.
            </summary>
    </member>
    <member name="P:NodaTime.Text.ZonedDateTimePattern.Resolver">
      <summary>
            Returns the resolver which is used to map local date/times to zoned date/times,
            handling skipped and ambiguous times appropriately (where the offset isn't specified in the pattern).
            </summary>
    </member>
    <member name="P:NodaTime.Text.ZonedDateTimePattern.ZoneProvider">
      <summary>
            Returns the provider which is used to look up time zones when parsing a pattern
            which contains a time zone identifier. This may be null, in which case the pattern can
            only be used for formatting (not parsing).
            </summary>
    </member>
    <member name="T:NodaTime.Text.LocalDateTimePatternParser">
      <summary>
            Parser for patterns of <see cref="T:NodaTime.LocalDateTime" /> values.
            </summary>
    </member>
    <member name="M:NodaTime.Text.LocalDateTimePatternParser.LocalDateTimeParseBucket.CombineBuckets(NodaTime.Text.Patterns.PatternFields,NodaTime.Text.LocalDatePatternParser.LocalDateParseBucket,NodaTime.Text.LocalTimePatternParser.LocalTimeParseBucket,System.String)">
      <summary>
            Combines the values in a date bucket with the values in a time bucket.
            </summary>
      <remarks>
            This would normally be the <see cref="M:NodaTime.Text.LocalDateTimePatternParser.LocalDateTimeParseBucket.CalculateValue(NodaTime.Text.Patterns.PatternFields,System.String)" /> method, but we want
            to be able to use the same logic when parsing an <see cref="T:NodaTime.OffsetDateTime" />
            and <see cref="T:NodaTime.ZonedDateTime" />.
            </remarks>
    </member>
    <member name="T:NodaTime.Text.FixedFormatInfoPatternParser`1">
      <summary>
            A pattern parser for a single format info, which caches patterns by text/style.
            </summary>
    </member>
    <member name="T:NodaTime.Text.FormatHelper">
      <summary>
              Provides helper methods for formatting values using pattern strings.
            </summary>
    </member>
    <member name="F:NodaTime.Text.FormatHelper.MaximumPaddingLength">
      <summary>
            The maximum number of characters allowed for padded values.
            </summary>
    </member>
    <member name="F:NodaTime.Text.FormatHelper.MaximumInt64Length">
      <summary>
            Maximum number of digits in a (positive) long.
            </summary>
    </member>
    <member name="M:NodaTime.Text.FormatHelper.LeftPad(System.Int32,System.Int32,System.Text.StringBuilder)">
      <summary>
            Formats the given value left padded with zeros.
            </summary>
      <remarks>
            Left pads with zeros the value into a field of <paramref name="length" /> characters. If the value
            is longer than <paramref name="length" />, the entire value is formatted. If the value is negative,
            it is preceded by "-" but this does not count against the length.
            </remarks>
      <param name="value">The value to format.</param>
      <param name="length">The length to fill.</param>
      <param name="outputBuffer">The output buffer to add the digits to.</param>
      <exception cref="T:System.FormatException">if too many characters are requested. <see cref="F:NodaTime.Text.FormatHelper.MaximumPaddingLength" />.</exception>
    </member>
    <member name="M:NodaTime.Text.FormatHelper.AppendFraction(System.Int32,System.Int32,System.Int32,System.Text.StringBuilder)">
      <summary>
            Formats the given value, which is an integer representation of a fraction.
            Note: current usage means this never has to cope with negative numbers.
            </summary>
      <example>
        <code>AppendFraction(1200, 4, 5, builder)</code> will result in "0120" being
            appended to the builder. The value is treated as effectively 0.01200 because
            the scale is 5, but only 4 digits are formatted.
            </example>
      <param name="value">The value to format.</param>
      <param name="length">The length to fill. Must be at most <paramref name="scale" />.</param>
      <param name="scale">The scale of the value i.e. the number of significant digits is the range of the value. Must be in the range [1, 7].</param>
      <param name="outputBuffer">The output buffer to add the digits to.</param>
    </member>
    <member name="M:NodaTime.Text.FormatHelper.AppendFractionTruncate(System.Int32,System.Int32,System.Int32,System.Text.StringBuilder)">
      <summary>
            Formats the given value, which is an integer representation of a fraction,
            truncating any right-most zero digits.
            If the entire value is truncated then the preceeding decimal separater is also removed.
            Note: current usage means this never has to cope with negative numbers.
            </summary>
      <example>
        <code>AppendFractionTruncate(1200, 4, 5, builder)</code> will result in "001" being
            appended to the builder. The value is treated as effectively 0.01200 because
            the scale is 5; only 4 digits are formatted (leaving "0120") and then the rightmost
            0 digit is truncated.
            </example>
      <param name="value">The value to format.</param>
      <param name="length">The length to fill. Must be at most <paramref name="scale" />.</param>
      <param name="scale">The scale of the value i.e. the number of significant digits is the range of the value. Must be in the range [1, 7].</param>
      <param name="outputBuffer">The output buffer to add the digits to.</param>
    </member>
    <member name="M:NodaTime.Text.FormatHelper.FormatInvariant(System.Int64,System.Text.StringBuilder)">
      <summary>
            Formats the given value using the invariant culture, with no truncation or padding.
            </summary>
      <param name="value">The value to format.</param>
      <param name="outputBuffer">The output buffer to add the digits to.</param>
    </member>
    <member name="T:NodaTime.Text.InstantPattern">
      <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.Instant" /> values.
            </summary>
      <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
    </member>
    <member name="T:NodaTime.Text.InstantPattern.Patterns">
      <summary>
            Class whose existence is solely to avoid type initialization order issues, most of which stem
            from needing NodaFormatInfo.InvariantInfo...
            </summary>
    </member>
    <member name="F:NodaTime.Text.InstantPattern.DefaultMinLabel">
      <summary>
            Default label for <see cref="F:NodaTime.Instant.MinValue" /> when formatting.
            </summary>
    </member>
    <member name="F:NodaTime.Text.InstantPattern.DefaultMaxLabel">
      <summary>
            Default label for <see cref="F:NodaTime.Instant.MaxValue" /> when formatting.
            </summary>
    </member>
    <member name="F:NodaTime.Text.InstantPattern.OutOfRangeLabel">
      <summary>
            Label at the start of any out-of-range value.
            </summary>
    </member>
    <member name="M:NodaTime.Text.InstantPattern.Parse(System.String)">
      <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
      <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
      <param name="text">The text value to parse.</param>
      <returns>The result of parsing, which may be successful or unsuccessful.</returns>
    </member>
    <member name="M:NodaTime.Text.InstantPattern.Format(NodaTime.Instant)">
      <summary>
            Formats the given instant as text according to the rules of this pattern.
            </summary>
      <param name="value">The instant to format.</param>
      <returns>The instant formatted according to this pattern.</returns>
    </member>
    <member name="M:NodaTime.Text.InstantPattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo)">
      <summary>
            Creates a pattern for the given pattern text and format info. The default
            min/max labels are used.
            </summary>
      <param name="patternText">Pattern text to create the pattern for</param>
      <param name="formatInfo">The format info to use in the pattern</param>
      <returns>A pattern for parsing and formatting instants.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.InstantPattern.Create(System.String,System.Globalization.CultureInfo)">
      <summary>
            Creates a pattern for the given pattern text and culture.
            </summary>
      <remarks>
            See the user guide for the available pattern text options.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <param name="cultureInfo">The culture to use in the pattern</param>
      <returns>A pattern for parsing and formatting instants.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.InstantPattern.CreateWithCurrentCulture(System.String)">
      <summary>
            Creates a pattern for the given pattern text in the current thread's current culture.
            </summary>
      <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <returns>A pattern for parsing and formatting instants.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.InstantPattern.CreateWithInvariantCulture(System.String)">
      <summary>
            Creates a pattern for the given pattern text in the invariant culture, using the default
            min/max labels.
            </summary>
      <remarks>
            See the user guide for the available pattern text options.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <returns>A pattern for parsing and formatting instants.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.InstantPattern.CreateNumericPattern(System.Globalization.CultureInfo,System.Boolean)">
      <summary>
            Creates a "numeric" pattern for the given culture. The numeric format gives the
            number of ticks in decimal format, with or without thousands separators.
            </summary>
      <param name="cultureInfo">The culture to use in the pattern</param>
      <param name="includeThousandsSeparators">True to include thousands separators when parsing or formatting; false to omit them.</param>
      <returns>A numeric pattern for the configuration</returns>
    </member>
    <member name="M:NodaTime.Text.InstantPattern.WithFormatInfo(NodaTime.Globalization.NodaFormatInfo)">
      <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            localization information.
            </summary>
      <param name="formatInfo">The localization information to use in the new pattern.</param>
      <returns>A new pattern with the given localization information.</returns>
    </member>
    <member name="M:NodaTime.Text.InstantPattern.WithCulture(System.Globalization.CultureInfo)">
      <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
      <param name="cultureInfo">The culture to use in the new pattern.</param>
      <returns>A new pattern with the given culture.</returns>
    </member>
    <member name="M:NodaTime.Text.InstantPattern.WithMinMaxLabels(System.String,System.String)">
      <summary>
            Creates a new pattern for the same original pattern text and culture as this pattern, but
            with the given min/max labels.
            </summary>
      <param name="minLabel">Text to use for <see cref="F:NodaTime.Instant.MinValue" />. Must be non-empty, and not the same as <paramref name="maxLabel" />.</param>
      <param name="maxLabel">Text to use for <see cref="F:NodaTime.Instant.MaxValue" />. Must be non-empty, and not the same as <paramref name="minLabel" /></param>
      <returns>A new pattern with the given min/max labels.</returns>
      <exception cref="T:System.ArgumentException">
      </exception>
    </member>
    <member name="P:NodaTime.Text.InstantPattern.GeneralPattern">
      <summary>
            Returns the general pattern, which always uses an invariant culture. The general pattern represents
            an instant as a UTC date/time in ISO-8601 style "yyyy-MM-ddTHH:mm:ss'Z'".
            </summary>
    </member>
    <member name="P:NodaTime.Text.InstantPattern.ExtendedIsoPattern">
      <summary>
            Returns an invariant instant pattern which is ISO-8601 compatible, providing up to 7 decimal places
            of sub-second accuracy. (These digits are omitted when unnecessary.)
            This corresponds to the text pattern "yyyy'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFF'Z'".
            </summary>
    </member>
    <member name="P:NodaTime.Text.InstantPattern.PatternText">
      <summary>
            Returns the pattern text for this pattern, as supplied on creation.
            </summary>
    </member>
    <member name="P:NodaTime.Text.InstantPattern.FormatInfo">
      <summary>
            Returns the localization information used in this pattern.
            </summary>
    </member>
    <member name="T:NodaTime.Text.InstantPatternParser">
      <summary>
            Pattern parsing support for <see cref="T:NodaTime.Instant" />.
            </summary>
      <remarks>
            Supported patterns:
            <list type="bullet"><item><description>g: general; the UTC ISO-8601 instant in the style yyyy-MM-ddTHH:mm:ssZ</description></item><item><description>n: numeric; the number of ticks since the epoch using thousands separators</description></item><item><description>d: numeric; the number of ticks since the epoch without thousands separators</description></item></list></remarks>
    </member>
    <member name="T:NodaTime.Text.InvalidPatternException">
      <summary>
            Exception thrown to indicate that the format pattern provided for either formatting or parsing is invalid.
            </summary>
      <threadsafety>Any public static members of this type are thread safe. Any instance members are not guaranteed to be thread safe.
            See the thread safety section of the user guide for more information.
            </threadsafety>
    </member>
    <member name="M:NodaTime.Text.InvalidPatternException.#ctor">
      <summary>
            Creates a new InvalidPatternException with no message.
            </summary>
    </member>
    <member name="M:NodaTime.Text.InvalidPatternException.#ctor(System.String)">
      <summary>
            Creates a new InvalidPatternException with the given message.
            </summary>
      <param name="message">A message describing the nature of the failure</param>
    </member>
    <member name="M:NodaTime.Text.InvalidPatternException.#ctor(System.String,System.Object[])">
      <summary>
            Creates a new InvalidPatternException by formatting the given format string with
            the specified parameters, in the current culture.
            </summary>
      <param name="formatString">Format string to use in order to create the final message</param>
      <param name="parameters">Format string parameters</param>
    </member>
    <member name="M:NodaTime.Text.InvalidPatternException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Creates a new InvalidPatternException from the given serialization information.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
    </member>
    <member name="T:NodaTime.Text.IPattern`1">
      <summary>
            Generic interface supporting parsing and formatting. Parsing always results in a 
            <see cref="T:NodaTime.Text.ParseResult`1" /> which can represent success or failure.
            </summary>
      <remarks>
            Idiomatic text handling in Noda Time involves creating a pattern once and reusing it multiple
            times, rather than specifying the pattern text repeatedly. All patterns are immutable and thread-safe,
            and include the culture used for localization purposes.
            </remarks>
      <typeparam name="T">Type of value to parse or format.</typeparam>
    </member>
    <member name="M:NodaTime.Text.IPattern`1.Parse(System.String)">
      <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
      <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
      <param name="text">The text value to parse.</param>
      <returns>The result of parsing, which may be successful or unsuccessful.</returns>
    </member>
    <member name="M:NodaTime.Text.IPattern`1.Format(`0)">
      <summary>
            Formats the given value as text according to the rules of this pattern.
            </summary>
      <param name="value">The value to format.</param>
      <returns>The value formatted according to this pattern.</returns>
    </member>
    <member name="T:NodaTime.Text.LocalDatePattern">
      <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.LocalDate" /> values.
            </summary>
      <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
    </member>
    <member name="T:NodaTime.Text.LocalDatePattern.Patterns">
      <summary>
            Class whose existence is solely to avoid type initialization order issues, most of which stem
            from needing NodaFormatInfo.InvariantInfo...
            </summary>
    </member>
    <member name="M:NodaTime.Text.LocalDatePattern.Parse(System.String)">
      <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
      <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
      <param name="text">The text value to parse.</param>
      <returns>The result of parsing, which may be successful or unsuccessful.</returns>
    </member>
    <member name="M:NodaTime.Text.LocalDatePattern.Format(NodaTime.LocalDate)">
      <summary>
            Formats the given local date as text according to the rules of this pattern.
            </summary>
      <param name="value">The local date to format.</param>
      <returns>The local date formatted according to this pattern.</returns>
    </member>
    <member name="M:NodaTime.Text.LocalDatePattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo,NodaTime.LocalDate)">
      <summary>
            Creates a pattern for the given pattern text, format info, and template value.
            </summary>
      <param name="patternText">Pattern text to create the pattern for</param>
      <param name="formatInfo">The format info to use in the pattern</param>
      <param name="templateValue">Template value to use for unspecified fields</param>
      <returns>A pattern for parsing and formatting local dates.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.LocalDatePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.LocalDate)">
      <summary>
            Creates a pattern for the given pattern text, culture, and template value.
            </summary>
      <remarks>
            See the user guide for the available pattern text options.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <param name="cultureInfo">The culture to use in the pattern</param>
      <param name="templateValue">Template value to use for unspecified fields</param>
      <returns>A pattern for parsing and formatting local dates.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.LocalDatePattern.Create(System.String,System.Globalization.CultureInfo)">
      <summary>
            Creates a pattern for the given pattern text and culture, with a template value of 2000-01-01.
            </summary>
      <remarks>
            See the user guide for the available pattern text options.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <param name="cultureInfo">The culture to use in the pattern</param>
      <returns>A pattern for parsing and formatting local dates.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.LocalDatePattern.CreateWithCurrentCulture(System.String)">
      <summary>
            Creates a pattern for the given pattern text in the current thread's current culture.
            </summary>
      <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <returns>A pattern for parsing and formatting local dates.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.LocalDatePattern.CreateWithInvariantCulture(System.String)">
      <summary>
            Creates a pattern for the given pattern text in the invariant culture.
            </summary>
      <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <returns>A pattern for parsing and formatting local dates.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.LocalDatePattern.WithFormatInfo(NodaTime.Globalization.NodaFormatInfo)">
      <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            localization information.
            </summary>
      <param name="newFormatInfo">The localization information to use in the new pattern.</param>
      <returns>A new pattern with the given localization information.</returns>
    </member>
    <member name="M:NodaTime.Text.LocalDatePattern.WithCulture(System.Globalization.CultureInfo)">
      <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
      <param name="cultureInfo">The culture to use in the new pattern.</param>
      <returns>A new pattern with the given culture.</returns>
    </member>
    <member name="M:NodaTime.Text.LocalDatePattern.WithTemplateValue(NodaTime.LocalDate)">
      <summary>
            Creates a pattern like this one, but with the specified template value.
            </summary>
      <param name="newTemplateValue">The template value for the new pattern, used to fill in unspecified fields.</param>
      <returns>A new pattern with the given template value.</returns>
    </member>
    <member name="P:NodaTime.Text.LocalDatePattern.IsoPattern">
      <summary>
            Returns an invariant local date pattern which is ISO-8601 compatible.
            This corresponds to the text pattern "yyyy'-'MM'-'dd".
            </summary>
    </member>
    <member name="P:NodaTime.Text.LocalDatePattern.PatternText">
      <summary>
            Returns the pattern text for this pattern, as supplied on creation.
            </summary>
    </member>
    <member name="P:NodaTime.Text.LocalDatePattern.FormatInfo">
      <summary>
            Returns the localization information used in this pattern.
            </summary>
    </member>
    <member name="P:NodaTime.Text.LocalDatePattern.TemplateValue">
      <summary>
            Returns the value used as a template for parsing: any field values unspecified
            in the pattern are taken from the template.
            </summary>
    </member>
    <member name="T:NodaTime.Text.LocalDateTimePattern">
      <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.LocalDateTime" /> values.
            </summary>
      <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
    </member>
    <member name="T:NodaTime.Text.LocalDateTimePattern.Patterns">
      <summary>
            Class whose existence is solely to avoid type initialization order issues, most of which stem
            from needing NodaFormatInfo.InvariantInfo...
            </summary>
    </member>
    <member name="M:NodaTime.Text.LocalDateTimePattern.Parse(System.String)">
      <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
      <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
      <param name="text">The text value to parse.</param>
      <returns>The result of parsing, which may be successful or unsuccessful.</returns>
    </member>
    <member name="M:NodaTime.Text.LocalDateTimePattern.Format(NodaTime.LocalDateTime)">
      <summary>
            Formats the given local date/time as text according to the rules of this pattern.
            </summary>
      <param name="value">The local date/time to format.</param>
      <returns>The local date/time formatted according to this pattern.</returns>
    </member>
    <member name="M:NodaTime.Text.LocalDateTimePattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo,NodaTime.LocalDateTime)">
      <summary>
            Creates a pattern for the given pattern text, format info, and template value.
            </summary>
      <param name="patternText">Pattern text to create the pattern for</param>
      <param name="formatInfo">The format info to use in the pattern</param>
      <param name="templateValue">Template value to use for unspecified fields</param>
      <returns>A pattern for parsing and formatting local date/times.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.LocalDateTimePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.LocalDateTime)">
      <summary>
            Creates a pattern for the given pattern text, culture, and template value.
            </summary>
      <remarks>
            See the user guide for the available pattern text options.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <param name="cultureInfo">The culture to use in the pattern</param>
      <param name="templateValue">Template value to use for unspecified fields</param>
      <returns>A pattern for parsing and formatting local date/times.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.LocalDateTimePattern.Create(System.String,System.Globalization.CultureInfo)">
      <summary>
            Creates a pattern for the given pattern text and culture, with a template value of midnight on 2000-01-01.
            </summary>
      <remarks>
            See the user guide for the available pattern text options.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <param name="cultureInfo">The culture to use in the pattern</param>
      <returns>A pattern for parsing and formatting local date/times.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.LocalDateTimePattern.CreateWithCurrentCulture(System.String)">
      <summary>
            Creates a pattern for the given pattern text in the current thread's current culture.
            </summary>
      <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <returns>A pattern for parsing and formatting local date/times.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.LocalDateTimePattern.CreateWithInvariantCulture(System.String)">
      <summary>
            Creates a pattern for the given pattern text in the invariant culture.
            </summary>
      <remarks>
            See the user guide for the available pattern text options.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <returns>A pattern for parsing and formatting local date/times.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.LocalDateTimePattern.WithFormatInfo(NodaTime.Globalization.NodaFormatInfo)">
      <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            localization information.
            </summary>
      <param name="newFormatInfo">The localization information to use in the new pattern.</param>
      <returns>A new pattern with the given localization information.</returns>
    </member>
    <member name="M:NodaTime.Text.LocalDateTimePattern.WithCulture(System.Globalization.CultureInfo)">
      <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
      <param name="cultureInfo">The culture to use in the new pattern.</param>
      <returns>A new pattern with the given culture.</returns>
    </member>
    <member name="M:NodaTime.Text.LocalDateTimePattern.WithTemplateValue(NodaTime.LocalDateTime)">
      <summary>
            Creates a pattern like this one, but with the specified template value.
            </summary>
      <param name="newTemplateValue">The template value for the new pattern, used to fill in unspecified fields.</param>
      <returns>A new pattern with the given template value.</returns>
    </member>
    <member name="P:NodaTime.Text.LocalDateTimePattern.GeneralIsoPattern">
      <summary>
            Returns an invariant local date/time pattern which is ISO-8601 compatible, down to the second.
            This corresponds to the text pattern "yyyy'-'MM'-'dd'T'HH':'mm':'ss", and is also used as the "sortable"
            standard pattern.
            </summary>
    </member>
    <member name="P:NodaTime.Text.LocalDateTimePattern.ExtendedIsoPattern">
      <summary>
            Returns an invariant local date/time pattern which is ISO-8601 compatible, providing up to 7 decimal places
            of sub-second accuracy. (These digits are omitted when unnecessary.)
            This corresponds to the text pattern "yyyy'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFF".
            </summary>
    </member>
    <member name="P:NodaTime.Text.LocalDateTimePattern.BclRoundtripPattern">
      <summary>
            Returns an invariant local date/time pattern which is ISO-8601 compatible, providing up to 7 decimal places
            of sub-second accuracy which are always present (including trailing zeroes). This is compatible with the
            BCL round-trip formatting of <see cref="T:System.DateTime" /> values with a kind of "unspecified".
            This corresponds to the text pattern "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffff".
            </summary>
    </member>
    <member name="P:NodaTime.Text.LocalDateTimePattern.FullRoundtripPattern">
      <summary>
            Returns an invariant local date/time pattern which round trips values including the calendar system.
            This corresponds to the text pattern "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffff '('c')'".
            </summary>
    </member>
    <member name="P:NodaTime.Text.LocalDateTimePattern.PatternText">
      <summary>
            Returns the pattern text for this pattern, as supplied on creation.
            </summary>
    </member>
    <member name="P:NodaTime.Text.LocalDateTimePattern.FormatInfo">
      <summary>
            Returns the localization information used in this pattern.
            </summary>
    </member>
    <member name="P:NodaTime.Text.LocalDateTimePattern.TemplateValue">
      <summary>
            Returns the value used as a template for parsing: any field values unspecified
            in the pattern are taken from the template.
            </summary>
    </member>
    <member name="T:NodaTime.Text.LocalDatePatternParser">
      <summary>
            Parser for patterns of <see cref="T:NodaTime.LocalDate" /> values.
            </summary>
    </member>
    <member name="T:NodaTime.Text.LocalDatePatternParser.LocalDateParseBucket">
      <summary>
            Bucket to put parsed values in, ready for later result calculation. This type is also used
            by LocalDateTimePattern to store and calculate values.
            </summary>
    </member>
    <member name="F:NodaTime.Text.LocalDatePatternParser.TwoDigitYearMax">
      <summary>
            Maximum two-digit-year in the template to treat as the current century.
            (One day we may want to make this configurable, but it feels very low
            priority.)
            </summary>
    </member>
    <member name="T:NodaTime.Text.LocalTimePattern">
      <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.LocalTime" /> values.
            </summary>
      <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
    </member>
    <member name="T:NodaTime.Text.LocalTimePattern.Patterns">
      <summary>
            Class whose existence is solely to avoid type initialization order issues, most of which stem
            from needing NodaFormatInfo.InvariantInfo...
            </summary>
    </member>
    <member name="M:NodaTime.Text.LocalTimePattern.Parse(System.String)">
      <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
      <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
      <param name="text">The text value to parse.</param>
      <returns>The result of parsing, which may be successful or unsuccessful.</returns>
    </member>
    <member name="M:NodaTime.Text.LocalTimePattern.Format(NodaTime.LocalTime)">
      <summary>
            Formats the given local time as text according to the rules of this pattern.
            </summary>
      <param name="value">The local time to format.</param>
      <returns>The local time formatted according to this pattern.</returns>
    </member>
    <member name="M:NodaTime.Text.LocalTimePattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo,NodaTime.LocalTime)">
      <summary>
            Creates a pattern for the given pattern text, format info, and template value.
            </summary>
      <param name="patternText">Pattern text to create the pattern for</param>
      <param name="formatInfo">The format info to use in the pattern</param>
      <param name="templateValue">Template value to use for unspecified fields</param>
      <returns>A pattern for parsing and formatting local times.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.LocalTimePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.LocalTime)">
      <summary>
            Creates a pattern for the given pattern text, culture, and template value.
            </summary>
      <remarks>
            See the user guide for the available pattern text options.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <param name="cultureInfo">The culture to use in the pattern</param>
      <param name="templateValue">Template value to use for unspecified fields</param>
      <returns>A pattern for parsing and formatting local times.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.LocalTimePattern.Create(System.String,System.Globalization.CultureInfo)">
      <summary>
            Creates a pattern for the given pattern text and culture, with a template value of midnight.
            </summary>
      <remarks>
            See the user guide for the available pattern text options.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <param name="cultureInfo">The culture to use in the pattern</param>
      <returns>A pattern for parsing and formatting local times.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.LocalTimePattern.CreateWithCurrentCulture(System.String)">
      <summary>
            Creates a pattern for the given pattern text in the current thread's current culture.
            </summary>
      <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <returns>A pattern for parsing and formatting local times.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.LocalTimePattern.CreateWithInvariantCulture(System.String)">
      <summary>
            Creates a pattern for the given pattern text in the invariant culture.
            </summary>
      <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <returns>A pattern for parsing and formatting local times.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.LocalTimePattern.WithFormatInfo(NodaTime.Globalization.NodaFormatInfo)">
      <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            localization information.
            </summary>
      <param name="newFormatInfo">The localization information to use in the new pattern.</param>
      <returns>A new pattern with the given localization information.</returns>
    </member>
    <member name="M:NodaTime.Text.LocalTimePattern.WithCulture(System.Globalization.CultureInfo)">
      <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
      <param name="cultureInfo">The culture to use in the new pattern.</param>
      <returns>A new pattern with the given culture.</returns>
    </member>
    <member name="M:NodaTime.Text.LocalTimePattern.WithTemplateValue(NodaTime.LocalTime)">
      <summary>
            Creates a pattern like this one, but with the specified template value.
            </summary>
      <param name="newTemplateValue">The template value for the new pattern, used to fill in unspecified fields.</param>
      <returns>A new pattern with the given template value.</returns>
    </member>
    <member name="P:NodaTime.Text.LocalTimePattern.ExtendedIsoPattern">
      <summary>
            Returns an invariant local time pattern which is ISO-8601 compatible, providing up to 7 decimal places.
            (These digits are omitted when unnecessary.)
            This corresponds to the text pattern "HH':'mm':'ss;FFFFFFF".
            </summary>
    </member>
    <member name="P:NodaTime.Text.LocalTimePattern.PatternText">
      <summary>
            Returns the pattern text for this pattern, as supplied on creation.
            </summary>
    </member>
    <member name="P:NodaTime.Text.LocalTimePattern.FormatInfo">
      <summary>
            Returns the localization information used in this pattern.
            </summary>
    </member>
    <member name="P:NodaTime.Text.LocalTimePattern.TemplateValue">
      <summary>
            Returns the value used as a template for parsing: any field values unspecified
            in the pattern are taken from the template.
            </summary>
    </member>
    <member name="T:NodaTime.Text.LocalTimePatternParser">
      <summary>
            Pattern parser for <see cref="T:NodaTime.LocalTime" /> values.
            </summary>
    </member>
    <member name="T:NodaTime.Text.LocalTimePatternParser.LocalTimeParseBucket">
      <summary>
            Bucket to put parsed values in, ready for later result calculation. This type is also used
            by LocalDateTimePattern to store and calculate values.
            </summary>
    </member>
    <member name="M:NodaTime.Text.LocalTimePatternParser.LocalTimeParseBucket.CalculateValue(NodaTime.Text.Patterns.PatternFields,System.String)">
      <summary>
            Calculates the value from the parsed pieces.
            </summary>
    </member>
    <member name="T:NodaTime.Text.NamespaceDoc">
      <summary>
        <para>
            The NodaTime.Text namespace contains types related to formatting and parsing date and time
            values to and from text. Each core Noda Time type has its own "pattern" class to create a more
            object-oriented (and efficient) approach to text handling than the one taken to the BCL.
            See the user guide for more information.
            </para>
      </summary>
    </member>
    <member name="T:NodaTime.Text.OffsetPattern">
      <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.Offset" /> values.
            </summary>
      <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
    </member>
    <member name="F:NodaTime.Text.OffsetPattern.GeneralInvariantPattern">
      <summary>
            The "general" offset pattern (e.g. +HH, +HH:mm, +HH:mm:ss, +HH:mm:ss.fff) for the invariant culture.
            </summary>
    </member>
    <member name="F:NodaTime.Text.OffsetPattern.GeneralInvariantPatternWithZ">
      <summary>
            The "general" offset pattern (e.g. +HH, +HH:mm, +HH:mm:ss, +HH:mm:ss.fff) for the invariant culture,
            but producing (and allowing) Z as a value for a zero offset.
            </summary>
    </member>
    <member name="M:NodaTime.Text.OffsetPattern.Parse(System.String)">
      <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
      <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
      <param name="text">The text value to parse.</param>
      <returns>The result of parsing, which may be successful or unsuccessful.</returns>
    </member>
    <member name="M:NodaTime.Text.OffsetPattern.Format(NodaTime.Offset)">
      <summary>
            Formats the given offset as text according to the rules of this pattern.
            </summary>
      <param name="value">The offset to format.</param>
      <returns>The offset formatted according to this pattern.</returns>
    </member>
    <member name="M:NodaTime.Text.OffsetPattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo)">
      <summary>
            Creates a pattern for the given pattern text and format info.
            </summary>
      <param name="patternText">Pattern text to create the pattern for</param>
      <param name="formatInfo">Localization information</param>
      <returns>A pattern for parsing and formatting offsets.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.OffsetPattern.Create(System.String,System.Globalization.CultureInfo)">
      <summary>
            Creates a pattern for the given pattern text and culture.
            </summary>
      <remarks>
            See the user guide for the available pattern text options.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <param name="cultureInfo">The culture to use in the pattern</param>
      <returns>A pattern for parsing and formatting offsets.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.OffsetPattern.CreateWithCurrentCulture(System.String)">
      <summary>
            Creates a pattern for the given pattern text in the current thread's current culture.
            </summary>
      <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <returns>A pattern for parsing and formatting offsets.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.OffsetPattern.CreateWithInvariantCulture(System.String)">
      <summary>
            Creates a pattern for the given pattern text in the invariant culture.
            </summary>
      <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
      <param name="patternText">Pattern text to create the pattern for</param>
      <returns>A pattern for parsing and formatting offsets.</returns>
      <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
    </member>
    <member name="M:NodaTime.Text.OffsetPattern.WithCulture(System.Globalization.CultureInfo)">
      <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
      <param name="cultureInfo">The culture to use in the new pattern.</param>
      <returns>A new pattern with the given culture.</returns>
    </member>
    <member name="P:NodaTime.Text.OffsetPattern.PatternText">
      <summary>
            Returns the pattern text for this pattern, as supplied on creation.
            </summary>
    </member>
    <member name="P:NodaTime.Text.OffsetPattern.FormatInfo">
      <summary>
            Returns the localization information used in this pattern.
            </summary>
    </member>
    <member name="P:NodaTime.Text.OffsetPattern.UnderlyingPattern">
      <summary>
            Returns the pattern that this object delegates to. Mostly useful to avoid this public class
            implementing an internal interface.
            </summary>
    </member>
    <member name="T:NodaTime.Text.OffsetPatternParser.ZPrefixPattern">
      <summary>
            Pattern which optionally delegates to another, but both parses and formats Offset.Zero as "Z".
            </summary>
    </member>
    <member name="T:NodaTime.Text.OffsetPatternParser.OffsetParseBucket">
      <summary>
            Provides a container for the interim parsed pieces of an <see cref="T:NodaTime.Offset" /> value.
            </summary>
    </member>
    <member name="M:NodaTime.Text.OffsetPatternParser.OffsetParseBucket.CalculateValue(NodaTime.Text.Patterns.PatternFields,System.String)">
      <summary>
            Calculates the value from the parsed pieces.
            </summary>
    </member>
    <member name="T:NodaTime.Text.PeriodPattern">
      <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.Period" /> values.
            </summary>
      <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="F:NodaTime.Text.PeriodPattern.RoundtripPattern">
      <summary>
            Pattern which uses the normal ISO format for all the supported ISO
            fields, but extends the time part with "s" for milliseconds and "t" for ticks.
            No normalization is carried out, and a period may contain weeks as well as years, months and days.
            Each element may also be negative, independently of other elements. This pattern round-trips its
            values: a parse/format cycle will produce an identical period, including units.
            </summary>
    </member>
    <member name="F:NodaTime.Text.PeriodPattern.NormalizingIsoPattern">
      <summary>
            A "normalizing" pattern which abides by the ISO-8601 duration format as far as possible.
            Weeks are added to the number of days (after multiplying by 7). Time units are normalized
            (extending into days where necessary), and fractions of seconds are represented within the
            seconds part. Unlike ISO-8601, which pattern allows for negative values within a period.
            </summary>
      <remarks>
            Note that normalizing the period when formatting will cause an <see cref="T:System.OverflowException" />
            if the period contains more than <see cref="F:System.Int64.MaxValue" /> ticks when the
            combined weeks/days/time portions are considered. Such a period could never
            be useful anyway, however.
            </remarks>
    </member>
    <member name="M:NodaTime.Text.PeriodPattern.Parse(System.String)">
      <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
      <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
      <param name="text">The text value to parse.</param>
      <returns>The result of parsing, which may be successful or unsuccessful.</returns>
    </member>
    <member name="M:NodaTime.Text.PeriodPattern.Format(NodaTime.Period)">
      <summary>
            Formats the given period as text according to the rules of this pattern.
            </summary>
      <param name="value">The period to format.</param>
      <returns>The period formatted according to this pattern.</returns>
    </member>
    <member name="T:NodaTime.Text.TextCursor">
      <summary>
            Provides a cursor over text being parsed. None of the methods in this class throw exceptions (unless
            there is a bug in Noda Time, in which case an exception is appropriate) and none of the methods
            have ref parameters indicating failures, unlike subclasses. This class is used as the basis for both
            value and pattern parsing, so can make no judgement about what's wrong (i.e. it wouldn't know what
            type of failure to indicate). Instead, methods return Boolean values to indicate success or failure.
            </summary>
    </member>
    <member name="F:NodaTime.Text.TextCursor.Nul">
      <summary>
            A nul character. This character is not allowed in any parsable string and is used to
            indicate that the current character is not set.
            </summary>
    </member>
    <member name="M:NodaTime.Text.TextCursor.#ctor(System.String)">
      <summary>
            Initializes a new instance to parse the given value.
            </summary>
    </member>
    <member name="M:NodaTime.Text.TextCursor.ToString">
      <summary>
              Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
              A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="M:NodaTime.Text.TextCursor.PeekNext">
      <summary>
            Returns the next character if there is one or <see cref="F:NodaTime.Text.TextCursor.Nul" /> if there isn't.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NodaTime.Text.TextCursor.Move(System.Int32)">
      <summary>
            Moves the specified target index. If the new index is out of range of the valid indicies
            for this string then the index is set to the beginning or the end of the string whichever
            is nearest the requested index.
            </summary>
      <param name="targetIndex">Index of the target.</param>
      <returns>
        <c>true</c> if the requested index is in range.</returns>
    </member>
    <member name="M:NodaTime.Text.TextCursor.MoveNext">
      <summary>
            Moves to the next character.
            </summary>
      <returns>
        <c>true</c> if the requested index is in range.</returns>
    </member>
    <member name="M:NodaTime.Text.TextCursor.MovePrevious">
      <summary>
            Moves to the previous character.
            </summary>
      <returns>
        <c>true</c> if the requested index is in range.</returns>
    </member>
    <member name="P:NodaTime.Text.TextCursor.Current">
      <summary>
            Gets the current character.
            </summary>
    </member>
    <member name="P:NodaTime.Text.TextCursor.HasMoreCharacters">
      <summary>
            Gets a value indicating whether this instance has more characters.
            </summary>
      <value>
        <c>true</c> if this instance has more characters; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:NodaTime.Text.TextCursor.Index">
      <summary>
            Gets the current index into the string being parsed.
            </summary>
    </member>
    <member name="P:NodaTime.Text.TextCursor.Length">
      <summary>
            Gets the length of the string being parsed.
            </summary>
    </member>
    <member name="P:NodaTime.Text.TextCursor.Value">
      <summary>
            Gets the string being parsed.
            </summary>
    </member>
    <member name="P:NodaTime.Text.TextCursor.Remainder">
      <summary>
            Gets the remainder the string that has not been parsed yet.
            </summary>
    </member>
    <member name="T:NodaTime.Text.ParseBucket`1">
      <summary>
            Base class for "buckets" of parse data - as field values are parsed, they are stored in a bucket,
            then the final value is calculated at the end.
            </summary>
    </member>
    <member name="M:NodaTime.Text.ParseBucket`1.CalculateValue(NodaTime.Text.Patterns.PatternFields,System.String)">
      <summary>
            Performs the final conversion from fields to a value. The parse can still fail here, if there
            are incompatible field values.
            </summary>
      <param name="usedFields">Indicates which fields were part of the original text pattern.</param>
      <param name="value">Complete value being parsed</param>
    </member>
    <member name="M:NodaTime.Text.ParseBucket`1.IsFieldUsed(NodaTime.Text.Patterns.PatternFields,NodaTime.Text.Patterns.PatternFields)">
      <summary>
            Convenience method to check whether a particular field has been used. It's here as it'll primarily
            be used by buckets; ideally we'd make it an extension method on PatternFields, or use Unconstrained
            Melody...
            </summary>
    </member>
    <member name="M:NodaTime.Text.ParseBucket`1.AreAllFieldsUsed(NodaTime.Text.Patterns.PatternFields,NodaTime.Text.Patterns.PatternFields)">
      <summary>
            Convenience method to check whether a particular field set of fields has been used. This is
            similar to <see cref="M:NodaTime.Text.ParseBucket`1.IsFieldUsed(NodaTime.Text.Patterns.PatternFields,NodaTime.Text.Patterns.PatternFields)" />, except it's expected to be used with multiple fields,
            and will only return true if all the specified fields are present.
            </summary>
    </member>
    <member name="T:NodaTime.Text.ParseResult`1">
      <summary>
            The result of a parse operation.
            </summary>
      <typeparam name="T">The type which was parsed, such as a <see cref="T:NodaTime.LocalDateTime" />.</typeparam>
      <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="F:NodaTime.Text.ParseResult`1.FormatOnlyPattern">
      <summary>
            This isn't really an issue with the value so much as the pattern... but the result is the same.
            </summary>
    </member>
    <member name="M:NodaTime.Text.ParseResult`1.GetValueOrThrow">
      <summary>
            Returns the value from the parse operation if it was successful, or throws an exception indicating the parse failure
            otherwise.
            </summary>
      <remarks>
            This method is exactly equivalent to fetching the <see cref="P:NodaTime.Text.ParseResult`1.Value" /> property, but more explicit in terms of throwing
            an exception on failure.
            </remarks>
      <returns>The result of the parsing operation if it was successful.</returns>
    </member>
    <member name="M:NodaTime.Text.ParseResult`1.TryGetValue(`0,`0@)">
      <summary>
            Returns the success value, and sets the out parameter to either
            the specified failure value of T or the successful parse result value.
            </summary>
      <param name="failureValue">The "default" value to set in <paramref name="result" /> if parsing failed.</param>
      <param name="result">The parameter to store the parsed value in on success.</param>
      <returns>True if this parse result was successful, or false otherwise.</returns>
    </member>
    <member name="M:NodaTime.Text.ParseResult`1.Convert``1(System.Func{`0,``0})">
      <summary>
            Converts this result to a new target type, either by executing the given projection
            for a success result, or propagating the exception provider for failure.
            </summary>
    </member>
    <member name="M:NodaTime.Text.ParseResult`1.ConvertError``1">
      <summary>
            Converts this result to a new target type by propagating the exception provider.
            This parse result must already be an error result.
            </summary>
    </member>
    <member name="M:NodaTime.Text.ParseResult`1.InconsistentValues(System.String,System.Char,System.Char)">
      <summary>
            Two fields (e.g. "hour of day" and "hour of half day") were mutually inconsistent.
            </summary>
    </member>
    <member name="M:NodaTime.Text.ParseResult`1.InconsistentMonthValues(System.String)">
      <summary>
            The month of year is inconsistent between the text and numeric specifications.
            We can't use InconsistentValues for this as the pattern character is the same in both cases.
            </summary>
    </member>
    <member name="M:NodaTime.Text.ParseResult`1.InconsistentDayOfWeekTextValue(System.String)">
      <summary>
            The day of month is inconsistent with the day of week value.
            We can't use InconsistentValues for this as the pattern character is the same in both cases.
            </summary>
    </member>
    <member name="M:NodaTime.Text.ParseResult`1.ExpectedEndOfString(NodaTime.Text.ValueCursor)">
      <summary>
            We'd expected to get to the end of the string now, but we haven't.
            </summary>
    </member>
    <member name="P:NodaTime.Text.ParseResult`1.Value">
      <summary>
            Returns the value from the parse operation if it was successful, or throws an exception indicating the parse failure
            otherwise.
            </summary>
      <remarks>
            This method is exactly equivalent to calling the <see cref="M:NodaTime.Text.ParseResult`1.GetValueOrThrow" /> method, but is terser if the code is
            already clear that it will throw if the parse failed.
            </remarks>
      <returns>The result of the parsing operation if it was successful.</returns>
    </member>
    <member name="P:NodaTime.Text.ParseResult`1.Exception">
      <summary>
            Returns an exception indicating the cause of the parse failure.
            </summary>
      <remarks>This property is typically used to wrap parse failures in higher level exceptions.</remarks>
      <returns>The exception indicating the cause of the parse failure.</returns>
      <exception cref="T:System.InvalidOperationException">The parse operation succeeded.</exception>
    </member>
    <member name="P:NodaTime.Text.ParseResult`1.Success">
      <summary>
            Indicates whether the parse operation was successful.
            </summary>
      <remarks>
            This returns True if and only if fetching the value with the <see cref="P:NodaTime.Text.ParseResult`1.Value" /> property will return with no exception.
            </remarks>
    </member>
    <member name="T:NodaTime.Text.UnparsableValueException">
      <summary>
            Exception thrown to indicate that the specified value could not be parsed.
            </summary>
      <threadsafety>Any public static members of this type are thread safe. Any instance members are not guaranteed to be thread safe.
            See the thread safety section of the user guide for more information.
            </threadsafety>
    </member>
    <member name="M:NodaTime.Text.UnparsableValueException.#ctor">
      <summary>
            Creates a new UnparsableValueException with no message.
            </summary>
    </member>
    <member name="M:NodaTime.Text.UnparsableValueException.#ctor(System.String)">
      <summary>
            Creates a new UnparsableValueException with the given message.
            </summary>
      <param name="message">The failure message</param>
    </member>
    <member name="M:NodaTime.Text.UnparsableValueException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Creates a new UnparsableValueException from the given serialization information.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
    </member>
    <member name="M:NodaTime.Text.ValueCursor.#ctor(System.String)">
      <summary>
              Initializes a new instance of the <see cref="T:NodaTime.Text.ValueCursor" /> class.
            </summary>
      <param name="value">The string to parse.</param>
    </member>
    <member name="M:NodaTime.Text.ValueCursor.Match(System.Char)">
      <summary>
              Attempts to match the specified character with the current character of the string. If the
              character matches then the index is moved passed the character.
            </summary>
      <param name="character">The character to match.</param>
      <returns>
        <c>true</c> if the character matches.</returns>
    </member>
    <member name="M:NodaTime.Text.ValueCursor.Match(System.String)">
      <summary>
            Attempts to match the specified string with the current point in the string. If the
            character matches then the index is moved past the string.
            </summary>
      <param name="match">The string to match.</param>
      <returns>
        <c>true</c> if the string matches.</returns>
    </member>
    <member name="M:NodaTime.Text.ValueCursor.MatchCaseInsensitive(System.String,System.Globalization.CompareInfo,System.Boolean)">
      <summary>
            Attempts to match the specified string with the current point in the string in a case-insensitive
            manner, according to the given comparison info. The cursor is optionally updated to the end of the match.
            </summary>
    </member>
    <member name="M:NodaTime.Text.ValueCursor.CompareOrdinal(System.String)">
      <summary>
            Compares the value from the current cursor position with the given match. If the
            given match string is longer than the remaining length, the comparison still goes
            ahead but the result is never 0: if the result of comparing to the end of the
            value returns 0, the result is -1 to indicate that the value is earlier than the given match.
            Conversely, if the remaining value is longer than the match string, the comparison only
            goes as far as the end of the match. So "xabcd" with the cursor at "a" will return 0 when
            matched with "abc".
            </summary>
      <returns>A negative number if the value (from the current cursor position) is lexicographically
            earlier than the given match string; 0 if they are equal (as far as the end of the match) and
            a positive number if the value is lexicographically later than the given match string.</returns>
    </member>
    <member name="M:NodaTime.Text.ValueCursor.ParseInt64``1(System.Int64@)">
      <summary>
            Parses digits at the current point in the string as a signed 64-bit integer value.
            Currently this method only supports cultures whose negative sign is "-" (and
            using ASCII digits).
            </summary>
      <param name="result">The result integer value. The value of this is not guaranteed
            to be anything specific if the return value is non-null.</param>
      <returns>null if the digits were parsed, or the appropriate parse failure</returns>
    </member>
    <member name="M:NodaTime.Text.ValueCursor.ParseDigits(System.Int32,System.Int32,System.Int32@)">
      <summary>
            Parses digits at the current point in the string. If the minimum required
            digits are not present then the index is unchanged. If there are more digits than
            the maximum allowed they are ignored.
            </summary>
      <param name="minimumDigits">The minimum allowed digits.</param>
      <param name="maximumDigits">The maximum allowed digits.</param>
      <param name="result">The result integer value. The value of this is not guaranteed
            to be anything specific if the return value is false.</param>
      <returns>
        <c>true</c> if the digits were parsed.</returns>
    </member>
    <member name="M:NodaTime.Text.ValueCursor.ParseFraction(System.Int32,System.Int32,System.Int32@,System.Boolean)">
      <summary>
            Parses digits at the current point in the string as a fractional value.
            At least one digit must be present, if allRequired is false there's no requirement for *all*
            the digits to be present.
            </summary>
      <param name="maximumDigits">The maximum allowed digits.</param>
      <param name="scale">The scale of the fractional value.</param>
      <param name="result">The result value scaled by scale. The value of this is not guaranteed
            to be anything specific if the return value is false.</param>
      <param name="allRequired">If true, <paramref name="maximumDigits" /> digits must be present in the
            input sequence. If false, there must be just at least one digit.</param>
      <returns>
        <c>true</c> if the digits were parsed.</returns>
    </member>
    <member name="M:NodaTime.Text.ValueCursor.GetDigit">
      <summary>
            Gets the integer value of the current digit character, or -1 for "not a digit".
            </summary>
      <remarks>
            This currently only handles ASCII digits, which is all we have to parse to stay in line with the BCL.
            </remarks>
    </member>
    <member name="M:NodaTime.Text.ZonedDateTimePatternParser.ZonedDateTimeParseBucket.TryParseFixedZone(NodaTime.Text.ValueCursor)">
      <summary>
            Attempts to parse a fixed time zone from "UTC" with an optional
            offset, expressed as +HH, +HH:mm, +HH:mm:ss or +HH:mm:ss.fff - i.e. the
            general format. If it manages, it will move the cursor and return the
            zone. Otherwise, it will return null and the cursor will remain where
            it was.
            </summary>
    </member>
    <member name="M:NodaTime.Text.ZonedDateTimePatternParser.ZonedDateTimeParseBucket.TryParseProviderZone(NodaTime.Text.ValueCursor)">
      <summary>
            Tries to parse a time zone ID from the provider. Returns the zone
            on success (after moving the cursor to the end of the ID) or null on failure
            (leaving the cursor where it was).
            </summary>
    </member>
    <member name="T:NodaTime.Text.Patterns.AbstractPattern`1">
      <summary>
            Abstract class to provide common facilities
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.AbstractPattern`1.Parse(System.String)">
      <summary>
            Performs the first part of the parse, validating the value is non-empty before
            handing over to ParseImpl for the meat of the work.
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.AbstractPattern`1.ParseImpl(System.String)">
      <summary>
            Overridden by derived classes to parse the given value, which is guaranteed to be 
            non-null and non-empty. It will have been trimmed appropriately if the parse style allows leading or trailing whitespace.
            </summary>
    </member>
    <member name="T:NodaTime.Text.Patterns.DatePatternHelper">
      <summary>
            Common methods used when parsing dates - these are used from both LocalDateTimePatternParser
            and LocalDatePatternParser.
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.DatePatternHelper.CreateYearHandler``2(System.Func{``0,System.Int32},System.Func{``0,System.Int32},System.Action{``1,System.Int32})">
      <summary>
            Creates a character handler for the year specifier (y).
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.DatePatternHelper.CheckIfNextCharacterMightBeDigit(NodaTime.Text.Patterns.PatternCursor)">
      <summary>
            Returns true if the next character in the pattern might represent a digit from another value (e.g. a different
            field). Returns false otherwise, e.g. if we've reached the end of the pattern, or the next character is a literal
            non-digit. 
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.DatePatternHelper.CreateMonthOfYearHandler``2(System.Func{``0,System.Int32},System.Action{``1,System.Int32},System.Action{``1,System.Int32})">
      <summary>
            Creates a character handler for the month-of-year specifier (M).
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.DatePatternHelper.CreateDayHandler``2(System.Func{``0,System.Int32},System.Func{``0,System.Int32},System.Action{``1,System.Int32},System.Action{``1,System.Int32})">
      <summary>
            Creates a character handler for the day specifier (d).
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.DatePatternHelper.CreateEraHandler``2(System.Func{``0,NodaTime.Calendars.Era},System.Func{``1,NodaTime.Text.LocalDatePatternParser.LocalDateParseBucket})">
      <summary>
            Creates a character handler for the era specifier (g).
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.DatePatternHelper.CreateCalendarHandler``2(System.Func{``0,NodaTime.CalendarSystem},System.Action{``1,NodaTime.CalendarSystem})">
      <summary>
            Creates a character handler for the calendar specifier (c).
            </summary>
    </member>
    <member name="T:NodaTime.Text.Patterns.IPatternParser`1">
      <summary>
            Internal interface used by FixedFormatInfoPatternParser. Unfortunately
            even though this is internal, implementations must either use public methods
            or explicit interface implementation.
            </summary>
    </member>
    <member name="T:NodaTime.Text.Patterns.PatternCursor">
      <summary>
            Extends <see cref="T:NodaTime.Text.TextCursor" /> to simplify parsing patterns such as "yyyy-MM-dd".
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.PatternCursor.GetQuotedString(System.Char)">
      <summary>
            Gets the quoted string.
            </summary>
      <remarks>The cursor is left positioned at the end of the quoted region.</remarks>
      <param name="closeQuote">The close quote character to match for the end of the quoted string.</param>
      <returns>The quoted string sans open and close quotes. This can be an empty string but will not be null.</returns>
    </member>
    <member name="M:NodaTime.Text.Patterns.PatternCursor.GetRepeatCount(System.Int32)">
      <summary>
            Gets the pattern repeat count. The cursor is left on the final character of the
            repeated sequence.
            </summary>
      <param name="maximumCount">The maximum number of repetitions allowed.</param>
      <returns>The repetition count which is alway at least <c>1</c>.</returns>
    </member>
    <member name="M:NodaTime.Text.Patterns.PatternCursor.GetEmbeddedPattern(System.Char,System.Char)">
      <summary>
            Returns a string containing the embedded pattern within this one.
            </summary>
      <remarks>
        <para>
            The cursor is expected to be positioned before the <paramref name="startPattern" /> character,
            and onsuccess the cursor will be positioned on the <paramref name="endPattern" /> character.
            </para>
        <para>Quote characters (' and ") and escaped characters (escaped with a backslash) are handled
            but not unescaped: the resulting pattern should be ready for parsing as normal.</para>
      </remarks>
      <param name="startPattern">The character expected to start the pattern.</param>
      <param name="endPattern">The character expected to end the pattern.</param>
      <returns>The embedded pattern, not including the start/end pattern characters.</returns>
    </member>
    <member name="T:NodaTime.Text.Patterns.PatternFields">
      <summary>
            Enum representing the fields available within patterns. This single enum is shared
            by all parser types for simplicity, although most fields aren't used by most parsers.
            Pattern fields don't necessarily have corresponding duration or date/time fields,
            due to concepts such as "sign".
            </summary>
    </member>
    <member name="T:NodaTime.Text.Patterns.PatternBclSupport`1">
      <summary>
            Class providing simple support for the various Parse/TryParse/ParseExact/TryParseExact/Format overloads 
            provided by individual types.
            </summary>
    </member>
    <member name="T:NodaTime.Text.Patterns.TimePatternHelper">
      <summary>
            Common methods used when parsing dates - these are used from LocalDateTimePatternParser,
            OffsetPatternParser and LocalTimePatternParser.
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.TimePatternHelper.CreatePeriodHandler``2(System.Int32,System.Func{``0,System.Int32},System.Action{``1,System.Int32})">
      <summary>
            Creates a character handler for a dot (period). This is *not* culture sensitive - it is
            always treated as a literal, but with the additional behaviour that if it's followed by an 'F' pattern,
            that makes the period optional.
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.TimePatternHelper.CreateCommaDotHandler``2(System.Int32,System.Func{``0,System.Int32},System.Action{``1,System.Int32})">
      <summary>
            Creates a character handler for a dot (period) or comma, which have the same meaning.
            Formatting always uses a dot, but parsing will allow a comma instead, to conform with
            ISO-8601. This is *not* culture sensitive.
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.TimePatternHelper.CreateFractionHandler``2(System.Int32,System.Func{``0,System.Int32},System.Action{``1,System.Int32})">
      <summary>
            Creates a character handler to handle the "fraction of a second" specifier (f or F).
            </summary>
    </member>
    <member name="T:NodaTime.Text.Patterns.CompositePattern`1">
      <summary>
            Composite pattern which parses by trying several parse patterns in turn, and formats
            by calling a delegate (which may have come from another <see cref="T:NodaTime.Text.IPattern`1" /> to start with).
            </summary>
    </member>
    <member name="T:NodaTime.Text.Patterns.SteppedPatternBuilder`2">
      <summary>
            Builder for a pattern which implements parsing and formatting as a sequence of steps applied
            in turn.
            </summary>
    </member>
    <member name="T:NodaTime.Text.Patterns.SteppedPatternBuilder`2.IPostPatternParseFormatAction">
      <summary>
            Hack to handle genitive month names - we only know what we need to do *after* we've parsed the whole pattern.
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.SetFormatOnly">
      <summary>
            Sets this pattern to only be capable of formatting; any attempt to parse using the
            built pattern will fail immediately.
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.ParseCustomPattern(System.String,System.Collections.Generic.Dictionary{System.Char,NodaTime.Text.CharacterHandler{`0,`1}})">
      <summary>
            Performs common parsing operations: start with a parse action to move the
            value cursor onto the first character, then call a character handler for each
            character in the pattern to build up the steps. If any handler fails,
            that failure is returned - otherwise the return value is null.
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.ValidateUsedFields">
      <summary>
            Validates the combination of fields used.
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.Build">
      <summary>
            Returns a built pattern. This is mostly to keep the API for the builder separate from that of the pattern,
            and for thread safety (publishing a new object, thus leading to a memory barrier).
            Note that this builder *must not* be used after the result has been built.
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddField(NodaTime.Text.Patterns.PatternFields,System.Char)">
      <summary>
            Registers that a pattern field has been used in this pattern, and throws a suitable error
            result if it's already been used.
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddLiteral(System.String,System.Func{NodaTime.Text.ValueCursor,NodaTime.Text.ParseResult{`0}})">
      <summary>
            Adds text which must be matched exactly when parsing, and appended directly when formatting.
            This overload uses the same failure result for all text values.
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.HandlePercent(NodaTime.Text.Patterns.PatternCursor,NodaTime.Text.Patterns.SteppedPatternBuilder{`0,`1})">
      <summary>
            Handle a leading "%" which acts as a pseudo-escape - it's mostly used to allow format strings such as "%H" to mean
            "use a custom format string consisting of H instead of a standard pattern H".
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.HandlePaddedField(System.Int32,NodaTime.Text.Patterns.PatternFields,System.Int32,System.Int32,System.Func{`0,System.Int32},System.Action{`1,System.Int32})">
      <summary>
            Returns a handler for a zero-padded purely-numeric field specifier, such as "seconds", "minutes", "24-hour", "12-hour" etc.
            </summary>
      <param name="maxCount">Maximum permissable count (usually two)</param>
      <param name="field">Field to remember that we've seen</param>
      <param name="minValue">Minimum valid value for the field (inclusive)</param>
      <param name="maxValue">Maximum value value for the field (inclusive)</param>
      <param name="getter">Delegate to retrieve the field value when formatting</param>
      <param name="setter">Delegate to set the field value into a bucket when parsing</param>
      <returns>The pattern parsing failure, or null on success.</returns>
    </member>
    <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddLiteral(System.Char,System.Func{NodaTime.Text.ValueCursor,System.Char,NodaTime.Text.ParseResult{`0}})">
      <summary>
            Adds a character which must be matched exactly when parsing, and appended directly when formatting.
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddParseLongestTextAction(System.Char,System.Action{`1,System.Int32},System.Globalization.CompareInfo,System.Collections.Generic.IList{System.String})">
      <summary>
            Adds parse actions for a list of strings, such as days of the week or month names.
            The parsing is performed case-insensitively. All candidates are tested, and only the longest
            match is used.
            TODO: Make this much more efficient in terms of capture...
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddParseLongestTextAction(System.Char,System.Action{`1,System.Int32},System.Globalization.CompareInfo,System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String})">
      <summary>
            Adds parse actions for two list of strings, such as non-genitive and genitive month names.
            The parsing is performed case-insensitively. All candidates are tested, and only the longest
            match is used.
            TODO: Make this much more efficient in terms of capture...
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.FindLongestMatch(System.Globalization.CompareInfo,NodaTime.Text.ValueCursor,System.Collections.Generic.IList{System.String},System.Int32@,System.Int32@)">
      <summary>
            Find the longest match from a given set of candidate strings, updating the index/length of the best value
            accordingly.
            </summary>
    </member>
    <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddRequiredSign(System.Action{`1,System.Boolean},System.Func{`0,System.Boolean})">
      <summary>
            Adds parse and format actions for a mandatory positive/negative sign.
            </summary>
      <param name="signSetter">Action to take when to set the given sign within the bucket</param>
      <param name="nonNegativePredicate">Predicate to detect whether the value being formatted is non-negative</param>
    </member>
    <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddNegativeOnlySign(System.Action{`1,System.Boolean},System.Func{`0,System.Boolean})">
      <summary>
            Adds parse and format actions for an "negative only" sign.
            </summary>
      <param name="signSetter">Action to take when to set the given sign within the bucket</param>
      <param name="nonNegativePredicate">Predicate to detect whether the value being formatted is non-negative</param>
    </member>
    <member name="T:NodaTime.Properties.PatternResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NodaTime.Properties.PatternResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NodaTime.Properties.PatternResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NodaTime.Properties.PatternResources.Eras_AnnoHegirae">
      <summary>
              Looks up a localized string similar to A.H.|AH.
            </summary>
    </member>
    <member name="P:NodaTime.Properties.PatternResources.Eras_AnnoMartyrum">
      <summary>
              Looks up a localized string similar to A.M.|AM.
            </summary>
    </member>
    <member name="P:NodaTime.Properties.PatternResources.Eras_AnnoMundi">
      <summary>
              Looks up a localized string similar to A.M.|AM.
            </summary>
    </member>
    <member name="P:NodaTime.Properties.PatternResources.Eras_AnnoPersico">
      <summary>
              Looks up a localized string similar to A.P.|AP.
            </summary>
    </member>
    <member name="P:NodaTime.Properties.PatternResources.Eras_BeforeCommon">
      <summary>
              Looks up a localized string similar to B.C.|B.C.E.|BC|BCE.
            </summary>
    </member>
    <member name="P:NodaTime.Properties.PatternResources.Eras_Common">
      <summary>
              Looks up a localized string similar to A.D.|AD|C.E.|CE.
            </summary>
    </member>
    <member name="P:NodaTime.Properties.PatternResources.OffsetPatternFull">
      <summary>
              Looks up a localized string similar to +HH:mm:ss.fff.
            </summary>
    </member>
    <member name="P:NodaTime.Properties.PatternResources.OffsetPatternLong">
      <summary>
              Looks up a localized string similar to +HH:mm:ss.
            </summary>
    </member>
    <member name="P:NodaTime.Properties.PatternResources.OffsetPatternMedium">
      <summary>
              Looks up a localized string similar to +HH:mm.
            </summary>
    </member>
    <member name="P:NodaTime.Properties.PatternResources.OffsetPatternShort">
      <summary>
              Looks up a localized string similar to +HH.
            </summary>
    </member>
    <member name="T:NodaTime.Properties.Messages">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Format_BadQuote">
      <summary>
              Looks up a localized string similar to Format string is missing a close quote: {0}.
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.FormatDefaultExceptionMessage">
      <summary>
              Looks up a localized string similar to Format error..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Noda_ArgumentNull">
      <summary>
              Looks up a localized string similar to Argument cannot be null..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Noda_CannotChangeReadOnly">
      <summary>
              Looks up a localized string similar to Cannot change a read only object..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Noda_StringEmpty">
      <summary>
              Looks up a localized string similar to The string cannot be empty..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Noda_StringEmptyOrWhitespace">
      <summary>
              Looks up a localized string similar to The string cannot be empty or only contain white space..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_AmbiguousLocalTime">
      <summary>
              Looks up a localized string similar to The local date/time is ambiguous in the target time zone..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_CalendarAndEra">
      <summary>
              Looks up a localized string similar to The era specifier cannot be specified in the same pattern as the calendar specifier..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_CannotParseValue">
      <summary>
              Looks up a localized string similar to The value "{0}" cannot be parsed into an instance of {1} using pattern "{2}".
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_DateSeparatorMismatch">
      <summary>
              Looks up a localized string similar to The value string does not match a date separator in the format string..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_DayOfMonthOutOfRange">
      <summary>
              Looks up a localized string similar to The day {0} is out of range in month {1} of year {2}..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_DoubleAssignment">
      <summary>
              Looks up a localized string similar to The pattern flag '{0}' cannot appear twice and parse different values..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_EmptyFormatsArray">
      <summary>
              Looks up a localized string similar to The list of formats cannot be empty..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_EmptyPeriod">
      <summary>
              Looks up a localized string similar to The specified period was empty..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_EmptyZPrefixedOffsetPattern">
      <summary>
              Looks up a localized string similar to The Z prefix for an Offset pattern must be followed by a custom pattern..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_EndOfString">
      <summary>
              Looks up a localized string similar to Input string ended unexpectedly early..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_EraWithoutYearOfEra">
      <summary>
              Looks up a localized string similar to The era specifier cannot be used without the "year of era" specifier..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_EscapeAtEndOfString">
      <summary>
              Looks up a localized string similar to The format string has an escape character (backslash '\') at the end of the string..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_EscapedCharacterMismatch">
      <summary>
              Looks up a localized string similar to The value string does not match an escaped character in the format string: "\{0}".
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_ExpectedEndOfString">
      <summary>
              Looks up a localized string similar to Expected end of input, but more data remains..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_ExtraValueCharacters">
      <summary>
              Looks up a localized string similar to The format matches a prefix of the value string but not the entire string. Part not matching: "{0}"..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_FieldValueOutOfRange">
      <summary>
              Looks up a localized string similar to The value {0} is out of range for the field '{1}' in the {2} type..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_FormatElementInvalid">
      <summary>
              Looks up a localized string similar to The items of the format string array cannot be null or empty..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_FormatInvalid">
      <summary>
              Looks up a localized string similar to The format string is invalid: "{0}".
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_FormatOnlyPattern">
      <summary>
              Looks up a localized string similar to This pattern is only capable of formatting, not parsing..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_FormatStringEmpty">
      <summary>
              Looks up a localized string similar to The format string is empty..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_Hour12PatternNotSupported">
      <summary>
              Looks up a localized string similar to The 'h' pattern flag (12 hour format) is not supported by the {0} type..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_InconsistentDayOfWeekTextValue">
      <summary>
              Looks up a localized string similar to The specified day of the week does not matched the computed value..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_InconsistentMonthTextValue">
      <summary>
              Looks up a localized string similar to The month values specified as text and numbers are inconsistent..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_InconsistentValues2">
      <summary>
              Looks up a localized string similar to The individual values for the fields '{0}' and '{1}' created an inconsistency in the {2} type..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_InvalidHour24">
      <summary>
              Looks up a localized string similar to 24 is only valid as an hour number when the units smaller than hours are all 0..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_InvalidOffset">
      <summary>
              Looks up a localized string similar to The specified offset is invalid for the given date/time..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_InvalidUnitSpecifier">
      <summary>
              Looks up a localized string similar to The period unit specifier '{0}' is invalid..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_MismatchedCharacter">
      <summary>
              Looks up a localized string similar to The value string does not match a simple character in the format string "{0}"..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_MismatchedNumber">
      <summary>
              Looks up a localized string similar to The value string does not match the required number from the format string "{0}"..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_MismatchedText">
      <summary>
              Looks up a localized string similar to The value string does not match the text-based field '{0}'..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_MisplacedUnitSpecifier">
      <summary>
              Looks up a localized string similar to The period unit specifier '{0}' appears at the wrong place in the input string..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_MissingAmPmDesignator">
      <summary>
              Looks up a localized string similar to The value string does not match the AM or PM designator for the culture at the required place..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_MissingEmbeddedPatternEnd">
      <summary>
              Looks up a localized string similar to The pattern has an embedded pattern which is missing its closing character ('{0}')..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_MissingEmbeddedPatternStart">
      <summary>
              Looks up a localized string similar to The pattern has an embedded pattern which is missing its opening character ('{0}')..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_MissingEndQuote">
      <summary>
              Looks up a localized string similar to The format string is missing the end quote character "{0}"..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_MissingNumber">
      <summary>
              Looks up a localized string similar to The value string does not include a number in the expected position..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_MissingSign">
      <summary>
              Looks up a localized string similar to The required value sign is missing..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_MonthOutOfRange">
      <summary>
              Looks up a localized string similar to The month {0} is out of range in year {1}..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_MultipleCapitalDurationFields">
      <summary>
              Looks up a localized string similar to Only one of "D", "H", "M" or "S" can occur in a duration format string..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_NoMatchingCalendarSystem">
      <summary>
              Looks up a localized string similar to The specified calendar id is not recognized..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_NoMatchingFormat">
      <summary>
              Looks up a localized string similar to None of the specified formats matches the given value string..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_NoMatchingZoneId">
      <summary>
              Looks up a localized string similar to The specified time zone identifier is not recognized..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_PercentAtEndOfString">
      <summary>
              Looks up a localized string similar to A percent sign (%) appears at the end of the format string..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_PercentDoubled">
      <summary>
              Looks up a localized string similar to A percent sign (%) is followed by another percent sign in the format string..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_PositiveSignInvalid">
      <summary>
              Looks up a localized string similar to A positive value sign is not valid at this point..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_PrecisionNotSupported">
      <summary>
              Looks up a localized string similar to The standard format "{0}" for type {1} does not support a precision..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_QuotedStringMismatch">
      <summary>
              Looks up a localized string similar to The value string does not match a quoted string in the pattern..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_RepeatCountExceeded">
      <summary>
              Looks up a localized string similar to There were more consecutive copies of the pattern character "{0}" than the maximum allowed ({1}) in the format string..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_RepeatCountUnderMinimum">
      <summary>
              Looks up a localized string similar to There were fewer consecutive copies of the pattern character "{0}" than the minimum allowed ({1}) in the format string..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_RepeatedFieldInPattern">
      <summary>
              Looks up a localized string similar to The field "{0}" is specified multiple times in the pattern..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_RepeatedUnitSpecifier">
      <summary>
              Looks up a localized string similar to The period unit specifier '{0}' appears multiple times in the input string..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_SkippedLocalTime">
      <summary>
              Looks up a localized string similar to The local date/time is skipped in the target time zone..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_TimeSeparatorMismatch">
      <summary>
              Looks up a localized string similar to The value string does not match a time separator in the format string..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_UnexpectedEndOfString">
      <summary>
              Looks up a localized string similar to More characters were expected in the parsable string [{0}]..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_UnexpectedNegative">
      <summary>
              Looks up a localized string similar to The value string includes a negative value where only a non-negative one is allowed..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_UnknownFailure">
      <summary>
              Looks up a localized string similar to Internal Error: The specified ParseFailureKind is unknown [{0}]..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_UnknownStandardFormat">
      <summary>
              Looks up a localized string similar to The standard format "{0}" is not valid for the {1} type..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_UnparsableValue">
      <summary>
              Looks up a localized string similar to {0} Value being parsed: '{1}'. (^ indicates error position.).
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_UnparsableValuePostParse">
      <summary>
              Looks up a localized string similar to {0} Value being parsed: '{1}'..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_ValueOutOfRange">
      <summary>
              Looks up a localized string similar to The value {0} is out of the legal range for the {1} type..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_ValueStringEmpty">
      <summary>
              Looks up a localized string similar to The value string is empty..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_YearOfEraOutOfRange">
      <summary>
              Looks up a localized string similar to The year {0} is out of range for the {1} era in the {2} calendar..
            </summary>
    </member>
    <member name="P:NodaTime.Properties.Messages.Parse_ZPrefixNotAtStartOfPattern">
      <summary>
              Looks up a localized string similar to The Z prefix for an Offset pattern must occur at the beginning of the pattern..
            </summary>
    </member>
    <member name="T:NodaTime.Properties.AssemblyInfo">
      <summary>
            Just a static class to house the public key, which allows us to avoid repeating it all over the place.
            </summary>
    </member>
    <member name="T:NodaTime.Globalization.NamespaceDoc">
      <summary>
        <para>
            The NodaTime.Globalization namespace contains types related to culture-sensitive
            aspects of behaviour, principally for the sake of text formatting and parsing.
            </para>
      </summary>
    </member>
    <member name="T:NodaTime.Globalization.NodaFormatInfo">
      <summary>
            A <see cref="T:System.IFormatProvider" /> for Noda Time types, initialised from a <see cref="P:NodaTime.Globalization.NodaFormatInfo.CultureInfo" />.
            This provides a single place defining how NodaTime values are formatted and displayed, depending on the culture.
            </summary>
      <remarks>
            Currently this is "shallow-immutable" - although none of these properties can be changed, the
            CultureInfo itself may be mutable. In the future we will make this fully immutable.
            </remarks>
      <threadsafety>Instances which use read-only CultureInfo instances are immutable,
            and may be used freely between threads. Instances with mutable cultures should not be shared between threads
            without external synchronization.
            See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="T:NodaTime.Globalization.NodaFormatInfo.EraDescription">
      <summary>
            The description for an era: the primary name and all possible names.
            </summary>
    </member>
    <member name="F:NodaTime.Globalization.NodaFormatInfo.InvariantInfo">
      <summary>
            A NodaFormatInfo wrapping the invariant culture.
            </summary>
    </member>
    <member name="M:NodaTime.Globalization.NodaFormatInfo.#ctor(System.Globalization.CultureInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Globalization.NodaFormatInfo" /> class.
            </summary>
      <param name="cultureInfo">The culture info to base this on.</param>
    </member>
    <member name="M:NodaTime.Globalization.NodaFormatInfo.ConvertMonthArray(System.String[])">
      <summary>
            The BCL returns arrays of month names starting at 0; we want a read-only list starting at 1 (with 0 as null).
            </summary>
    </member>
    <member name="M:NodaTime.Globalization.NodaFormatInfo.ConvertDayArray(System.String[])">
      <summary>
            The BCL returns arrays of week names starting at 0 as Sunday; we want a read-only list starting at 1 (with 0 as null)
            and with 7 as Sunday.
            </summary>
    </member>
    <member name="M:NodaTime.Globalization.NodaFormatInfo.ConvertGenitiveMonthArray(System.Collections.Generic.IList{System.String},System.String[],System.String[])">
      <summary>
            Checks whether any of the genitive names differ from the non-genitive names, and returns
            either a reference to the non-genitive names or a converted list as per ConvertMonthArray.
            </summary>
      <remarks>
        <para>
            Mono uses the invariant month names for the genitive month names by default, so we'll assume that
            if we see an invariant name, that *isn't* deliberately a genitive month name. A non-invariant culture
            which decided to have genitive month names exactly matching the invariant ones would be distinctly odd.
            See http://bugzilla.xamarin.com/show_bug.cgi?id=3278 for more details and progress.
            </para>
        <para>
            Mono 3.0.6 has an exciting and different bug, where all the abbreviated genitive month names are just numbers ("1" etc).
            So again, if we detect that, we'll go back to the non-genitive version.
            See http://bugzilla.xamarin.com/show_bug.cgi?id=11361 for more details and progress.
            </para>
      </remarks>
    </member>
    <member name="M:NodaTime.Globalization.NodaFormatInfo.GetEraNames(NodaTime.Calendars.Era)">
      <summary>
            Returns the names for the given era in this culture.
            </summary>
      <param name="era">The era to find the names of.</param>
      <returns>A read-only list of names for the given era, or an empty list if
            the era is not known in this culture.</returns>
    </member>
    <member name="M:NodaTime.Globalization.NodaFormatInfo.GetEraPrimaryName(NodaTime.Calendars.Era)">
      <summary>
            Returns the primary name for the given era in this culture.
            </summary>
      <param name="era">The era to find the primary name of.</param>
      <returns>The primary name for the given era, or an empty string if the era name is not known.</returns>
    </member>
    <member name="M:NodaTime.Globalization.NodaFormatInfo.ClearCache">
      <summary>
            Clears the cache. Only used for test purposes.
            </summary>
    </member>
    <member name="M:NodaTime.Globalization.NodaFormatInfo.GetFormatInfo(System.Globalization.CultureInfo)">
      <summary>
            Gets the <see cref="T:NodaTime.Globalization.NodaFormatInfo" /> for the given <see cref="P:NodaTime.Globalization.NodaFormatInfo.CultureInfo" />.
            </summary>
      <remarks>
            This method maintains a cache of results for read-only cultures.
            </remarks>
      <param name="cultureInfo">The culture info.</param>
      <returns>The <see cref="T:NodaTime.Globalization.NodaFormatInfo" />. Will never be null.</returns>
    </member>
    <member name="M:NodaTime.Globalization.NodaFormatInfo.GetInstance(System.IFormatProvider)">
      <summary>
            Gets the <see cref="T:NodaTime.Globalization.NodaFormatInfo" /> for the given <see cref="T:System.IFormatProvider" />. If the
            format provider is null or if it does not provide a <see cref="T:NodaTime.Globalization.NodaFormatInfo" />
            object then the format object for the current thread is returned.
            </summary>
      <param name="provider">The <see cref="T:System.IFormatProvider" />.</param>
      <returns>The <see cref="T:NodaTime.Globalization.NodaFormatInfo" />. Will never be null.</returns>
    </member>
    <member name="M:NodaTime.Globalization.NodaFormatInfo.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
    </member>
    <member name="P:NodaTime.Globalization.NodaFormatInfo.CultureInfo">
      <summary>
            Gets the culture info associated with this format provider.
            </summary>
    </member>
    <member name="P:NodaTime.Globalization.NodaFormatInfo.CompareInfo">
      <summary>
            Gets the text comparison information associated with this format provider.
            </summary>
    </member>
    <member name="P:NodaTime.Globalization.NodaFormatInfo.LongMonthNames">
      <summary>
            Returns a read-only list of the names of the months for the default calendar for this culture.
            See the usage guide for caveats around the use of these names for other calendars.
            Element 0 of the list is null, to allow a more natural mapping from (say) 1 to the string "January".
            </summary>
    </member>
    <member name="P:NodaTime.Globalization.NodaFormatInfo.ShortMonthNames">
      <summary>
            Returns a read-only list of the abbreviated names of the months for the default calendar for this culture.
            See the usage guide for caveats around the use of these names for other calendars.
            Element 0 of the list is null, to allow a more natural mapping from (say) 1 to the string "Jan".
            </summary>
    </member>
    <member name="P:NodaTime.Globalization.NodaFormatInfo.LongMonthGenitiveNames">
      <summary>
            Returns a read-only list of the names of the months for the default calendar for this culture.
            See the usage guide for caveats around the use of these names for other calendars.
            Element 0 of the list is null, to allow a more natural mapping from (say) 1 to the string "January".
            The genitive form is used for month text where the day of month also appears in the pattern.
            If the culture does not use genitive month names, this property will return the same reference as
            <see cref="P:NodaTime.Globalization.NodaFormatInfo.LongMonthNames" />.
            </summary>
    </member>
    <member name="P:NodaTime.Globalization.NodaFormatInfo.ShortMonthGenitiveNames">
      <summary>
            Returns a read-only list of the abbreviated names of the months for the default calendar for this culture.
            See the usage guide for caveats around the use of these names for other calendars.
            Element 0 of the list is null, to allow a more natural mapping from (say) 1 to the string "Jan".
            The genitive form is used for month text where the day also appears in the pattern.
            If the culture does not use genitive month names, this property will return the same reference as
            <see cref="P:NodaTime.Globalization.NodaFormatInfo.ShortMonthNames" />.
            </summary>
    </member>
    <member name="P:NodaTime.Globalization.NodaFormatInfo.LongDayNames">
      <summary>
            Returns a read-only list of the names of the days of the week for the default calendar for this culture.
            See the usage guide for caveats around the use of these names for other calendars.
            Element 0 of the list is null, and the other elements correspond with the index values returned from
            <see cref="P:NodaTime.LocalDateTime.DayOfWeek" /> and similar properties.
            </summary>
    </member>
    <member name="P:NodaTime.Globalization.NodaFormatInfo.ShortDayNames">
      <summary>
            Returns a read-only list of the abbreviated names of the days of the week for the default calendar for this culture.
            See the usage guide for caveats around the use of these names for other calendars.
            Element 0 of the list is null, and the other elements correspond with the index values returned from
            <see cref="P:NodaTime.LocalDateTime.DayOfWeek" /> and similar properties.
            </summary>
    </member>
    <member name="P:NodaTime.Globalization.NodaFormatInfo.NumberFormat">
      <summary>
            Gets the number format associated with this formatting information.
            </summary>
    </member>
    <member name="P:NodaTime.Globalization.NodaFormatInfo.DateTimeFormat">
      <summary>
            Gets the BCL date time format associated with this formatting information.
            </summary>
    </member>
    <member name="P:NodaTime.Globalization.NodaFormatInfo.PositiveSign">
      <summary>
              Gets the positive sign.
            </summary>
    </member>
    <member name="P:NodaTime.Globalization.NodaFormatInfo.NegativeSign">
      <summary>
            Gets the negative sign.
            </summary>
    </member>
    <member name="P:NodaTime.Globalization.NodaFormatInfo.TimeSeparator">
      <summary>
            Gets the time separator.
            </summary>
    </member>
    <member name="P:NodaTime.Globalization.NodaFormatInfo.DateSeparator">
      <summary>
            Gets the date separator.
            </summary>
    </member>
    <member name="P:NodaTime.Globalization.NodaFormatInfo.AMDesignator">
      <summary>
            Gets the AM designator.
            </summary>
    </member>
    <member name="P:NodaTime.Globalization.NodaFormatInfo.PMDesignator">
      <summary>
            Gets the PM designator.
            </summary>
    </member>
    <member name="P:NodaTime.Globalization.NodaFormatInfo.CurrentInfo">
      <summary>
            Gets the <see cref="T:NodaTime.Globalization.NodaFormatInfo" /> object for the current thread.
            </summary>
    </member>
    <member name="P:NodaTime.Globalization.NodaFormatInfo.OffsetPatternFull">
      <summary>
            Gets the <see cref="T:NodaTime.Offset" /> "F" pattern.
            </summary>
    </member>
    <member name="P:NodaTime.Globalization.NodaFormatInfo.OffsetPatternLong">
      <summary>
            Gets the <see cref="T:NodaTime.Offset" /> "L" pattern.
            </summary>
    </member>
    <member name="P:NodaTime.Globalization.NodaFormatInfo.OffsetPatternMedium">
      <summary>
            Gets the <see cref="T:NodaTime.Offset" /> "M" pattern.
            </summary>
    </member>
    <member name="P:NodaTime.Globalization.NodaFormatInfo.OffsetPatternShort">
      <summary>
            Gets the <see cref="T:NodaTime.Offset" /> "S" pattern.
            </summary>
    </member>
    <member name="T:NodaTime.Fields.MonthsPeriodField">
      <summary>
            Period field which uses a <see cref="T:NodaTime.Calendars.YearMonthDayCalculator" /> to add/subtract months.
            </summary>
    </member>
    <member name="T:NodaTime.Fields.FixedDurationPeriodField">
      <summary>
            Period field class representing a field with a fixed duration regardless of when it occurs.
            </summary>
    </member>
    <member name="T:NodaTime.Fields.IPeriodField">
      <summary>
            General representation of the difference between two LocalInstant values in a particular unit,
            such as "months" or "hours". This is effectively a vector type: it doesn't make sense to ask
            a period field for its value at a particular local instant; instead, a number of units can be
            added to an existing local instant, and you can request the difference between two local instants
            in terms of that unit.
            </summary>
    </member>
    <member name="M:NodaTime.Fields.IPeriodField.Add(NodaTime.LocalInstant,System.Int64)">
      <summary>
            Adds a duration value (which may be negative) to the instant. This may not
            be reversible; for example, adding a month to January 30th will result in
            February 28th or February 29th.
            </summary>
      <param name="localInstant">The local instant to add to</param>
      <param name="value">The value to add, in the units of the field</param>
      <returns>The updated local instant</returns>
    </member>
    <member name="M:NodaTime.Fields.IPeriodField.Subtract(NodaTime.LocalInstant,NodaTime.LocalInstant)">
      <summary>
            Computes the difference between two local instants, as measured in the units
            of this field. Any fractional units are dropped from the result. Calling
            Subtract reverses the effect of calling Add, as far as possible.
            </summary>
      <remarks>
            The result is determined so as not to overshoot when added back: calling
            <see cref="M:NodaTime.Fields.IPeriodField.Add(NodaTime.LocalInstant,System.Int64)" /> using <paramref name="subtrahendInstant" /> and
            the result of this method will yield a value which is between <paramref name="subtrahendInstant" />
            and <paramref name="minuendInstant" />. (In a simpler world, it would exactly equal
            <paramref name="minuendInstant" />, but that's not always possible.)
            </remarks>
      <param name="minuendInstant">The local instant to subtract from</param>
      <param name="subtrahendInstant">The local instant to subtract from minuendInstant</param>
      <returns>The difference in the units of this field</returns>
    </member>
    <member name="T:NodaTime.Fields.NamespaceDoc">
      <summary>
        <para>
            The NodaTime.Fields namespace contains types related to individual period fields.
            All types within this namespace are internal.
            </para>
      </summary>
    </member>
    <member name="T:NodaTime.Fields.YearsPeriodField">
      <summary>
            Period field which uses a <see cref="T:NodaTime.Calendars.YearMonthDayCalculator" /> to add/subtract years.
            </summary>
    </member>
    <member name="T:NodaTime.Fields.PeriodFieldSet">
      <summary>
            An immutable collection of date/time and period fields.
            </summary>
    </member>
    <member name="T:NodaTime.Fields.PeriodFieldSet.Builder">
      <summary>
            Mutable set of fields which can be built into a full, immutable FieldSet.
            </summary>
    </member>
    <member name="T:NodaTime.Calendars.Era">
      <summary>
            Represents an era used in a calendar.
            </summary>
      <remarks>All the built-in calendars in Noda Time use the values specified by the static
            read-only fields in this class. These may be compared for reference equality to check for specific
            eras.</remarks>
      <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
    </member>
    <member name="F:NodaTime.Calendars.Era.Common">
      <summary>
            The "Common" era (CE), also known as Anno Domini (AD). This is used in the ISO, Gregorian and Julian calendars.
            </summary>
    </member>
    <member name="F:NodaTime.Calendars.Era.BeforeCommon">
      <summary>
            The "before common" era (BCE), also known as Before Christ (BC). This is used in the ISO, Gregorian and Julian calendars.
            </summary>
    </member>
    <member name="F:NodaTime.Calendars.Era.AnnoMartyrum">
      <summary>
            The "Anno Martyrum" or "Era of the Martyrs". This is the sole era used in the Coptic calendar.
            </summary>
    </member>
    <member name="F:NodaTime.Calendars.Era.AnnoMartyrm">
      <summary>
            The "Anno Martyrum" or "Era of the Martyrs". This is the sole era used in the Coptic calendar.
            </summary>
    </member>
    <member name="F:NodaTime.Calendars.Era.AnnoHegirae">
      <summary>
            The "Anno Hegira" era. This is the sole era used in the Hijri (Islamic) calendar.
            </summary>
    </member>
    <member name="F:NodaTime.Calendars.Era.AnnoMundi">
      <summary>
            The "Anno Mundi" era. This is the sole era used in the Hebrew calendar.
            </summary>
    </member>
    <member name="F:NodaTime.Calendars.Era.AnnoPersico">
      <summary>
            The "Anno Persico" era. This is the sole era used in the Persian calendar.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.Era.ToString">
      <summary>
            Returns the name of this era.
            </summary>
      <returns>The name of this era.</returns>
    </member>
    <member name="P:NodaTime.Calendars.Era.Name">
      <summary>
            Returns the name of this era, e.g. "CE" or "BCE".
            </summary>
    </member>
    <member name="T:NodaTime.Calendars.FixedMonthYearMonthDayCalculator">
      <summary>
            Abstract implementation of a year/month/day calculator based around months which always have 30 days.
            </summary>
      <remarks>
            As the month length is fixed various calculations can be optimised.
            This implementation assumes any additional days after twelve
            months fall into a thirteenth month.
            </remarks>
    </member>
    <member name="T:NodaTime.Calendars.HebrewScripturalCalculator">
      <summary>
            Implementation of the algorithms described in
            http://www.cs.tau.ac.il/~nachum/calendar-book/papers/calendar.ps, using scriptural
            month numbering.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.HebrewScripturalCalculator.GetOrPopulateCache(System.Int32)">
      <summary>
            Returns the cached "absolute day at start of year / IsHeshvanLong / IsKislevShort" combination,
            populating the cache if necessary. Bits 0-22 are the "elapsed days start of year"; bit 23 is
            "is Heshvan long"; bit 24 is "is Kislev short". If the year is out of the range for the cache,
            the value is populated but not cached.
            </summary>
      <param name="year">
      </param>
    </member>
    <member name="M:NodaTime.Calendars.HebrewScripturalCalculator.ComputeCacheEntry(System.Int32)">
      <summary>
            Computes the cache entry value for the given year, but without populating the cache.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.HebrewScripturalCalculator.AbsoluteFromHebrew(System.Int32,System.Int32,System.Int32)">
      <summary>
            Returns the "absolute day number" for the given year, month and day in the Hebrew calendar.
            The absolute day number of 0001-01-01 AD (Gregorian) is 1.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.HebrewScripturalCalculator.HebrewFromAbsolute(System.Int32)">
      <summary>
            Converts an "absolute day number" into a year, month and day in the Hebrew calendar.
            The absolute day number of 0001-01-01 AD (Gregorian) is 1.
            </summary>
    </member>
    <member name="T:NodaTime.Calendars.HebrewMonthConverter">
      <summary>
            Conversions between civil and scriptural month numbers in the Hebrew calendar system.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.HebrewMonthConverter.CivilToScriptural(System.Int32,System.Int32)">
      <summary>
            Given a civil month number and a year in which it occurs, this method returns
            the equivalent scriptural month number.
            </summary>
      <remarks>
            No validation is performed in this method: an input month number of 13 in a non-leap-year
            will return a result of 7.
            </remarks>
      <param name="year">Year during which the month occurs.</param>
      <param name="month">Civil month number.</param>
      <returns>The scriptural month number.</returns>
    </member>
    <member name="M:NodaTime.Calendars.HebrewMonthConverter.ScripturalToCivil(System.Int32,System.Int32)">
      <summary>
            Given an scriptural month number and a year in which it occurs, this method returns
            the equivalent scriptural month number.
            </summary>
      <remarks>
            No validation is performed in this method: an input month number of 13 in a non-leap-year
            will return a result of 7.
            </remarks>
      <param name="year">Year during which the month occurs.</param>
      <param name="month">Civil month number.</param>
      <returns>The scriptural month number.</returns>
    </member>
    <member name="T:NodaTime.Calendars.HebrewMonthNumbering">
      <summary>
            The month numbering to use for the Hebrew calendar.
            </summary>
      <remarks>
            When requesting a Hebrew calendar with <see cref="M:NodaTime.CalendarSystem.GetHebrewCalendar(NodaTime.Calendars.HebrewMonthNumbering)" />, a month numbering
            system needs to be specified. There are two main ways of numbering the Hebrew months: the civil
            system where month 1 is the start of the new year (Tishri) and scriptural system where month 1 is
            Nisan, according to biblical custom.
            </remarks>
    </member>
    <member name="F:NodaTime.Calendars.HebrewMonthNumbering.Civil">
      <summary>
        <para>
            The numbering system where month 1 is Tishri. This has the advantage of familiarity with other
            calendars where the first month is 1; it is easier to tell which date comes before which, aside
            from anything else. It is also the  numbering system used by the BCL.
            </para>
        <para>The main disadvantage is that due to leap years effectively "splitting" Adar into Adar I
            and Adar II, the months after that (Nisan, Iyyar and so on) have month numberings which depend
            on the year.</para>
      </summary>
    </member>
    <member name="F:NodaTime.Calendars.HebrewMonthNumbering.Scriptural">
      <summary>
        <para>
            The numbering system where month 1 is Nisan. This is the numbering system which matches biblical
            custom (such as Leviticus 23:5). This has the advantage that the split of Adar is at the end of the
            numbering system, so all other month names are stable.
            </para>
        <para>The primary disadvantage of this numbering system is that months 1-6 come after months 7-12 (or 13),
            which is counter-intuitive.</para>
      </summary>
    </member>
    <member name="T:NodaTime.Calendars.HebrewYearMonthDayCalculator">
      <summary>
            See <see cref="M:NodaTime.CalendarSystem.GetHebrewCalendar(NodaTime.Calendars.HebrewMonthNumbering)" /> for details. This is effectively
            an adapter around <see cref="T:NodaTime.Calendars.HebrewScripturalCalculator" />.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.HebrewYearMonthDayCalculator.IsLeapYear(System.Int32)">
      <summary>
            Returns whether or not the given year is a leap year - that is, one with 13 months. This is
            not quite the same as a leap year in (say) the Gregorian calendar system...
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.HebrewYearMonthDayCalculator.SetYear(NodaTime.LocalInstant,System.Int32)">
      <summary>
            Change the year, maintaining month and day as well as possible. This doesn't
            work in the same way as other calendars; see http://judaism.stackexchange.com/questions/39053
            for the reasoning behind the rules.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.HebrewYearMonthDayCalculator.AbsoluteDayFromLocalInstant(NodaTime.LocalInstant)">
      <summary>
            Converts a LocalInstant into an absolute day number.
            </summary>
    </member>
    <member name="T:NodaTime.Calendars.IslamicEpoch">
      <summary>
            The epoch to use when constructing an Islamic calendar.
            </summary>
      <remarks>
            The Islamic, or Hijri, calendar can either be constructed
            starting on July 15th 622CE (in the Julian calendar) or on the following day.
            The former is the "astronomical" or "Thursday" epoch; the latter is the "civil" or "Friday" epoch.
            </remarks>
      <seealso cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)" />
    </member>
    <member name="F:NodaTime.Calendars.IslamicEpoch.Astronomical">
      <summary>
            Epoch beginning on July 15th 622CE (Julian), which is July 18th 622 CE in the Gregorian calendar.
            </summary>
    </member>
    <member name="F:NodaTime.Calendars.IslamicEpoch.Civil">
      <summary>
            Epoch beginning on July 16th 622CE (Julian), which is July 19th 622 CE in the Gregorian calendar.
            </summary>
    </member>
    <member name="T:NodaTime.Calendars.IslamicLeapYearPattern">
      <summary>
            The pattern of leap years to use when constructing an Islamic calendar.
            </summary>
      <remarks>
        <para>
            The Islamic, or Hijri, calendar is a lunar calendar of 12 months, each of 29 or 30 days.
            The calendar can be defined in either observational or tabular terms; 
            Noda Time implements a tabular calendar, where a pattern of leap years (in which the last month has
            an extra day) repeats every 30 years, according to one of the patterns within this enum.
            </para>
        <para>
            While the patterns themselves are reasonably commonly documented (see e.g.
            <a href="http://en.wikipedia.org/wiki/Tabular_Islamic_calendar">Wikipedia</a>)
            there is little standardization in terms of naming the patterns. I hope the current names do not
            cause offence to anyone; suggestions for better names would be welcome.
            </para>
        <seealso cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)" />
      </remarks>
    </member>
    <member name="F:NodaTime.Calendars.IslamicLeapYearPattern.Base15">
      <summary>
            A pattern of leap years in 2, 5, 7, 10, 13, 15, 18, 21, 24, 26 and 29.
            This pattern and <see cref="F:NodaTime.Calendars.IslamicLeapYearPattern.Base16" /> are the most commonly used ones,
            and only differ in whether the 15th or 16th year is deemed leap.
            </summary>
    </member>
    <member name="F:NodaTime.Calendars.IslamicLeapYearPattern.Base16">
      <summary>
            A pattern of leap years in 2, 5, 7, 10, 13, 16, 18, 21, 24, 26 and 29.
            This pattern and <see cref="F:NodaTime.Calendars.IslamicLeapYearPattern.Base15" /> are the most commonly used ones,
            and only differ in whether the 15th or 16th year is deemed leap.
            </summary>
    </member>
    <member name="F:NodaTime.Calendars.IslamicLeapYearPattern.Indian">
      <summary>
            A pattern of leap years in 2, 5, 8, 10, 13, 16, 19, 21, 24, 27 and 29.
            </summary>
    </member>
    <member name="F:NodaTime.Calendars.IslamicLeapYearPattern.HabashAlHasib">
      <summary>
            A pattern of leap years in 2, 5, 8, 11, 13, 16, 19, 21, 24, 27 and 30.
            </summary>
    </member>
    <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.MonthPairLength">
      <summary>Days in a pair of months, in days.</summary>
    </member>
    <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.LongMonthLength">
      <summary>The length of a long month, in days.</summary>
    </member>
    <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.ShortMonthLength">
      <summary>The length of a short month, in days.</summary>
    </member>
    <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.AverageTicksPerYear">
      <summary>The typical number of ticks in a year.</summary>
    </member>
    <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.DaysPerNonLeapYear">
      <summary>The number of days in a non-leap year.</summary>
    </member>
    <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.DaysPerLeapYear">
      <summary>The number of days in a leap year.</summary>
    </member>
    <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.TicksPerNonLeapYear">
      <summary>The number of ticks in a non-leap year.</summary>
    </member>
    <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.TicksAtCivilEpoch">
      <summary>The ticks for the civil (Friday) epoch of July 16th 622CE.</summary>
    </member>
    <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.TicksAtAstronomicalEpoch">
      <summary>The ticks for the civil (Thursday) epoch of July 15th 622CE.</summary>
    </member>
    <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.LeapYearCycleLength">
      <summary>The length of the cycle of leap years.</summary>
    </member>
    <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.DaysPerLeapCycle">
      <summary>The number of days in leap cycle.</summary>
    </member>
    <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.leapYearPatternBits">
      <summary>The pattern of leap years within a cycle, one bit per year, for this calendar.</summary>
    </member>
    <member name="M:NodaTime.Calendars.IslamicYearMonthDayCalculator.GetLeapYearPatternBits(NodaTime.Calendars.IslamicLeapYearPattern)">
      <summary>
            Returns the pattern of leap years within a cycle, one bit per year, for the specified pattern.
            Note that although cycle years are usually numbered 1-30, the bit pattern is for 0-29; cycle year
            30 is represented by bit 0.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.IslamicYearMonthDayCalculator.GetYear1Ticks(NodaTime.Calendars.IslamicEpoch)">
      <summary>
            Returns the LocalInstant ticks at the specified epoch.
            </summary>
    </member>
    <member name="T:NodaTime.Calendars.IsoYearMonthDayCalculator">
      <summary>
            The ISO-8601 calendar is equivalent to the Gregorian calendar but the century
            and year-of-century are 0-based, and for negative centuries the year is treated as 0-based too.
            (This may be a bug in previous versions of Noda Time, but we should be backward compatible
            at least until we know for sure.)
            </summary>
    </member>
    <member name="T:NodaTime.Calendars.NamespaceDoc">
      <summary>
        <para>
            The NodaTime.Calendars namespace contains types related to calendars beyond the
            <see cref="T:NodaTime.CalendarSystem" /> type in the core NodaTime namespace.
            </para>
      </summary>
    </member>
    <member name="T:NodaTime.Calendars.PersianYearMonthDayCalculator">
      <summary>
            Implementation of the Persian (Solar Hijri) calendar. This is an algorithmic
            implementation rather than the true observational version, and it follows the
            simple 33 year leap cycle implemented by .NET rather than the more complicated
            form of variable-length cycles and grand cycles devised by Ahmad Birashk.
            </summary>
    </member>
    <member name="F:NodaTime.Calendars.PersianYearMonthDayCalculator.TicksAtStartOfYear1Constant">
      <summary>The ticks for the epoch of March 21st 622CE.</summary>
    </member>
    <member name="T:NodaTime.Calendars.RegularYearMonthDayCalculator">
      <summary>
            Subclass of YearMonthDayCalculator for calendars with the following attributes:
            <list type="bullet"><item>A fixed number of months</item><item>Occasional leap years which are always 1 day longer than non-leap years</item></list></summary>
    </member>
    <member name="T:NodaTime.Calendars.TickArithmetic">
      <summary>
            Common operations on ticks.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.TickArithmetic.FastTicksToDays(System.Int64)">
      <summary>
            Converts a number of ticks into days, rounding down. The number of ticks must be
            non-negative (to have an easily-predictable outcome), but this is *not* validated in this method.
            This method is equivalent to dividing by NodaConstants.TicksPerStandardDay, but appears to be
            very significantly faster under the x64 JIT (and no slower under the x86 JIT).
            See http://stackoverflow.com/questions/22258070 for the inspiration.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.TickArithmetic.TicksToDays(System.Int64)">
      <summary>
            Converts a number of ticks into days, rounding down. This method works with any number of
            ticks, so long as it's not within the earliest representable 24 hours (where Noda Time arithmetic
            tends to go pear-shaped anyway...)
            </summary>
    </member>
    <member name="T:NodaTime.Calendars.TimeOfDayCalculator">
      <summary>
            Calculator to handle time-of-day related fields.
            This is a static class because we don't intend to model
            different lengths of days, or hours etc. (We have no state
            at all, and need no polymorphism.)
            </summary>
    </member>
    <member name="T:NodaTime.Calendars.WeekYearCalculator">
      <summary>
            Calculator for week-year, week-of-week-year and day-of-week-based calculations.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.WeekYearCalculator.GetWeekOfWeekYear(NodaTime.LocalInstant)">
      <summary>
            Finds the week-of-week year containing the given local instant, by finding out when the week year
            started, and then simply dividing "how far we are through the year" by "the number of ticks in a week".
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.WeekYearCalculator.GetWeekYearTicks(System.Int32)">
      <summary>
            Returns the ticks at the start of the given week-year.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.WeekYearCalculator.GetWeekYear(NodaTime.LocalInstant)">
      <summary>
            Finds the week-year containing the given local instant.
            </summary>
    </member>
    <member name="T:NodaTime.Calendars.YearMonthDay">
      <summary>
            Just a useful struct to be hand a whole year/month/day value in one go.
            This type is a dumb calendar-neutral type; it's just a composition of
            three integers.
            </summary>
    </member>
    <member name="F:NodaTime.Calendars.YearMonthDayCalculator.yearCache">
      <summary>
            Cache to speed up working out when a particular year starts.
            See the <see cref="T:NodaTime.Calendars.YearStartCacheEntry" /> documentation and <see cref="M:NodaTime.Calendars.YearMonthDayCalculator.GetStartOfYearInDays(System.Int32)" />
            for more details.
            </summary>
    </member>
    <member name="F:NodaTime.Calendars.YearMonthDayCalculator.eras">
      <summary>
            Array of eras in this calculator; this is never mutated.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetTicksFromStartOfYearToStartOfMonth(System.Int32,System.Int32)">
      <summary>
            Returns the number of ticks from the start of the given year to the start of the given month.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.YearMonthDayCalculator.CalculateStartOfYearDays(System.Int32)">
      <summary>
            Compute the start of the given year in days since 1970-01-01 ISO. The year may be outside
            the bounds advertised by the calendar, but only by a single year - this is
            used for internal calls which sometimes need to compare a valid value with
            an invalid one, for estimates etc.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.YearMonthDayCalculator.MonthsBetween(NodaTime.LocalInstant,NodaTime.LocalInstant)">
      <summary>
            Subtract subtrahendInstant from minuendInstant, in terms of months.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetStartOfYearInTicks(System.Int32)">
      <summary>
            Returns the number of ticks since the Unix epoch at the start of the given year.
            This is virtual to allow GregorianCalendarSystem to override it for an ultra-efficient
            cache for modern years. This method can cope with a value for <paramref name="year" /> outside
            the normal range, so long as the resulting computation doesn't overflow. (Min and max years
            are therefore chosen to be slightly more restrictive than we would otherwise need, for the
            sake of simplicity.) This is useful for values which first involve estimates which might be out
            by a year either way.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetYearMonthDayTicks(System.Int32,System.Int32,System.Int32)">
      <summary>
            Computes the ticks of the local instant at the start of the given year/month/day.
            This assumes all parameters have been validated previously.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetYearMonthTicks(System.Int32,System.Int32)">
      <summary>
            Returns the number of ticks (the LocalInstant, effectively) at the start of the
            given year/month.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetLocalInstant(NodaTime.Calendars.Era,System.Int32,System.Int32,System.Int32)">
      <summary>
            Era-based year/month/day: this implementation ignores the era, which is valid for single-era
            calendars, although it does validate the era first.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetEraIndex(NodaTime.Calendars.Era)">
      <summary>
            Convenience method to perform nullity and validity checking on the era, converting it to
            the index within the list of eras used in this calendar system.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetYearOfEra(NodaTime.LocalInstant)">
      <summary>
            Returns the year-of-era for the given local instant. The base implementation is to return the plain
            year, which is suitable for single-era calendars.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetCenturyOfEra(NodaTime.LocalInstant)">
      <summary>
            Handling for century-of-era where (say) year 123 is in century 2... but so is year 200.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetYearOfCentury(NodaTime.LocalInstant)">
      <summary>
            Handling for year-of-century in the range [1, 100].
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetEra(NodaTime.LocalInstant)">
      <summary>
            Returns the era for the given local instant. The base implementation is to return 0, which is
            suitable for single-era calendars.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetAbsoluteYear(System.Int32,System.Int32)">
      <summary>
            Default implementation of GetAbsoluteYear which assumes a single era.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetMinYearOfEra(System.Int32)">
      <summary>
            See <see cref="M:NodaTime.CalendarSystem.GetMinYearOfEra(NodaTime.Calendars.Era)" /> - but this uses a pre-validated index.
            This default implementation returns 1, but can be overridden by derived classes.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetMaxYearOfEra(System.Int32)">
      <summary>
            See <see cref="M:NodaTime.CalendarSystem.GetMaxYearOfEra(NodaTime.Calendars.Era)" /> - but this uses a pre-validated index.
            This default implementation returns the maximum year for this calendar, which is
            a valid implementation for single-era calendars.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetStartOfYearInDays(System.Int32)">
      <summary>
            Fetches the start of the year (in days since 1970-01-01 ISO) from the cache, or calculates
            and caches it.
            </summary>
    </member>
    <member name="P:NodaTime.Calendars.YearMonthDayCalculator.TicksAtStartOfYear1">
      <summary>
            Only exposed outside the calculator for validation by tests.
            </summary>
    </member>
    <member name="T:NodaTime.Calendars.YearStartCacheEntry">
      <summary>
            Type containing as much logic as possible for how the cache of "start of year" data works.
            As of Noda Time 1.3, this is not specific to YearMonthDayCalculator - it can be used for
            other frames of reference, so long as they comply with the restrictions listed below.
            </summary>
      <remarks>
        <para>
            Each entry in the cache is a 32-bit number. The "value" part of the entry consists of the
            number of days since the Unix epoch (negative for a value before the epoch). As Noda Time
            only supports a number of ticks since the Unix epoch of between long.MinValue and long.MaxValue,
            we only need to support a number of days in the range
            [long.MinValue / TicksPerDay, long.MaxValue / TicksPerDay] which is [-10675200, 10675200] (rounding
            away from 0). This value can be stored in 25 bits.
            </para>
        <para>
            The remaining 7 bits of the value are used for validation. For any given year, the bottom
            10 bits are used as the index into the cache (which is an array). The next 7 most significant
            bits are stored in the entry. So long as we have fewer than 17 significant bits in the year value,
            this will be a unique combination. A single validation value (the most highly positive value) is
            reserved to indicate an invalid entry. The cache is initialized with all entries invalid.
            This gives us a range of year numbers greater than [-60000, 60000] without any risk of collisions. By
            contrast, the ISO calendar years are in the range [-27255, 31195] - so we'd have to be dealing with a
            calendar with either very short years, or an epoch a long way ahead or behind the Unix epoch.
            </para>
        <para>
            The fact that each cache entry is only 32 bits means that we can safely use the cache from multiple
            threads without locking. 32-bit aligned values are guaranteed to be accessed atomically, so we know we'll
            never get the value for one year with the validation bits for another, for example.
            </para>
      </remarks>
    </member>
    <member name="F:NodaTime.Calendars.YearStartCacheEntry.Invalid">
      <summary>
            Entry which is guaranteed to be obviously invalid for any real date, by having
            a validation value which is larger than any valid year number.
            </summary>
    </member>
    <member name="F:NodaTime.Calendars.YearStartCacheEntry.value">
      <summary>
            Entry value: most significant 25 bits are the number of days (e.g. since the Unix epoch); remaining 7 bits are
            the validator.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.YearStartCacheEntry.GetValidator(System.Int32)">
      <summary>
            Returns the validator to use for a given year, a non-negative number containing at most
            EntryValidationBits bits.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.YearStartCacheEntry.GetCacheIndex(System.Int32)">
      <summary>
            Returns the cache index, in [0, CacheSize), that should be used to store the given year's cache entry.
            </summary>
    </member>
    <member name="M:NodaTime.Calendars.YearStartCacheEntry.IsValidForYear(System.Int32)">
      <summary>
            Returns whether this cache entry is valid for the given year, and so is safe to use.  (We assume that we
            have located this entry via the correct cache index.)
            </summary>
    </member>
    <member name="P:NodaTime.Calendars.YearStartCacheEntry.StartOfYearDays">
      <summary>
            Returns the (signed) number of days since the Unix epoch for the cache entry.
            </summary>
    </member>
    <member name="T:NodaTime.Annotations.MutableAttribute">
      <summary>
            Indicates that a type is mutable. Some members of this type
            allow state to be visibly changed.
            </summary>
    </member>
    <member name="T:NodaTime.Annotations.ImmutableAttribute">
      <summary>
            Indicates that a type is immutable. After construction, the publicly visible
            state of the object will not change.
            </summary>
      <remarks>
        <p>
            This attribute only applies to types, not fields:
            it's entirely feasible to have a readonly field of a mutable type, or a read/write
            field of an immutable type. In such cases for reference types (classes and interfaces)
            it's important to distinguish between the value of the variable (a reference) and the
            object it refers to. Value types are more complicated as in some cases the compiler
            will copy values before operating on them; however as all value types in Noda Time are
            immutable (aside from explictily implemented serialization operations) this rarely causes
            an issue.
            </p>
        <p>
            Some types may be publicly immutable, but contain privately mutable
            aspects, e.g. caches. If it proves to be useful to indicate the kind of
            immutability we're implementing, we can add an appropriate property to this
            attribute.
            </p>
      </remarks>
    </member>
    <member name="T:NodaTime.Annotations.VisibleForTestingAttribute">
      <summary>
            Attribute indicating that a particular member would normally be private (or potentially protected)
            but is exposed for test purposes.
            </summary>
      <remarks>
            Currently this excludes nested types, fields, and events - but it could be expanded to do so. Likewise
            we don't indicate the intended access mode, which could be done via an enum. For the moment we'll
            assume everything would be private apart from for testing.
            </remarks>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.AppConfigFactory">
      <summary>
            Configuration factory that understands app.config file format.
            It is focused only on specific section of the configuration file (i.e. section reserved for SDK) and 
            is able to detect changes of the configuration in run-time.
            </summary>
    </member>
    <member name="F:Sportradar.SDK.Services.SdkConfiguration.AppConfigFactory.DEFAULT_SECTION_NAME">
      <summary>
            Default section name in app.config when not specified otherwise.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Services.SdkConfiguration.AppConfigFactory.FromSection(System.String)">
      <summary>
            Create a configuration factory that uses a certain section of the app.config file.
            </summary>
      <param name="section_name">Name of the section.</param>
      <returns>The factory.</returns>
    </member>
    <member name="M:Sportradar.SDK.Services.SdkConfiguration.AppConfigFactory.BuildConfig">
      <summary>
            Assemble a configuration.
            </summary>
      <returns>
            A usuable configuration.
            </returns>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.AppConfigWrapper">
      <summary>
             Problem is that users cache the ISdkConfiguration instance they get,
             and app.config is a bit awkward as a new instance has to be obtained all the time using GetSection().
            
             This is a wrapper so that the underlying section can change, but the client has just this instance cached.
             </summary>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.IConfigFactory">
      <summary>
            Configuration factory interface.
            </summary>
    </member>
    <member name="M:Sportradar.SDK.Services.SdkConfiguration.IConfigFactory.BuildConfig">
      <summary>
            Factory method to create (an immutable) configuration.
            </summary>
      <returns>SDK configuration</returns>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.ISdkConfiguration">
      <summary>
            SDK configuration.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ISdkConfiguration.BetPal">
      <summary>
            SDK configuration element with BetPal feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ISdkConfiguration.Common">
      <summary>
            SDK configuration element where common settings used throughout the SDK library are specified.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ISdkConfiguration.Dynamic">
      <summary>
            SDK configuration element where settings for the server-side configuration service are specified (mostly access parameters).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ISdkConfiguration.Lcoo">
      <summary>
            SDK configuration element with Live Cycle of Odds provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ISdkConfiguration.LiveOdds">
      <summary>
            SDK configuration element with LiveOdds feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ISdkConfiguration.LiveOddsBetTypes">
      <summary>
            SDK configuration element with LiveOdds BetType data feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ISdkConfiguration.LiveOddsVbl">
      <summary>
            SDK configuration element with LiveOdds VFL feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ISdkConfiguration.LiveOddsVdr">
      <summary>
            SDK configuration element with LiveOdds VFL feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ISdkConfiguration.LiveOddsVfl">
      <summary>
            SDK configuration element with LiveOdds VFL feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ISdkConfiguration.LiveOddsVfc">
      <summary>
            SDK configuration element with LiveOdds VFC feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ISdkConfiguration.LiveOddsVhc">
      <summary>
            SDK configuration element with LiveOdds VFL feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ISdkConfiguration.LiveOddsVto">
      <summary>
            SDK configuration element with LiveOdds VTO feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ISdkConfiguration.LivePlex">
      <summary>
            SDK configuration element with BetPal feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ISdkConfiguration.LiveScout">
      <summary>
            SDK configuration element with LiveScout feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ISdkConfiguration.MessageDispatcher">
      <summary>
            SDK configuration element where Message Dispatcher settings are specified.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ISdkConfiguration.OddsCreator">
      <summary>
            SDK configuration element with OddsCreator provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ISdkConfiguration.PersistentState">
      <summary>
            SDK configuration element with Persistent State provider settings (SqLite database settings).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ISdkConfiguration.SoccerRoulette">
      <summary>
            SDK configuration element with BetPal feed provider settings.
            </summary>
    </member>
    <member name="E:Sportradar.SDK.Services.SdkConfiguration.ISdkConfiguration.OnConfigurationReloaded">
      <summary>
            Event fired every time that configuration is reloaded / refreshed and might have changed.
            This is a good time for components to update their cached configuration settings, if any.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationDelegates">
      <summary>
            Configuration delegates.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationDelegates.ConfigReloadedDelegate">
      <summary>
            Indicates that configuration has been reloaded/refreshed and might have changed.
            This is a good time for components to update their cached configuration settings, if any.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOddsVbl">
      <summary>
            SDK configuration element with LiveOdds VFL feed provider settings.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.ConfigurationElementFeed">
      <summary>
            Base SDK configuration element for all feeds
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ConfigurationElementFeed.AlertLogLevel">
      <summary>
            Specifies log level threshold used while logging alert messages.
            Possible values are: Debug, Info, Warn, Error, Fatal
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ConfigurationElementFeed.ClientInteractionLogLevel">
      <summary>
            Specifies log level threshold used while logging client interaction messages.
            Possible values are: Debug, Info, Warn, Error, Fatal
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ConfigurationElementFeed.ConfigLogLevel">
      <summary>
            Specifies log level threshold used while logging configuration settings used by client (server and local).
            Possible values are: Debug, Info, Warn, Error, Fatal
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ConfigurationElementFeed.DeadLetterLogLevel">
      <summary>
            Specifies log level threshold used while logging dead letter messages.
            Possible values are: Debug, Info, Warn, Error, Fatal
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ConfigurationElementFeed.InvalidMsgLogLevel">
      <summary>
            Specifies log level threshold used while logging invalid/corrupt messages.
            Possible values are: Debug, Info, Warn, Error, Fatal
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ConfigurationElementFeed.StatsLogLevel">
      <summary>
            Specifies log level threshold used while logging SDK statistics.
            Possible values are: Debug, Info, Warn, Error, Fatal
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ConfigurationElementFeed.TrafficLogLevel">
      <summary>
            Specifies log level threshold used while logging incoming and outgoing traffic (live feed messages).
            Possible values are: Debug, Info, Warn, Error, Fatal
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ConfigurationElementFeed.LoggingFeedName">
      <summary>
            Prefix used to indicate feed
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ConfigurationElementFeed.TotalBufferSize">
      <summary>
            Total message buffer size (overrides automatic defaults for servers)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ConfigurationElementFeed.SchemaValidationStrictness">
      <summary>
             Schema validation strictness. 
             0 = OFF, 1=ON, 2=STRICT, 3=VERY_STRICT
            
             Default = 2
             </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.ConfigurationElementFeed.ReceiveBufferSize">
      <summary>
            Receive buffer size for one line of message (overrides automatic defaults for servers)
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLcoo">
      <summary>
            SDK configuration element with LCoO feed provider settings. 
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLcoo.IsInitialized">
      <summary>
            Is section initialized?
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLcoo.Password">
      <summary>
            Password 
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLcoo.Username">
      <summary>
            Username
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLcoo.InitialFetchDelay">
      <summary>
            Initial delay between two consecutive data fetches
            </summary>
      <remarks>
            You should not set this option unless you are sure what the implications are.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLcoo.RegularFetchDelay">
      <summary>
            Regular delay between two consecutive data fetches
            </summary>
      <remarks>
            You should not set this option unless you are sure what the implications are.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLcoo.FeedName">
      <summary>
            Feed name. Usually FileGet or Fixtures.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLcoo.FixtureTimezone">
      <summary>
            Timezone to use in parsing fixtures. Default Europe/Oslo
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLcoo.DataFetchUrl">
      <summary>
            String format of url to fetch data from
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLcoo.ClearQueueUrl">
      <summary>
            String format of url to clear full queue
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOddsLivePlex">
      <summary>
            SDK configuration element with LivePlex feed provider settings.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOddsSoccerRoulette">
      <summary>
            SDK configuration element with Soccer Roulette feed provider settings.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOddsVdr">
      <summary>
            SDK configuration element with LiveOdds VHC feed provider settings.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOddsVfc">
      <summary>
            SDK configuration element with LiveOdds VFC (virtual football cup) feed provider settings.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOddsVhc">
      <summary>
            SDK configuration element with LiveOdds VHC feed provider settings.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOddsVirtual">
      <summary>
            SDK configuration element with virtual gaming feed provider settings.
            </summary>
      <remarks>
            Warning: not production ready yet
            </remarks>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOddsBetPal">
      <summary>
            SDK configuration element with BetPal feed provider settings.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationDynamic">
      <summary>
            SDK configuration element where settings for the server-side configuration service are specified (mostly access parameters).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationDynamic.BookmakerId">
      <summary>
            Bookmaker id
            </summary>
      <remarks>
            This one will override the <see cref="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationCommon.BookmakerId">common</see> settings.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationDynamic.HttpResponseTimeout">
      <summary>
            Time to wait for the HTTP request to complete.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationDynamic.HttpUrl">
      <summary>
            HTTP URL can have {ID}, {NS} and {VER} placeholders, else id=.., ver=.. and ns=.. query parameters are appended to the URL
            Example: "http://localhost:8080/abc"
            </summary>
      <remarks>
            ID means bookmaker ID, either common or local setting
            NS means namespace (usually: Sportradar.SDK, so config server can store configuration for multiple types of clients)
            VER means SDK (assembly) version
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationDynamic.IsInitialized">
      <summary>
            Is section initialized?
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationDynamic.MaxFetchInterval">
      <summary>
            Max fetch interval
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationDynamic.MinFetchInterval">
      <summary>
            Min fetch interval
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationDynamic.SSLThumbprint">
      <summary>
            Optional SSL server certificate thumbprint
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOddsBetTypes">
      <summary>
            SDK configuration element with LiveOdds BetType data feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOddsBetTypes.ConnectionTimeout">
      <summary>
            Time to wait for the connection with LiveOdds feed server to be established.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOddsBetTypes.IsEnabled">
      <summary>
            Is bet type translation enabled?
            true for yes; false for no.
            </summary>
      <remarks>
            Use this to manually disable bet translations.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOddsBetTypes.RefreshInterval">
      <summary>
            Bet type translation cache refresh interval.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOddsBetTypes.ResponseTimeout">
      <summary>
            Time to wait for the bet types translation response message.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOddsVfl">
      <summary>
            SDK configuration element with LiveOdds VFL feed provider settings.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed">
      <summary>
            SDK configuration element where common live feed provider settings are stored (connectivity, rate limiters, etc.).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.BookmakerId">
      <summary>
            Bookmaker (client) id.
            </summary>
      <remarks>
            This one will override the <see cref="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationCommon.BookmakerId">common</see> settings.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.ClientAliveMsgTimeout">
      <summary>
            Client alive message timeout.
            </summary>
      <remarks>
            TimeSpan.Zero means default timeout will be used.
            BEWARE: there is probably no need to change it unless the protocol updates.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.EventRequestLimiterInterval">
      <summary>
            MatchRequest limiter (interval).
            </summary>
      <remarks>
            When TimeSpan.Zero the default settings as appropriate for the server are used.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.EventRequestLimiterNumber">
      <summary>
            MatchRequest limiter (number).
            </summary>
      <remarks>
        <see cref="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.EventRequestLimiterInterval" /> must not be set to TimeSpan.Zero.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.Hostname">
      <summary>
            Host name (overrides automatic defaults for servers)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.Insecure">
      <summary>
            Whether insecure version of the connection provider should be used that doesn't check the SSL server certificate thumbprint.
            Implicitly set by <see cref="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationCommon.SafeMode" />.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.InvalidDataReconnectWait">
      <summary>
            Delay before we try reconnecting to server after we got invalid data.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.LoginLimiterInterval">
      <summary>
            Login limiter (interval).
            </summary>
      <remarks>
            When TimeSpan.Zero the default settings as appropriate for the server are used.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.LoginLimiterNumber">
      <summary>
            Login limiter (number).
            </summary>
      <remarks>
        <see cref="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.LoginLimiterInterval" /> must not be set to TimeSpan.Zero.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.MaxReconnectWait">
      <summary>
            Delay before we try reconnecting to server after we got disconnected (max, overrides automatic defaults for servers)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.MaxRequestEventIds">
      <summary>
            Max number of match ids that a client can specify in any request.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.MaxRequestTimeAllowance">
      <summary>
            Maximum amount of time for request response
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.MaxServerTimestampAge">
      <summary>
            Server timestamp is only usable to us if it is not outdated so that we can interpolate between two successive server timestamps.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.MaxTimeSkew">
      <summary>
            Maximum time difference between local time and server time.
            When detected time skew is over this limit the connection to the server will be immediately
            dropped and a reconnect attempted.
            
            Usual time skew values should be:
            <list type="number"><item><description>10 minutes when no time synchronization is performed</description></item><item><description>5 seconds (if NTP protocol is used for time synchronization)</description></item><item><description>TimeSpan.Zero means the setting is off (which is the default in SafeMode)</description></item></list></summary>
      <remarks>
            BEWARE! Low values might prevent a successful connection to the server or cause undesired 
            disconnecting / reconnecting. That in turn might lead to connection blocking on
            the server side.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.MinReconnectWait">
      <summary>
            Delay before we try reconnecting to server after we got disconnected (min, overrides automatic defaults for servers)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.Port">
      <summary>
            Port number (overrides automatic defaults for servers)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.ReceiveTimeout">
      <summary>
            Amount of time to wait for (socket) receive operation to complete successfully.
            </summary>
      <remarks>
            TimeSpan.Zero means default timeout will be used, negative value means use maximum value.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.RequestLimiterInterval">
      <summary>
            Request limiter (interval).
            </summary>
      <remarks>
            When TimeSpan.Zero the default settings as appropriate for the server are used.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.RequestLimiterNumber">
      <summary>
            Request limiter (number).
            </summary>
      <remarks>
        <see cref="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.RequestLimiterInterval" /> must not be set to TimeSpan.Zero.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.SendTimeout">
      <summary>
            Amount of time to wait for (socket) send operation to complete successfully.
            </summary>
      <remarks>
            TimeSpan.Zero means default timeout will be used, negative value means use maximum value.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.ServerAliveMsgTimeout">
      <summary>
            Server alive message timeout.
            </summary>
      <remarks>
            TimeSpan.Zero means default timeout will be used.
            BEWARE: there is probably no need to change it unless the protocol updates.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.SSLThumbprint">
      <summary>
            Optional SSL server certificate thumbprint (overrides automatic defaults for servers)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.Test">
      <summary>
            Whether we should connect to development/test server instead of production one.
            Cannot be used for LiveOddsVfl and BetPal.
            </summary>
      <remarks>
            Note that test accounts are disabled on weekends.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.TimeKeeperMaxSamples">
      <summary>
            TimeKeeper should keep that many samples.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.UseSSL">
      <summary>
            Whether SSL sockets should be used for communication (overrides automatic defaults for servers).
            Cannot be used for LiveScout.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveFeed.RestartOnParseError">
      <summary>
            If true, the feed will reconnect on any parse error
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOddsVto">
      <summary>
            SDK configuration element with LiveOdds VFL feed provider settings.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationMessageDispatcher">
      <summary>
            SDK configuration element where Message Dispatcher settings are specified.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationMessageDispatcher.DispatcherThreadPingTimeout">
      <summary>
            If there is no alive ping received from any of the dispatcher threads in this timeout period, 
            the dispatcher will update its health status to unresponsive. This can be caused by a client handler 
            blocking the dispatcher thread execution.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationMessageDispatcher.HealthCheckInterval">
      <summary>
            Interval at which dispatcher health status is checked (i.e. whether all dispatcher threads are live and kicking)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationMessageDispatcher.MaxDispatchEventsPerSecond">
      <summary>
            Limits the rate at which events can be dispatched to client handlers.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationMessageDispatcher.NumDispatchers">
      <summary>
            Total number of message dispatcher threads
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationOddsCreator">
      <summary>
            SDK configuration element with OddsCreator feed provider settings. 
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationOddsCreator.IsInitialized">
      <summary>
            Is section initialized?
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationOddsCreator.Password">
      <summary>
            Password 
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationOddsCreator.Username">
      <summary>
            Username
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationPersistentState">
      <summary>
            SDK configuration element with Persistent State provider settings (SqLite database settings).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationPersistentState.ExpireInterval">
      <summary>
            Time interval to check for expired key value pairs stored in PersistentStateBuffer
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationPersistentState.FlushInterval">
      <summary>
            Time interval to flush key value pairs into provided persistant store
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationPersistentState.MaxAge">
      <summary>
            Max age for stored key value pairs in PersistentStateBuffer 
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationPersistentState.MaxFlushBatchSize">
      <summary>
            Maximum number of key value pairs in state buffer before flushing
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationPersistentState.SqliteDatabaseDirectory">
      <summary>
            Directory for the Sqlite database file
            </summary>
      <remarks>
            By default AppDomain.CurrentDomain.BaseDirectory is used.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationPersistentState.SqliteDatabaseFilename">
      <summary>
            Filename for the Sqlite database file
            </summary>
      <remarks>
            By default "sdkstate.db" is used as the filename
            </remarks>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationSection">
      <summary>
            SDK configuration section.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationSection.BetPal">
      <summary>
            SDK configuration element with LiveOdds BetPal feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationSection.LivePlex">
      <summary>
            SDK configuration element with LiveOdds LivePlex feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationSection.SoccerRoulette">
      <summary>
            SDK configuration element with LiveOdds SoccerRoulette feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationSection.Common">
      <summary>
            SDK configuration element where common settings used throughout the SDK library are specified.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationSection.Dynamic">
      <summary>
            SDK configuration element where settings for the server-side configuration service are specified (mostly access parameters).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationSection.LiveOdds">
      <summary>
            SDK configuration element with LiveOdds feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationSection.LiveOddsBetTypes">
      <summary>
            SDK configuration element with LiveOdds BetType data feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationSection.LiveOddsVdr">
      <summary>
            SDK configuration element with LiveOdds BetPal feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationSection.LiveOddsVfl">
      <summary>
            SDK configuration element with LiveOdds VFL feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationSection.LiveOddsVfc">
      <summary>
            SDK configuration element with LiveOdds VFC feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationSection.LiveOddsVbl">
      <summary>
            SDK configuration element with LiveOdds VBL feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationSection.LiveOddsVto">
      <summary>
            SDK configuration element with LiveOdds VTO feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationSection.LiveOddsVhc">
      <summary>
            SDK configuration element with LiveOdds BetPal feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationSection.LiveScout">
      <summary>
            SDK configuration element with LiveScout feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationSection.MessageDispatcher">
      <summary>
            SDK configuration element where Message Dispatcher settings are specified.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationSection.OddsCreator">
      <summary>
            SDK configuration element with OddsCreator provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationSection.Lcoo">
      <summary>
            SDK configuration element with Live Cycle of Odds provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationSection.PersistentState">
      <summary>
            SDK configuration element with Persistent State provider settings (SqLite database settings).
            </summary>
    </member>
    <member name="E:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationSection.OnConfigurationReloaded">
      <summary>
            Event fired every time that configuration is reloaded / refreshed and might have changed.
            This is a good time for components to update their cached configuration settings, if any.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveScout">
      <summary>
            SDK configuration element with LiveScout feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveScout.IsInitialized">
      <summary>
            Is section initialized?
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveScout.ScoutUsername">
      <summary>
            Scout username (overrides IProtocolData)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveScout.ScoutPassword">
      <summary>
            Scout key (overrides IProtocolData)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveScout.MaxMatchListInterval">
      <summary>
            Timespan limit for when the scout match list is requested.
            </summary>
      <remarks>
            This is the maximum "width" of the interval [hours_back, hours_forward].
            Not settable in the configuration directly.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveScout.ServerTimeSyncInterval">
      <summary>
            Specifies how frequently we should be requesting for the current scout server time.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveScout.MatchExpireCheckInterval">
      <summary>
            Specifies how frequently we should check for expiration of matches.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveScout.MatchExpireMaxAge">
      <summary>
            Specifies how long a match can not receive messages and still be actual.
            </summary>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationCommon">
      <summary>
            SDK configuration element where common settings used throughout the SDK library are specified.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationCommon.ExecutionLogLevel">
      <summary>
            Specifies log level threshold used while logging SDK library code execution.
            Possible values are: Debug, Info, Warn, Error, Fatal
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationCommon.ConfigLogLevel">
      <summary>
            Specifies log level threshold used while logging configuration settings used by client (server and local).
            Possible values are: Debug, Info, Warn, Error, Fatal
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationCommon.StatsLogLevel">
      <summary>
            Specifies log level threshold used while logging SDK statistics.
            Possible values are: Debug, Info, Warn, Error, Fatal
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationCommon.LogPath">
      <summary>
            Root path where SDK logs will be stored (relative or absolute).
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationCommon.OldLogCleanupInterval">
      <summary>
            Old log clean-up interval.
            </summary>
      <remarks>
            How often the clean up task is invoked.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationCommon.OldLogMaxAge">
      <summary>
            Old log max-age.
            </summary>
      <remarks>
            Log files with a modified time older than that will be removed.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationCommon.BookmakerId">
      <summary>
            Bookmaker id
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationCommon.MaxThreadPoolThreads">
      <summary>
            Maximum number of thread pool threads
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationCommon.QueueHighWatermark">
      <summary>
            High watermark for all limited priority queue instances (number of items).
            Signals that a queue will soon reach its full capacity and that we should probably stop processing incoming messages until things calm down a bit.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationCommon.QueueLowWatermark">
      <summary>
            Low watermark for all limited priority queue instances (number of items).
            Signals that a queue is getting filled up and that client may experience some additional latency in msg delivery.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationCommon.QueueMaxCapacity">
      <summary>
            Capacity (max. number of items) that can be stored in any limited priority queue instance.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationCommon.SafeMode">
      <summary>
            Indicates whether "safe-mode" SDK components are used instead of normal ones.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationCommon.Logging">
      <summary>
            Indicates whether SDK logging should be enabled
            </summary>
      <remarks>
            If this is set to false we will be unable to help you with any SDK problems
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationCommon.UniquenessStrictness">
      <summary>
            Verify whether we are the only instance running
            </summary>
      <remarks>
            0 means no checking, 1 means checking but no error, 2 means fail if there are more instances
            </remarks>
    </member>
    <member name="T:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOdds">
      <summary>
            SDK configuration element with LiveOdds feed provider settings.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOdds.BetTypeLanguages">
      <summary>
            List of languages for meta-data, separated by ';' (e.g. en;de)
            </summary>
      <remarks>
            When null this falls back to <see cref="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOdds.Languages" /> or null (which means use server defaults).
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOdds.BookmakerKey">
      <summary>
            Bookmaker key (overrides IProtocolData)
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOdds.CleanupInterval">
      <summary>
            Clean-up interval.
            </summary>
      <remarks>
            You should not set this option unless you are sure what the implications are.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOdds.CleanupMaxAge">
      <summary>
            Clean-up max-age.
            </summary>
      <remarks>
            You should not set this option unless you are sure what the implications are.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOdds.ErrorRecoveryDelay">
      <summary>
            Error recovery kicks-in this amount of time after "alive".
            </summary>
      <remarks>
            You should not set this option unless you are sure what the implications are.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOdds.ErrorRecoveryMaxChunkSize">
      <summary>
            Max chunk size for an error recovery.
            </summary>
      <remarks>
            You should not set this option unless you are sure what the implications are.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOdds.IsInitialized">
      <summary>
            Is section initialized?
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOdds.Languages">
      <summary>
            List of languages, separated by ';' (e.g. en;de)
            </summary>
      <remarks>
            This is the default languages specification which might be overridden in
            <see cref="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOdds.MetaLanguages" /> or <see cref="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOdds.BetTypeLanguages" />.
            Null is valid and means use server defaults.
            </remarks>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOdds.LocalizeOdds">
      <summary>
            Localize odds.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOdds.MaxMetaRequestInterval">
      <summary>
            Max interval when requesting meta-information about all matches.
            </summary>
    </member>
    <member name="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOdds.MetaLanguages">
      <summary>
            List of languages for meta-data, separated by ';' (e.g. en;de)
            </summary>
      <remarks>
            When null this falls back to <see cref="P:Sportradar.SDK.Services.SdkConfiguration.SdkConfigurationLiveOdds.Languages" /> or null (which means use server defaults).
            </remarks>
    </member>
    <member name="E:Sportradar.SDK.Services.SdkConfiguration.SdkLiveConfiguration.OnConfigurationReloaded">
      <summary>
            Event fired every time that configuration is reloaded / refreshed and might have changed.
            This is a good time for components to update their cached configuration settings, if any.
            </summary>
    </member>
    <member name="T:log4net.Appender.IAppender">
      <summary>
            Implement this interface for your own strategies for printing log statements.
            </summary>
      <remarks>
        <para>
            Implementors should consider extending the <see cref="T:log4net.Appender.AppenderSkeleton" />
            class which provides a default implementation of this interface.
            </para>
        <para>
            Appenders can also implement the <see cref="T:log4net.Core.IOptionHandler" /> interface. Therefore
            they would require that the <see cref="M:IOptionHandler.ActivateOptions()" /> method
            be called after the appenders properties have been configured.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Appender.IAppender.Close">
      <summary>
            Closes the appender and releases resources.
            </summary>
      <remarks>
        <para>
            Releases any resources allocated within the appender such as file handles, 
            network connections, etc.
            </para>
        <para>
            It is a programming error to append to a closed appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.IAppender.DoAppend(log4net.Core.LoggingEvent)">
      <summary>
            Log the logging event in Appender specific way.
            </summary>
      <param name="loggingEvent">The event to log</param>
      <remarks>
        <para>
            This method is called to log a message into this appender.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.IAppender.Name">
      <summary>
            Gets or sets the name of this appender.
            </summary>
      <value>The name of the appender.</value>
      <remarks>
        <para>The name uniquely identifies the appender.</para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.IBulkAppender">
      <summary>
            Interface for appenders that support bulk logging.
            </summary>
      <remarks>
        <para>
            This interface extends the <see cref="T:log4net.Appender.IAppender" /> interface to
            support bulk logging of <see cref="T:log4net.Core.LoggingEvent" /> objects. Appenders
            should only implement this interface if they can bulk log efficiently.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Appender.IBulkAppender.DoAppend(log4net.Core.LoggingEvent[])">
      <summary>
            Log the array of logging events in Appender specific way.
            </summary>
      <param name="loggingEvents">The events to log</param>
      <remarks>
        <para>
            This method is called to log an array of events into this appender.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.IOptionHandler">
      <summary>
            Interface used to delay activate a configured object.
            </summary>
      <remarks>
        <para>
            This allows an object to defer activation of its options until all
            options have been set. This is required for components which have
            related options that remain ambiguous until all are set.
            </para>
        <para>
            If a component implements this interface then the <see cref="M:log4net.Core.IOptionHandler.ActivateOptions" /> method 
            must be called by the container after its all the configured properties have been set 
            and before the component can be used.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Core.IOptionHandler.ActivateOptions">
      <summary>
            Activate the options that were previously set with calls to properties.
            </summary>
      <remarks>
        <para>
            This allows an object to defer activation of its options until all
            options have been set. This is required for components which have
            related options that remain ambiguous until all are set.
            </para>
        <para>
            If a component implements this interface then this method must be called
            after its properties have been set before the component can be used.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.AppenderSkeleton">
      <summary>
            Abstract base class implementation of <see cref="T:log4net.Appender.IAppender" />. 
            </summary>
      <remarks>
        <para>
            This class provides the code for common functionality, such 
            as support for threshold filtering and support for general filters.
            </para>
        <para>
            Appenders can also implement the <see cref="T:log4net.Core.IOptionHandler" /> interface. Therefore
            they would require that the <see cref="M:IOptionHandler.ActivateOptions()" /> method
            be called after the appenders properties have been configured.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Appender.AppenderSkeleton.c_renderBufferSize">
      <summary>
            Initial buffer size
            </summary>
    </member>
    <member name="F:log4net.Appender.AppenderSkeleton.c_renderBufferMaxCapacity">
      <summary>
            Maximum buffer size before it is recycled
            </summary>
    </member>
    <member name="F:log4net.Appender.AppenderSkeleton.m_layout">
      <summary>
            The layout of this appender.
            </summary>
      <remarks>
            See <see cref="P:log4net.Appender.AppenderSkeleton.Layout" /> for more information.
            </remarks>
    </member>
    <member name="F:log4net.Appender.AppenderSkeleton.m_name">
      <summary>
            The name of this appender.
            </summary>
      <remarks>
            See <see cref="P:log4net.Appender.AppenderSkeleton.Name" /> for more information.
            </remarks>
    </member>
    <member name="F:log4net.Appender.AppenderSkeleton.m_threshold">
      <summary>
            The level threshold of this appender.
            </summary>
      <remarks>
        <para>
            There is no level threshold filtering by default.
            </para>
        <para>
            See <see cref="P:log4net.Appender.AppenderSkeleton.Threshold" /> for more information.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.AppenderSkeleton.m_errorHandler">
      <summary>
            It is assumed and enforced that errorHandler is never null.
            </summary>
      <remarks>
        <para>
            It is assumed and enforced that errorHandler is never null.
            </para>
        <para>
            See <see cref="P:log4net.Appender.AppenderSkeleton.ErrorHandler" /> for more information.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.AppenderSkeleton.m_headFilter">
      <summary>
            The first filter in the filter chain.
            </summary>
      <remarks>
        <para>
            Set to <c>null</c> initially.
            </para>
        <para>
            See <see cref="T:log4net.Filter.IFilter" /> for more information.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.AppenderSkeleton.m_tailFilter">
      <summary>
            The last filter in the filter chain.
            </summary>
      <remarks>
            See <see cref="T:log4net.Filter.IFilter" /> for more information.
            </remarks>
    </member>
    <member name="F:log4net.Appender.AppenderSkeleton.m_closed">
      <summary>
            Flag indicating if this appender is closed.
            </summary>
      <remarks>
            See <see cref="M:log4net.Appender.AppenderSkeleton.Close" /> for more information.
            </remarks>
    </member>
    <member name="F:log4net.Appender.AppenderSkeleton.m_recursiveGuard">
      <summary>
            The guard prevents an appender from repeatedly calling its own DoAppend method
            </summary>
    </member>
    <member name="F:log4net.Appender.AppenderSkeleton.m_renderWriter">
      <summary>
            StringWriter used to render events
            </summary>
    </member>
    <member name="F:log4net.Appender.AppenderSkeleton.declaringType">
      <summary>
            The fully qualified type of the AppenderSkeleton class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>Empty default constructor</para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.Finalize">
      <summary>
            Finalizes this appender by calling the implementation's 
            <see cref="M:log4net.Appender.AppenderSkeleton.Close" /> method.
            </summary>
      <remarks>
        <para>
            If this appender has not been closed then the <c>Finalize</c> method
            will call <see cref="M:log4net.Appender.AppenderSkeleton.Close" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.ActivateOptions">
      <summary>
            Initialize the appender based on the options set
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.AppenderSkeleton.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.AppenderSkeleton.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.AppenderSkeleton.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.Close">
      <summary>
            Closes the appender and release resources.
            </summary>
      <remarks>
        <para>
            Release any resources allocated within the appender such as file handles, 
            network connections, etc.
            </para>
        <para>
            It is a programming error to append to a closed appender.
            </para>
        <para>
            This method cannot be overridden by subclasses. This method 
            delegates the closing of the appender to the <see cref="M:log4net.Appender.AppenderSkeleton.OnClose" />
            method which must be overridden in the subclass.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent)">
      <summary>
            Performs threshold checks and invokes filters before 
            delegating actual logging to the subclasses specific 
            <see cref="M:Append(LoggingEvent)" /> method.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            This method cannot be overridden by derived classes. A
            derived class should override the <see cref="M:Append(LoggingEvent)" /> method
            which is called by this method.
            </para>
        <para>
            The implementation of this method is as follows:
            </para>
        <para>
          <list type="bullet">
            <item>
              <description>
            		Checks that the severity of the <paramref name="loggingEvent" />
            		is greater than or equal to the <see cref="P:log4net.Appender.AppenderSkeleton.Threshold" /> of this
            		appender.</description>
            </item>
            <item>
              <description>
            		Checks that the <see cref="T:log4net.Filter.IFilter" /> chain accepts the 
            		<paramref name="loggingEvent" />.
            		</description>
            </item>
            <item>
              <description>
            		Calls <see cref="M:PreAppendCheck()" /> and checks that 
            		it returns <c>true</c>.</description>
            </item>
          </list>
        </para>
        <para>
            If all of the above steps succeed then the <paramref name="loggingEvent" />
            will be passed to the abstract <see cref="M:Append(LoggingEvent)" /> method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent[])">
      <summary>
            Performs threshold checks and invokes filters before 
            delegating actual logging to the subclasses specific 
            <see cref="M:Append(LoggingEvent[])" /> method.
            </summary>
      <param name="loggingEvents">The array of events to log.</param>
      <remarks>
        <para>
            This method cannot be overridden by derived classes. A
            derived class should override the <see cref="M:Append(LoggingEvent[])" /> method
            which is called by this method.
            </para>
        <para>
            The implementation of this method is as follows:
            </para>
        <para>
          <list type="bullet">
            <item>
              <description>
            		Checks that the severity of the <paramref name="loggingEvents" />
            		is greater than or equal to the <see cref="P:log4net.Appender.AppenderSkeleton.Threshold" /> of this
            		appender.</description>
            </item>
            <item>
              <description>
            		Checks that the <see cref="T:log4net.Filter.IFilter" /> chain accepts the 
            		<paramref name="loggingEvents" />.
            		</description>
            </item>
            <item>
              <description>
            		Calls <see cref="M:PreAppendCheck()" /> and checks that 
            		it returns <c>true</c>.</description>
            </item>
          </list>
        </para>
        <para>
            If all of the above steps succeed then the <paramref name="loggingEvents" />
            will be passed to the <see cref="M:Append(LoggingEvent[])" /> method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.FilterEvent(log4net.Core.LoggingEvent)">
      <summary>
            Test if the logging event should we output by this appender
            </summary>
      <param name="loggingEvent">the event to test</param>
      <returns>
        <c>true</c> if the event should be output, <c>false</c> if the event should be ignored</returns>
      <remarks>
        <para>
            This method checks the logging event against the threshold level set
            on this appender and also against the filters specified on this
            appender.
            </para>
        <para>
            The implementation of this method is as follows:
            </para>
        <para>
          <list type="bullet">
            <item>
              <description>
            		Checks that the severity of the <paramref name="loggingEvent" />
            		is greater than or equal to the <see cref="P:log4net.Appender.AppenderSkeleton.Threshold" /> of this
            		appender.</description>
            </item>
            <item>
              <description>
            		Checks that the <see cref="T:log4net.Filter.IFilter" /> chain accepts the 
            		<paramref name="loggingEvent" />.
            		</description>
            </item>
          </list>
        </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.AddFilter(log4net.Filter.IFilter)">
      <summary>
            Adds a filter to the end of the filter chain.
            </summary>
      <param name="filter">the filter to add to this appender</param>
      <remarks>
        <para>
            The Filters are organized in a linked list.
            </para>
        <para>
            Setting this property causes the new filter to be pushed onto the 
            back of the filter chain.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.ClearFilters">
      <summary>
            Clears the filter list for this appender.
            </summary>
      <remarks>
        <para>
            Clears the filter list for this appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.IsAsSevereAsThreshold(log4net.Core.Level)">
      <summary>
            Checks if the message level is below this appender's threshold.
            </summary>
      <param name="level">
        <see cref="T:log4net.Core.Level" /> to test against.</param>
      <remarks>
        <para>
            If there is no threshold set, then the return value is always <c>true</c>.
            </para>
      </remarks>
      <returns>
        <c>true</c> if the <paramref name="level" /> meets the <see cref="P:log4net.Appender.AppenderSkeleton.Threshold" /> 
            requirements of this appender.
            </returns>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.OnClose">
      <summary>
            Is called when the appender is closed. Derived classes should override 
            this method if resources need to be released.
            </summary>
      <remarks>
        <para>
            Releases any resources allocated within the appender such as file handles, 
            network connections, etc.
            </para>
        <para>
            It is a programming error to append to a closed appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.Append(log4net.Core.LoggingEvent)">
      <summary>
            Subclasses of <see cref="T:log4net.Appender.AppenderSkeleton" /> should implement this method 
            to perform actual logging.
            </summary>
      <param name="loggingEvent">The event to append.</param>
      <remarks>
        <para>
            A subclass must implement this method to perform
            logging of the <paramref name="loggingEvent" />.
            </para>
        <para>This method will be called by <see cref="M:DoAppend(LoggingEvent)" />
            if all the conditions listed for that method are met.
            </para>
        <para>
            To restrict the logging of events in the appender
            override the <see cref="M:PreAppendCheck()" /> method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.Append(log4net.Core.LoggingEvent[])">
      <summary>
            Append a bulk array of logging events.
            </summary>
      <param name="loggingEvents">the array of logging events</param>
      <remarks>
        <para>
            This base class implementation calls the <see cref="M:Append(LoggingEvent)" />
            method for each element in the bulk array.
            </para>
        <para>
            A sub class that can better process a bulk array of events should
            override this method in addition to <see cref="M:Append(LoggingEvent)" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.PreAppendCheck">
      <summary>
            Called before <see cref="M:Append(LoggingEvent)" /> as a precondition.
            </summary>
      <remarks>
        <para>
            This method is called by <see cref="M:DoAppend(LoggingEvent)" />
            before the call to the abstract <see cref="M:Append(LoggingEvent)" /> method.
            </para>
        <para>
            This method can be overridden in a subclass to extend the checks 
            made before the event is passed to the <see cref="M:Append(LoggingEvent)" /> method.
            </para>
        <para>
            A subclass should ensure that they delegate this call to
            this base class if it is overridden.
            </para>
      </remarks>
      <returns>
        <c>true</c> if the call to <see cref="M:Append(LoggingEvent)" /> should proceed.</returns>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.RenderLoggingEvent(log4net.Core.LoggingEvent)">
      <summary>
            Renders the <see cref="T:log4net.Core.LoggingEvent" /> to a string.
            </summary>
      <param name="loggingEvent">The event to render.</param>
      <returns>The event rendered as a string.</returns>
      <remarks>
        <para>
            Helper method to render a <see cref="T:log4net.Core.LoggingEvent" /> to 
            a string. This appender must have a <see cref="P:log4net.Appender.AppenderSkeleton.Layout" />
            set to render the <paramref name="loggingEvent" /> to 
            a string.
            </para>
        <para>If there is exception data in the logging event and 
            the layout does not process the exception, this method 
            will append the exception text to the rendered string.
            </para>
        <para>
            Where possible use the alternative version of this method
            <see cref="M:RenderLoggingEvent(TextWriter,LoggingEvent)" />.
            That method streams the rendering onto an existing Writer
            which can give better performance if the caller already has
            a <see cref="T:System.IO.TextWriter" /> open and ready for writing.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.RenderLoggingEvent(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Renders the <see cref="T:log4net.Core.LoggingEvent" /> to a string.
            </summary>
      <param name="loggingEvent">The event to render.</param>
      <param name="writer">The TextWriter to write the formatted event to</param>
      <remarks>
        <para>
            Helper method to render a <see cref="T:log4net.Core.LoggingEvent" /> to 
            a string. This appender must have a <see cref="P:log4net.Appender.AppenderSkeleton.Layout" />
            set to render the <paramref name="loggingEvent" /> to 
            a string.
            </para>
        <para>If there is exception data in the logging event and 
            the layout does not process the exception, this method 
            will append the exception text to the rendered string.
            </para>
        <para>
            Use this method in preference to <see cref="M:RenderLoggingEvent(LoggingEvent)" />
            where possible. If, however, the caller needs to render the event
            to a string then <see cref="M:RenderLoggingEvent(LoggingEvent)" /> does
            provide an efficient mechanism for doing so.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AppenderSkeleton.Threshold">
      <summary>
            Gets or sets the threshold <see cref="T:log4net.Core.Level" /> of this appender.
            </summary>
      <value>
            The threshold <see cref="T:log4net.Core.Level" /> of the appender. 
            </value>
      <remarks>
        <para>
            All log events with lower level than the threshold level are ignored 
            by the appender.
            </para>
        <para>
            In configuration files this option is specified by setting the
            value of the <see cref="P:log4net.Appender.AppenderSkeleton.Threshold" /> option to a level
            string, such as "DEBUG", "INFO" and so on.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AppenderSkeleton.ErrorHandler">
      <summary>
            Gets or sets the <see cref="T:log4net.Core.IErrorHandler" /> for this appender.
            </summary>
      <value>The <see cref="T:log4net.Core.IErrorHandler" /> of the appender</value>
      <remarks>
        <para>
            The <see cref="T:log4net.Appender.AppenderSkeleton" /> provides a default 
            implementation for the <see cref="P:log4net.Appender.AppenderSkeleton.ErrorHandler" /> property. 
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AppenderSkeleton.FilterHead">
      <summary>
            The filter chain.
            </summary>
      <value>The head of the filter chain filter chain.</value>
      <remarks>
        <para>
            Returns the head Filter. The Filters are organized in a linked list
            and so all Filters on this Appender are available through the result.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AppenderSkeleton.Layout">
      <summary>
            Gets or sets the <see cref="T:log4net.Layout.ILayout" /> for this appender.
            </summary>
      <value>The layout of the appender.</value>
      <remarks>
        <para>
            See <see cref="P:log4net.Appender.AppenderSkeleton.RequiresLayout" /> for more information.
            </para>
      </remarks>
      <seealso cref="P:log4net.Appender.AppenderSkeleton.RequiresLayout" />
    </member>
    <member name="P:log4net.Appender.AppenderSkeleton.Name">
      <summary>
            Gets or sets the name of this appender.
            </summary>
      <value>The name of the appender.</value>
      <remarks>
        <para>
            The name uniquely identifies the appender.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AppenderSkeleton.RequiresLayout">
      <summary>
            Tests if this appender requires a <see cref="P:log4net.Appender.AppenderSkeleton.Layout" /> to be set.
            </summary>
      <remarks>
        <para>
            In the rather exceptional case, where the appender 
            implementation admits a layout but can also work without it, 
            then the appender should return <c>true</c>.
            </para>
        <para>
            This default implementation always returns <c>false</c>.
            </para>
      </remarks>
      <returns>
        <c>true</c> if the appender requires a layout object, otherwise <c>false</c>.
            </returns>
    </member>
    <member name="T:log4net.Appender.BufferingAppenderSkeleton">
      <summary>
            Abstract base class implementation of <see cref="T:log4net.Appender.IAppender" /> that 
            buffers events in a fixed size buffer.
            </summary>
      <remarks>
        <para>
            This base class should be used by appenders that need to buffer a 
            number of events before logging them. For example the <see cref="T:log4net.Appender.AdoNetAppender" /> 
            buffers events and then submits the entire contents of the buffer to 
            the underlying database in one go.
            </para>
        <para>
            Subclasses should override the <see cref="M:SendBuffer(LoggingEvent[])" />
            method to deliver the buffered events.
            </para>
        <para>The BufferingAppenderSkeleton maintains a fixed size cyclic 
            buffer of events. The size of the buffer is set using 
            the <see cref="P:log4net.Appender.BufferingAppenderSkeleton.BufferSize" /> property.
            </para>
        <para>A <see cref="T:log4net.Core.ITriggeringEventEvaluator" /> is used to inspect 
            each event as it arrives in the appender. If the <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Evaluator" /> 
            triggers, then the current buffer is sent immediately 
            (see <see cref="M:SendBuffer(LoggingEvent[])" />). Otherwise the event 
            is stored in the buffer. For example, an evaluator can be used to 
            deliver the events immediately when an ERROR event arrives.
            </para>
        <para>
            The buffering appender can be configured in a <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Lossy" /> mode. 
            By default the appender is NOT lossy. When the buffer is full all 
            the buffered events are sent with <see cref="M:SendBuffer(LoggingEvent[])" />.
            If the <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Lossy" /> property is set to <c>true</c> then the 
            buffer will not be sent when it is full, and new events arriving 
            in the appender will overwrite the oldest event in the buffer. 
            In lossy mode the buffer will only be sent when the <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Evaluator" />
            triggers. This can be useful behavior when you need to know about 
            ERROR events but not about events with a lower level, configure an 
            evaluator that will trigger when an ERROR event arrives, the whole 
            buffer will be sent which gives a history of events leading up to
            the ERROR event.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Appender.BufferingAppenderSkeleton.DEFAULT_BUFFER_SIZE">
      <summary>
            The default buffer size.
            </summary>
      <remarks>
            The default size of the cyclic buffer used to store events.
            This is set to 512 by default.
            </remarks>
    </member>
    <member name="F:log4net.Appender.BufferingAppenderSkeleton.m_bufferSize">
      <summary>
            The size of the cyclic buffer used to hold the logging events.
            </summary>
      <remarks>
            Set to <see cref="F:log4net.Appender.BufferingAppenderSkeleton.DEFAULT_BUFFER_SIZE" /> by default.
            </remarks>
    </member>
    <member name="F:log4net.Appender.BufferingAppenderSkeleton.m_cb">
      <summary>
            The cyclic buffer used to store the logging events.
            </summary>
    </member>
    <member name="F:log4net.Appender.BufferingAppenderSkeleton.m_evaluator">
      <summary>
            The triggering event evaluator that causes the buffer to be sent immediately.
            </summary>
      <remarks>
            The object that is used to determine if an event causes the entire
            buffer to be sent immediately. This field can be <c>null</c>, which 
            indicates that event triggering is not to be done. The evaluator
            can be set using the <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Evaluator" /> property. If this appender
            has the <see cref="F:log4net.Appender.BufferingAppenderSkeleton.m_lossy" /> (<see cref="P:log4net.Appender.BufferingAppenderSkeleton.Lossy" /> property) set to 
            <c>true</c> then an <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Evaluator" /> must be set.
            </remarks>
    </member>
    <member name="F:log4net.Appender.BufferingAppenderSkeleton.m_lossy">
      <summary>
            Indicates if the appender should overwrite events in the cyclic buffer 
            when it becomes full, or if the buffer should be flushed when the 
            buffer is full.
            </summary>
      <remarks>
            If this field is set to <c>true</c> then an <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Evaluator" /> must 
            be set.
            </remarks>
    </member>
    <member name="F:log4net.Appender.BufferingAppenderSkeleton.m_lossyEvaluator">
      <summary>
            The triggering event evaluator filters discarded events.
            </summary>
      <remarks>
            The object that is used to determine if an event that is discarded should
            really be discarded or if it should be sent to the appenders. 
            This field can be <c>null</c>, which indicates that all discarded events will
            be discarded. 
            </remarks>
    </member>
    <member name="F:log4net.Appender.BufferingAppenderSkeleton.m_fixFlags">
      <summary>
            Value indicating which fields in the event should be fixed
            </summary>
      <remarks>
            By default all fields are fixed
            </remarks>
    </member>
    <member name="F:log4net.Appender.BufferingAppenderSkeleton.m_eventMustBeFixed">
      <summary>
            The events delivered to the subclass must be fixed.
            </summary>
    </member>
    <member name="M:log4net.Appender.BufferingAppenderSkeleton.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.BufferingAppenderSkeleton" /> class.
            </summary>
      <remarks>
        <para>
            Protected default constructor to allow subclassing.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingAppenderSkeleton.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.BufferingAppenderSkeleton" /> class.
            </summary>
      <param name="eventMustBeFixed">the events passed through this appender must be
            fixed by the time that they arrive in the derived class' <c>SendBuffer</c> method.</param>
      <remarks>
        <para>
            Protected constructor to allow subclassing.
            </para>
        <para>
            The <paramref name="eventMustBeFixed" /> should be set if the subclass
            expects the events delivered to be fixed even if the 
            <see cref="P:log4net.Appender.BufferingAppenderSkeleton.BufferSize" /> is set to zero, i.e. when no buffering occurs.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingAppenderSkeleton.Flush">
      <summary>
            Flush the currently buffered events
            </summary>
      <remarks>
        <para>
            Flushes any events that have been buffered.
            </para>
        <para>
            If the appender is buffering in <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Lossy" /> mode then the contents
            of the buffer will NOT be flushed to the appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingAppenderSkeleton.Flush(System.Boolean)">
      <summary>
            Flush the currently buffered events
            </summary>
      <param name="flushLossyBuffer">set to <c>true</c> to flush the buffer of lossy events</param>
      <remarks>
        <para>
            Flushes events that have been buffered. If <paramref name="flushLossyBuffer" /> is
            <c>false</c> then events will only be flushed if this buffer is non-lossy mode.
            </para>
        <para>
            If the appender is buffering in <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Lossy" /> mode then the contents
            of the buffer will only be flushed if <paramref name="flushLossyBuffer" /> is <c>true</c>.
            In this case the contents of the buffer will be tested against the 
            <see cref="P:log4net.Appender.BufferingAppenderSkeleton.LossyEvaluator" /> and if triggering will be output. All other buffered
            events will be discarded.
            </para>
        <para>
            If <paramref name="flushLossyBuffer" /> is <c>true</c> then the buffer will always
            be emptied by calling this method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingAppenderSkeleton.ActivateOptions">
      <summary>
            Initialize the appender based on the options set
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.BufferingAppenderSkeleton.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.BufferingAppenderSkeleton.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.BufferingAppenderSkeleton.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingAppenderSkeleton.OnClose">
      <summary>
            Close this appender instance.
            </summary>
      <remarks>
        <para>
            Close this appender instance. If this appender is marked
            as not <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Lossy" /> then the remaining events in 
            the buffer must be sent when the appender is closed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingAppenderSkeleton.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)" /> method. 
            </summary>
      <param name="loggingEvent">the event to log</param>
      <remarks>
        <para>
            Stores the <paramref name="loggingEvent" /> in the cyclic buffer.
            </para>
        <para>
            The buffer will be sent (i.e. passed to the <see cref="M:log4net.Appender.BufferingAppenderSkeleton.SendBuffer(log4net.Core.LoggingEvent[])" /> 
            method) if one of the following conditions is met:
            </para>
        <list type="bullet">
          <item>
            <description>The cyclic buffer is full and this appender is
            		marked as not lossy (see <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Lossy" />)</description>
          </item>
          <item>
            <description>An <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Evaluator" /> is set and
            		it is triggered for the <paramref name="loggingEvent" />
            		specified.</description>
          </item>
        </list>
        <para>
            Before the event is stored in the buffer it is fixed
            (see <see cref="M:LoggingEvent.FixVolatileData(FixFlags)" />) to ensure that
            any data referenced by the event will be valid when the buffer
            is processed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingAppenderSkeleton.SendFromBuffer(log4net.Core.LoggingEvent,log4net.Util.CyclicBuffer)">
      <summary>
            Sends the contents of the buffer.
            </summary>
      <param name="firstLoggingEvent">The first logging event.</param>
      <param name="buffer">The buffer containing the events that need to be send.</param>
      <remarks>
        <para>
            The subclass must override <see cref="M:SendBuffer(LoggingEvent[])" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingAppenderSkeleton.SendBuffer(log4net.Core.LoggingEvent[])">
      <summary>
            Sends the events.
            </summary>
      <param name="events">The events that need to be send.</param>
      <remarks>
        <para>
            The subclass must override this method to process the buffered events.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.BufferingAppenderSkeleton.Lossy">
      <summary>
            Gets or sets a value that indicates whether the appender is lossy.
            </summary>
      <value>
        <c>true</c> if the appender is lossy, otherwise <c>false</c>. The default is <c>false</c>.
            </value>
      <remarks>
        <para>
            This appender uses a buffer to store logging events before 
            delivering them. A triggering event causes the whole buffer
            to be send to the remote sink. If the buffer overruns before
            a triggering event then logging events could be lost. Set
            <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Lossy" /> to <c>false</c> to prevent logging events 
            from being lost.
            </para>
        <para>If <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Lossy" /> is set to <c>true</c> then an
            <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Evaluator" /> must be specified.</para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.BufferingAppenderSkeleton.BufferSize">
      <summary>
            Gets or sets the size of the cyclic buffer used to hold the 
            logging events.
            </summary>
      <value>
            The size of the cyclic buffer used to hold the logging events.
            </value>
      <remarks>
        <para>
            The <see cref="P:log4net.Appender.BufferingAppenderSkeleton.BufferSize" /> option takes a positive integer
            representing the maximum number of logging events to collect in 
            a cyclic buffer. When the <see cref="P:log4net.Appender.BufferingAppenderSkeleton.BufferSize" /> is reached,
            oldest events are deleted as new events are added to the
            buffer. By default the size of the cyclic buffer is 512 events.
            </para>
        <para>
            If the <see cref="P:log4net.Appender.BufferingAppenderSkeleton.BufferSize" /> is set to a value less than
            or equal to 1 then no buffering will occur. The logging event
            will be delivered synchronously (depending on the <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Lossy" />
            and <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Evaluator" /> properties). Otherwise the event will
            be buffered.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.BufferingAppenderSkeleton.Evaluator">
      <summary>
            Gets or sets the <see cref="T:log4net.Core.ITriggeringEventEvaluator" /> that causes the 
            buffer to be sent immediately.
            </summary>
      <value>
            The <see cref="T:log4net.Core.ITriggeringEventEvaluator" /> that causes the buffer to be
            sent immediately.
            </value>
      <remarks>
        <para>
            The evaluator will be called for each event that is appended to this 
            appender. If the evaluator triggers then the current buffer will 
            immediately be sent (see <see cref="M:SendBuffer(LoggingEvent[])" />).
            </para>
        <para>If <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Lossy" /> is set to <c>true</c> then an
            <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Evaluator" /> must be specified.</para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.BufferingAppenderSkeleton.LossyEvaluator">
      <summary>
            Gets or sets the value of the <see cref="T:log4net.Core.ITriggeringEventEvaluator" /> to use.
            </summary>
      <value>
            The value of the <see cref="T:log4net.Core.ITriggeringEventEvaluator" /> to use.
            </value>
      <remarks>
        <para>
            The evaluator will be called for each event that is discarded from this 
            appender. If the evaluator triggers then the current buffer will immediately 
            be sent (see <see cref="M:SendBuffer(LoggingEvent[])" />).
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.BufferingAppenderSkeleton.OnlyFixPartialEventData">
      <summary>
            Gets or sets a value indicating if only part of the logging event data
            should be fixed.
            </summary>
      <value>
        <c>true</c> if the appender should only fix part of the logging event 
            data, otherwise <c>false</c>. The default is <c>false</c>.
            </value>
      <remarks>
        <para>
            Setting this property to <c>true</c> will cause only part of the
            event data to be fixed and serialized. This will improve performance.
            </para>
        <para>
            See <see cref="M:LoggingEvent.FixVolatileData(FixFlags)" /> for more information.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.BufferingAppenderSkeleton.Fix">
      <summary>
            Gets or sets a the fields that will be fixed in the event
            </summary>
      <value>
            The event fields that will be fixed before the event is buffered
            </value>
      <remarks>
        <para>
            The logging event needs to have certain thread specific values 
            captured before it can be buffered. See <see cref="P:log4net.Core.LoggingEvent.Fix" />
            for details.
            </para>
      </remarks>
      <seealso cref="P:log4net.Core.LoggingEvent.Fix" />
    </member>
    <member name="T:log4net.Appender.AdoNetAppender">
      <summary>
            Appender that logs to a database.
            </summary>
      <remarks>
        <para>
          <see cref="T:log4net.Appender.AdoNetAppender" /> appends logging events to a table within a
            database. The appender can be configured to specify the connection 
            string by setting the <see cref="P:log4net.Appender.AdoNetAppender.ConnectionString" /> property. 
            The connection type (provider) can be specified by setting the <see cref="P:log4net.Appender.AdoNetAppender.ConnectionType" />
            property. For more information on database connection strings for
            your specific database see <a href="http://www.connectionstrings.com/">http://www.connectionstrings.com/</a>.
            </para>
        <para>
            Records are written into the database either using a prepared
            statement or a stored procedure. The <see cref="P:log4net.Appender.AdoNetAppender.CommandType" /> property
            is set to <see cref="F:System.Data.CommandType.Text" /> (<c>System.Data.CommandType.Text</c>) to specify a prepared statement
            or to <see cref="F:System.Data.CommandType.StoredProcedure" /> (<c>System.Data.CommandType.StoredProcedure</c>) to specify a stored
            procedure.
            </para>
        <para>
            The prepared statement text or the name of the stored procedure
            must be set in the <see cref="P:log4net.Appender.AdoNetAppender.CommandText" /> property.
            </para>
        <para>
            The prepared statement or stored procedure can take a number
            of parameters. Parameters are added using the <see cref="M:log4net.Appender.AdoNetAppender.AddParameter(log4net.Appender.AdoNetAppenderParameter)" />
            method. This adds a single <see cref="T:log4net.Appender.AdoNetAppenderParameter" /> to the
            ordered list of parameters. The <see cref="T:log4net.Appender.AdoNetAppenderParameter" />
            type may be subclassed if required to provide database specific
            functionality. The <see cref="T:log4net.Appender.AdoNetAppenderParameter" /> specifies
            the parameter name, database type, size, and how the value should
            be generated using a <see cref="T:log4net.Layout.ILayout" />.
            </para>
      </remarks>
      <example>
            An example of a SQL Server table that could be logged to:
            <code lang="SQL">
            CREATE TABLE [dbo].[Log] ( 
              [ID] [int] IDENTITY (1, 1) NOT NULL ,
              [Date] [datetime] NOT NULL ,
              [Thread] [varchar] (255) NOT NULL ,
              [Level] [varchar] (20) NOT NULL ,
              [Logger] [varchar] (255) NOT NULL ,
              [Message] [varchar] (4000) NOT NULL 
            ) ON [PRIMARY]
            </code></example>
      <example>
            An example configuration to log to the above table:
            <code lang="XML" escaped="true"><appender name="AdoNetAppender_SqlServer" type="log4net.Appender.AdoNetAppender"><connectionType value="System.Data.SqlClient.SqlConnection, System.Data, Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /><connectionString value="data source=SQLSVR;initial catalog=test_log4net;integrated security=false;persist security info=True;User ID=sa;Password=sa" /><commandText value="INSERT INTO Log ([Date],[Thread],[Level],[Logger],[Message]) VALUES (@log_date, @thread, @log_level, @logger, @message)" /><parameter><parameterName value="@log_date" /><dbType value="DateTime" /><layout type="log4net.Layout.PatternLayout" value="%date{yyyy'-'MM'-'dd HH':'mm':'ss'.'fff}" /></parameter><parameter><parameterName value="@thread" /><dbType value="String" /><size value="255" /><layout type="log4net.Layout.PatternLayout" value="%thread" /></parameter><parameter><parameterName value="@log_level" /><dbType value="String" /><size value="50" /><layout type="log4net.Layout.PatternLayout" value="%level" /></parameter><parameter><parameterName value="@logger" /><dbType value="String" /><size value="255" /><layout type="log4net.Layout.PatternLayout" value="%logger" /></parameter><parameter><parameterName value="@message" /><dbType value="String" /><size value="4000" /><layout type="log4net.Layout.PatternLayout" value="%message" /></parameter></appender></code></example>
      <author>Julian Biddle</author>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Lance Nehring</author>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_usePreparedCommand">
      <summary>
            Flag to indicate if we are using a command object
            </summary>
      <remarks>
        <para>
            Set to <c>true</c> when the appender is to use a prepared
            statement or stored procedure to insert into the database.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_parameters">
      <summary>
            The list of <see cref="T:log4net.Appender.AdoNetAppenderParameter" /> objects.
            </summary>
      <remarks>
        <para>
            The list of <see cref="T:log4net.Appender.AdoNetAppenderParameter" /> objects.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_securityContext">
      <summary>
            The security context to use for privileged calls
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_dbConnection">
      <summary>
            The <see cref="T:System.Data.IDbConnection" /> that will be used
            to insert logging events into a database.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_dbCommand">
      <summary>
            The database command.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_connectionString">
      <summary>
            Database connection string.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_appSettingsKey">
      <summary>
            The appSettings key from App.Config that contains the connection string.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_connectionStringName">
      <summary>
            The connectionStrings key from App.Config that contains the connection string.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_connectionType">
      <summary>
            String type name of the <see cref="T:System.Data.IDbConnection" /> type name.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_commandText">
      <summary>
            The text of the command.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_commandType">
      <summary>
            The command type.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_useTransactions">
      <summary>
            Indicates whether to use transactions when writing to the database.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_reconnectOnError">
      <summary>
            Indicates whether to use transactions when writing to the database.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.declaringType">
      <summary>
            The fully qualified type of the AdoNetAppender class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.#ctor">
      <summary> 
            Initializes a new instance of the <see cref="T:log4net.Appender.AdoNetAppender" /> class.
            </summary>
      <remarks>
            Public default constructor to initialize a new instance of this class.
            </remarks>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.ActivateOptions">
      <summary>
            Initialize the appender based on the options set
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.AdoNetAppender.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.AdoNetAppender.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.AdoNetAppender.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.OnClose">
      <summary>
            Override the parent method to close the database
            </summary>
      <remarks>
        <para>
            Closes the database command and database connection.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.SendBuffer(log4net.Core.LoggingEvent[])">
      <summary>
            Inserts the events into the database.
            </summary>
      <param name="events">The events to insert into the database.</param>
      <remarks>
        <para>
            Insert all the events specified in the <paramref name="events" />
            array into the database.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.AddParameter(log4net.Appender.AdoNetAppenderParameter)">
      <summary>
            Adds a parameter to the command.
            </summary>
      <param name="parameter">The parameter to add to the command.</param>
      <remarks>
        <para>
            Adds a parameter to the ordered list of command parameters.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.SendBuffer(System.Data.IDbTransaction,log4net.Core.LoggingEvent[])">
      <summary>
            Writes the events to the database using the transaction specified.
            </summary>
      <param name="dbTran">The transaction that the events will be executed under.</param>
      <param name="events">The array of events to insert into the database.</param>
      <remarks>
        <para>
            The transaction argument can be <c>null</c> if the appender has been
            configured not to use transactions. See <see cref="P:log4net.Appender.AdoNetAppender.UseTransactions" />
            property for more information.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.GetLogStatement(log4net.Core.LoggingEvent)">
      <summary>
            Formats the log message into database statement text.
            </summary>
      <param name="logEvent">The event being logged.</param>
      <remarks>
            This method can be overridden by subclasses to provide 
            more control over the format of the database statement.
            </remarks>
      <returns>
            Text that can be passed to a <see cref="T:System.Data.IDbCommand" />.
            </returns>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.CreateConnection(System.Type,System.String)">
      <summary>
            Creates an <see cref="T:System.Data.IDbConnection" /> instance used to connect to the database.
            </summary>
      <remarks>
            This method is called whenever a new IDbConnection is needed (i.e. when a reconnect is necessary).
            </remarks>
      <param name="connectionType">The <see cref="T:System.Type" /> of the <see cref="T:System.Data.IDbConnection" /> object.</param>
      <param name="connectionString">The connectionString output from the ResolveConnectionString method.</param>
      <returns>An <see cref="T:System.Data.IDbConnection" /> instance with a valid connection string.</returns>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.ResolveConnectionString(System.String@)">
      <summary>
            Resolves the connection string from the ConnectionString, ConnectionStringName, or AppSettingsKey
            property.
            </summary>
      <remarks>
            ConnectiongStringName is only supported on .NET 2.0 and higher.
            </remarks>
      <param name="connectionStringContext">Additional information describing the connection string.</param>
      <returns>A connection string used to connect to the database.</returns>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.ResolveConnectionType">
      <summary>
            Retrieves the class type of the ADO.NET provider.
            </summary>
      <remarks>
        <para>
            Gets the Type of the ADO.NET provider to use to connect to the
            database. This method resolves the type specified in the 
            <see cref="P:log4net.Appender.AdoNetAppender.ConnectionType" /> property.
            </para>
        <para>
            Subclasses can override this method to return a different type
            if necessary.
            </para>
      </remarks>
      <returns>The <see cref="T:System.Type" /> of the ADO.NET provider</returns>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.InitializeDatabaseCommand">
      <summary>
            Prepares the database command and initialize the parameters.
            </summary>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.InitializeDatabaseConnection">
      <summary>
            Connects to the database.
            </summary>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.DisposeCommand(System.Boolean)">
      <summary>
            Cleanup the existing command.
            </summary>
      <param name="ignoreException">
            If true, a message will be written using LogLog.Warn if an exception is encountered when calling Dispose.
            </param>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.DiposeConnection">
      <summary>
            Cleanup the existing connection.
            </summary>
      <remarks>
            Calls the IDbConnection's <see cref="M:System.Data.IDbConnection.Close" /> method.
            </remarks>
    </member>
    <member name="P:log4net.Appender.AdoNetAppender.ConnectionString">
      <summary>
            Gets or sets the database connection string that is used to connect to 
            the database.
            </summary>
      <value>
            The database connection string used to connect to the database.
            </value>
      <remarks>
        <para>
            The connections string is specific to the connection type.
            See <see cref="P:log4net.Appender.AdoNetAppender.ConnectionType" /> for more information.
            </para>
      </remarks>
      <example>Connection string for MS Access via ODBC:
            <code>"DSN=MS Access Database;UID=admin;PWD=;SystemDB=C:\data\System.mdw;SafeTransactions = 0;FIL=MS Access;DriverID = 25;DBQ=C:\data\train33.mdb"</code></example>
      <example>Another connection string for MS Access via ODBC:
            <code>"Driver={Microsoft Access Driver (*.mdb)};DBQ=C:\Work\cvs_root\log4net-1.2\access.mdb;UID=;PWD=;"</code></example>
      <example>Connection string for MS Access via OLE DB:
            <code>"Provider=Microsoft.Jet.OLEDB.4.0;Data Source=C:\Work\cvs_root\log4net-1.2\access.mdb;User Id=;Password=;"</code></example>
    </member>
    <member name="P:log4net.Appender.AdoNetAppender.AppSettingsKey">
      <summary>
            The appSettings key from App.Config that contains the connection string.
            </summary>
    </member>
    <member name="P:log4net.Appender.AdoNetAppender.ConnectionStringName">
      <summary>
            The connectionStrings key from App.Config that contains the connection string.
            </summary>
      <remarks>
            This property requires at least .NET 2.0.
            </remarks>
    </member>
    <member name="P:log4net.Appender.AdoNetAppender.ConnectionType">
      <summary>
            Gets or sets the type name of the <see cref="T:System.Data.IDbConnection" /> connection
            that should be created.
            </summary>
      <value>
            The type name of the <see cref="T:System.Data.IDbConnection" /> connection.
            </value>
      <remarks>
        <para>
            The type name of the ADO.NET provider to use.
            </para>
        <para>
            The default is to use the OLE DB provider.
            </para>
      </remarks>
      <example>Use the OLE DB Provider. This is the default value.
            <code>System.Data.OleDb.OleDbConnection, System.Data, Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</code></example>
      <example>Use the MS SQL Server Provider. 
            <code>System.Data.SqlClient.SqlConnection, System.Data, Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</code></example>
      <example>Use the ODBC Provider. 
            <code>Microsoft.Data.Odbc.OdbcConnection,Microsoft.Data.Odbc,version=1.0.3300.0,publicKeyToken=b77a5c561934e089,culture=neutral</code>
            This is an optional package that you can download from 
            <a href="http://msdn.microsoft.com/downloads">http://msdn.microsoft.com/downloads</a> 
            search for <b>ODBC .NET Data Provider</b>.
            </example>
      <example>Use the Oracle Provider. 
            <code>System.Data.OracleClient.OracleConnection, System.Data.OracleClient, Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</code>
            This is an optional package that you can download from 
            <a href="http://msdn.microsoft.com/downloads">http://msdn.microsoft.com/downloads</a> 
            search for <b>.NET Managed Provider for Oracle</b>.
            </example>
    </member>
    <member name="P:log4net.Appender.AdoNetAppender.CommandText">
      <summary>
            Gets or sets the command text that is used to insert logging events
            into the database.
            </summary>
      <value>
            The command text used to insert logging events into the database.
            </value>
      <remarks>
        <para>
            Either the text of the prepared statement or the
            name of the stored procedure to execute to write into
            the database.
            </para>
        <para>
            The <see cref="P:log4net.Appender.AdoNetAppender.CommandType" /> property determines if
            this text is a prepared statement or a stored procedure.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AdoNetAppender.CommandType">
      <summary>
            Gets or sets the command type to execute.
            </summary>
      <value>
            The command type to execute.
            </value>
      <remarks>
        <para>
            This value may be either <see cref="F:System.Data.CommandType.Text" /> (<c>System.Data.CommandType.Text</c>) to specify
            that the <see cref="P:log4net.Appender.AdoNetAppender.CommandText" /> is a prepared statement to execute, 
            or <see cref="F:System.Data.CommandType.StoredProcedure" /> (<c>System.Data.CommandType.StoredProcedure</c>) to specify that the
            <see cref="P:log4net.Appender.AdoNetAppender.CommandText" /> property is the name of a stored procedure
            to execute.
            </para>
        <para>
            The default value is <see cref="F:System.Data.CommandType.Text" /> (<c>System.Data.CommandType.Text</c>).
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AdoNetAppender.UseTransactions">
      <summary>
            Should transactions be used to insert logging events in the database.
            </summary>
      <value>
        <c>true</c> if transactions should be used to insert logging events in
            the database, otherwise <c>false</c>. The default value is <c>true</c>.
            </value>
      <remarks>
        <para>
            Gets or sets a value that indicates whether transactions should be used
            to insert logging events in the database.
            </para>
        <para>
            When set a single transaction will be used to insert the buffered events
            into the database. Otherwise each event will be inserted without using
            an explicit transaction.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AdoNetAppender.SecurityContext">
      <summary>
            Gets or sets the <see cref="P:log4net.Appender.AdoNetAppender.SecurityContext" /> used to call the NetSend method.
            </summary>
      <value>
            The <see cref="P:log4net.Appender.AdoNetAppender.SecurityContext" /> used to call the NetSend method.
            </value>
      <remarks>
        <para>
            Unless a <see cref="P:log4net.Appender.AdoNetAppender.SecurityContext" /> specified here for this appender
            the <see cref="P:log4net.Core.SecurityContextProvider.DefaultProvider" /> is queried for the
            security context to use. The default behavior is to use the security context
            of the current thread.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AdoNetAppender.ReconnectOnError">
      <summary>
            Should this appender try to reconnect to the database on error.
            </summary>
      <value>
        <c>true</c> if the appender should try to reconnect to the database after an
            error has occurred, otherwise <c>false</c>. The default value is <c>false</c>, 
            i.e. not to try to reconnect.
            </value>
      <remarks>
        <para>
            The default behaviour is for the appender not to try to reconnect to the
            database if an error occurs. Subsequent logging events are discarded.
            </para>
        <para>
            To force the appender to attempt to reconnect to the database set this
            property to <c>true</c>.
            </para>
        <note>
            When the appender attempts to connect to the database there may be a
            delay of up to the connection timeout specified in the connection string.
            This delay will block the calling application's thread. 
            Until the connection can be reestablished this potential delay may occur multiple times.
            </note>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AdoNetAppender.Connection">
      <summary>
            Gets or sets the underlying <see cref="T:System.Data.IDbConnection" />.
            </summary>
      <value>
            The underlying <see cref="T:System.Data.IDbConnection" />.
            </value>
      <remarks>
        <see cref="T:log4net.Appender.AdoNetAppender" /> creates a <see cref="T:System.Data.IDbConnection" /> to insert 
            logging events into a database.  Classes deriving from <see cref="T:log4net.Appender.AdoNetAppender" /> 
            can use this property to get or set this <see cref="T:System.Data.IDbConnection" />.  Use the 
            underlying <see cref="T:System.Data.IDbConnection" /> returned from <see cref="P:log4net.Appender.AdoNetAppender.Connection" /> if 
            you require access beyond that which <see cref="T:log4net.Appender.AdoNetAppender" /> provides.
            </remarks>
    </member>
    <member name="T:log4net.Appender.AdoNetAppenderParameter">
      <summary>
            Parameter type used by the <see cref="T:log4net.Appender.AdoNetAppender" />.
            </summary>
      <remarks>
        <para>
            This class provides the basic database parameter properties
            as defined by the <see cref="T:System.Data.IDbDataParameter" /> interface.
            </para>
        <para>This type can be subclassed to provide database specific
            functionality. The two methods that are called externally are
            <see cref="M:log4net.Appender.AdoNetAppenderParameter.Prepare(System.Data.IDbCommand)" /> and <see cref="M:log4net.Appender.AdoNetAppenderParameter.FormatValue(System.Data.IDbCommand,log4net.Core.LoggingEvent)" />.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.AdoNetAppenderParameter.m_parameterName">
      <summary>
            The name of this parameter.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppenderParameter.m_dbType">
      <summary>
            The database type for this parameter.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppenderParameter.m_inferType">
      <summary>
            Flag to infer type rather than use the DbType
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppenderParameter.m_precision">
      <summary>
            The precision for this parameter.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppenderParameter.m_scale">
      <summary>
            The scale for this parameter.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppenderParameter.m_size">
      <summary>
            The size for this parameter.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppenderParameter.m_layout">
      <summary>
            The <see cref="T:log4net.Layout.IRawLayout" /> to use to render the
            logging event into an object for this parameter.
            </summary>
    </member>
    <member name="M:log4net.Appender.AdoNetAppenderParameter.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.AdoNetAppenderParameter" /> class.
            </summary>
      <remarks>
            Default constructor for the AdoNetAppenderParameter class.
            </remarks>
    </member>
    <member name="M:log4net.Appender.AdoNetAppenderParameter.Prepare(System.Data.IDbCommand)">
      <summary>
            Prepare the specified database command object.
            </summary>
      <param name="command">The command to prepare.</param>
      <remarks>
        <para>
            Prepares the database command object by adding
            this parameter to its collection of parameters.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AdoNetAppenderParameter.FormatValue(System.Data.IDbCommand,log4net.Core.LoggingEvent)">
      <summary>
            Renders the logging event and set the parameter value in the command.
            </summary>
      <param name="command">The command containing the parameter.</param>
      <param name="loggingEvent">The event to be rendered.</param>
      <remarks>
        <para>
            Renders the logging event using this parameters layout
            object. Sets the value of the parameter on the command object.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AdoNetAppenderParameter.ParameterName">
      <summary>
            Gets or sets the name of this parameter.
            </summary>
      <value>
            The name of this parameter.
            </value>
      <remarks>
        <para>
            The name of this parameter. The parameter name
            must match up to a named parameter to the SQL stored procedure
            or prepared statement.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AdoNetAppenderParameter.DbType">
      <summary>
            Gets or sets the database type for this parameter.
            </summary>
      <value>
            The database type for this parameter.
            </value>
      <remarks>
        <para>
            The database type for this parameter. This property should
            be set to the database type from the <see cref="P:log4net.Appender.AdoNetAppenderParameter.DbType" />
            enumeration. See <see cref="P:System.Data.IDataParameter.DbType" />.
            </para>
        <para>
            This property is optional. If not specified the ADO.NET provider 
            will attempt to infer the type from the value.
            </para>
      </remarks>
      <seealso cref="P:System.Data.IDataParameter.DbType" />
    </member>
    <member name="P:log4net.Appender.AdoNetAppenderParameter.Precision">
      <summary>
            Gets or sets the precision for this parameter.
            </summary>
      <value>
            The precision for this parameter.
            </value>
      <remarks>
        <para>
            The maximum number of digits used to represent the Value.
            </para>
        <para>
            This property is optional. If not specified the ADO.NET provider 
            will attempt to infer the precision from the value.
            </para>
      </remarks>
      <seealso cref="P:System.Data.IDbDataParameter.Precision" />
    </member>
    <member name="P:log4net.Appender.AdoNetAppenderParameter.Scale">
      <summary>
            Gets or sets the scale for this parameter.
            </summary>
      <value>
            The scale for this parameter.
            </value>
      <remarks>
        <para>
            The number of decimal places to which Value is resolved.
            </para>
        <para>
            This property is optional. If not specified the ADO.NET provider 
            will attempt to infer the scale from the value.
            </para>
      </remarks>
      <seealso cref="P:System.Data.IDbDataParameter.Scale" />
    </member>
    <member name="P:log4net.Appender.AdoNetAppenderParameter.Size">
      <summary>
            Gets or sets the size for this parameter.
            </summary>
      <value>
            The size for this parameter.
            </value>
      <remarks>
        <para>
            The maximum size, in bytes, of the data within the column.
            </para>
        <para>
            This property is optional. If not specified the ADO.NET provider 
            will attempt to infer the size from the value.
            </para>
        <para>
            For BLOB data types like VARCHAR(max) it may be impossible to infer the value automatically, use -1 as the size in this case.
            </para>
      </remarks>
      <seealso cref="P:System.Data.IDbDataParameter.Size" />
    </member>
    <member name="P:log4net.Appender.AdoNetAppenderParameter.Layout">
      <summary>
            Gets or sets the <see cref="T:log4net.Layout.IRawLayout" /> to use to 
            render the logging event into an object for this 
            parameter.
            </summary>
      <value>
            The <see cref="T:log4net.Layout.IRawLayout" /> used to render the
            logging event into an object for this parameter.
            </value>
      <remarks>
        <para>
            The <see cref="T:log4net.Layout.IRawLayout" /> that renders the value for this
            parameter.
            </para>
        <para>
            The <see cref="T:log4net.Layout.RawLayoutConverter" /> can be used to adapt
            any <see cref="T:log4net.Layout.ILayout" /> into a <see cref="T:log4net.Layout.IRawLayout" />
            for use in the property.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.AnsiColorTerminalAppender">
      <summary>
            Appends logging events to the terminal using ANSI color escape sequences.
            </summary>
      <remarks>
        <para>
            AnsiColorTerminalAppender appends log events to the standard output stream
            or the error output stream using a layout specified by the 
            user. It also allows the color of a specific level of message to be set.
            </para>
        <note>
            This appender expects the terminal to understand the VT100 control set 
            in order to interpret the color codes. If the terminal or console does not
            understand the control codes the behavior is not defined.
            </note>
        <para>
            By default, all output is written to the console's standard output stream.
            The <see cref="P:log4net.Appender.AnsiColorTerminalAppender.Target" /> property can be set to direct the output to the
            error stream.
            </para>
        <para>
            NOTE: This appender writes each message to the <c>System.Console.Out</c> or 
            <c>System.Console.Error</c> that is set at the time the event is appended.
            Therefore it is possible to programmatically redirect the output of this appender 
            (for example NUnit does this to capture program output). While this is the desired
            behavior of this appender it may have security implications in your application. 
            </para>
        <para>
            When configuring the ANSI colored terminal appender, a mapping should be
            specified to map a logging level to a color. For example:
            </para>
        <code lang="XML" escaped="true">
          <mapping>
            <level value="ERROR" />
            <foreColor value="White" />
            <backColor value="Red" />
            <attributes value="Bright,Underscore" />
          </mapping>
          <mapping>
            <level value="DEBUG" />
            <backColor value="Green" />
          </mapping>
        </code>
        <para>
            The Level is the standard log4net logging level and ForeColor and BackColor can be any
            of the following values:
            <list type="bullet"><item><term>Blue</term><description></description></item><item><term>Green</term><description></description></item><item><term>Red</term><description></description></item><item><term>White</term><description></description></item><item><term>Yellow</term><description></description></item><item><term>Purple</term><description></description></item><item><term>Cyan</term><description></description></item></list>
            These color values cannot be combined together to make new colors.
            </para>
        <para>
            The attributes can be any combination of the following:
            <list type="bullet"><item><term>Bright</term><description>foreground is brighter</description></item><item><term>Dim</term><description>foreground is dimmer</description></item><item><term>Underscore</term><description>message is underlined</description></item><item><term>Blink</term><description>foreground is blinking (does not work on all terminals)</description></item><item><term>Reverse</term><description>foreground and background are reversed</description></item><item><term>Hidden</term><description>output is hidden</description></item><item><term>Strikethrough</term><description>message has a line through it</description></item></list>
            While any of these attributes may be combined together not all combinations
            work well together, for example setting both <i>Bright</i> and <i>Dim</i> attributes makes
            no sense.
            </para>
      </remarks>
      <author>Patrick Wagstrom</author>
      <author>Nicko Cadell</author>
    </member>
    <member name="T:log4net.Appender.AnsiColorTerminalAppender.AnsiAttributes">
      <summary>
            The enum of possible display attributes
            </summary>
      <remarks>
        <para>
            The following flags can be combined together to
            form the ANSI color attributes.
            </para>
      </remarks>
      <seealso cref="T:log4net.Appender.AnsiColorTerminalAppender" />
    </member>
    <member name="T:log4net.Appender.AnsiColorTerminalAppender.AnsiColor">
      <summary>
            The enum of possible foreground or background color values for 
            use with the color mapping method
            </summary>
      <remarks>
        <para>
            The output can be in one for the following ANSI colors.
            </para>
      </remarks>
      <seealso cref="T:log4net.Appender.AnsiColorTerminalAppender" />
    </member>
    <member name="T:log4net.Appender.AnsiColorTerminalAppender.LevelColors">
      <summary>
            A class to act as a mapping between the level that a logging call is made at and
            the color it should be displayed as.
            </summary>
      <remarks>
        <para>
            Defines the mapping between a level and the color it should be displayed in.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AnsiColorTerminalAppender.LevelColors.ActivateOptions">
      <summary>
            Initialize the options for the object
            </summary>
      <remarks>
        <para>
            Combine the <see cref="P:log4net.Appender.AnsiColorTerminalAppender.LevelColors.ForeColor" /> and <see cref="P:log4net.Appender.AnsiColorTerminalAppender.LevelColors.BackColor" /> together
            and append the attributes.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AnsiColorTerminalAppender.LevelColors.ForeColor">
      <summary>
            The mapped foreground color for the specified level
            </summary>
      <remarks>
        <para>
            Required property.
            The mapped foreground color for the specified level
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AnsiColorTerminalAppender.LevelColors.BackColor">
      <summary>
            The mapped background color for the specified level
            </summary>
      <remarks>
        <para>
            Required property.
            The mapped background color for the specified level
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AnsiColorTerminalAppender.LevelColors.Attributes">
      <summary>
            The color attributes for the specified level
            </summary>
      <remarks>
        <para>
            Required property.
            The color attributes for the specified level
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AnsiColorTerminalAppender.LevelColors.CombinedColor">
      <summary>
            The combined <see cref="P:log4net.Appender.AnsiColorTerminalAppender.LevelColors.ForeColor" />, <see cref="P:log4net.Appender.AnsiColorTerminalAppender.LevelColors.BackColor" /> and
            <see cref="P:log4net.Appender.AnsiColorTerminalAppender.LevelColors.Attributes" /> suitable for setting the ansi terminal color.
            </summary>
    </member>
    <member name="F:log4net.Appender.AnsiColorTerminalAppender.ConsoleOut">
      <summary>
            The <see cref="P:log4net.Appender.AnsiColorTerminalAppender.Target" /> to use when writing to the Console 
            standard output stream.
            </summary>
      <remarks>
        <para>
            The <see cref="P:log4net.Appender.AnsiColorTerminalAppender.Target" /> to use when writing to the Console 
            standard output stream.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.AnsiColorTerminalAppender.ConsoleError">
      <summary>
            The <see cref="P:log4net.Appender.AnsiColorTerminalAppender.Target" /> to use when writing to the Console 
            standard error output stream.
            </summary>
      <remarks>
        <para>
            The <see cref="P:log4net.Appender.AnsiColorTerminalAppender.Target" /> to use when writing to the Console 
            standard error output stream.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.AnsiColorTerminalAppender.PostEventCodes">
      <summary>
            Ansi code to reset terminal
            </summary>
    </member>
    <member name="F:log4net.Appender.AnsiColorTerminalAppender.m_writeToErrorStream">
      <summary>
            Flag to write output to the error stream rather than the standard output stream
            </summary>
    </member>
    <member name="F:log4net.Appender.AnsiColorTerminalAppender.m_levelMapping">
      <summary>
            Mapping from level object to color value
            </summary>
    </member>
    <member name="M:log4net.Appender.AnsiColorTerminalAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.AnsiColorTerminalAppender" /> class.
            </summary>
      <remarks>
            The instance of the <see cref="T:log4net.Appender.AnsiColorTerminalAppender" /> class is set up to write 
            to the standard output stream.
            </remarks>
    </member>
    <member name="M:log4net.Appender.AnsiColorTerminalAppender.AddMapping(log4net.Appender.AnsiColorTerminalAppender.LevelColors)">
      <summary>
            Add a mapping of level to color
            </summary>
      <param name="mapping">The mapping to add</param>
      <remarks>
        <para>
            Add a <see cref="T:log4net.Appender.AnsiColorTerminalAppender.LevelColors" /> mapping to this appender.
            Each mapping defines the foreground and background colours
            for a level.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AnsiColorTerminalAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)" /> method.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Writes the event to the console.
            </para>
        <para>
            The format of the output will depend on the appender's layout.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AnsiColorTerminalAppender.ActivateOptions">
      <summary>
            Initialize the options for this appender
            </summary>
      <remarks>
        <para>
            Initialize the level to color mappings set on this appender.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AnsiColorTerminalAppender.Target">
      <summary>
            Target is the value of the console output stream.
            </summary>
      <value>
            Target is the value of the console output stream.
            This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
            </value>
      <remarks>
        <para>
            Target is the value of the console output stream.
            This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AnsiColorTerminalAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.LevelMappingEntry">
      <summary>
            An entry in the <see cref="T:log4net.Util.LevelMapping" /></summary>
      <remarks>
        <para>
            This is an abstract base class for types that are stored in the
            <see cref="T:log4net.Util.LevelMapping" /> object.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.LevelMappingEntry.#ctor">
      <summary>
            Default protected constructor
            </summary>
      <remarks>
        <para>
            Default protected constructor
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LevelMappingEntry.ActivateOptions">
      <summary>
            Initialize any options defined on this entry
            </summary>
      <remarks>
        <para>
            Should be overridden by any classes that need to initialise based on their options
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.LevelMappingEntry.Level">
      <summary>
            The level that is the key for this mapping 
            </summary>
      <value>
            The <see cref="P:log4net.Util.LevelMappingEntry.Level" /> that is the key for this mapping 
            </value>
      <remarks>
        <para>
            Get or set the <see cref="P:log4net.Util.LevelMappingEntry.Level" /> that is the key for this
            mapping subclass.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.AppenderCollection">
      <summary>
            A strongly-typed collection of <see cref="T:log4net.Appender.IAppender" /> objects.
            </summary>
      <author>Nicko Cadell</author>
    </member>
    <member name="T:log4net.Appender.AppenderCollection.IAppenderCollectionEnumerator">
      <summary>
            Supports type-safe iteration over a <see cref="T:log4net.Appender.AppenderCollection" />.
            </summary>
      <exclude />
    </member>
    <member name="M:log4net.Appender.AppenderCollection.IAppenderCollectionEnumerator.MoveNext">
      <summary>
            Advances the enumerator to the next element in the collection.
            </summary>
      <returns>
        <c>true</c> if the enumerator was successfully advanced to the next element; 
            <c>false</c> if the enumerator has passed the end of the collection.
            </returns>
      <exception cref="T:System.InvalidOperationException">
            The collection was modified after the enumerator was created.
            </exception>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.IAppenderCollectionEnumerator.Reset">
      <summary>
            Sets the enumerator to its initial position, before the first element in the collection.
            </summary>
    </member>
    <member name="P:log4net.Appender.AppenderCollection.IAppenderCollectionEnumerator.Current">
      <summary>
            Gets the current element in the collection.
            </summary>
    </member>
    <member name="T:log4net.Appender.AppenderCollection.Tag">
      <summary>
            Type visible only to our subclasses
            Used to access protected constructor
            </summary>
      <exclude />
    </member>
    <member name="T:log4net.Appender.AppenderCollection.Enumerator">
      <summary>
            Supports simple iteration over a <see cref="T:log4net.Appender.AppenderCollection" />.
            </summary>
      <exclude />
    </member>
    <member name="M:log4net.Appender.AppenderCollection.Enumerator.#ctor(log4net.Appender.AppenderCollection)">
      <summary>
            Initializes a new instance of the <c>Enumerator</c> class.
            </summary>
      <param name="tc">
      </param>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.Enumerator.MoveNext">
      <summary>
            Advances the enumerator to the next element in the collection.
            </summary>
      <returns>
        <c>true</c> if the enumerator was successfully advanced to the next element; 
            <c>false</c> if the enumerator has passed the end of the collection.
            </returns>
      <exception cref="T:System.InvalidOperationException">
            The collection was modified after the enumerator was created.
            </exception>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.Enumerator.Reset">
      <summary>
            Sets the enumerator to its initial position, before the first element in the collection.
            </summary>
    </member>
    <member name="P:log4net.Appender.AppenderCollection.Enumerator.Current">
      <summary>
            Gets the current element in the collection.
            </summary>
    </member>
    <member name="T:log4net.Appender.AppenderCollection.ReadOnlyAppenderCollection">
      <exclude />
    </member>
    <member name="F:log4net.Appender.AppenderCollection.EmptyCollection">
      <summary>
            An empty readonly static AppenderCollection
            </summary>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.ReadOnly(log4net.Appender.AppenderCollection)">
      <summary>
            Creates a read-only wrapper for a <c>AppenderCollection</c> instance.
            </summary>
      <param name="list">list to create a readonly wrapper arround</param>
      <returns>
            An <c>AppenderCollection</c> wrapper that is read-only.
            </returns>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.#ctor">
      <summary>
            Initializes a new instance of the <c>AppenderCollection</c> class
            that is empty and has the default initial capacity.
            </summary>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <c>AppenderCollection</c> class
            that has the specified initial capacity.
            </summary>
      <param name="capacity">
            The number of elements that the new <c>AppenderCollection</c> is initially capable of storing.
            </param>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.#ctor(log4net.Appender.AppenderCollection)">
      <summary>
            Initializes a new instance of the <c>AppenderCollection</c> class
            that contains elements copied from the specified <c>AppenderCollection</c>.
            </summary>
      <param name="c">The <c>AppenderCollection</c> whose elements are copied to the new collection.</param>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.#ctor(log4net.Appender.IAppender[])">
      <summary>
            Initializes a new instance of the <c>AppenderCollection</c> class
            that contains elements copied from the specified <see cref="T:log4net.Appender.IAppender" /> array.
            </summary>
      <param name="a">The <see cref="T:log4net.Appender.IAppender" /> array whose elements are copied to the new list.</param>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.#ctor(System.Collections.ICollection)">
      <summary>
            Initializes a new instance of the <c>AppenderCollection</c> class
            that contains elements copied from the specified <see cref="T:log4net.Appender.IAppender" /> collection.
            </summary>
      <param name="col">The <see cref="T:log4net.Appender.IAppender" /> collection whose elements are copied to the new list.</param>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.#ctor(log4net.Appender.AppenderCollection.Tag)">
      <summary>
            Allow subclasses to avoid our default constructors
            </summary>
      <param name="tag">
      </param>
      <exclude />
    </member>
    <member name="M:log4net.Appender.AppenderCollection.CopyTo(log4net.Appender.IAppender[])">
      <summary>
            Copies the entire <c>AppenderCollection</c> to a one-dimensional
            <see cref="T:log4net.Appender.IAppender" /> array.
            </summary>
      <param name="array">The one-dimensional <see cref="T:log4net.Appender.IAppender" /> array to copy to.</param>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.CopyTo(log4net.Appender.IAppender[],System.Int32)">
      <summary>
            Copies the entire <c>AppenderCollection</c> to a one-dimensional
            <see cref="T:log4net.Appender.IAppender" /> array, starting at the specified index of the target array.
            </summary>
      <param name="array">The one-dimensional <see cref="T:log4net.Appender.IAppender" /> array to copy to.</param>
      <param name="start">The zero-based index in <paramref name="array" /> at which copying begins.</param>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.Add(log4net.Appender.IAppender)">
      <summary>
            Adds a <see cref="T:log4net.Appender.IAppender" /> to the end of the <c>AppenderCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Appender.IAppender" /> to be added to the end of the <c>AppenderCollection</c>.</param>
      <returns>The index at which the value has been added.</returns>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.Clear">
      <summary>
            Removes all elements from the <c>AppenderCollection</c>.
            </summary>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.Clone">
      <summary>
            Creates a shallow copy of the <see cref="T:log4net.Appender.AppenderCollection" />.
            </summary>
      <returns>A new <see cref="T:log4net.Appender.AppenderCollection" /> with a shallow copy of the collection data.</returns>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.Contains(log4net.Appender.IAppender)">
      <summary>
            Determines whether a given <see cref="T:log4net.Appender.IAppender" /> is in the <c>AppenderCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Appender.IAppender" /> to check for.</param>
      <returns>
        <c>true</c> if <paramref name="item" /> is found in the <c>AppenderCollection</c>; otherwise, <c>false</c>.</returns>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.IndexOf(log4net.Appender.IAppender)">
      <summary>
            Returns the zero-based index of the first occurrence of a <see cref="T:log4net.Appender.IAppender" />
            in the <c>AppenderCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Appender.IAppender" /> to locate in the <c>AppenderCollection</c>.</param>
      <returns>
            The zero-based index of the first occurrence of <paramref name="item" /> 
            in the entire <c>AppenderCollection</c>, if found; otherwise, -1.
            </returns>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.Insert(System.Int32,log4net.Appender.IAppender)">
      <summary>
            Inserts an element into the <c>AppenderCollection</c> at the specified index.
            </summary>
      <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
      <param name="item">The <see cref="T:log4net.Appender.IAppender" /> to insert.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Appender.AppenderCollection.Count" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.Remove(log4net.Appender.IAppender)">
      <summary>
            Removes the first occurrence of a specific <see cref="T:log4net.Appender.IAppender" /> from the <c>AppenderCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Appender.IAppender" /> to remove from the <c>AppenderCollection</c>.</param>
      <exception cref="T:System.ArgumentException">
            The specified <see cref="T:log4net.Appender.IAppender" /> was not found in the <c>AppenderCollection</c>.
            </exception>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.RemoveAt(System.Int32)">
      <summary>
            Removes the element at the specified index of the <c>AppenderCollection</c>.
            </summary>
      <param name="index">The zero-based index of the element to remove.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Appender.AppenderCollection.Count" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.GetEnumerator">
      <summary>
            Returns an enumerator that can iterate through the <c>AppenderCollection</c>.
            </summary>
      <returns>An <see cref="T:log4net.Appender.AppenderCollection.Enumerator" /> for the entire <c>AppenderCollection</c>.</returns>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.AddRange(log4net.Appender.AppenderCollection)">
      <summary>
            Adds the elements of another <c>AppenderCollection</c> to the current <c>AppenderCollection</c>.
            </summary>
      <param name="x">The <c>AppenderCollection</c> whose elements should be added to the end of the current <c>AppenderCollection</c>.</param>
      <returns>The new <see cref="P:log4net.Appender.AppenderCollection.Count" /> of the <c>AppenderCollection</c>.</returns>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.AddRange(log4net.Appender.IAppender[])">
      <summary>
            Adds the elements of a <see cref="T:log4net.Appender.IAppender" /> array to the current <c>AppenderCollection</c>.
            </summary>
      <param name="x">The <see cref="T:log4net.Appender.IAppender" /> array whose elements should be added to the end of the <c>AppenderCollection</c>.</param>
      <returns>The new <see cref="P:log4net.Appender.AppenderCollection.Count" /> of the <c>AppenderCollection</c>.</returns>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.AddRange(System.Collections.ICollection)">
      <summary>
            Adds the elements of a <see cref="T:log4net.Appender.IAppender" /> collection to the current <c>AppenderCollection</c>.
            </summary>
      <param name="col">The <see cref="T:log4net.Appender.IAppender" /> collection whose elements should be added to the end of the <c>AppenderCollection</c>.</param>
      <returns>The new <see cref="P:log4net.Appender.AppenderCollection.Count" /> of the <c>AppenderCollection</c>.</returns>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.TrimToSize">
      <summary>
            Sets the capacity to the actual number of elements.
            </summary>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.ToArray">
      <summary>
            Return the collection elements as an array
            </summary>
      <returns>the array</returns>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.ValidateIndex(System.Int32)">
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="i" /> is less than zero</para>
        <para>-or-</para>
        <para>
          <paramref name="i" /> is equal to or greater than <see cref="P:log4net.Appender.AppenderCollection.Count" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.ValidateIndex(System.Int32,System.Boolean)">
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="i" /> is less than zero</para>
        <para>-or-</para>
        <para>
          <paramref name="i" /> is equal to or greater than <see cref="P:log4net.Appender.AppenderCollection.Count" />.</para>
      </exception>
    </member>
    <member name="P:log4net.Appender.AppenderCollection.Count">
      <summary>
            Gets the number of elements actually contained in the <c>AppenderCollection</c>.
            </summary>
    </member>
    <member name="P:log4net.Appender.AppenderCollection.IsSynchronized">
      <summary>
            Gets a value indicating whether access to the collection is synchronized (thread-safe).
            </summary>
      <returns>true if access to the ICollection is synchronized (thread-safe); otherwise, false.</returns>
    </member>
    <member name="P:log4net.Appender.AppenderCollection.SyncRoot">
      <summary>
            Gets an object that can be used to synchronize access to the collection.
            </summary>
    </member>
    <member name="P:log4net.Appender.AppenderCollection.Item(System.Int32)">
      <summary>
            Gets or sets the <see cref="T:log4net.Appender.IAppender" /> at the specified index.
            </summary>
      <param name="index">The zero-based index of the element to get or set.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Appender.AppenderCollection.Count" />.</para>
      </exception>
    </member>
    <member name="P:log4net.Appender.AppenderCollection.IsFixedSize">
      <summary>
            Gets a value indicating whether the collection has a fixed size.
            </summary>
      <value>true if the collection has a fixed size; otherwise, false. The default is false</value>
    </member>
    <member name="P:log4net.Appender.AppenderCollection.IsReadOnly">
      <summary>
            Gets a value indicating whether the IList is read-only.
            </summary>
      <value>true if the collection is read-only; otherwise, false. The default is false</value>
    </member>
    <member name="P:log4net.Appender.AppenderCollection.Capacity">
      <summary>
            Gets or sets the number of elements the <c>AppenderCollection</c> can contain.
            </summary>
    </member>
    <member name="T:log4net.Appender.AspNetTraceAppender">
      <summary>
        <para>
            Appends log events to the ASP.NET <see cref="T:System.Web.TraceContext" /> system.
            </para>
      </summary>
      <remarks>
        <para>
            Diagnostic information and tracing messages that you specify are appended to the output 
            of the page that is sent to the requesting browser. Optionally, you can view this information
            from a separate trace viewer (Trace.axd) that displays trace information for every page in a 
            given application.
            </para>
        <para>
            Trace statements are processed and displayed only when tracing is enabled. You can control 
            whether tracing is displayed to a page, to the trace viewer, or both.
            </para>
        <para>
            The logging event is passed to the <see cref="M:TraceContext.Write(string)" /> or 
            <see cref="M:TraceContext.Warn(string)" /> method depending on the level of the logging event.
            The event's logger name is the default value for the category parameter of the Write/Warn method. 
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Ron Grabowski</author>
    </member>
    <member name="F:log4net.Appender.AspNetTraceAppender.m_category">
      <summary>
            Defaults to %logger
            </summary>
    </member>
    <member name="M:log4net.Appender.AspNetTraceAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.AspNetTraceAppender" /> class.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AspNetTraceAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            Write the logging event to the ASP.NET trace
            </summary>
      <param name="loggingEvent">the event to log</param>
      <remarks>
        <para>
            Write the logging event to the ASP.NET trace
            <c>HttpContext.Current.Trace</c> 
            (<see cref="T:System.Web.TraceContext" />).
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AspNetTraceAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AspNetTraceAppender.Category">
      <summary>
            The category parameter sent to the Trace method.
            </summary>
      <remarks>
        <para>
            Defaults to %logger which will use the logger name of the current 
            <see cref="T:log4net.Core.LoggingEvent" /> as the category parameter.
            </para>
        <para>
        </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.IAppenderAttachable">
      <summary>
            Interface for attaching appenders to objects.
            </summary>
      <remarks>
        <para>
            Interface for attaching, removing and retrieving appenders.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Core.IAppenderAttachable.AddAppender(log4net.Appender.IAppender)">
      <summary>
            Attaches an appender.
            </summary>
      <param name="appender">The appender to add.</param>
      <remarks>
        <para>
            Add the specified appender. The implementation may
            choose to allow or deny duplicate appenders.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.IAppenderAttachable.GetAppender(System.String)">
      <summary>
            Gets an attached appender with the specified name.
            </summary>
      <param name="name">The name of the appender to get.</param>
      <returns>
            The appender with the name specified, or <c>null</c> if no appender with the
            specified name is found.
            </returns>
      <remarks>
        <para>
            Returns an attached appender with the <paramref name="name" /> specified.
            If no appender with the specified name is found <c>null</c> will be
            returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.IAppenderAttachable.RemoveAllAppenders">
      <summary>
            Removes all attached appenders.
            </summary>
      <remarks>
        <para>
            Removes and closes all attached appenders
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.IAppenderAttachable.RemoveAppender(log4net.Appender.IAppender)">
      <summary>
            Removes the specified appender from the list of attached appenders.
            </summary>
      <param name="appender">The appender to remove.</param>
      <returns>The appender removed from the list</returns>
      <remarks>
        <para>
            The appender removed is not closed.
            If you are discarding the appender you must call
            <see cref="M:log4net.Appender.IAppender.Close" /> on the appender removed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.IAppenderAttachable.RemoveAppender(System.String)">
      <summary>
            Removes the appender with the specified name from the list of appenders.
            </summary>
      <param name="name">The name of the appender to remove.</param>
      <returns>The appender removed from the list</returns>
      <remarks>
        <para>
            The appender removed is not closed.
            If you are discarding the appender you must call
            <see cref="M:log4net.Appender.IAppender.Close" /> on the appender removed.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.IAppenderAttachable.Appenders">
      <summary>
            Gets all attached appenders.
            </summary>
      <value>
            A collection of attached appenders.
            </value>
      <remarks>
        <para>
            Gets a collection of attached appenders.
            If there are no attached appenders the
            implementation should return an empty 
            collection rather than <c>null</c>.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.BufferingForwardingAppender">
      <summary>
            Buffers events and then forwards them to attached appenders.
            </summary>
      <remarks>
        <para>
            The events are buffered in this appender until conditions are
            met to allow the appender to deliver the events to the attached 
            appenders. See <see cref="T:log4net.Appender.BufferingAppenderSkeleton" /> for the
            conditions that cause the buffer to be sent.
            </para>
        <para>The forwarding appender can be used to specify different 
            thresholds and filters for the same appender at different locations 
            within the hierarchy.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Appender.BufferingForwardingAppender.m_appenderAttachedImpl">
      <summary>
            Implementation of the <see cref="T:log4net.Core.IAppenderAttachable" /> interface
            </summary>
    </member>
    <member name="M:log4net.Appender.BufferingForwardingAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.BufferingForwardingAppender" /> class.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingForwardingAppender.OnClose">
      <summary>
            Closes the appender and releases resources.
            </summary>
      <remarks>
        <para>
            Releases any resources allocated within the appender such as file handles, 
            network connections, etc.
            </para>
        <para>
            It is a programming error to append to a closed appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingForwardingAppender.SendBuffer(log4net.Core.LoggingEvent[])">
      <summary>
            Send the events.
            </summary>
      <param name="events">The events that need to be send.</param>
      <remarks>
        <para>
            Forwards the events to the attached appenders.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingForwardingAppender.AddAppender(log4net.Appender.IAppender)">
      <summary>
            Adds an <see cref="T:log4net.Appender.IAppender" /> to the list of appenders of this
            instance.
            </summary>
      <param name="newAppender">The <see cref="T:log4net.Appender.IAppender" /> to add to this appender.</param>
      <remarks>
        <para>
            If the specified <see cref="T:log4net.Appender.IAppender" /> is already in the list of
            appenders, then it won't be added again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingForwardingAppender.GetAppender(System.String)">
      <summary>
            Looks for the appender with the specified name.
            </summary>
      <param name="name">The name of the appender to lookup.</param>
      <returns>
            The appender with the specified name, or <c>null</c>.
            </returns>
      <remarks>
        <para>
            Get the named appender attached to this buffering appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingForwardingAppender.RemoveAllAppenders">
      <summary>
            Removes all previously added appenders from this appender.
            </summary>
      <remarks>
        <para>
            This is useful when re-reading configuration information.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingForwardingAppender.RemoveAppender(log4net.Appender.IAppender)">
      <summary>
            Removes the specified appender from the list of appenders.
            </summary>
      <param name="appender">The appender to remove.</param>
      <returns>The appender removed from the list</returns>
      <remarks>
            The appender removed is not closed.
            If you are discarding the appender you must call
            <see cref="M:log4net.Appender.IAppender.Close" /> on the appender removed.
            </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingForwardingAppender.RemoveAppender(System.String)">
      <summary>
            Removes the appender with the specified name from the list of appenders.
            </summary>
      <param name="name">The name of the appender to remove.</param>
      <returns>The appender removed from the list</returns>
      <remarks>
            The appender removed is not closed.
            If you are discarding the appender you must call
            <see cref="M:log4net.Appender.IAppender.Close" /> on the appender removed.
            </remarks>
    </member>
    <member name="P:log4net.Appender.BufferingForwardingAppender.Appenders">
      <summary>
            Gets the appenders contained in this appender as an 
            <see cref="T:System.Collections.ICollection" />.
            </summary>
      <remarks>
            If no appenders can be found, then an <see cref="T:log4net.Util.EmptyCollection" /> 
            is returned.
            </remarks>
      <returns>
            A collection of the appenders in this appender.
            </returns>
    </member>
    <member name="T:log4net.Appender.ColoredConsoleAppender">
      <summary>
            Appends logging events to the console.
            </summary>
      <remarks>
        <para>
            ColoredConsoleAppender appends log events to the standard output stream
            or the error output stream using a layout specified by the 
            user. It also allows the color of a specific type of message to be set.
            </para>
        <para>
            By default, all output is written to the console's standard output stream.
            The <see cref="P:log4net.Appender.ColoredConsoleAppender.Target" /> property can be set to direct the output to the
            error stream.
            </para>
        <para>
            NOTE: This appender writes directly to the application's attached console
            not to the <c>System.Console.Out</c> or <c>System.Console.Error</c><c>TextWriter</c>.
            The <c>System.Console.Out</c> and <c>System.Console.Error</c> streams can be
            programmatically redirected (for example NUnit does this to capture program output).
            This appender will ignore these redirections because it needs to use Win32
            API calls to colorize the output. To respect these redirections the <see cref="T:log4net.Appender.ConsoleAppender" />
            must be used.
            </para>
        <para>
            When configuring the colored console appender, mapping should be
            specified to map a logging level to a color. For example:
            </para>
        <code lang="XML" escaped="true">
          <mapping>
            <level value="ERROR" />
            <foreColor value="White" />
            <backColor value="Red, HighIntensity" />
          </mapping>
          <mapping>
            <level value="DEBUG" />
            <backColor value="Green" />
          </mapping>
        </code>
        <para>
            The Level is the standard log4net logging level and ForeColor and BackColor can be any
            combination of the following values:
            <list type="bullet"><item><term>Blue</term><description></description></item><item><term>Green</term><description></description></item><item><term>Red</term><description></description></item><item><term>White</term><description></description></item><item><term>Yellow</term><description></description></item><item><term>Purple</term><description></description></item><item><term>Cyan</term><description></description></item><item><term>HighIntensity</term><description></description></item></list></para>
      </remarks>
      <author>Rick Hobbs</author>
      <author>Nicko Cadell</author>
    </member>
    <member name="T:log4net.Appender.ColoredConsoleAppender.Colors">
      <summary>
            The enum of possible color values for use with the color mapping method
            </summary>
      <remarks>
        <para>
            The following flags can be combined together to
            form the colors.
            </para>
      </remarks>
      <seealso cref="T:log4net.Appender.ColoredConsoleAppender" />
    </member>
    <member name="T:log4net.Appender.ColoredConsoleAppender.LevelColors">
      <summary>
            A class to act as a mapping between the level that a logging call is made at and
            the color it should be displayed as.
            </summary>
      <remarks>
        <para>
            Defines the mapping between a level and the color it should be displayed in.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ColoredConsoleAppender.LevelColors.ActivateOptions">
      <summary>
            Initialize the options for the object
            </summary>
      <remarks>
        <para>
            Combine the <see cref="P:log4net.Appender.ColoredConsoleAppender.LevelColors.ForeColor" /> and <see cref="P:log4net.Appender.ColoredConsoleAppender.LevelColors.BackColor" /> together.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.ColoredConsoleAppender.LevelColors.ForeColor">
      <summary>
            The mapped foreground color for the specified level
            </summary>
      <remarks>
        <para>
            Required property.
            The mapped foreground color for the specified level.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.ColoredConsoleAppender.LevelColors.BackColor">
      <summary>
            The mapped background color for the specified level
            </summary>
      <remarks>
        <para>
            Required property.
            The mapped background color for the specified level.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.ColoredConsoleAppender.LevelColors.CombinedColor">
      <summary>
            The combined <see cref="P:log4net.Appender.ColoredConsoleAppender.LevelColors.ForeColor" /> and <see cref="P:log4net.Appender.ColoredConsoleAppender.LevelColors.BackColor" /> suitable for 
            setting the console color.
            </summary>
    </member>
    <member name="F:log4net.Appender.ColoredConsoleAppender.ConsoleOut">
      <summary>
            The <see cref="P:log4net.Appender.ColoredConsoleAppender.Target" /> to use when writing to the Console 
            standard output stream.
            </summary>
      <remarks>
        <para>
            The <see cref="P:log4net.Appender.ColoredConsoleAppender.Target" /> to use when writing to the Console 
            standard output stream.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.ColoredConsoleAppender.ConsoleError">
      <summary>
            The <see cref="P:log4net.Appender.ColoredConsoleAppender.Target" /> to use when writing to the Console 
            standard error output stream.
            </summary>
      <remarks>
        <para>
            The <see cref="P:log4net.Appender.ColoredConsoleAppender.Target" /> to use when writing to the Console 
            standard error output stream.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.ColoredConsoleAppender.m_writeToErrorStream">
      <summary>
            Flag to write output to the error stream rather than the standard output stream
            </summary>
    </member>
    <member name="F:log4net.Appender.ColoredConsoleAppender.m_levelMapping">
      <summary>
            Mapping from level object to color value
            </summary>
    </member>
    <member name="F:log4net.Appender.ColoredConsoleAppender.m_consoleOutputWriter">
      <summary>
            The console output stream writer to write to
            </summary>
      <remarks>
        <para>
            This writer is not thread safe.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ColoredConsoleAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.ColoredConsoleAppender" /> class.
            </summary>
      <remarks>
            The instance of the <see cref="T:log4net.Appender.ColoredConsoleAppender" /> class is set up to write 
            to the standard output stream.
            </remarks>
    </member>
    <member name="M:log4net.Appender.ColoredConsoleAppender.#ctor(log4net.Layout.ILayout)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.ColoredConsoleAppender" /> class
            with the specified layout.
            </summary>
      <param name="layout">the layout to use for this appender</param>
      <remarks>
            The instance of the <see cref="T:log4net.Appender.ColoredConsoleAppender" /> class is set up to write 
            to the standard output stream.
            </remarks>
    </member>
    <member name="M:log4net.Appender.ColoredConsoleAppender.#ctor(log4net.Layout.ILayout,System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.ColoredConsoleAppender" /> class
            with the specified layout.
            </summary>
      <param name="layout">the layout to use for this appender</param>
      <param name="writeToErrorStream">flag set to <c>true</c> to write to the console error stream</param>
      <remarks>
            When <paramref name="writeToErrorStream" /> is set to <c>true</c>, output is written to
            the standard error output stream.  Otherwise, output is written to the standard
            output stream.
            </remarks>
    </member>
    <member name="M:log4net.Appender.ColoredConsoleAppender.AddMapping(log4net.Appender.ColoredConsoleAppender.LevelColors)">
      <summary>
            Add a mapping of level to color - done by the config file
            </summary>
      <param name="mapping">The mapping to add</param>
      <remarks>
        <para>
            Add a <see cref="T:log4net.Appender.ColoredConsoleAppender.LevelColors" /> mapping to this appender.
            Each mapping defines the foreground and background colors
            for a level.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ColoredConsoleAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent)" /> method.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Writes the event to the console.
            </para>
        <para>
            The format of the output will depend on the appender's layout.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ColoredConsoleAppender.ActivateOptions">
      <summary>
            Initialize the options for this appender
            </summary>
      <remarks>
        <para>
            Initialize the level to color mappings set on this appender.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.ColoredConsoleAppender.Target">
      <summary>
            Target is the value of the console output stream.
            This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
            </summary>
      <value>
            Target is the value of the console output stream.
            This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
            </value>
      <remarks>
        <para>
            Target is the value of the console output stream.
            This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.ColoredConsoleAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.ConsoleAppender">
      <summary>
            Appends logging events to the console.
            </summary>
      <remarks>
        <para>
            ConsoleAppender appends log events to the standard output stream
            or the error output stream using a layout specified by the 
            user.
            </para>
        <para>
            By default, all output is written to the console's standard output stream.
            The <see cref="P:log4net.Appender.ConsoleAppender.Target" /> property can be set to direct the output to the
            error stream.
            </para>
        <para>
            NOTE: This appender writes each message to the <c>System.Console.Out</c> or 
            <c>System.Console.Error</c> that is set at the time the event is appended.
            Therefore it is possible to programmatically redirect the output of this appender 
            (for example NUnit does this to capture program output). While this is the desired
            behavior of this appender it may have security implications in your application. 
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Appender.ConsoleAppender.ConsoleOut">
      <summary>
            The <see cref="P:log4net.Appender.ConsoleAppender.Target" /> to use when writing to the Console 
            standard output stream.
            </summary>
      <remarks>
        <para>
            The <see cref="P:log4net.Appender.ConsoleAppender.Target" /> to use when writing to the Console 
            standard output stream.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.ConsoleAppender.ConsoleError">
      <summary>
            The <see cref="P:log4net.Appender.ConsoleAppender.Target" /> to use when writing to the Console 
            standard error output stream.
            </summary>
      <remarks>
        <para>
            The <see cref="P:log4net.Appender.ConsoleAppender.Target" /> to use when writing to the Console 
            standard error output stream.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ConsoleAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.ConsoleAppender" /> class.
            </summary>
      <remarks>
            The instance of the <see cref="T:log4net.Appender.ConsoleAppender" /> class is set up to write 
            to the standard output stream.
            </remarks>
    </member>
    <member name="M:log4net.Appender.ConsoleAppender.#ctor(log4net.Layout.ILayout)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.ConsoleAppender" /> class
            with the specified layout.
            </summary>
      <param name="layout">the layout to use for this appender</param>
      <remarks>
            The instance of the <see cref="T:log4net.Appender.ConsoleAppender" /> class is set up to write 
            to the standard output stream.
            </remarks>
    </member>
    <member name="M:log4net.Appender.ConsoleAppender.#ctor(log4net.Layout.ILayout,System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.ConsoleAppender" /> class
            with the specified layout.
            </summary>
      <param name="layout">the layout to use for this appender</param>
      <param name="writeToErrorStream">flag set to <c>true</c> to write to the console error stream</param>
      <remarks>
            When <paramref name="writeToErrorStream" /> is set to <c>true</c>, output is written to
            the standard error output stream.  Otherwise, output is written to the standard
            output stream.
            </remarks>
    </member>
    <member name="M:log4net.Appender.ConsoleAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)" /> method.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Writes the event to the console.
            </para>
        <para>
            The format of the output will depend on the appender's layout.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.ConsoleAppender.Target">
      <summary>
            Target is the value of the console output stream.
            This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
            </summary>
      <value>
            Target is the value of the console output stream.
            This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
            </value>
      <remarks>
        <para>
            Target is the value of the console output stream.
            This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.ConsoleAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.DebugAppender">
      <summary>
            Appends log events to the <see cref="T:System.Diagnostics.Debug" /> system.
            </summary>
      <remarks>
        <para>
            The application configuration file can be used to control what listeners 
            are actually used. See the MSDN documentation for the 
            <see cref="T:System.Diagnostics.Debug" /> class for details on configuring the
            debug system.
            </para>
        <para>
            Events are written using the <see cref="M:System.Diagnostics.Debug.Write(string,string)" />
            method. The event's logger name is passed as the value for the category name to the Write method.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Appender.DebugAppender.m_immediateFlush">
      <summary>
            Immediate flush means that the underlying writer or output stream
            will be flushed at the end of each append operation.
            </summary>
      <remarks>
        <para>
            Immediate flush is slower but ensures that each append request is 
            actually written. If <see cref="P:log4net.Appender.DebugAppender.ImmediateFlush" /> is set to
            <c>false</c>, then there is a good chance that the last few
            logs events are not actually written to persistent media if and
            when the application crashes.
            </para>
        <para>
            The default value is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.DebugAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.DebugAppender" />.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.DebugAppender.#ctor(log4net.Layout.ILayout)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.DebugAppender" /> 
            with a specified layout.
            </summary>
      <param name="layout">The layout to use with this appender.</param>
      <remarks>
        <para>
            Obsolete constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.DebugAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            Writes the logging event to the <see cref="T:System.Diagnostics.Debug" /> system.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Writes the logging event to the <see cref="T:System.Diagnostics.Debug" /> system.
            If <see cref="P:log4net.Appender.DebugAppender.ImmediateFlush" /> is <c>true</c> then the <see cref="M:System.Diagnostics.Debug.Flush" />
            is called.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.DebugAppender.ImmediateFlush">
      <summary>
            Gets or sets a value that indicates whether the appender will 
            flush at the end of each write.
            </summary>
      <remarks>
        <para>The default behavior is to flush at the end of each 
            write. If the option is set to<c>false</c>, then the underlying 
            stream can defer writing to physical medium to a later time. 
            </para>
        <para>
            Avoiding the flush operation at the end of each append results 
            in a performance gain of 10 to 20 percent. However, there is safety
            trade-off involved in skipping flushing. Indeed, when flushing is
            skipped, then it is likely that the last few log events will not
            be recorded on disk when the application exits. This is a high
            price to pay even for a 20% performance gain.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.DebugAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.EventLogAppender">
      <summary>
            Writes events to the system event log.
            </summary>
      <remarks>
        <para>
            The appender will fail if you try to write using an event source that doesn't exist unless it is running with local administrator privileges.
            See also http://logging.apache.org/log4net/release/faq.html#trouble-EventLog
            </para>
        <para>
            The <c>EventID</c> of the event log entry can be
            set using the <c>EventID</c> property (<see cref="P:log4net.Core.LoggingEvent.Properties" />)
            on the <see cref="T:log4net.Core.LoggingEvent" />.
            </para>
        <para>
            The <c>Category</c> of the event log entry can be
            set using the <c>Category</c> property (<see cref="P:log4net.Core.LoggingEvent.Properties" />)
            on the <see cref="T:log4net.Core.LoggingEvent" />.
            </para>
        <para>
            There is a limit of 32K characters for an event log message
            </para>
        <para>
            When configuring the EventLogAppender a mapping can be
            specified to map a logging level to an event log entry type. For example:
            </para>
        <code lang="XML">
            &lt;mapping&gt;
            	&lt;level value="ERROR" /&gt;
            	&lt;eventLogEntryType value="Error" /&gt;
            &lt;/mapping&gt;
            &lt;mapping&gt;
            	&lt;level value="DEBUG" /&gt;
            	&lt;eventLogEntryType value="Information" /&gt;
            &lt;/mapping&gt;
            </code>
        <para>
            The Level is the standard log4net logging level and eventLogEntryType can be any value
            from the <see cref="T:System.Diagnostics.EventLogEntryType" /> enum, i.e.:
            <list type="bullet"><item><term>Error</term><description>an error event</description></item><item><term>Warning</term><description>a warning event</description></item><item><term>Information</term><description>an informational event</description></item></list></para>
      </remarks>
      <author>Aspi Havewala</author>
      <author>Douglas de la Torre</author>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Thomas Voss</author>
    </member>
    <member name="T:log4net.Appender.EventLogAppender.Level2EventLogEntryType">
      <summary>
            A class to act as a mapping between the level that a logging call is made at and
            the color it should be displayed as.
            </summary>
      <remarks>
        <para>
            Defines the mapping between a level and its event log entry type.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.EventLogAppender.Level2EventLogEntryType.EventLogEntryType">
      <summary>
            The <see cref="P:log4net.Appender.EventLogAppender.Level2EventLogEntryType.EventLogEntryType" /> for this entry
            </summary>
      <remarks>
        <para>
            Required property.
            The <see cref="P:log4net.Appender.EventLogAppender.Level2EventLogEntryType.EventLogEntryType" /> for this entry
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.EventLogAppender.m_logName">
      <summary>
            The log name is the section in the event logs where the messages
            are stored.
            </summary>
    </member>
    <member name="F:log4net.Appender.EventLogAppender.m_applicationName">
      <summary>
            Name of the application to use when logging.  This appears in the
            application column of the event log named by <see cref="F:log4net.Appender.EventLogAppender.m_logName" />.
            </summary>
    </member>
    <member name="F:log4net.Appender.EventLogAppender.m_machineName">
      <summary>
            The name of the machine which holds the event log. This is
            currently only allowed to be '.' i.e. the current machine.
            </summary>
    </member>
    <member name="F:log4net.Appender.EventLogAppender.m_levelMapping">
      <summary>
            Mapping from level object to EventLogEntryType
            </summary>
    </member>
    <member name="F:log4net.Appender.EventLogAppender.m_securityContext">
      <summary>
            The security context to use for privileged calls
            </summary>
    </member>
    <member name="F:log4net.Appender.EventLogAppender.m_eventId">
      <summary>
            The event ID to use unless one is explicitly specified via the <c>LoggingEvent</c>'s properties.
            </summary>
    </member>
    <member name="F:log4net.Appender.EventLogAppender.m_category">
      <summary>
            The event category to use unless one is explicitly specified via the <c>LoggingEvent</c>'s properties.
            </summary>
    </member>
    <member name="F:log4net.Appender.EventLogAppender.declaringType">
      <summary>
            The fully qualified type of the EventLogAppender class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="F:log4net.Appender.EventLogAppender.MAX_EVENTLOG_MESSAGE_SIZE_DEFAULT">
      <summary>
            The maximum size supported by default.
            </summary>
      <remarks>
            http://msdn.microsoft.com/en-us/library/xzwc042w(v=vs.100).aspx
            The 32766 documented max size is two bytes shy of 32K (I'm assuming 32766 
            may leave space for a two byte null terminator of #0#0). The 32766 max 
            length is what the .NET 4.0 source code checks for, but this is WRONG! 
            Strings with a length &gt; 31839 on Windows Vista or higher can CORRUPT 
            the event log! See: System.Diagnostics.EventLogInternal.InternalWriteEvent() 
            for the use of the 32766 max size.
            </remarks>
    </member>
    <member name="F:log4net.Appender.EventLogAppender.MAX_EVENTLOG_MESSAGE_SIZE_VISTA_OR_NEWER">
      <summary>
            The maximum size supported by a windows operating system that is vista
            or newer.
            </summary>
      <remarks>
            See ReportEvent API:
            	http://msdn.microsoft.com/en-us/library/aa363679(VS.85).aspx
            ReportEvent's lpStrings parameter:
            "A pointer to a buffer containing an array of 
            null-terminated strings that are merged into the message before Event Viewer 
            displays the string to the user. This parameter must be a valid pointer 
            (or NULL), even if wNumStrings is zero. Each string is limited to 31,839 characters."
            
            Going beyond the size of 31839 will (at some point) corrupt the event log on Windows
            Vista or higher! It may succeed for a while...but you will eventually run into the
            error: "System.ComponentModel.Win32Exception : A device attached to the system is
            not functioning", and the event log will then be corrupt (I was able to corrupt 
            an event log using a length of 31877 on Windows 7).
            
            The max size for Windows Vista or higher is documented here:
            	http://msdn.microsoft.com/en-us/library/xzwc042w(v=vs.100).aspx.
            Going over this size may succeed a few times but the buffer will overrun and 
            eventually corrupt the log (based on testing).
            
            The maxEventMsgSize size is based on the max buffer size of the lpStrings parameter of the ReportEvent API.
            The documented max size for EventLog.WriteEntry for Windows Vista and higher is 31839, but I'm leaving room for a
            terminator of #0#0, as we cannot see the source of ReportEvent (though we could use an API monitor to examine the
            buffer, given enough time).
            </remarks>
    </member>
    <member name="F:log4net.Appender.EventLogAppender.MAX_EVENTLOG_MESSAGE_SIZE">
      <summary>
            The maximum size that the operating system supports for
            a event log message.
            </summary>
      <remarks>
            Used to determine the maximum string length that can be written
            to the operating system event log and eventually truncate a string
            that exceeds the limits.
            </remarks>
    </member>
    <member name="M:log4net.Appender.EventLogAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.EventLogAppender" /> class.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.EventLogAppender.#ctor(log4net.Layout.ILayout)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.EventLogAppender" /> class
            with the specified <see cref="T:log4net.Layout.ILayout" />.
            </summary>
      <param name="layout">The <see cref="T:log4net.Layout.ILayout" /> to use with this appender.</param>
      <remarks>
        <para>
            Obsolete constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.EventLogAppender.AddMapping(log4net.Appender.EventLogAppender.Level2EventLogEntryType)">
      <summary>
            Add a mapping of level to <see cref="T:System.Diagnostics.EventLogEntryType" /> - done by the config file
            </summary>
      <param name="mapping">The mapping to add</param>
      <remarks>
        <para>
            Add a <see cref="T:log4net.Appender.EventLogAppender.Level2EventLogEntryType" /> mapping to this appender.
            Each mapping defines the event log entry type for a level.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.EventLogAppender.ActivateOptions">
      <summary>
            Initialize the appender based on the options set
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.EventLogAppender.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.EventLogAppender.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.EventLogAppender.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.EventLogAppender.CreateEventSource(System.String,System.String,System.String)">
      <summary>
            Create an event log source
            </summary>
      <remarks>
            Uses different API calls under NET_2_0
            </remarks>
    </member>
    <member name="M:log4net.Appender.EventLogAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)" />
            method. 
            </summary>
      <param name="loggingEvent">the event to log</param>
      <remarks>
        <para>Writes the event to the system event log using the 
            <see cref="P:log4net.Appender.EventLogAppender.ApplicationName" />.</para>
        <para>If the event has an <c>EventID</c> property (see <see cref="P:log4net.Core.LoggingEvent.Properties" />)
            set then this integer will be used as the event log event id.</para>
        <para>
            There is a limit of 32K characters for an event log message
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.EventLogAppender.GetEntryType(log4net.Core.Level)">
      <summary>
            Get the equivalent <see cref="T:System.Diagnostics.EventLogEntryType" /> for a <see cref="T:log4net.Core.Level" /><paramref name="level" /></summary>
      <param name="level">the Level to convert to an EventLogEntryType</param>
      <returns>The equivalent <see cref="T:System.Diagnostics.EventLogEntryType" /> for a <see cref="T:log4net.Core.Level" /><paramref name="level" /></returns>
      <remarks>
            Because there are fewer applicable <see cref="T:System.Diagnostics.EventLogEntryType" />
            values to use in logging levels than there are in the 
            <see cref="T:log4net.Core.Level" /> this is a one way mapping. There is
            a loss of information during the conversion.
            </remarks>
    </member>
    <member name="M:log4net.Appender.EventLogAppender.GetMaxEventLogMessageSize">
      <summary>
            This method determines the maximum event log message size allowed for
            the current environment.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:log4net.Appender.EventLogAppender.LogName">
      <summary>
            The name of the log where messages will be stored.
            </summary>
      <value>
            The string name of the log where messages will be stored.
            </value>
      <remarks>
        <para>This is the name of the log as it appears in the Event Viewer
            tree. The default value is to log into the <c>Application</c>
            log, this is where most applications write their events. However
            if you need a separate log for your application (or applications)
            then you should set the <see cref="P:log4net.Appender.EventLogAppender.LogName" /> appropriately.</para>
        <para>This should not be used to distinguish your event log messages
            from those of other applications, the <see cref="P:log4net.Appender.EventLogAppender.ApplicationName" />
            property should be used to distinguish events. This property should be 
            used to group together events into a single log.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.EventLogAppender.ApplicationName">
      <summary>
            Property used to set the Application name.  This appears in the
            event logs when logging.
            </summary>
      <value>
            The string used to distinguish events from different sources.
            </value>
      <remarks>
            Sets the event log source property.
            </remarks>
    </member>
    <member name="P:log4net.Appender.EventLogAppender.MachineName">
      <summary>
            This property is used to return the name of the computer to use
            when accessing the event logs.  Currently, this is the current
            computer, denoted by a dot "."
            </summary>
      <value>
            The string name of the machine holding the event log that 
            will be logged into.
            </value>
      <remarks>
            This property cannot be changed. It is currently set to '.'
            i.e. the local machine. This may be changed in future.
            </remarks>
    </member>
    <member name="P:log4net.Appender.EventLogAppender.SecurityContext">
      <summary>
            Gets or sets the <see cref="P:log4net.Appender.EventLogAppender.SecurityContext" /> used to write to the EventLog.
            </summary>
      <value>
            The <see cref="P:log4net.Appender.EventLogAppender.SecurityContext" /> used to write to the EventLog.
            </value>
      <remarks>
        <para>
            The system security context used to write to the EventLog.
            </para>
        <para>
            Unless a <see cref="P:log4net.Appender.EventLogAppender.SecurityContext" /> specified here for this appender
            the <see cref="P:log4net.Core.SecurityContextProvider.DefaultProvider" /> is queried for the
            security context to use. The default behavior is to use the security context
            of the current thread.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.EventLogAppender.EventId">
      <summary>
            Gets or sets the <c>EventId</c> to use unless one is explicitly specified via the <c>LoggingEvent</c>'s properties.
            </summary>
      <remarks>
        <para>
            The <c>EventID</c> of the event log entry will normally be
            set using the <c>EventID</c> property (<see cref="P:log4net.Core.LoggingEvent.Properties" />)
            on the <see cref="T:log4net.Core.LoggingEvent" />.
            This property provides the fallback value which defaults to 0.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.EventLogAppender.Category">
      <summary>
            Gets or sets the <c>Category</c> to use unless one is explicitly specified via the <c>LoggingEvent</c>'s properties.
            </summary>
      <remarks>
        <para>
            The <c>Category</c> of the event log entry will normally be
            set using the <c>Category</c> property (<see cref="P:log4net.Core.LoggingEvent.Properties" />)
            on the <see cref="T:log4net.Core.LoggingEvent" />.
            This property provides the fallback value which defaults to 0.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.EventLogAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.TextWriterAppender">
      <summary>
            Sends logging events to a <see cref="T:System.IO.TextWriter" />.
            </summary>
      <remarks>
        <para>
            An Appender that writes to a <see cref="T:System.IO.TextWriter" />.
            </para>
        <para>
            This appender may be used stand alone if initialized with an appropriate
            writer, however it is typically used as a base class for an appender that
            can open a <see cref="T:System.IO.TextWriter" /> to write to.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Douglas de la Torre</author>
    </member>
    <member name="F:log4net.Appender.TextWriterAppender.m_qtw">
      <summary>
            This is the <see cref="T:log4net.Util.QuietTextWriter" /> where logging events
            will be written to. 
            </summary>
    </member>
    <member name="F:log4net.Appender.TextWriterAppender.m_immediateFlush">
      <summary>
            Immediate flush means that the underlying <see cref="T:System.IO.TextWriter" /> 
            or output stream will be flushed at the end of each append operation.
            </summary>
      <remarks>
        <para>
            Immediate flush is slower but ensures that each append request is 
            actually written. If <see cref="P:log4net.Appender.TextWriterAppender.ImmediateFlush" /> is set to
            <c>false</c>, then there is a good chance that the last few
            logging events are not actually persisted if and when the application 
            crashes.
            </para>
        <para>
            The default value is <c>true</c>.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.TextWriterAppender.declaringType">
      <summary>
            The fully qualified type of the TextWriterAppender class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.TextWriterAppender" /> class.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.#ctor(log4net.Layout.ILayout,System.IO.Stream)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.TextWriterAppender" /> class and
            sets the output destination to a new <see cref="T:System.IO.StreamWriter" /> initialized 
            with the specified <see cref="T:System.IO.Stream" />.
            </summary>
      <param name="layout">The layout to use with this appender.</param>
      <param name="os">The <see cref="T:System.IO.Stream" /> to output to.</param>
      <remarks>
        <para>
            Obsolete constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.#ctor(log4net.Layout.ILayout,System.IO.TextWriter)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.TextWriterAppender" /> class and sets
            the output destination to the specified <see cref="T:System.IO.StreamWriter" />.
            </summary>
      <param name="layout">The layout to use with this appender</param>
      <param name="writer">The <see cref="T:System.IO.TextWriter" /> to output to</param>
      <remarks>
            The <see cref="T:System.IO.TextWriter" /> must have been previously opened.
            </remarks>
      <remarks>
        <para>
            Obsolete constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.PreAppendCheck">
      <summary>
            This method determines if there is a sense in attempting to append.
            </summary>
      <remarks>
        <para>
            This method checks if an output target has been set and if a
            layout has been set. 
            </para>
      </remarks>
      <returns>
        <c>false</c> if any of the preconditions fail.</returns>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)" />
            method. 
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Writes a log statement to the output stream if the output stream exists 
            and is writable.  
            </para>
        <para>
            The format of the output will depend on the appender's layout.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.Append(log4net.Core.LoggingEvent[])">
      <summary>
            This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent[])" />
            method. 
            </summary>
      <param name="loggingEvents">The array of events to log.</param>
      <remarks>
        <para>
            This method writes all the bulk logged events to the output writer
            before flushing the stream.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.OnClose">
      <summary>
            Close this appender instance. The underlying stream or writer is also closed.
            </summary>
      <remarks>
            Closed appenders cannot be reused.
            </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.WriteFooterAndCloseWriter">
      <summary>
            Writes the footer and closes the underlying <see cref="T:System.IO.TextWriter" />.
            </summary>
      <remarks>
        <para>
            Writes the footer and closes the underlying <see cref="T:System.IO.TextWriter" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.CloseWriter">
      <summary>
            Closes the underlying <see cref="T:System.IO.TextWriter" />.
            </summary>
      <remarks>
        <para>
            Closes the underlying <see cref="T:System.IO.TextWriter" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.Reset">
      <summary>
            Clears internal references to the underlying <see cref="T:System.IO.TextWriter" /> 
            and other variables.
            </summary>
      <remarks>
        <para>
            Subclasses can override this method for an alternate closing behavior.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.WriteFooter">
      <summary>
            Writes a footer as produced by the embedded layout's <see cref="P:log4net.Layout.ILayout.Footer" /> property.
            </summary>
      <remarks>
        <para>
            Writes a footer as produced by the embedded layout's <see cref="P:log4net.Layout.ILayout.Footer" /> property.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.WriteHeader">
      <summary>
            Writes a header produced by the embedded layout's <see cref="P:log4net.Layout.ILayout.Header" /> property.
            </summary>
      <remarks>
        <para>
            Writes a header produced by the embedded layout's <see cref="P:log4net.Layout.ILayout.Header" /> property.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.PrepareWriter">
      <summary>
            Called to allow a subclass to lazily initialize the writer
            </summary>
      <remarks>
        <para>
            This method is called when an event is logged and the <see cref="P:log4net.Appender.TextWriterAppender.Writer" /> or
            <see cref="P:log4net.Appender.TextWriterAppender.QuietWriter" /> have not been set. This allows a subclass to
            attempt to initialize the writer multiple times.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.TextWriterAppender.ImmediateFlush">
      <summary>
            Gets or set whether the appender will flush at the end 
            of each append operation.
            </summary>
      <value>
        <para>
            The default behavior is to flush at the end of each 
            append operation.
            </para>
        <para>
            If this option is set to <c>false</c>, then the underlying 
            stream can defer persisting the logging event to a later 
            time.
            </para>
      </value>
      <remarks>
            Avoiding the flush operation at the end of each append results in
            a performance gain of 10 to 20 percent. However, there is safety
            trade-off involved in skipping flushing. Indeed, when flushing is
            skipped, then it is likely that the last few log events will not
            be recorded on disk when the application exits. This is a high
            price to pay even for a 20% performance gain.
            </remarks>
    </member>
    <member name="P:log4net.Appender.TextWriterAppender.Writer">
      <summary>
            Sets the <see cref="T:System.IO.TextWriter" /> where the log output will go.
            </summary>
      <remarks>
        <para>
            The specified <see cref="T:System.IO.TextWriter" /> must be open and writable.
            </para>
        <para>
            The <see cref="T:System.IO.TextWriter" /> will be closed when the appender 
            instance is closed.
            </para>
        <para>
          <b>Note:</b> Logging to an unopened <see cref="T:System.IO.TextWriter" /> will fail.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.TextWriterAppender.ErrorHandler">
      <summary>
            Gets or set the <see cref="T:log4net.Core.IErrorHandler" /> and the underlying 
            <see cref="T:log4net.Util.QuietTextWriter" />, if any, for this appender. 
            </summary>
      <value>
            The <see cref="T:log4net.Core.IErrorHandler" /> for this appender.
            </value>
    </member>
    <member name="P:log4net.Appender.TextWriterAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.TextWriterAppender.QuietWriter">
      <summary>
            Gets or sets the <see cref="T:log4net.Util.QuietTextWriter" /> where logging events
            will be written to. 
            </summary>
      <value>
            The <see cref="T:log4net.Util.QuietTextWriter" /> where logging events are written.
            </value>
      <remarks>
        <para>
            This is the <see cref="T:log4net.Util.QuietTextWriter" /> where logging events
            will be written to. 
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.FileAppender">
      <summary>
            Appends logging events to a file.
            </summary>
      <remarks>
        <para>
            Logging events are sent to the file specified by
            the <see cref="P:log4net.Appender.FileAppender.File" /> property.
            </para>
        <para>
            The file can be opened in either append or overwrite mode 
            by specifying the <see cref="P:log4net.Appender.FileAppender.AppendToFile" /> property.
            If the file path is relative it is taken as relative from 
            the application base directory. The file encoding can be
            specified by setting the <see cref="P:log4net.Appender.FileAppender.Encoding" /> property.
            </para>
        <para>
            The layout's <see cref="P:log4net.Layout.ILayout.Header" /> and <see cref="P:log4net.Layout.ILayout.Footer" />
            values will be written each time the file is opened and closed
            respectively. If the <see cref="P:log4net.Appender.FileAppender.AppendToFile" /> property is <see langword="true" />
            then the file may contain multiple copies of the header and footer.
            </para>
        <para>
            This appender will first try to open the file for writing when <see cref="M:log4net.Appender.FileAppender.ActivateOptions" />
            is called. This will typically be during configuration.
            If the file cannot be opened for writing the appender will attempt
            to open the file again each time a message is logged to the appender.
            If the file cannot be opened for writing when a message is logged then
            the message will be discarded by this appender.
            </para>
        <para>
            The <see cref="T:log4net.Appender.FileAppender" /> supports pluggable file locking models via
            the <see cref="P:log4net.Appender.FileAppender.LockingModel" /> property.
            The default behavior, implemented by <see cref="T:log4net.Appender.FileAppender.ExclusiveLock" /> 
            is to obtain an exclusive write lock on the file until this appender is closed.
            The alternative models only hold a
            write lock while the appender is writing a logging event (<see cref="T:log4net.Appender.FileAppender.MinimalLock" />)
            or synchronize by using a named system wide Mutex (<see cref="T:log4net.Appender.FileAppender.InterProcessLock" />).
            </para>
        <para>
            All locking strategies have issues and you should seriously consider using a different strategy that
            avoids having multiple processes logging to the same file.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Rodrigo B. de Oliveira</author>
      <author>Douglas de la Torre</author>
      <author>Niall Daley</author>
    </member>
    <member name="T:log4net.Appender.FileAppender.LockingStream">
      <summary>
            Write only <see cref="T:System.IO.Stream" /> that uses the <see cref="T:log4net.Appender.FileAppender.LockingModelBase" /> 
            to manage access to an underlying resource.
            </summary>
    </member>
    <member name="M:log4net.Appender.FileAppender.LockingStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
      <summary>
            True asynchronous writes are not supported, the implementation forces a synchronous write.
            </summary>
    </member>
    <member name="T:log4net.Appender.FileAppender.LockingModelBase">
      <summary>
            Locking model base class
            </summary>
      <remarks>
        <para>
            Base class for the locking models available to the <see cref="T:log4net.Appender.FileAppender" /> derived loggers.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.LockingModelBase.OpenFile(System.String,System.Boolean,System.Text.Encoding)">
      <summary>
            Open the output file
            </summary>
      <param name="filename">The filename to use</param>
      <param name="append">Whether to append to the file, or overwrite</param>
      <param name="encoding">The encoding to use</param>
      <remarks>
        <para>
            Open the file specified and prepare for logging. 
            No writes will be made until <see cref="M:log4net.Appender.FileAppender.LockingModelBase.AcquireLock" /> is called.
            Must be called before any calls to <see cref="M:log4net.Appender.FileAppender.LockingModelBase.AcquireLock" />,
            <see cref="M:log4net.Appender.FileAppender.LockingModelBase.ReleaseLock" /> and <see cref="M:log4net.Appender.FileAppender.LockingModelBase.CloseFile" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.LockingModelBase.CloseFile">
      <summary>
            Close the file
            </summary>
      <remarks>
        <para>
            Close the file. No further writes will be made.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.LockingModelBase.AcquireLock">
      <summary>
            Acquire the lock on the file
            </summary>
      <returns>A stream that is ready to be written to.</returns>
      <remarks>
        <para>
            Acquire the lock on the file in preparation for writing to it. 
            Return a stream pointing to the file. <see cref="M:log4net.Appender.FileAppender.LockingModelBase.ReleaseLock" />
            must be called to release the lock on the output file.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.LockingModelBase.ReleaseLock">
      <summary>
            Release the lock on the file
            </summary>
      <remarks>
        <para>
            Release the lock on the file. No further writes will be made to the 
            stream until <see cref="M:log4net.Appender.FileAppender.LockingModelBase.AcquireLock" /> is called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.LockingModelBase.CreateStream(System.String,System.Boolean,System.IO.FileShare)">
      <summary>
            Helper method that creates a FileStream under CurrentAppender's SecurityContext.
            </summary>
      <remarks>
        <para>
            Typically called during OpenFile or AcquireLock. 
            </para>
        <para>
            If the directory portion of the <paramref name="filename" /> does not exist, it is created
            via Directory.CreateDirecctory.
            </para>
      </remarks>
      <param name="filename">
      </param>
      <param name="append">
      </param>
      <param name="fileShare">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:log4net.Appender.FileAppender.LockingModelBase.CloseStream(System.IO.Stream)">
      <summary>
            Helper method to close <paramref name="stream" /> under CurrentAppender's SecurityContext.
            </summary>
      <remarks>
            Does not set <paramref name="stream" /> to null.
            </remarks>
      <param name="stream">
      </param>
    </member>
    <member name="P:log4net.Appender.FileAppender.LockingModelBase.CurrentAppender">
      <summary>
            Gets or sets the <see cref="T:log4net.Appender.FileAppender" /> for this LockingModel
            </summary>
      <value>
            The <see cref="T:log4net.Appender.FileAppender" /> for this LockingModel
            </value>
      <remarks>
        <para>
            The file appender this locking model is attached to and working on
            behalf of.
            </para>
        <para>
            The file appender is used to locate the security context and the error handler to use.
            </para>
        <para>
            The value of this property will be set before <see cref="M:log4net.Appender.FileAppender.LockingModelBase.OpenFile(System.String,System.Boolean,System.Text.Encoding)" /> is
            called.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.FileAppender.ExclusiveLock">
      <summary>
            Hold an exclusive lock on the output file
            </summary>
      <remarks>
        <para>
            Open the file once for writing and hold it open until <see cref="M:log4net.Appender.FileAppender.ExclusiveLock.CloseFile" /> is called. 
            Maintains an exclusive lock on the file during this time.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.ExclusiveLock.OpenFile(System.String,System.Boolean,System.Text.Encoding)">
      <summary>
            Open the file specified and prepare for logging.
            </summary>
      <param name="filename">The filename to use</param>
      <param name="append">Whether to append to the file, or overwrite</param>
      <param name="encoding">The encoding to use</param>
      <remarks>
        <para>
            Open the file specified and prepare for logging. 
            No writes will be made until <see cref="M:log4net.Appender.FileAppender.ExclusiveLock.AcquireLock" /> is called.
            Must be called before any calls to <see cref="M:log4net.Appender.FileAppender.ExclusiveLock.AcquireLock" />,
            <see cref="M:log4net.Appender.FileAppender.ExclusiveLock.ReleaseLock" /> and <see cref="M:log4net.Appender.FileAppender.ExclusiveLock.CloseFile" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.ExclusiveLock.CloseFile">
      <summary>
            Close the file
            </summary>
      <remarks>
        <para>
            Close the file. No further writes will be made.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.ExclusiveLock.AcquireLock">
      <summary>
            Acquire the lock on the file
            </summary>
      <returns>A stream that is ready to be written to.</returns>
      <remarks>
        <para>
            Does nothing. The lock is already taken
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.ExclusiveLock.ReleaseLock">
      <summary>
            Release the lock on the file
            </summary>
      <remarks>
        <para>
            Does nothing. The lock will be released when the file is closed.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.FileAppender.MinimalLock">
      <summary>
            Acquires the file lock for each write
            </summary>
      <remarks>
        <para>
            Opens the file once for each <see cref="M:log4net.Appender.FileAppender.MinimalLock.AcquireLock" />/<see cref="M:log4net.Appender.FileAppender.MinimalLock.ReleaseLock" /> cycle, 
            thus holding the lock for the minimal amount of time. This method of locking
            is considerably slower than <see cref="T:log4net.Appender.FileAppender.ExclusiveLock" /> but allows 
            other processes to move/delete the log file whilst logging continues.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.MinimalLock.OpenFile(System.String,System.Boolean,System.Text.Encoding)">
      <summary>
            Prepares to open the file when the first message is logged.
            </summary>
      <param name="filename">The filename to use</param>
      <param name="append">Whether to append to the file, or overwrite</param>
      <param name="encoding">The encoding to use</param>
      <remarks>
        <para>
            Open the file specified and prepare for logging. 
            No writes will be made until <see cref="M:log4net.Appender.FileAppender.MinimalLock.AcquireLock" /> is called.
            Must be called before any calls to <see cref="M:log4net.Appender.FileAppender.MinimalLock.AcquireLock" />,
            <see cref="M:log4net.Appender.FileAppender.MinimalLock.ReleaseLock" /> and <see cref="M:log4net.Appender.FileAppender.MinimalLock.CloseFile" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.MinimalLock.CloseFile">
      <summary>
            Close the file
            </summary>
      <remarks>
        <para>
            Close the file. No further writes will be made.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.MinimalLock.AcquireLock">
      <summary>
            Acquire the lock on the file
            </summary>
      <returns>A stream that is ready to be written to.</returns>
      <remarks>
        <para>
            Acquire the lock on the file in preparation for writing to it. 
            Return a stream pointing to the file. <see cref="M:log4net.Appender.FileAppender.MinimalLock.ReleaseLock" />
            must be called to release the lock on the output file.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.MinimalLock.ReleaseLock">
      <summary>
            Release the lock on the file
            </summary>
      <remarks>
        <para>
            Release the lock on the file. No further writes will be made to the 
            stream until <see cref="M:log4net.Appender.FileAppender.MinimalLock.AcquireLock" /> is called again.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.FileAppender.InterProcessLock">
      <summary>
            Provides cross-process file locking.
            </summary>
      <author>Ron Grabowski</author>
      <author>Steve Wranovsky</author>
    </member>
    <member name="M:log4net.Appender.FileAppender.InterProcessLock.OpenFile(System.String,System.Boolean,System.Text.Encoding)">
      <summary>
            Open the file specified and prepare for logging.
            </summary>
      <param name="filename">The filename to use</param>
      <param name="append">Whether to append to the file, or overwrite</param>
      <param name="encoding">The encoding to use</param>
      <remarks>
        <para>
            Open the file specified and prepare for logging. 
            No writes will be made until <see cref="M:log4net.Appender.FileAppender.InterProcessLock.AcquireLock" /> is called.
            Must be called before any calls to <see cref="M:log4net.Appender.FileAppender.InterProcessLock.AcquireLock" />,
            -<see cref="M:log4net.Appender.FileAppender.InterProcessLock.ReleaseLock" /> and <see cref="M:log4net.Appender.FileAppender.InterProcessLock.CloseFile" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.InterProcessLock.CloseFile">
      <summary>
            Close the file
            </summary>
      <remarks>
        <para>
            Close the file. No further writes will be made.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.InterProcessLock.AcquireLock">
      <summary>
            Acquire the lock on the file
            </summary>
      <returns>A stream that is ready to be written to.</returns>
      <remarks>
        <para>
            Does nothing. The lock is already taken
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.InterProcessLock.ReleaseLock">
      <summary>
      </summary>
    </member>
    <member name="F:log4net.Appender.FileAppender.m_appendToFile">
      <summary>
            Flag to indicate if we should append to the file
            or overwrite the file. The default is to append.
            </summary>
    </member>
    <member name="F:log4net.Appender.FileAppender.m_fileName">
      <summary>
            The name of the log file.
            </summary>
    </member>
    <member name="F:log4net.Appender.FileAppender.m_encoding">
      <summary>
            The encoding to use for the file stream.
            </summary>
    </member>
    <member name="F:log4net.Appender.FileAppender.m_securityContext">
      <summary>
            The security context to use for privileged calls
            </summary>
    </member>
    <member name="F:log4net.Appender.FileAppender.m_stream">
      <summary>
            The stream to log to. Has added locking semantics
            </summary>
    </member>
    <member name="F:log4net.Appender.FileAppender.m_lockingModel">
      <summary>
            The locking model to use
            </summary>
    </member>
    <member name="F:log4net.Appender.FileAppender.declaringType">
      <summary>
            The fully qualified type of the FileAppender class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Default constructor
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.#ctor(log4net.Layout.ILayout,System.String,System.Boolean)">
      <summary>
            Construct a new appender using the layout, file and append mode.
            </summary>
      <param name="layout">the layout to use with this appender</param>
      <param name="filename">the full path to the file to write to</param>
      <param name="append">flag to indicate if the file should be appended to</param>
      <remarks>
        <para>
            Obsolete constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.#ctor(log4net.Layout.ILayout,System.String)">
      <summary>
            Construct a new appender using the layout and file specified.
            The file will be appended to.
            </summary>
      <param name="layout">the layout to use with this appender</param>
      <param name="filename">the full path to the file to write to</param>
      <remarks>
        <para>
            Obsolete constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.ActivateOptions">
      <summary>
            Activate the options on the file appender. 
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.FileAppender.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.FileAppender.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.FileAppender.ActivateOptions" /> must be called again.
            </para>
        <para>
            This will cause the file to be opened.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.Reset">
      <summary>
            Closes any previously opened file and calls the parent's <see cref="M:log4net.Appender.TextWriterAppender.Reset" />.
            </summary>
      <remarks>
        <para>
            Resets the filename and the file stream.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.PrepareWriter">
      <summary>
            Called to initialize the file writer
            </summary>
      <remarks>
        <para>
            Will be called for each logged message until the file is
            successfully opened.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)" />
            method. 
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Writes a log statement to the output stream if the output stream exists 
            and is writable.  
            </para>
        <para>
            The format of the output will depend on the appender's layout.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.Append(log4net.Core.LoggingEvent[])">
      <summary>
            This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent[])" />
            method. 
            </summary>
      <param name="loggingEvents">The array of events to log.</param>
      <remarks>
        <para>
            Acquires the output file locks once before writing all the events to
            the stream.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.WriteFooter">
      <summary>
            Writes a footer as produced by the embedded layout's <see cref="P:log4net.Layout.ILayout.Footer" /> property.
            </summary>
      <remarks>
        <para>
            Writes a footer as produced by the embedded layout's <see cref="P:log4net.Layout.ILayout.Footer" /> property.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.WriteHeader">
      <summary>
            Writes a header produced by the embedded layout's <see cref="P:log4net.Layout.ILayout.Header" /> property.
            </summary>
      <remarks>
        <para>
            Writes a header produced by the embedded layout's <see cref="P:log4net.Layout.ILayout.Header" /> property.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.CloseWriter">
      <summary>
            Closes the underlying <see cref="T:System.IO.TextWriter" />.
            </summary>
      <remarks>
        <para>
            Closes the underlying <see cref="T:System.IO.TextWriter" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.CloseFile">
      <summary>
            Closes the previously opened file.
            </summary>
      <remarks>
        <para>
            Writes the <see cref="P:log4net.Layout.ILayout.Footer" /> to the file and then
            closes the file.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.SafeOpenFile(System.String,System.Boolean)">
      <summary>
            Sets and <i>opens</i> the file where the log output will go. The specified file must be writable.
            </summary>
      <param name="fileName">The path to the log file. Must be a fully qualified path.</param>
      <param name="append">If true will append to fileName. Otherwise will truncate fileName</param>
      <remarks>
        <para>
            Calls <see cref="M:log4net.Appender.FileAppender.OpenFile(System.String,System.Boolean)" /> but guarantees not to throw an exception.
            Errors are passed to the <see cref="P:log4net.Appender.TextWriterAppender.ErrorHandler" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.OpenFile(System.String,System.Boolean)">
      <summary>
            Sets and <i>opens</i> the file where the log output will go. The specified file must be writable.
            </summary>
      <param name="fileName">The path to the log file. Must be a fully qualified path.</param>
      <param name="append">If true will append to fileName. Otherwise will truncate fileName</param>
      <remarks>
        <para>
            If there was already an opened file, then the previous file
            is closed first.
            </para>
        <para>
            This method will ensure that the directory structure
            for the <paramref name="fileName" /> specified exists.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.SetQWForFiles(System.IO.Stream)">
      <summary>
            Sets the quiet writer used for file output
            </summary>
      <param name="fileStream">the file stream that has been opened for writing</param>
      <remarks>
        <para>
            This implementation of <see cref="M:SetQWForFiles(Stream)" /> creates a <see cref="T:System.IO.StreamWriter" />
            over the <paramref name="fileStream" /> and passes it to the 
            <see cref="M:SetQWForFiles(TextWriter)" /> method.
            </para>
        <para>
            This method can be overridden by sub classes that want to wrap the
            <see cref="T:System.IO.Stream" /> in some way, for example to encrypt the output
            data using a <c>System.Security.Cryptography.CryptoStream</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.SetQWForFiles(System.IO.TextWriter)">
      <summary>
            Sets the quiet writer being used.
            </summary>
      <param name="writer">the writer over the file stream that has been opened for writing</param>
      <remarks>
        <para>
            This method can be overridden by sub classes that want to
            wrap the <see cref="T:System.IO.TextWriter" /> in some way.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.ConvertToFullPath(System.String)">
      <summary>
            Convert a path into a fully qualified path.
            </summary>
      <param name="path">The path to convert.</param>
      <returns>The fully qualified path.</returns>
      <remarks>
        <para>
            Converts the path specified to a fully
            qualified path. If the path is relative it is
            taken as relative from the application base 
            directory.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.FileAppender.File">
      <summary>
            Gets or sets the path to the file that logging will be written to.
            </summary>
      <value>
            The path to the file that logging will be written to.
            </value>
      <remarks>
        <para>
            If the path is relative it is taken as relative from 
            the application base directory.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.FileAppender.AppendToFile">
      <summary>
            Gets or sets a flag that indicates whether the file should be
            appended to or overwritten.
            </summary>
      <value>
            Indicates whether the file should be appended to or overwritten.
            </value>
      <remarks>
        <para>
            If the value is set to false then the file will be overwritten, if 
            it is set to true then the file will be appended to.
            </para>
            The default value is true.
            </remarks>
    </member>
    <member name="P:log4net.Appender.FileAppender.Encoding">
      <summary>
            Gets or sets <see cref="P:log4net.Appender.FileAppender.Encoding" /> used to write to the file.
            </summary>
      <value>
            The <see cref="P:log4net.Appender.FileAppender.Encoding" /> used to write to the file.
            </value>
      <remarks>
        <para>
            The default encoding set is <see cref="P:System.Text.Encoding.Default" />
            which is the encoding for the system's current ANSI code page.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.FileAppender.SecurityContext">
      <summary>
            Gets or sets the <see cref="P:log4net.Appender.FileAppender.SecurityContext" /> used to write to the file.
            </summary>
      <value>
            The <see cref="P:log4net.Appender.FileAppender.SecurityContext" /> used to write to the file.
            </value>
      <remarks>
        <para>
            Unless a <see cref="P:log4net.Appender.FileAppender.SecurityContext" /> specified here for this appender
            the <see cref="P:log4net.Core.SecurityContextProvider.DefaultProvider" /> is queried for the
            security context to use. The default behavior is to use the security context
            of the current thread.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.FileAppender.LockingModel">
      <summary>
            Gets or sets the <see cref="P:log4net.Appender.FileAppender.LockingModel" /> used to handle locking of the file.
            </summary>
      <value>
            The <see cref="P:log4net.Appender.FileAppender.LockingModel" /> used to lock the file.
            </value>
      <remarks>
        <para>
            Gets or sets the <see cref="P:log4net.Appender.FileAppender.LockingModel" /> used to handle locking of the file.
            </para>
        <para>
            There are three built in locking models, <see cref="T:log4net.Appender.FileAppender.ExclusiveLock" />, <see cref="T:log4net.Appender.FileAppender.MinimalLock" /> and <see cref="T:log4net.Appender.FileAppender.InterProcessLock" /> .
            The first locks the file from the start of logging to the end, the 
            second locks only for the minimal amount of time when logging each message
            and the last synchronizes processes using a named system wide Mutex.
            </para>
        <para>
            The default locking model is the <see cref="T:log4net.Appender.FileAppender.ExclusiveLock" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.LogException">
      <summary>
            Exception base type for log4net.
            </summary>
      <remarks>
        <para>
            This type extends <see cref="T:System.ApplicationException" />. It
            does not add any new functionality but does differentiate the
            type of exception being thrown.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Core.LogException.#ctor">
      <summary>
            Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Core.LogException" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogException.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="message">A message to include with the exception.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Core.LogException" /> class with
            the specified message.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogException.#ctor(System.String,System.Exception)">
      <summary>
            Constructor
            </summary>
      <param name="message">A message to include with the exception.</param>
      <param name="innerException">A nested exception to include.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Core.LogException" /> class
            with the specified message and inner exception.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Serialization constructor
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Core.LogException" /> class 
            with serialized data.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.ForwardingAppender">
      <summary>
            This appender forwards logging events to attached appenders.
            </summary>
      <remarks>
        <para>
            The forwarding appender can be used to specify different thresholds
            and filters for the same appender at different locations within the hierarchy.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Appender.ForwardingAppender.m_appenderAttachedImpl">
      <summary>
            Implementation of the <see cref="T:log4net.Core.IAppenderAttachable" /> interface
            </summary>
    </member>
    <member name="M:log4net.Appender.ForwardingAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.ForwardingAppender" /> class.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ForwardingAppender.OnClose">
      <summary>
            Closes the appender and releases resources.
            </summary>
      <remarks>
        <para>
            Releases any resources allocated within the appender such as file handles, 
            network connections, etc.
            </para>
        <para>
            It is a programming error to append to a closed appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ForwardingAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            Forward the logging event to the attached appenders 
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Delivers the logging event to all the attached appenders.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ForwardingAppender.Append(log4net.Core.LoggingEvent[])">
      <summary>
            Forward the logging events to the attached appenders 
            </summary>
      <param name="loggingEvents">The array of events to log.</param>
      <remarks>
        <para>
            Delivers the logging events to all the attached appenders.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ForwardingAppender.AddAppender(log4net.Appender.IAppender)">
      <summary>
            Adds an <see cref="T:log4net.Appender.IAppender" /> to the list of appenders of this
            instance.
            </summary>
      <param name="newAppender">The <see cref="T:log4net.Appender.IAppender" /> to add to this appender.</param>
      <remarks>
        <para>
            If the specified <see cref="T:log4net.Appender.IAppender" /> is already in the list of
            appenders, then it won't be added again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ForwardingAppender.GetAppender(System.String)">
      <summary>
            Looks for the appender with the specified name.
            </summary>
      <param name="name">The name of the appender to lookup.</param>
      <returns>
            The appender with the specified name, or <c>null</c>.
            </returns>
      <remarks>
        <para>
            Get the named appender attached to this appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ForwardingAppender.RemoveAllAppenders">
      <summary>
            Removes all previously added appenders from this appender.
            </summary>
      <remarks>
        <para>
            This is useful when re-reading configuration information.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ForwardingAppender.RemoveAppender(log4net.Appender.IAppender)">
      <summary>
            Removes the specified appender from the list of appenders.
            </summary>
      <param name="appender">The appender to remove.</param>
      <returns>The appender removed from the list</returns>
      <remarks>
            The appender removed is not closed.
            If you are discarding the appender you must call
            <see cref="M:log4net.Appender.IAppender.Close" /> on the appender removed.
            </remarks>
    </member>
    <member name="M:log4net.Appender.ForwardingAppender.RemoveAppender(System.String)">
      <summary>
            Removes the appender with the specified name from the list of appenders.
            </summary>
      <param name="name">The name of the appender to remove.</param>
      <returns>The appender removed from the list</returns>
      <remarks>
            The appender removed is not closed.
            If you are discarding the appender you must call
            <see cref="M:log4net.Appender.IAppender.Close" /> on the appender removed.
            </remarks>
    </member>
    <member name="P:log4net.Appender.ForwardingAppender.Appenders">
      <summary>
            Gets the appenders contained in this appender as an 
            <see cref="T:System.Collections.ICollection" />.
            </summary>
      <remarks>
            If no appenders can be found, then an <see cref="T:log4net.Util.EmptyCollection" /> 
            is returned.
            </remarks>
      <returns>
            A collection of the appenders in this appender.
            </returns>
    </member>
    <member name="T:log4net.Appender.LocalSyslogAppender">
      <summary>
            Logs events to a local syslog service.
            </summary>
      <remarks>
        <note>
            This appender uses the POSIX libc library functions <c>openlog</c>, <c>syslog</c>, and <c>closelog</c>.
            If these functions are not available on the local system then this appender will not work!
            </note>
        <para>
            The functions <c>openlog</c>, <c>syslog</c>, and <c>closelog</c> are specified in SUSv2 and 
            POSIX 1003.1-2001 standards. These are used to log messages to the local syslog service.
            </para>
        <para>
            This appender talks to a local syslog service. If you need to log to a remote syslog
            daemon and you cannot configure your local syslog service to do this you may be
            able to use the <see cref="T:log4net.Appender.RemoteSyslogAppender" /> to log via UDP.
            </para>
        <para>
            Syslog messages must have a facility and and a severity. The severity
            is derived from the Level of the logging event.
            The facility must be chosen from the set of defined syslog 
            <see cref="T:log4net.Appender.LocalSyslogAppender.SyslogFacility" /> values. The facilities list is predefined
            and cannot be extended.
            </para>
        <para>
            An identifier is specified with each log message. This can be specified
            by setting the <see cref="P:log4net.Appender.LocalSyslogAppender.Identity" /> property. The identity (also know 
            as the tag) must not contain white space. The default value for the
            identity is the application name (from <see cref="P:log4net.Util.SystemInfo.ApplicationFriendlyName" />).
            </para>
      </remarks>
      <author>Rob Lyon</author>
      <author>Nicko Cadell</author>
    </member>
    <member name="T:log4net.Appender.LocalSyslogAppender.SyslogSeverity">
      <summary>
            syslog severities
            </summary>
      <remarks>
        <para>
            The log4net Level maps to a syslog severity using the
            <see cref="M:log4net.Appender.LocalSyslogAppender.AddMapping(log4net.Appender.LocalSyslogAppender.LevelSeverity)" /> method and the <see cref="T:log4net.Appender.LocalSyslogAppender.LevelSeverity" />
            class. The severity is set on <see cref="P:log4net.Appender.LocalSyslogAppender.LevelSeverity.Severity" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.LocalSyslogAppender.SyslogFacility">
      <summary>
            syslog facilities
            </summary>
      <remarks>
        <para>
            The syslog facility defines which subsystem the logging comes from.
            This is set on the <see cref="P:log4net.Appender.LocalSyslogAppender.Facility" /> property.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.LocalSyslogAppender.LevelSeverity">
      <summary>
            A class to act as a mapping between the level that a logging call is made at and
            the syslog severity that is should be logged at.
            </summary>
      <remarks>
        <para>
            A class to act as a mapping between the level that a logging call is made at and
            the syslog severity that is should be logged at.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.LocalSyslogAppender.LevelSeverity.Severity">
      <summary>
            The mapped syslog severity for the specified level
            </summary>
      <remarks>
        <para>
            Required property.
            The mapped syslog severity for the specified level
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.LocalSyslogAppender.m_facility">
      <summary>
            The facility. The default facility is <see cref="F:log4net.Appender.LocalSyslogAppender.SyslogFacility.User" />.
            </summary>
    </member>
    <member name="F:log4net.Appender.LocalSyslogAppender.m_identity">
      <summary>
            The message identity
            </summary>
    </member>
    <member name="F:log4net.Appender.LocalSyslogAppender.m_handleToIdentity">
      <summary>
            Marshaled handle to the identity string. We have to hold on to the
            string as the <c>openlog</c> and <c>syslog</c> APIs just hold the
            pointer to the ident and dereference it for each log message.
            </summary>
    </member>
    <member name="F:log4net.Appender.LocalSyslogAppender.m_levelMapping">
      <summary>
            Mapping from level object to syslog severity
            </summary>
    </member>
    <member name="M:log4net.Appender.LocalSyslogAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.LocalSyslogAppender" /> class.
            </summary>
      <remarks>
            This instance of the <see cref="T:log4net.Appender.LocalSyslogAppender" /> class is set up to write 
            to a local syslog service.
            </remarks>
    </member>
    <member name="M:log4net.Appender.LocalSyslogAppender.AddMapping(log4net.Appender.LocalSyslogAppender.LevelSeverity)">
      <summary>
            Add a mapping of level to severity
            </summary>
      <param name="mapping">The mapping to add</param>
      <remarks>
        <para>
            Adds a <see cref="T:log4net.Appender.LocalSyslogAppender.LevelSeverity" /> to this appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.LocalSyslogAppender.ActivateOptions">
      <summary>
            Initialize the appender based on the options set.
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.LocalSyslogAppender.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.LocalSyslogAppender.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.LocalSyslogAppender.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.LocalSyslogAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)" /> method.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Writes the event to a remote syslog daemon.
            </para>
        <para>
            The format of the output will depend on the appender's layout.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.LocalSyslogAppender.OnClose">
      <summary>
            Close the syslog when the appender is closed
            </summary>
      <remarks>
        <para>
            Close the syslog when the appender is closed
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.LocalSyslogAppender.GetSeverity(log4net.Core.Level)">
      <summary>
            Translates a log4net level to a syslog severity.
            </summary>
      <param name="level">A log4net level.</param>
      <returns>A syslog severity.</returns>
      <remarks>
        <para>
            Translates a log4net level to a syslog severity.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.LocalSyslogAppender.GeneratePriority(log4net.Appender.LocalSyslogAppender.SyslogFacility,log4net.Appender.LocalSyslogAppender.SyslogSeverity)">
      <summary>
            Generate a syslog priority.
            </summary>
      <param name="facility">The syslog facility.</param>
      <param name="severity">The syslog severity.</param>
      <returns>A syslog priority.</returns>
    </member>
    <member name="M:log4net.Appender.LocalSyslogAppender.openlog(System.IntPtr,System.Int32,log4net.Appender.LocalSyslogAppender.SyslogFacility)">
      <summary>
            Open connection to system logger.
            </summary>
    </member>
    <member name="M:log4net.Appender.LocalSyslogAppender.syslog(System.Int32,System.String,System.String)">
      <summary>
            Generate a log message.
            </summary>
      <remarks>
        <para>
            The libc syslog method takes a format string and a variable argument list similar
            to the classic printf function. As this type of vararg list is not supported
            by C# we need to specify the arguments explicitly. Here we have specified the
            format string with a single message argument. The caller must set the format 
            string to <c>"%s"</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.LocalSyslogAppender.closelog">
      <summary>
            Close descriptor used to write to system logger.
            </summary>
    </member>
    <member name="P:log4net.Appender.LocalSyslogAppender.Identity">
      <summary>
            Message identity
            </summary>
      <remarks>
        <para>
            An identifier is specified with each log message. This can be specified
            by setting the <see cref="P:log4net.Appender.LocalSyslogAppender.Identity" /> property. The identity (also know 
            as the tag) must not contain white space. The default value for the
            identity is the application name (from <see cref="P:log4net.Util.SystemInfo.ApplicationFriendlyName" />).
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.LocalSyslogAppender.Facility">
      <summary>
            Syslog facility
            </summary>
      <remarks>
            Set to one of the <see cref="T:log4net.Appender.LocalSyslogAppender.SyslogFacility" /> values. The list of
            facilities is predefined and cannot be extended. The default value
            is <see cref="F:log4net.Appender.LocalSyslogAppender.SyslogFacility.User" />.
            </remarks>
    </member>
    <member name="P:log4net.Appender.LocalSyslogAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="P:log4net.Appender.AppenderSkeleton.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="P:log4net.Appender.AppenderSkeleton.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.ManagedColoredConsoleAppender">
      <summary>
            Appends colorful logging events to the console, using the .NET 2
            built-in capabilities.
            </summary>
      <remarks>
        <para>
            ManagedColoredConsoleAppender appends log events to the standard output stream
            or the error output stream using a layout specified by the 
            user. It also allows the color of a specific type of message to be set.
            </para>
        <para>
            By default, all output is written to the console's standard output stream.
            The <see cref="P:log4net.Appender.ManagedColoredConsoleAppender.Target" /> property can be set to direct the output to the
            error stream.
            </para>
        <para>
            When configuring the colored console appender, mappings should be
            specified to map logging levels to colors. For example:
            </para>
        <code lang="XML" escaped="true">
          <mapping>
            <level value="ERROR" />
            <foreColor value="DarkRed" />
            <backColor value="White" />
          </mapping>
          <mapping>
            <level value="WARN" />
            <foreColor value="Yellow" />
          </mapping>
          <mapping>
            <level value="INFO" />
            <foreColor value="White" />
          </mapping>
          <mapping>
            <level value="DEBUG" />
            <foreColor value="Blue" />
          </mapping>
        </code>
        <para>
            The Level is the standard log4net logging level while
            ForeColor and BackColor are the values of <see cref="T:System.ConsoleColor" />
            enumeration.
            </para>
        <para>
            Based on the ColoredConsoleAppender
            </para>
      </remarks>
      <author>Rick Hobbs</author>
      <author>Nicko Cadell</author>
      <author>Pavlos Touboulidis</author>
    </member>
    <member name="T:log4net.Appender.ManagedColoredConsoleAppender.LevelColors">
      <summary>
            A class to act as a mapping between the level that a logging call is made at and
            the color it should be displayed as.
            </summary>
      <remarks>
        <para>
            Defines the mapping between a level and the color it should be displayed in.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.ManagedColoredConsoleAppender.LevelColors.ForeColor">
      <summary>
            The mapped foreground color for the specified level
            </summary>
      <remarks>
        <para>
            Required property.
            The mapped foreground color for the specified level.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.ManagedColoredConsoleAppender.LevelColors.BackColor">
      <summary>
            The mapped background color for the specified level
            </summary>
      <remarks>
        <para>
            Required property.
            The mapped background color for the specified level.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.ManagedColoredConsoleAppender.ConsoleOut">
      <summary>
            The <see cref="P:log4net.Appender.ManagedColoredConsoleAppender.Target" /> to use when writing to the Console 
            standard output stream.
            </summary>
      <remarks>
        <para>
            The <see cref="P:log4net.Appender.ManagedColoredConsoleAppender.Target" /> to use when writing to the Console 
            standard output stream.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.ManagedColoredConsoleAppender.ConsoleError">
      <summary>
            The <see cref="P:log4net.Appender.ManagedColoredConsoleAppender.Target" /> to use when writing to the Console 
            standard error output stream.
            </summary>
      <remarks>
        <para>
            The <see cref="P:log4net.Appender.ManagedColoredConsoleAppender.Target" /> to use when writing to the Console 
            standard error output stream.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.ManagedColoredConsoleAppender.m_writeToErrorStream">
      <summary>
            Flag to write output to the error stream rather than the standard output stream
            </summary>
    </member>
    <member name="F:log4net.Appender.ManagedColoredConsoleAppender.m_levelMapping">
      <summary>
            Mapping from level object to color value
            </summary>
    </member>
    <member name="M:log4net.Appender.ManagedColoredConsoleAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.ManagedColoredConsoleAppender" /> class.
            </summary>
      <remarks>
            The instance of the <see cref="T:log4net.Appender.ManagedColoredConsoleAppender" /> class is set up to write 
            to the standard output stream.
            </remarks>
    </member>
    <member name="M:log4net.Appender.ManagedColoredConsoleAppender.AddMapping(log4net.Appender.ManagedColoredConsoleAppender.LevelColors)">
      <summary>
            Add a mapping of level to color - done by the config file
            </summary>
      <param name="mapping">The mapping to add</param>
      <remarks>
        <para>
            Add a <see cref="T:log4net.Appender.ManagedColoredConsoleAppender.LevelColors" /> mapping to this appender.
            Each mapping defines the foreground and background colors
            for a level.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ManagedColoredConsoleAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent)" /> method.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Writes the event to the console.
            </para>
        <para>
            The format of the output will depend on the appender's layout.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ManagedColoredConsoleAppender.ActivateOptions">
      <summary>
            Initialize the options for this appender
            </summary>
      <remarks>
        <para>
            Initialize the level to color mappings set on this appender.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.ManagedColoredConsoleAppender.Target">
      <summary>
            Target is the value of the console output stream.
            This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
            </summary>
      <value>
            Target is the value of the console output stream.
            This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
            </value>
      <remarks>
        <para>
            Target is the value of the console output stream.
            This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.ManagedColoredConsoleAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.MemoryAppender">
      <summary>
            Stores logging events in an array.
            </summary>
      <remarks>
        <para>
            The memory appender stores all the logging events
            that are appended in an in-memory array.
            </para>
        <para>
            Use the <see cref="M:log4net.Appender.MemoryAppender.GetEvents" /> method to get
            the current list of events that have been appended.
            </para>
        <para>
            Use the <see cref="M:Clear()" /> method to clear the
            current list of events.
            </para>
      </remarks>
      <author>Julian Biddle</author>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Appender.MemoryAppender.m_eventsList">
      <summary>
            The list of events that have been appended.
            </summary>
    </member>
    <member name="F:log4net.Appender.MemoryAppender.m_fixFlags">
      <summary>
            Value indicating which fields in the event should be fixed
            </summary>
      <remarks>
            By default all fields are fixed
            </remarks>
    </member>
    <member name="M:log4net.Appender.MemoryAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.MemoryAppender" /> class.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.MemoryAppender.GetEvents">
      <summary>
            Gets the events that have been logged.
            </summary>
      <returns>The events that have been logged</returns>
      <remarks>
        <para>
            Gets the events that have been logged.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.MemoryAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)" /> method. 
            </summary>
      <param name="loggingEvent">the event to log</param>
      <remarks>
        <para>Stores the <paramref name="loggingEvent" /> in the events list.</para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.MemoryAppender.Clear">
      <summary>
            Clear the list of events
            </summary>
      <remarks>
            Clear the list of events
            </remarks>
    </member>
    <member name="P:log4net.Appender.MemoryAppender.OnlyFixPartialEventData">
      <summary>
            Gets or sets a value indicating whether only part of the logging event 
            data should be fixed.
            </summary>
      <value>
        <c>true</c> if the appender should only fix part of the logging event 
            data, otherwise <c>false</c>. The default is <c>false</c>.
            </value>
      <remarks>
        <para>
            Setting this property to <c>true</c> will cause only part of the event 
            data to be fixed and stored in the appender, hereby improving performance. 
            </para>
        <para>
            See <see cref="M:LoggingEvent.FixVolatileData(bool)" /> for more information.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.MemoryAppender.Fix">
      <summary>
            Gets or sets the fields that will be fixed in the event
            </summary>
      <remarks>
        <para>
            The logging event needs to have certain thread specific values 
            captured before it can be buffered. See <see cref="P:log4net.Core.LoggingEvent.Fix" />
            for details.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.NetSendAppender">
      <summary>
            Logs entries by sending network messages using the 
            <see cref="M:log4net.Appender.NetSendAppender.NetMessageBufferSend(System.String,System.String,System.String,System.String,System.Int32)" /> native function.
            </summary>
      <remarks>
        <para>
            You can send messages only to names that are active 
            on the network. If you send the message to a user name, 
            that user must be logged on and running the Messenger 
            service to receive the message.
            </para>
        <para>
            The receiver will get a top most window displaying the 
            messages one at a time, therefore this appender should 
            not be used to deliver a high volume of messages.
            </para>
        <para>
            The following table lists some possible uses for this appender :
            </para>
        <para>
          <list type="table">
            <listheader>
              <term>Action</term>
              <description>Property Value(s)</description>
            </listheader>
            <item>
              <term>Send a message to a user account on the local machine</term>
              <description>
                <para>
                  <see cref="P:log4net.Appender.NetSendAppender.Server" /> = &lt;name of the local machine&gt;
                        </para>
                <para>
                  <see cref="P:log4net.Appender.NetSendAppender.Recipient" /> = &lt;user name&gt;
                        </para>
              </description>
            </item>
            <item>
              <term>Send a message to a user account on a remote machine</term>
              <description>
                <para>
                  <see cref="P:log4net.Appender.NetSendAppender.Server" /> = &lt;name of the remote machine&gt;
                        </para>
                <para>
                  <see cref="P:log4net.Appender.NetSendAppender.Recipient" /> = &lt;user name&gt;
                        </para>
              </description>
            </item>
            <item>
              <term>Send a message to a domain user account</term>
              <description>
                <para>
                  <see cref="P:log4net.Appender.NetSendAppender.Server" /> = &lt;name of a domain controller | uninitialized&gt;
                        </para>
                <para>
                  <see cref="P:log4net.Appender.NetSendAppender.Recipient" /> = &lt;user name&gt;
                        </para>
              </description>
            </item>
            <item>
              <term>Send a message to all the names in a workgroup or domain</term>
              <description>
                <para>
                  <see cref="P:log4net.Appender.NetSendAppender.Recipient" /> = &lt;workgroup name | domain name&gt;*
                        </para>
              </description>
            </item>
            <item>
              <term>Send a message from the local machine to a remote machine</term>
              <description>
                <para>
                  <see cref="P:log4net.Appender.NetSendAppender.Server" /> = &lt;name of the local machine | uninitialized&gt;
                        </para>
                <para>
                  <see cref="P:log4net.Appender.NetSendAppender.Recipient" /> = &lt;name of the remote machine&gt;
                        </para>
              </description>
            </item>
          </list>
        </para>
        <para>
          <b>Note :</b> security restrictions apply for sending 
            network messages, see <see cref="M:log4net.Appender.NetSendAppender.NetMessageBufferSend(System.String,System.String,System.String,System.String,System.Int32)" /> 
            for more information.
            </para>
      </remarks>
      <example>
        <para>
            An example configuration section to log information 
            using this appender from the local machine, named 
            LOCAL_PC, to machine OPERATOR_PC :
            </para>
        <code lang="XML" escaped="true">
          <appender name="NetSendAppender_Operator" type="log4net.Appender.NetSendAppender">
            <server value="LOCAL_PC" />
            <recipient value="OPERATOR_PC" />
            <layout type="log4net.Layout.PatternLayout" value="%-5p %c [%x] - %m%n" />
          </appender>
        </code>
      </example>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Appender.NetSendAppender.m_server">
      <summary>
            The DNS or NetBIOS name of the server on which the function is to execute.
            </summary>
    </member>
    <member name="F:log4net.Appender.NetSendAppender.m_sender">
      <summary>
            The sender of the network message.
            </summary>
    </member>
    <member name="F:log4net.Appender.NetSendAppender.m_recipient">
      <summary>
            The message alias to which the message should be sent.
            </summary>
    </member>
    <member name="F:log4net.Appender.NetSendAppender.m_securityContext">
      <summary>
            The security context to use for privileged calls
            </summary>
    </member>
    <member name="M:log4net.Appender.NetSendAppender.#ctor">
      <summary>
            Initializes the appender.
            </summary>
      <remarks>
            The default constructor initializes all fields to their default values.
            </remarks>
    </member>
    <member name="M:log4net.Appender.NetSendAppender.ActivateOptions">
      <summary>
            Initialize the appender based on the options set.
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.NetSendAppender.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.NetSendAppender.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.NetSendAppender.ActivateOptions" /> must be called again.
            </para>
        <para>
            The appender will be ignored if no <see cref="P:log4net.Appender.NetSendAppender.Recipient" /> was specified.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">The required property <see cref="P:log4net.Appender.NetSendAppender.Recipient" /> was not specified.</exception>
    </member>
    <member name="M:log4net.Appender.NetSendAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)" /> method.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Sends the event using a network message.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.NetSendAppender.NetMessageBufferSend(System.String,System.String,System.String,System.String,System.Int32)">
      <summary>
            Sends a buffer of information to a registered message alias.
            </summary>
      <param name="serverName">The DNS or NetBIOS name of the server on which the function is to execute.</param>
      <param name="msgName">The message alias to which the message buffer should be sent</param>
      <param name="fromName">The originator of the message.</param>
      <param name="buffer">The message text.</param>
      <param name="bufferSize">The length, in bytes, of the message text.</param>
      <remarks>
        <para>
            The following restrictions apply for sending network messages:
            </para>
        <para>
          <list type="table">
            <listheader>
              <term>Platform</term>
              <description>Requirements</description>
            </listheader>
            <item>
              <term>Windows NT</term>
              <description>
                <para>
                        No special group membership is required to send a network message.
                        </para>
                <para>
                        Admin, Accounts, Print, or Server Operator group membership is required to 
                        successfully send a network message on a remote server.
                        </para>
              </description>
            </item>
            <item>
              <term>Windows 2000 or later</term>
              <description>
                <para>
                        If you send a message on a domain controller that is running Active Directory, 
                        access is allowed or denied based on the access control list (ACL) for the securable 
                        object. The default ACL permits only Domain Admins and Account Operators to send a network message. 
                        </para>
                <para>
                        On a member server or workstation, only Administrators and Server Operators can send a network message. 
                        </para>
              </description>
            </item>
          </list>
        </para>
        <para>
            For more information see <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/netmgmt/netmgmt/security_requirements_for_the_network_management_functions.asp">Security Requirements for the Network Management Functions</a>.
            </para>
      </remarks>
      <returns>
        <para>
            If the function succeeds, the return value is zero.
            </para>
      </returns>
    </member>
    <member name="P:log4net.Appender.NetSendAppender.Sender">
      <summary>
            Gets or sets the sender of the message.
            </summary>
      <value>
            The sender of the message.
            </value>
      <remarks>
            If this property is not specified, the message is sent from the local computer.
            </remarks>
    </member>
    <member name="P:log4net.Appender.NetSendAppender.Recipient">
      <summary>
            Gets or sets the message alias to which the message should be sent.
            </summary>
      <value>
            The recipient of the message.
            </value>
      <remarks>
            This property should always be specified in order to send a message.
            </remarks>
    </member>
    <member name="P:log4net.Appender.NetSendAppender.Server">
      <summary>
            Gets or sets the DNS or NetBIOS name of the remote server on which the function is to execute.
            </summary>
      <value>
            DNS or NetBIOS name of the remote server on which the function is to execute.
            </value>
      <remarks>
        <para>
            For Windows NT 4.0 and earlier, the string should begin with \\.
            </para>
        <para>
            If this property is not specified, the local computer is used. 
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.NetSendAppender.SecurityContext">
      <summary>
            Gets or sets the <see cref="P:log4net.Appender.NetSendAppender.SecurityContext" /> used to call the NetSend method.
            </summary>
      <value>
            The <see cref="P:log4net.Appender.NetSendAppender.SecurityContext" /> used to call the NetSend method.
            </value>
      <remarks>
        <para>
            Unless a <see cref="P:log4net.Appender.NetSendAppender.SecurityContext" /> specified here for this appender
            the <see cref="P:log4net.Core.SecurityContextProvider.DefaultProvider" /> is queried for the
            security context to use. The default behavior is to use the security context
            of the current thread.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.NetSendAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.OutputDebugStringAppender">
      <summary>
            Appends log events to the OutputDebugString system.
            </summary>
      <remarks>
        <para>
            OutputDebugStringAppender appends log events to the
            OutputDebugString system.
            </para>
        <para>
            The string is passed to the native <c>OutputDebugString</c> 
            function.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Appender.OutputDebugStringAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.OutputDebugStringAppender" /> class.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.OutputDebugStringAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            Write the logging event to the output debug string API
            </summary>
      <param name="loggingEvent">the event to log</param>
      <remarks>
        <para>
            Write the logging event to the output debug string API
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.OutputDebugStringAppender.OutputDebugString(System.String)">
      <summary>
            Stub for OutputDebugString native method
            </summary>
      <param name="message">the string to output</param>
      <remarks>
        <para>
            Stub for OutputDebugString native method
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.OutputDebugStringAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.UdpAppender">
      <summary>
             Sends logging events as connectionless UDP datagrams to a remote host or a 
             multicast group using an <see cref="T:System.Net.Sockets.UdpClient" />.
             </summary>
      <remarks>
        <para>
             UDP guarantees neither that messages arrive, nor that they arrive in the correct order.
             </para>
        <para>
             To view the logging results, a custom application can be developed that listens for logging 
             events.
             </para>
        <para>
             When decoding events send via this appender remember to use the same encoding
             to decode the events as was used to send the events. See the <see cref="P:log4net.Appender.UdpAppender.Encoding" />
             property to specify the encoding to use.
             </para>
      </remarks>
      <example>
             This example shows how to log receive logging events that are sent 
             on IP address 244.0.0.1 and port 8080 to the console. The event is 
             encoded in the packet as a unicode string and it is decoded as such. 
             <code lang="C#">
             IPEndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);
             UdpClient udpClient;
             byte[] buffer;
             string loggingEvent;
             
             try 
             {
                 udpClient = new UdpClient(8080);
                 
                 while(true) 
                 {
                     buffer = udpClient.Receive(ref remoteEndPoint);
                     loggingEvent = System.Text.Encoding.Unicode.GetString(buffer);
                     Console.WriteLine(loggingEvent);
                 }
             } 
             catch(Exception e) 
             {
                 Console.WriteLine(e.ToString());
             }
             </code><code lang="Visual Basic">
             Dim remoteEndPoint as IPEndPoint
             Dim udpClient as UdpClient
             Dim buffer as Byte()
             Dim loggingEvent as String
             
             Try 
                 remoteEndPoint = new IPEndPoint(IPAddress.Any, 0)
                 udpClient = new UdpClient(8080)
            
                 While True
                     buffer = udpClient.Receive(ByRef remoteEndPoint)
                     loggingEvent = System.Text.Encoding.Unicode.GetString(buffer)
                     Console.WriteLine(loggingEvent)
                 Wend
             Catch e As Exception
                 Console.WriteLine(e.ToString())
             End Try
             </code><para>
             An example configuration section to log information using this appender to the 
             IP 224.0.0.1 on port 8080:
             </para><code lang="XML" escaped="true"><appender name="UdpAppender" type="log4net.Appender.UdpAppender"><remoteAddress value="224.0.0.1" /><remotePort value="8080" /><layout type="log4net.Layout.PatternLayout" value="%-5level %logger [%ndc] - %message%newline" /></appender></code></example>
      <author>Gert Driesen</author>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Appender.UdpAppender.m_remoteAddress">
      <summary>
            The IP address of the remote host or multicast group to which 
            the logging event will be sent.
            </summary>
    </member>
    <member name="F:log4net.Appender.UdpAppender.m_remotePort">
      <summary>
            The TCP port number of the remote host or multicast group to 
            which the logging event will be sent.
            </summary>
    </member>
    <member name="F:log4net.Appender.UdpAppender.m_remoteEndPoint">
      <summary>
            The cached remote endpoint to which the logging events will be sent.
            </summary>
    </member>
    <member name="F:log4net.Appender.UdpAppender.m_localPort">
      <summary>
            The TCP port number from which the <see cref="T:System.Net.Sockets.UdpClient" /> will communicate.
            </summary>
    </member>
    <member name="F:log4net.Appender.UdpAppender.m_client">
      <summary>
            The <see cref="T:System.Net.Sockets.UdpClient" /> instance that will be used for sending the 
            logging events.
            </summary>
    </member>
    <member name="F:log4net.Appender.UdpAppender.m_encoding">
      <summary>
            The encoding to use for the packet.
            </summary>
    </member>
    <member name="M:log4net.Appender.UdpAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.UdpAppender" /> class.
            </summary>
      <remarks>
            The default constructor initializes all fields to their default values.
            </remarks>
    </member>
    <member name="M:log4net.Appender.UdpAppender.ActivateOptions">
      <summary>
            Initialize the appender based on the options set.
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.UdpAppender.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.UdpAppender.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.UdpAppender.ActivateOptions" /> must be called again.
            </para>
        <para>
            The appender will be ignored if no <see cref="P:log4net.Appender.UdpAppender.RemoteAddress" /> was specified or 
            an invalid remote or local TCP port number was specified.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">The required property <see cref="P:log4net.Appender.UdpAppender.RemoteAddress" /> was not specified.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The TCP port number assigned to <see cref="P:log4net.Appender.UdpAppender.LocalPort" /> or <see cref="P:log4net.Appender.UdpAppender.RemotePort" /> is less than <see cref="F:System.Net.IPEndPoint.MinPort" /> or greater than <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
    </member>
    <member name="M:log4net.Appender.UdpAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)" /> method.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Sends the event using an UDP datagram.
            </para>
        <para>
            Exceptions are passed to the <see cref="P:log4net.Appender.AppenderSkeleton.ErrorHandler" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.UdpAppender.OnClose">
      <summary>
            Closes the UDP connection and releases all resources associated with 
            this <see cref="T:log4net.Appender.UdpAppender" /> instance.
            </summary>
      <remarks>
        <para>
            Disables the underlying <see cref="T:System.Net.Sockets.UdpClient" /> and releases all managed 
            and unmanaged resources associated with the <see cref="T:log4net.Appender.UdpAppender" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.UdpAppender.InitializeClientConnection">
      <summary>
            Initializes the underlying  <see cref="T:System.Net.Sockets.UdpClient" /> connection.
            </summary>
      <remarks>
        <para>
            The underlying <see cref="T:System.Net.Sockets.UdpClient" /> is initialized and binds to the 
            port number from which you intend to communicate.
            </para>
        <para>
            Exceptions are passed to the <see cref="P:log4net.Appender.AppenderSkeleton.ErrorHandler" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.UdpAppender.RemoteAddress">
      <summary>
            Gets or sets the IP address of the remote host or multicast group to which
            the underlying <see cref="T:System.Net.Sockets.UdpClient" /> should sent the logging event.
            </summary>
      <value>
            The IP address of the remote host or multicast group to which the logging event 
            will be sent.
            </value>
      <remarks>
        <para>
            Multicast addresses are identified by IP class <b>D</b> addresses (in the range 224.0.0.0 to
            239.255.255.255).  Multicast packets can pass across different networks through routers, so
            it is possible to use multicasts in an Internet scenario as long as your network provider 
            supports multicasting.
            </para>
        <para>
            Hosts that want to receive particular multicast messages must register their interest by joining
            the multicast group.  Multicast messages are not sent to networks where no host has joined
            the multicast group.  Class <b>D</b> IP addresses are used for multicast groups, to differentiate
            them from normal host addresses, allowing nodes to easily detect if a message is of interest.
            </para>
        <para>
            Static multicast addresses that are needed globally are assigned by IANA.  A few examples are listed in the table below:
            </para>
        <para>
          <list type="table">
            <listheader>
              <term>IP Address</term>
              <description>Description</description>
            </listheader>
            <item>
              <term>224.0.0.1</term>
              <description>
                <para>
                        Sends a message to all system on the subnet.
                        </para>
              </description>
            </item>
            <item>
              <term>224.0.0.2</term>
              <description>
                <para>
                        Sends a message to all routers on the subnet.
                        </para>
              </description>
            </item>
            <item>
              <term>224.0.0.12</term>
              <description>
                <para>
                        The DHCP server answers messages on the IP address 224.0.0.12, but only on a subnet.
                        </para>
              </description>
            </item>
          </list>
        </para>
        <para>
            A complete list of actually reserved multicast addresses and their owners in the ranges
            defined by RFC 3171 can be found at the <A href="http://www.iana.org/assignments/multicast-addresses">IANA web site</A>. 
            </para>
        <para>
            The address range 239.0.0.0 to 239.255.255.255 is reserved for administrative scope-relative 
            addresses.  These addresses can be reused with other local groups.  Routers are typically 
            configured with filters to prevent multicast traffic in this range from flowing outside
            of the local network.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.UdpAppender.RemotePort">
      <summary>
            Gets or sets the TCP port number of the remote host or multicast group to which 
            the underlying <see cref="T:System.Net.Sockets.UdpClient" /> should sent the logging event.
            </summary>
      <value>
            An integer value in the range <see cref="F:System.Net.IPEndPoint.MinPort" /> to <see cref="F:System.Net.IPEndPoint.MaxPort" /> 
            indicating the TCP port number of the remote host or multicast group to which the logging event 
            will be sent.
            </value>
      <remarks>
            The underlying <see cref="T:System.Net.Sockets.UdpClient" /> will send messages to this TCP port number
            on the remote host or multicast group.
            </remarks>
      <exception cref="T:System.ArgumentOutOfRangeException">The value specified is less than <see cref="F:System.Net.IPEndPoint.MinPort" /> or greater than <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
    </member>
    <member name="P:log4net.Appender.UdpAppender.LocalPort">
      <summary>
            Gets or sets the TCP port number from which the underlying <see cref="T:System.Net.Sockets.UdpClient" /> will communicate.
            </summary>
      <value>
            An integer value in the range <see cref="F:System.Net.IPEndPoint.MinPort" /> to <see cref="F:System.Net.IPEndPoint.MaxPort" /> 
            indicating the TCP port number from which the underlying <see cref="T:System.Net.Sockets.UdpClient" /> will communicate.
            </value>
      <remarks>
        <para>
            The underlying <see cref="T:System.Net.Sockets.UdpClient" /> will bind to this port for sending messages.
            </para>
        <para>
            Setting the value to 0 (the default) will cause the udp client not to bind to
            a local port.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentOutOfRangeException">The value specified is less than <see cref="F:System.Net.IPEndPoint.MinPort" /> or greater than <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
    </member>
    <member name="P:log4net.Appender.UdpAppender.Encoding">
      <summary>
            Gets or sets <see cref="P:log4net.Appender.UdpAppender.Encoding" /> used to write the packets.
            </summary>
      <value>
            The <see cref="P:log4net.Appender.UdpAppender.Encoding" /> used to write the packets.
            </value>
      <remarks>
        <para>
            The <see cref="P:log4net.Appender.UdpAppender.Encoding" /> used to write the packets.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.UdpAppender.Client">
      <summary>
            Gets or sets the underlying <see cref="T:System.Net.Sockets.UdpClient" />.
            </summary>
      <value>
            The underlying <see cref="T:System.Net.Sockets.UdpClient" />.
            </value>
      <remarks>
        <see cref="T:log4net.Appender.UdpAppender" /> creates a <see cref="T:System.Net.Sockets.UdpClient" /> to send logging events 
            over a network.  Classes deriving from <see cref="T:log4net.Appender.UdpAppender" /> can use this
            property to get or set this <see cref="T:System.Net.Sockets.UdpClient" />.  Use the underlying <see cref="T:System.Net.Sockets.UdpClient" />
            returned from <see cref="P:log4net.Appender.UdpAppender.Client" /> if you require access beyond that which 
            <see cref="T:log4net.Appender.UdpAppender" /> provides.
            </remarks>
    </member>
    <member name="P:log4net.Appender.UdpAppender.RemoteEndPoint">
      <summary>
            Gets or sets the cached remote endpoint to which the logging events should be sent.
            </summary>
      <value>
            The cached remote endpoint to which the logging events will be sent.
            </value>
      <remarks>
            The <see cref="M:log4net.Appender.UdpAppender.ActivateOptions" /> method will initialize the remote endpoint 
            with the values of the <see cref="P:log4net.Appender.UdpAppender.RemoteAddress" /> and <see cref="P:log4net.Appender.UdpAppender.RemotePort" />
            properties.
            </remarks>
    </member>
    <member name="P:log4net.Appender.UdpAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.RemoteSyslogAppender">
      <summary>
            Logs events to a remote syslog daemon.
            </summary>
      <remarks>
        <para>
            The BSD syslog protocol is used to remotely log to
            a syslog daemon. The syslogd listens for for messages
            on UDP port 514.
            </para>
        <para>
            The syslog UDP protocol is not authenticated. Most syslog daemons
            do not accept remote log messages because of the security implications.
            You may be able to use the LocalSyslogAppender to talk to a local
            syslog service.
            </para>
        <para>
            There is an RFC 3164 that claims to document the BSD Syslog Protocol.
            This RFC can be seen here: http://www.faqs.org/rfcs/rfc3164.html.
            This appender generates what the RFC calls an "Original Device Message",
            i.e. does not include the TIMESTAMP or HOSTNAME fields. By observation
            this format of message will be accepted by all current syslog daemon
            implementations. The daemon will attach the current time and the source
            hostname or IP address to any messages received.
            </para>
        <para>
            Syslog messages must have a facility and and a severity. The severity
            is derived from the Level of the logging event.
            The facility must be chosen from the set of defined syslog 
            <see cref="T:log4net.Appender.RemoteSyslogAppender.SyslogFacility" /> values. The facilities list is predefined
            and cannot be extended.
            </para>
        <para>
            An identifier is specified with each log message. This can be specified
            by setting the <see cref="P:log4net.Appender.RemoteSyslogAppender.Identity" /> property. The identity (also know 
            as the tag) must not contain white space. The default value for the
            identity is the application name (from <see cref="P:log4net.Core.LoggingEvent.Domain" />).
            </para>
      </remarks>
      <author>Rob Lyon</author>
      <author>Nicko Cadell</author>
    </member>
    <member name="T:log4net.Appender.RemoteSyslogAppender.SyslogSeverity">
      <summary>
            syslog severities
            </summary>
      <remarks>
        <para>
            The syslog severities.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.RemoteSyslogAppender.SyslogFacility">
      <summary>
            syslog facilities
            </summary>
      <remarks>
        <para>
            The syslog facilities
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.RemoteSyslogAppender.LevelSeverity">
      <summary>
            A class to act as a mapping between the level that a logging call is made at and
            the syslog severity that is should be logged at.
            </summary>
      <remarks>
        <para>
            A class to act as a mapping between the level that a logging call is made at and
            the syslog severity that is should be logged at.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.RemoteSyslogAppender.LevelSeverity.Severity">
      <summary>
            The mapped syslog severity for the specified level
            </summary>
      <remarks>
        <para>
            Required property.
            The mapped syslog severity for the specified level
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.RemoteSyslogAppender.DefaultSyslogPort">
      <summary>
            Syslog port 514
            </summary>
    </member>
    <member name="F:log4net.Appender.RemoteSyslogAppender.c_renderBufferSize">
      <summary>
            Initial buffer size
            </summary>
    </member>
    <member name="F:log4net.Appender.RemoteSyslogAppender.c_renderBufferMaxCapacity">
      <summary>
            Maximum buffer size before it is recycled
            </summary>
    </member>
    <member name="F:log4net.Appender.RemoteSyslogAppender.m_facility">
      <summary>
            The facility. The default facility is <see cref="F:log4net.Appender.RemoteSyslogAppender.SyslogFacility.User" />.
            </summary>
    </member>
    <member name="F:log4net.Appender.RemoteSyslogAppender.m_identity">
      <summary>
            The message identity
            </summary>
    </member>
    <member name="F:log4net.Appender.RemoteSyslogAppender.m_levelMapping">
      <summary>
            Mapping from level object to syslog severity
            </summary>
    </member>
    <member name="M:log4net.Appender.RemoteSyslogAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.RemoteSyslogAppender" /> class.
            </summary>
      <remarks>
            This instance of the <see cref="T:log4net.Appender.RemoteSyslogAppender" /> class is set up to write 
            to a remote syslog daemon.
            </remarks>
    </member>
    <member name="M:log4net.Appender.RemoteSyslogAppender.AddMapping(log4net.Appender.RemoteSyslogAppender.LevelSeverity)">
      <summary>
            Add a mapping of level to severity
            </summary>
      <param name="mapping">The mapping to add</param>
      <remarks>
        <para>
            Add a <see cref="T:log4net.Appender.RemoteSyslogAppender.LevelSeverity" /> mapping to this appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RemoteSyslogAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)" /> method.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Writes the event to a remote syslog daemon.
            </para>
        <para>
            The format of the output will depend on the appender's layout.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RemoteSyslogAppender.ActivateOptions">
      <summary>
            Initialize the options for this appender
            </summary>
      <remarks>
        <para>
            Initialize the level to syslog severity mappings set on this appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RemoteSyslogAppender.GetSeverity(log4net.Core.Level)">
      <summary>
            Translates a log4net level to a syslog severity.
            </summary>
      <param name="level">A log4net level.</param>
      <returns>A syslog severity.</returns>
      <remarks>
        <para>
            Translates a log4net level to a syslog severity.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RemoteSyslogAppender.GeneratePriority(log4net.Appender.RemoteSyslogAppender.SyslogFacility,log4net.Appender.RemoteSyslogAppender.SyslogSeverity)">
      <summary>
            Generate a syslog priority.
            </summary>
      <param name="facility">The syslog facility.</param>
      <param name="severity">The syslog severity.</param>
      <returns>A syslog priority.</returns>
      <remarks>
        <para>
            Generate a syslog priority.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.RemoteSyslogAppender.Identity">
      <summary>
            Message identity
            </summary>
      <remarks>
        <para>
            An identifier is specified with each log message. This can be specified
            by setting the <see cref="P:log4net.Appender.RemoteSyslogAppender.Identity" /> property. The identity (also know 
            as the tag) must not contain white space. The default value for the
            identity is the application name (from <see cref="P:log4net.Core.LoggingEvent.Domain" />).
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.RemoteSyslogAppender.Facility">
      <summary>
            Syslog facility
            </summary>
      <remarks>
            Set to one of the <see cref="T:log4net.Appender.RemoteSyslogAppender.SyslogFacility" /> values. The list of
            facilities is predefined and cannot be extended. The default value
            is <see cref="F:log4net.Appender.RemoteSyslogAppender.SyslogFacility.User" />.
            </remarks>
    </member>
    <member name="T:log4net.Appender.RemotingAppender">
      <summary>
            Delivers logging events to a remote logging sink. 
            </summary>
      <remarks>
        <para>
            This Appender is designed to deliver events to a remote sink. 
            That is any object that implements the <see cref="T:log4net.Appender.RemotingAppender.IRemoteLoggingSink" />
            interface. It delivers the events using .NET remoting. The
            object to deliver events to is specified by setting the
            appenders <see cref="P:log4net.Appender.RemotingAppender.Sink" /> property.</para>
        <para>
            The RemotingAppender buffers events before sending them. This allows it to 
            make more efficient use of the remoting infrastructure.</para>
        <para>
            Once the buffer is full the events are still not sent immediately. 
            They are scheduled to be sent using a pool thread. The effect is that 
            the send occurs asynchronously. This is very important for a 
            number of non obvious reasons. The remoting infrastructure will 
            flow thread local variables (stored in the <see cref="T:System.Runtime.Remoting.Messaging.CallContext" />),
            if they are marked as <see cref="T:System.Runtime.Remoting.Messaging.ILogicalThreadAffinative" />, across the 
            remoting boundary. If the server is not contactable then
            the remoting infrastructure will clear the <see cref="T:System.Runtime.Remoting.Messaging.ILogicalThreadAffinative" />
            objects from the <see cref="T:System.Runtime.Remoting.Messaging.CallContext" />. To prevent a logging failure from
            having side effects on the calling application the remoting call must be made
            from a separate thread to the one used by the application. A <see cref="T:System.Threading.ThreadPool" />
            thread is used for this. If no <see cref="T:System.Threading.ThreadPool" /> thread is available then
            the events will block in the thread pool manager until a thread is available.</para>
        <para>
            Because the events are sent asynchronously using pool threads it is possible to close 
            this appender before all the queued events have been sent.
            When closing the appender attempts to wait until all the queued events have been sent, but 
            this will timeout after 30 seconds regardless.</para>
        <para>
            If this appender is being closed because the <see cref="E:System.AppDomain.ProcessExit" />
            event has fired it may not be possible to send all the queued events. During process
            exit the runtime limits the time that a <see cref="E:System.AppDomain.ProcessExit" />
            event handler is allowed to run for. If the runtime terminates the threads before
            the queued events have been sent then they will be lost. To ensure that all events
            are sent the appender must be closed before the application exits. See 
            <see cref="M:log4net.Core.LoggerManager.Shutdown" /> for details on how to shutdown
            log4net programmatically.</para>
      </remarks>
      <seealso cref="T:log4net.Appender.RemotingAppender.IRemoteLoggingSink" />
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Daniel Cazzulino</author>
    </member>
    <member name="T:log4net.Appender.RemotingAppender.IRemoteLoggingSink">
      <summary>
            Interface used to deliver <see cref="T:log4net.Core.LoggingEvent" /> objects to a remote sink.
            </summary>
      <remarks>
            This interface must be implemented by a remoting sink
            if the <see cref="T:log4net.Appender.RemotingAppender" /> is to be used
            to deliver logging events to the sink.
            </remarks>
    </member>
    <member name="M:log4net.Appender.RemotingAppender.IRemoteLoggingSink.LogEvents(log4net.Core.LoggingEvent[])">
      <summary>
            Delivers logging events to the remote sink
            </summary>
      <param name="events">Array of events to log.</param>
      <remarks>
        <para>
            Delivers logging events to the remote sink
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.RemotingAppender.m_sinkUrl">
      <summary>
            The URL of the remote sink.
            </summary>
    </member>
    <member name="F:log4net.Appender.RemotingAppender.m_sinkObj">
      <summary>
            The local proxy (.NET remoting) for the remote logging sink.
            </summary>
    </member>
    <member name="F:log4net.Appender.RemotingAppender.m_queuedCallbackCount">
      <summary>
            The number of queued callbacks currently waiting or executing
            </summary>
    </member>
    <member name="F:log4net.Appender.RemotingAppender.m_workQueueEmptyEvent">
      <summary>
            Event used to signal when there are no queued work items
            </summary>
      <remarks>
            This event is set when there are no queued work items. In this
            state it is safe to close the appender.
            </remarks>
    </member>
    <member name="M:log4net.Appender.RemotingAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.RemotingAppender" /> class.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RemotingAppender.ActivateOptions">
      <summary>
            Initialize the appender based on the options set
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.RemotingAppender.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.RemotingAppender.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.RemotingAppender.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RemotingAppender.SendBuffer(log4net.Core.LoggingEvent[])">
      <summary>
            Send the contents of the buffer to the remote sink.
            </summary>
      <remarks>
            The events are not sent immediately. They are scheduled to be sent
            using a pool thread. The effect is that the send occurs asynchronously.
            This is very important for a number of non obvious reasons. The remoting
            infrastructure will flow thread local variables (stored in the <see cref="T:System.Runtime.Remoting.Messaging.CallContext" />),
            if they are marked as <see cref="T:System.Runtime.Remoting.Messaging.ILogicalThreadAffinative" />, across the 
            remoting boundary. If the server is not contactable then
            the remoting infrastructure will clear the <see cref="T:System.Runtime.Remoting.Messaging.ILogicalThreadAffinative" />
            objects from the <see cref="T:System.Runtime.Remoting.Messaging.CallContext" />. To prevent a logging failure from
            having side effects on the calling application the remoting call must be made
            from a separate thread to the one used by the application. A <see cref="T:System.Threading.ThreadPool" />
            thread is used for this. If no <see cref="T:System.Threading.ThreadPool" /> thread is available then
            the events will block in the thread pool manager until a thread is available.
            </remarks>
      <param name="events">The events to send.</param>
    </member>
    <member name="M:log4net.Appender.RemotingAppender.OnClose">
      <summary>
            Override base class close.
            </summary>
      <remarks>
        <para>
            This method waits while there are queued work items. The events are
            sent asynchronously using <see cref="T:System.Threading.ThreadPool" /> work items. These items
            will be sent once a thread pool thread is available to send them, therefore
            it is possible to close the appender before all the queued events have been
            sent.</para>
        <para>
            This method attempts to wait until all the queued events have been sent, but this 
            method will timeout after 30 seconds regardless.</para>
        <para>
            If the appender is being closed because the <see cref="E:System.AppDomain.ProcessExit" />
            event has fired it may not be possible to send all the queued events. During process
            exit the runtime limits the time that a <see cref="E:System.AppDomain.ProcessExit" />
            event handler is allowed to run for.</para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RemotingAppender.BeginAsyncSend">
      <summary>
            A work item is being queued into the thread pool
            </summary>
    </member>
    <member name="M:log4net.Appender.RemotingAppender.EndAsyncSend">
      <summary>
            A work item from the thread pool has completed
            </summary>
    </member>
    <member name="M:log4net.Appender.RemotingAppender.SendBufferCallback(System.Object)">
      <summary>
            Send the contents of the buffer to the remote sink.
            </summary>
      <remarks>
            This method is designed to be used with the <see cref="T:System.Threading.ThreadPool" />.
            This method expects to be passed an array of <see cref="T:log4net.Core.LoggingEvent" />
            objects in the state param.
            </remarks>
      <param name="state">the logging events to send</param>
    </member>
    <member name="P:log4net.Appender.RemotingAppender.Sink">
      <summary>
            Gets or sets the URL of the well-known object that will accept 
            the logging events.
            </summary>
      <value>
            The well-known URL of the remote sink.
            </value>
      <remarks>
        <para>
            The URL of the remoting sink that will accept logging events.
            The sink must implement the <see cref="T:log4net.Appender.RemotingAppender.IRemoteLoggingSink" />
            interface.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.RollingFileAppender">
      <summary>
            Appender that rolls log files based on size or date or both.
            </summary>
      <remarks>
        <para>
            RollingFileAppender can roll log files based on size or date or both
            depending on the setting of the <see cref="P:log4net.Appender.RollingFileAppender.RollingStyle" /> property.
            When set to <see cref="F:log4net.Appender.RollingFileAppender.RollingMode.Size" /> the log file will be rolled
            once its size exceeds the <see cref="P:log4net.Appender.RollingFileAppender.MaximumFileSize" />.
            When set to <see cref="F:log4net.Appender.RollingFileAppender.RollingMode.Date" /> the log file will be rolled
            once the date boundary specified in the <see cref="P:log4net.Appender.RollingFileAppender.DatePattern" /> property
            is crossed.
            When set to <see cref="F:log4net.Appender.RollingFileAppender.RollingMode.Composite" /> the log file will be
            rolled once the date boundary specified in the <see cref="P:log4net.Appender.RollingFileAppender.DatePattern" /> property
            is crossed, but within a date boundary the file will also be rolled
            once its size exceeds the <see cref="P:log4net.Appender.RollingFileAppender.MaximumFileSize" />.
            When set to <see cref="F:log4net.Appender.RollingFileAppender.RollingMode.Once" /> the log file will be rolled when
            the appender is configured. This effectively means that the log file can be
            rolled once per program execution.
            </para>
        <para>
            A of few additional optional features have been added:
            <list type="bullet"><item>Attach date pattern for current log file <see cref="P:log4net.Appender.RollingFileAppender.StaticLogFileName" /></item><item>Backup number increments for newer files <see cref="P:log4net.Appender.RollingFileAppender.CountDirection" /></item><item>Infinite number of backups by file size <see cref="P:log4net.Appender.RollingFileAppender.MaxSizeRollBackups" /></item></list></para>
        <note>
          <para>
            For large or infinite numbers of backup files a <see cref="P:log4net.Appender.RollingFileAppender.CountDirection" /> 
            greater than zero is highly recommended, otherwise all the backup files need
            to be renamed each time a new backup is created.
            </para>
          <para>
            When Date/Time based rolling is used setting <see cref="P:log4net.Appender.RollingFileAppender.StaticLogFileName" /> 
            to <see langword="true" /> will reduce the number of file renamings to few or none.
            </para>
        </note>
        <note type="caution">
          <para>
            Changing <see cref="P:log4net.Appender.RollingFileAppender.StaticLogFileName" /> or <see cref="P:log4net.Appender.RollingFileAppender.CountDirection" /> without clearing
            the log file directory of backup files will cause unexpected and unwanted side effects.  
            </para>
        </note>
        <para>
            If Date/Time based rolling is enabled this appender will attempt to roll existing files
            in the directory without a Date/Time tag based on the last write date of the base log file.
            The appender only rolls the log file when a message is logged. If Date/Time based rolling 
            is enabled then the appender will not roll the log file at the Date/Time boundary but
            at the point when the next message is logged after the boundary has been crossed.
            </para>
        <para>
            The <see cref="T:log4net.Appender.RollingFileAppender" /> extends the <see cref="T:log4net.Appender.FileAppender" /> and
            has the same behavior when opening the log file.
            The appender will first try to open the file for writing when <see cref="M:log4net.Appender.RollingFileAppender.ActivateOptions" />
            is called. This will typically be during configuration.
            If the file cannot be opened for writing the appender will attempt
            to open the file again each time a message is logged to the appender.
            If the file cannot be opened for writing when a message is logged then
            the message will be discarded by this appender.
            </para>
        <para>
            When rolling a backup file necessitates deleting an older backup file the
            file to be deleted is moved to a temporary name before being deleted.
            </para>
        <note type="caution">
          <para>
            A maximum number of backup files when rolling on date/time boundaries is not supported.
            </para>
        </note>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Aspi Havewala</author>
      <author>Douglas de la Torre</author>
      <author>Edward Smit</author>
    </member>
    <member name="T:log4net.Appender.RollingFileAppender.RollingMode">
      <summary>
            Style of rolling to use
            </summary>
      <remarks>
        <para>
            Style of rolling to use
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.RollingFileAppender.RollPoint">
      <summary>
            The code assumes that the following 'time' constants are in a increasing sequence.
            </summary>
      <remarks>
        <para>
            The code assumes that the following 'time' constants are in a increasing sequence.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.RollingFileAppender.IDateTime">
      <summary>
            This interface is used to supply Date/Time information to the <see cref="T:log4net.Appender.RollingFileAppender" />.
            </summary>
      <remarks>
            This interface is used to supply Date/Time information to the <see cref="T:log4net.Appender.RollingFileAppender" />.
            Used primarily to allow test classes to plug themselves in so they can
            supply test date/times.
            </remarks>
    </member>
    <member name="P:log4net.Appender.RollingFileAppender.IDateTime.Now">
      <summary>
            Gets the <i>current</i> time.
            </summary>
      <value>The <i>current</i> time.</value>
      <remarks>
        <para>
            Gets the <i>current</i> time.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.RollingFileAppender.LocalDateTime">
      <summary>
            Default implementation of <see cref="T:log4net.Appender.RollingFileAppender.IDateTime" /> that returns the current time.
            </summary>
    </member>
    <member name="P:log4net.Appender.RollingFileAppender.LocalDateTime.Now">
      <summary>
            Gets the <b>current</b> time.
            </summary>
      <value>The <b>current</b> time.</value>
      <remarks>
        <para>
            Gets the <b>current</b> time.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.RollingFileAppender.UniversalDateTime">
      <summary>
            Implementation of <see cref="T:log4net.Appender.RollingFileAppender.IDateTime" /> that returns the current time as the coordinated universal time (UTC).
            </summary>
    </member>
    <member name="P:log4net.Appender.RollingFileAppender.UniversalDateTime.Now">
      <summary>
            Gets the <b>current</b> time.
            </summary>
      <value>The <b>current</b> time.</value>
      <remarks>
        <para>
            Gets the <b>current</b> time.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.declaringType">
      <summary>
            The fully qualified type of the RollingFileAppender class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_dateTime">
      <summary>
            This object supplies the current date/time.  Allows test code to plug in
            a method to control this class when testing date/time based rolling. The default
            implementation uses the underlying value of DateTime.Now.
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_datePattern">
      <summary>
            The date pattern. By default, the pattern is set to <c>".yyyy-MM-dd"</c> 
            meaning daily rollover.
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_scheduledFilename">
      <summary>
            The actual formatted filename that is currently being written to
            or will be the file transferred to on roll over
            (based on staticLogFileName).
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_nextCheck">
      <summary>
            The timestamp when we shall next recompute the filename.
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_now">
      <summary>
            Holds date of last roll over
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_rollPoint">
      <summary>
            The type of rolling done
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_maxFileSize">
      <summary>
            The default maximum file size is 10MB
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_maxSizeRollBackups">
      <summary>
            There is zero backup files by default
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_curSizeRollBackups">
      <summary>
            How many sized based backups have been made so far
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_countDirection">
      <summary>
            The rolling file count direction. 
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_rollingStyle">
      <summary>
            The rolling mode used in this appender.
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_rollDate">
      <summary>
            Cache flag set if we are rolling by date.
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_rollSize">
      <summary>
            Cache flag set if we are rolling by size.
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_staticLogFileName">
      <summary>
            Value indicating whether to always log to the same file.
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_preserveLogFileNameExtension">
      <summary>
            Value indicating whether to preserve the file name extension when rolling.
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_baseFileName">
      <summary>
            FileName provided in configuration.  Used for rolling properly
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.s_date1970">
      <summary>
            The 1st of January 1970 in UTC
            </summary>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.RollingFileAppender" /> class.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.SetQWForFiles(System.IO.TextWriter)">
      <summary>
            Sets the quiet writer being used.
            </summary>
      <remarks>
            This method can be overridden by sub classes.
            </remarks>
      <param name="writer">the writer to set</param>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            Write out a logging event.
            </summary>
      <param name="loggingEvent">the event to write to file.</param>
      <remarks>
        <para>
            Handles append time behavior for RollingFileAppender.  This checks
            if a roll over either by date (checked first) or time (checked second)
            is need and then appends to the file last.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.Append(log4net.Core.LoggingEvent[])">
      <summary>
            Write out an array of logging events.
            </summary>
      <param name="loggingEvents">the events to write to file.</param>
      <remarks>
        <para>
            Handles append time behavior for RollingFileAppender.  This checks
            if a roll over either by date (checked first) or time (checked second)
            is need and then appends to the file last.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.AdjustFileBeforeAppend">
      <summary>
            Performs any required rolling before outputting the next event
            </summary>
      <remarks>
        <para>
            Handles append time behavior for RollingFileAppender.  This checks
            if a roll over either by date (checked first) or time (checked second)
            is need and then appends to the file last.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.OpenFile(System.String,System.Boolean)">
      <summary>
            Creates and opens the file for logging.  If <see cref="P:log4net.Appender.RollingFileAppender.StaticLogFileName" />
            is false then the fully qualified name is determined and used.
            </summary>
      <param name="fileName">the name of the file to open</param>
      <param name="append">true to append to existing file</param>
      <remarks>
        <para>This method will ensure that the directory structure
            for the <paramref name="fileName" /> specified exists.</para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.GetNextOutputFileName(System.String)">
      <summary>
            Get the current output file name
            </summary>
      <param name="fileName">the base file name</param>
      <returns>the output file name</returns>
      <remarks>
            The output file name is based on the base fileName specified.
            If <see cref="P:log4net.Appender.RollingFileAppender.StaticLogFileName" /> is set then the output 
            file name is the same as the base file passed in. Otherwise
            the output file depends on the date pattern, on the count
            direction or both.
            </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.DetermineCurSizeRollBackups">
      <summary>
            Determines curSizeRollBackups (only within the current roll point)
            </summary>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.GetWildcardPatternForFile(System.String)">
      <summary>
            Generates a wildcard pattern that can be used to find all files
            that are similar to the base file name.
            </summary>
      <param name="baseFileName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.GetExistingFiles(System.String)">
      <summary>
            Builds a list of filenames for all files matching the base filename plus a file
            pattern.
            </summary>
      <param name="baseFilePath">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.RollOverIfDateBoundaryCrossing">
      <summary>
            Initiates a roll over if needed for crossing a date boundary since the last run.
            </summary>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.ExistingInit">
      <summary>
            Initializes based on existing conditions at time of <see cref="M:log4net.Appender.RollingFileAppender.ActivateOptions" />.
            </summary>
      <remarks>
        <para>
            Initializes based on existing conditions at time of <see cref="M:log4net.Appender.RollingFileAppender.ActivateOptions" />.
            The following is done
            <list type="bullet"><item>determine curSizeRollBackups (only within the current roll point)</item><item>initiates a roll over if needed for crossing a date boundary since the last run.</item></list></para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.InitializeFromOneFile(System.String,System.String)">
      <summary>
            Does the work of bumping the 'current' file counter higher
            to the highest count when an incremental file name is seen.
            The highest count is either the first file (when count direction
            is greater than 0) or the last file (when count direction less than 0).
            In either case, we want to know the highest count that is present.
            </summary>
      <param name="baseFile">
      </param>
      <param name="curFileName">
      </param>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.GetBackUpIndex(System.String)">
      <summary>
            Attempts to extract a number from the end of the file name that indicates
            the number of the times the file has been rolled over.
            </summary>
      <remarks>
            Certain date pattern extensions like yyyyMMdd will be parsed as valid backup indexes.
            </remarks>
      <param name="curFileName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.InitializeRollBackups(System.String,System.Collections.ArrayList)">
      <summary>
            Takes a list of files and a base file name, and looks for 
            'incremented' versions of the base file.  Bumps the max
            count up to the highest count seen.
            </summary>
      <param name="baseFile">
      </param>
      <param name="arrayFiles">
      </param>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.ComputeCheckPeriod(System.String)">
      <summary>
            Calculates the RollPoint for the datePattern supplied.
            </summary>
      <param name="datePattern">the date pattern to calculate the check period for</param>
      <returns>The RollPoint that is most accurate for the date pattern supplied</returns>
      <remarks>
            Essentially the date pattern is examined to determine what the
            most suitable roll point is. The roll point chosen is the roll point
            with the smallest period that can be detected using the date pattern
            supplied. i.e. if the date pattern only outputs the year, month, day 
            and hour then the smallest roll point that can be detected would be
            and hourly roll point as minutes could not be detected.
            </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.ActivateOptions">
      <summary>
            Initialize the appender based on the options set
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.RollingFileAppender.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.RollingFileAppender.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.RollingFileAppender.ActivateOptions" /> must be called again.
            </para>
        <para>
            Sets initial conditions including date/time roll over information, first check,
            scheduledFilename, and calls <see cref="M:log4net.Appender.RollingFileAppender.ExistingInit" /> to initialize
            the current number of backups.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.CombinePath(System.String,System.String)">
      <summary>
      </summary>
      <param name="path1">
      </param>
      <param name="path2">.1, .2, .3, etc.</param>
      <returns>
      </returns>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.RollOverTime(System.Boolean)">
      <summary>
            Rollover the file(s) to date/time tagged file(s).
            </summary>
      <param name="fileIsOpen">set to true if the file to be rolled is currently open</param>
      <remarks>
        <para>
            Rollover the file(s) to date/time tagged file(s).
            Resets curSizeRollBackups. 
            If fileIsOpen is set then the new file is opened (through SafeOpenFile).
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.RollFile(System.String,System.String)">
      <summary>
            Renames file <paramref name="fromFile" /> to file <paramref name="toFile" />.
            </summary>
      <param name="fromFile">Name of existing file to roll.</param>
      <param name="toFile">New name for file.</param>
      <remarks>
        <para>
            Renames file <paramref name="fromFile" /> to file <paramref name="toFile" />. It
            also checks for existence of target file and deletes if it does.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.FileExists(System.String)">
      <summary>
            Test if a file exists at a specified path
            </summary>
      <param name="path">the path to the file</param>
      <returns>true if the file exists</returns>
      <remarks>
        <para>
            Test if a file exists at a specified path
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.DeleteFile(System.String)">
      <summary>
            Deletes the specified file if it exists.
            </summary>
      <param name="fileName">The file to delete.</param>
      <remarks>
        <para>
            Delete a file if is exists.
            The file is first moved to a new filename then deleted.
            This allows the file to be removed even when it cannot
            be deleted, but it still can be moved.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.RollOverSize">
      <summary>
            Implements file roll base on file size.
            </summary>
      <remarks>
        <para>
            If the maximum number of size based backups is reached
            (<c>curSizeRollBackups == maxSizeRollBackups</c>) then the oldest
            file is deleted -- its index determined by the sign of countDirection.
            If <c>countDirection</c> &lt; 0, then files
            {<c>File.1</c>, ..., <c>File.curSizeRollBackups -1</c>}
            are renamed to {<c>File.2</c>, ...,
            <c>File.curSizeRollBackups</c>}. Moreover, <c>File</c> is
            renamed <c>File.1</c> and closed.
            </para>
        <para>
            A new file is created to receive further log output.
            </para>
        <para>
            If <c>maxSizeRollBackups</c> is equal to zero, then the
            <c>File</c> is truncated with no backup files created.
            </para>
        <para>
            If <c>maxSizeRollBackups</c> &lt; 0, then <c>File</c> is
            renamed if needed and no files are deleted.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.RollOverRenameFiles(System.String)">
      <summary>
            Implements file roll.
            </summary>
      <param name="baseFileName">the base name to rename</param>
      <remarks>
        <para>
            If the maximum number of size based backups is reached
            (<c>curSizeRollBackups == maxSizeRollBackups</c>) then the oldest
            file is deleted -- its index determined by the sign of countDirection.
            If <c>countDirection</c> &lt; 0, then files
            {<c>File.1</c>, ..., <c>File.curSizeRollBackups -1</c>}
            are renamed to {<c>File.2</c>, ...,
            <c>File.curSizeRollBackups</c>}. 
            </para>
        <para>
            If <c>maxSizeRollBackups</c> is equal to zero, then the
            <c>File</c> is truncated with no backup files created.
            </para>
        <para>
            If <c>maxSizeRollBackups</c> &lt; 0, then <c>File</c> is
            renamed if needed and no files are deleted.
            </para>
        <para>
            This is called by <see cref="M:log4net.Appender.RollingFileAppender.RollOverSize" /> to rename the files.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.NextCheckDate(System.DateTime,log4net.Appender.RollingFileAppender.RollPoint)">
      <summary>
            Get the start time of the next window for the current rollpoint
            </summary>
      <param name="currentDateTime">the current date</param>
      <param name="rollPoint">the type of roll point we are working with</param>
      <returns>the start time for the next roll point an interval after the currentDateTime date</returns>
      <remarks>
        <para>
            Returns the date of the next roll point after the currentDateTime date passed to the method.
            </para>
        <para>
            The basic strategy is to subtract the time parts that are less significant
            than the rollpoint from the current time. This should roll the time back to
            the start of the time window for the current rollpoint. Then we add 1 window
            worth of time and get the start time of the next window for the rollpoint.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.RollingFileAppender.DateTimeStrategy">
      <summary>
            Gets or sets the strategy for determining the current date and time. The default
            implementation is to use LocalDateTime which internally calls through to DateTime.Now. 
            DateTime.UtcNow may be used on frameworks newer than .NET 1.0 by specifying
            <see cref="T:log4net.Appender.RollingFileAppender.UniversalDateTime" />.
            </summary>
      <value>
            An implementation of the <see cref="T:log4net.Appender.RollingFileAppender.IDateTime" /> interface which returns the current date and time.
            </value>
      <remarks>
        <para>
            Gets or sets the <see cref="T:log4net.Appender.RollingFileAppender.IDateTime" /> used to return the current date and time.
            </para>
        <para>
            There are two built strategies for determining the current date and time, 
            <see cref="T:log4net.Appender.RollingFileAppender.LocalDateTime" />
            and <see cref="T:log4net.Appender.RollingFileAppender.UniversalDateTime" />.
            </para>
        <para>
            The default strategy is <see cref="T:log4net.Appender.RollingFileAppender.LocalDateTime" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.RollingFileAppender.DatePattern">
      <summary>
            Gets or sets the date pattern to be used for generating file names
            when rolling over on date.
            </summary>
      <value>
            The date pattern to be used for generating file names when rolling 
            over on date.
            </value>
      <remarks>
        <para>
            Takes a string in the same format as expected by 
            <see cref="T:log4net.DateFormatter.SimpleDateFormatter" />.
            </para>
        <para>
            This property determines the rollover schedule when rolling over
            on date.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.RollingFileAppender.MaxSizeRollBackups">
      <summary>
            Gets or sets the maximum number of backup files that are kept before
            the oldest is erased.
            </summary>
      <value>
            The maximum number of backup files that are kept before the oldest is
            erased.
            </value>
      <remarks>
        <para>
            If set to zero, then there will be no backup files and the log file 
            will be truncated when it reaches <see cref="P:log4net.Appender.RollingFileAppender.MaxFileSize" />.  
            </para>
        <para>
            If a negative number is supplied then no deletions will be made.  Note 
            that this could result in very slow performance as a large number of 
            files are rolled over unless <see cref="P:log4net.Appender.RollingFileAppender.CountDirection" /> is used.
            </para>
        <para>
            The maximum applies to <b>each</b> time based group of files and 
            <b>not</b> the total.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.RollingFileAppender.MaxFileSize">
      <summary>
            Gets or sets the maximum size that the output file is allowed to reach
            before being rolled over to backup files.
            </summary>
      <value>
            The maximum size in bytes that the output file is allowed to reach before being 
            rolled over to backup files.
            </value>
      <remarks>
        <para>
            This property is equivalent to <see cref="P:log4net.Appender.RollingFileAppender.MaximumFileSize" /> except
            that it is required for differentiating the setter taking a
            <see cref="T:System.Int64" /> argument from the setter taking a <see cref="T:System.String" /> 
            argument.
            </para>
        <para>
            The default maximum file size is 10MB (10*1024*1024).
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.RollingFileAppender.MaximumFileSize">
      <summary>
            Gets or sets the maximum size that the output file is allowed to reach
            before being rolled over to backup files.
            </summary>
      <value>
            The maximum size that the output file is allowed to reach before being 
            rolled over to backup files.
            </value>
      <remarks>
        <para>
            This property allows you to specify the maximum size with the
            suffixes "KB", "MB" or "GB" so that the size is interpreted being 
            expressed respectively in kilobytes, megabytes or gigabytes. 
            </para>
        <para>
            For example, the value "10KB" will be interpreted as 10240 bytes.
            </para>
        <para>
            The default maximum file size is 10MB.
            </para>
        <para>
            If you have the option to set the maximum file size programmatically
            consider using the <see cref="P:log4net.Appender.RollingFileAppender.MaxFileSize" /> property instead as this
            allows you to set the size in bytes as a <see cref="T:System.Int64" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.RollingFileAppender.CountDirection">
      <summary>
            Gets or sets the rolling file count direction. 
            </summary>
      <value>
            The rolling file count direction.
            </value>
      <remarks>
        <para>
            Indicates if the current file is the lowest numbered file or the
            highest numbered file.
            </para>
        <para>
            By default newer files have lower numbers (<see cref="P:log4net.Appender.RollingFileAppender.CountDirection" /> &lt; 0),
            i.e. log.1 is most recent, log.5 is the 5th backup, etc...
            </para>
        <para>
          <see cref="P:log4net.Appender.RollingFileAppender.CountDirection" /> &gt;= 0 does the opposite i.e.
            log.1 is the first backup made, log.5 is the 5th backup made, etc.
            For infinite backups use <see cref="P:log4net.Appender.RollingFileAppender.CountDirection" /> &gt;= 0 to reduce 
            rollover costs.
            </para>
        <para>The default file count direction is -1.</para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.RollingFileAppender.RollingStyle">
      <summary>
            Gets or sets the rolling style.
            </summary>
      <value>The rolling style.</value>
      <remarks>
        <para>
            The default rolling style is <see cref="F:log4net.Appender.RollingFileAppender.RollingMode.Composite" />.
            </para>
        <para>
            When set to <see cref="F:log4net.Appender.RollingFileAppender.RollingMode.Once" /> this appender's
            <see cref="P:log4net.Appender.FileAppender.AppendToFile" /> property is set to <c>false</c>, otherwise
            the appender would append to a single file rather than rolling
            the file each time it is opened.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.RollingFileAppender.PreserveLogFileNameExtension">
      <summary>
            Gets or sets a value indicating whether to preserve the file name extension when rolling.
            </summary>
      <value>
        <c>true</c> if the file name extension should be preserved.
            </value>
      <remarks>
        <para>
            By default file.log is rolled to file.log.yyyy-MM-dd or file.log.curSizeRollBackup.
            However, under Windows the new file name will loose any program associations as the
            extension is changed. Optionally file.log can be renamed to file.yyyy-MM-dd.log or
            file.curSizeRollBackup.log to maintain any program associations.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.RollingFileAppender.StaticLogFileName">
      <summary>
            Gets or sets a value indicating whether to always log to
            the same file.
            </summary>
      <value>
        <c>true</c> if always should be logged to the same file, otherwise <c>false</c>.
            </value>
      <remarks>
        <para>
            By default file.log is always the current file.  Optionally
            file.log.yyyy-mm-dd for current formatted datePattern can by the currently
            logging file (or file.log.curSizeRollBackup or even
            file.log.yyyy-mm-dd.curSizeRollBackup).
            </para>
        <para>
            This will make time based rollovers with a large number of backups 
            much faster as the appender it won't have to rename all the backups!
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.SmtpAppender">
      <summary>
            Send an e-mail when a specific logging event occurs, typically on errors 
            or fatal errors.
            </summary>
      <remarks>
        <para>
            The number of logging events delivered in this e-mail depend on
            the value of <see cref="P:log4net.Appender.BufferingAppenderSkeleton.BufferSize" /> option. The
            <see cref="T:log4net.Appender.SmtpAppender" /> keeps only the last
            <see cref="P:log4net.Appender.BufferingAppenderSkeleton.BufferSize" /> logging events in its 
            cyclic buffer. This keeps memory requirements at a reasonable level while 
            still delivering useful application context.
            </para>
        <note type="caution">
            Authentication and setting the server Port are only available on the MS .NET 1.1 runtime.
            For these features to be enabled you need to ensure that you are using a version of
            the log4net assembly that is built against the MS .NET 1.1 framework and that you are
            running the your application on the MS .NET 1.1 runtime. On all other platforms only sending
            unauthenticated messages to a server listening on port 25 (the default) is supported.
            </note>
        <para>
            Authentication is supported by setting the <see cref="P:log4net.Appender.SmtpAppender.Authentication" /> property to
            either <see cref="F:log4net.Appender.SmtpAppender.SmtpAuthentication.Basic" /> or <see cref="F:log4net.Appender.SmtpAppender.SmtpAuthentication.Ntlm" />.
            If using <see cref="F:log4net.Appender.SmtpAppender.SmtpAuthentication.Basic" /> authentication then the <see cref="P:log4net.Appender.SmtpAppender.Username" />
            and <see cref="P:log4net.Appender.SmtpAppender.Password" /> properties must also be set.
            </para>
        <para>
            To set the SMTP server port use the <see cref="P:log4net.Appender.SmtpAppender.Port" /> property. The default port is 25.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="T:log4net.Appender.SmtpAppender.SmtpAuthentication">
      <summary>
            Values for the <see cref="P:log4net.Appender.SmtpAppender.Authentication" /> property.
            </summary>
      <remarks>
        <para>
            SMTP authentication modes.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.SmtpAppender.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Default constructor
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.SmtpAppender.SendBuffer(log4net.Core.LoggingEvent[])">
      <summary>
            Sends the contents of the cyclic buffer as an e-mail message.
            </summary>
      <param name="events">The logging events to send.</param>
    </member>
    <member name="M:log4net.Appender.SmtpAppender.SendEmail(System.String)">
      <summary>
            Send the email message
            </summary>
      <param name="messageBody">the body text to include in the mail</param>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.To">
      <summary>
            Gets or sets a comma- or semicolon-delimited list of recipient e-mail addresses (use semicolon on .NET 1.1 and comma for later versions).
            </summary>
      <value>
        <para>
            For .NET 1.1 (System.Web.Mail): A semicolon-delimited list of e-mail addresses.
            </para>
        <para>
            For .NET 2.0 (System.Net.Mail): A comma-delimited list of e-mail addresses.
            </para>
      </value>
      <remarks>
        <para>
            For .NET 1.1 (System.Web.Mail): A semicolon-delimited list of e-mail addresses.
            </para>
        <para>
            For .NET 2.0 (System.Net.Mail): A comma-delimited list of e-mail addresses.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.Cc">
      <summary>
            Gets or sets a comma- or semicolon-delimited list of recipient e-mail addresses 
            that will be carbon copied (use semicolon on .NET 1.1 and comma for later versions).
            </summary>
      <value>
        <para>
            For .NET 1.1 (System.Web.Mail): A semicolon-delimited list of e-mail addresses.
            </para>
        <para>
            For .NET 2.0 (System.Net.Mail): A comma-delimited list of e-mail addresses.
            </para>
      </value>
      <remarks>
        <para>
            For .NET 1.1 (System.Web.Mail): A semicolon-delimited list of e-mail addresses.
            </para>
        <para>
            For .NET 2.0 (System.Net.Mail): A comma-delimited list of e-mail addresses.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.Bcc">
      <summary>
            Gets or sets a semicolon-delimited list of recipient e-mail addresses
            that will be blind carbon copied.
            </summary>
      <value>
            A semicolon-delimited list of e-mail addresses.
            </value>
      <remarks>
        <para>
            A semicolon-delimited list of recipient e-mail addresses.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.From">
      <summary>
            Gets or sets the e-mail address of the sender.
            </summary>
      <value>
            The e-mail address of the sender.
            </value>
      <remarks>
        <para>
            The e-mail address of the sender.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.Subject">
      <summary>
            Gets or sets the subject line of the e-mail message.
            </summary>
      <value>
            The subject line of the e-mail message.
            </value>
      <remarks>
        <para>
            The subject line of the e-mail message.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.SmtpHost">
      <summary>
            Gets or sets the name of the SMTP relay mail server to use to send 
            the e-mail messages.
            </summary>
      <value>
            The name of the e-mail relay server. If SmtpServer is not set, the 
            name of the local SMTP server is used.
            </value>
      <remarks>
        <para>
            The name of the e-mail relay server. If SmtpServer is not set, the 
            name of the local SMTP server is used.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.LocationInfo">
      <summary>
            Obsolete
            </summary>
      <remarks>
            Use the BufferingAppenderSkeleton Fix methods instead 
            </remarks>
      <remarks>
        <para>
            Obsolete property.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.Authentication">
      <summary>
            The mode to use to authentication with the SMTP server
            </summary>
      <remarks>
        <note type="caution">Authentication is only available on the MS .NET 1.1 runtime.</note>
        <para>
            Valid Authentication mode values are: <see cref="F:log4net.Appender.SmtpAppender.SmtpAuthentication.None" />, 
            <see cref="F:log4net.Appender.SmtpAppender.SmtpAuthentication.Basic" />, and <see cref="F:log4net.Appender.SmtpAppender.SmtpAuthentication.Ntlm" />. 
            The default value is <see cref="F:log4net.Appender.SmtpAppender.SmtpAuthentication.None" />. When using 
            <see cref="F:log4net.Appender.SmtpAppender.SmtpAuthentication.Basic" /> you must specify the <see cref="P:log4net.Appender.SmtpAppender.Username" /> 
            and <see cref="P:log4net.Appender.SmtpAppender.Password" /> to use to authenticate.
            When using <see cref="F:log4net.Appender.SmtpAppender.SmtpAuthentication.Ntlm" /> the Windows credentials for the current
            thread, if impersonating, or the process will be used to authenticate. 
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.Username">
      <summary>
            The username to use to authenticate with the SMTP server
            </summary>
      <remarks>
        <note type="caution">Authentication is only available on the MS .NET 1.1 runtime.</note>
        <para>
            A <see cref="P:log4net.Appender.SmtpAppender.Username" /> and <see cref="P:log4net.Appender.SmtpAppender.Password" /> must be specified when 
            <see cref="P:log4net.Appender.SmtpAppender.Authentication" /> is set to <see cref="F:log4net.Appender.SmtpAppender.SmtpAuthentication.Basic" />, 
            otherwise the username will be ignored. 
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.Password">
      <summary>
            The password to use to authenticate with the SMTP server
            </summary>
      <remarks>
        <note type="caution">Authentication is only available on the MS .NET 1.1 runtime.</note>
        <para>
            A <see cref="P:log4net.Appender.SmtpAppender.Username" /> and <see cref="P:log4net.Appender.SmtpAppender.Password" /> must be specified when 
            <see cref="P:log4net.Appender.SmtpAppender.Authentication" /> is set to <see cref="F:log4net.Appender.SmtpAppender.SmtpAuthentication.Basic" />, 
            otherwise the password will be ignored. 
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.Port">
      <summary>
            The port on which the SMTP server is listening
            </summary>
      <remarks>
        <note type="caution">Server Port is only available on the MS .NET 1.1 runtime.</note>
        <para>
            The port on which the SMTP server is listening. The default
            port is <c>25</c>. The Port can only be changed when running on
            the MS .NET 1.1 runtime.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.Priority">
      <summary>
            Gets or sets the priority of the e-mail message
            </summary>
      <value>
            One of the <see cref="T:System.Net.Mail.MailPriority" /> values.
            </value>
      <remarks>
        <para>
            Sets the priority of the e-mails generated by this
            appender. The default priority is <see cref="F:System.Net.Mail.MailPriority.Normal" />.
            </para>
        <para>
            If you are using this appender to report errors then
            you may want to set the priority to <see cref="F:System.Net.Mail.MailPriority.High" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.EnableSsl">
      <summary>
            Enable or disable use of SSL when sending e-mail message
            </summary>
      <remarks>
            This is available on MS .NET 2.0 runtime and higher
            </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.ReplyTo">
      <summary>
            Gets or sets the reply-to e-mail address.
            </summary>
      <remarks>
            This is available on MS .NET 2.0 runtime and higher
            </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.SubjectEncoding">
      <summary>
            Gets or sets the subject encoding to be used.
            </summary>
      <remarks>
            The default encoding is the operating system's current ANSI codepage.
            </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.BodyEncoding">
      <summary>
            Gets or sets the body encoding to be used.
            </summary>
      <remarks>
            The default encoding is the operating system's current ANSI codepage.
            </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.SmtpPickupDirAppender">
      <summary>
            Send an email when a specific logging event occurs, typically on errors 
            or fatal errors. Rather than sending via smtp it writes a file into the
            directory specified by <see cref="P:log4net.Appender.SmtpPickupDirAppender.PickupDir" />. This allows services such
            as the IIS SMTP agent to manage sending the messages.
            </summary>
      <remarks>
        <para>
            The configuration for this appender is identical to that of the <c>SMTPAppender</c>,
            except that instead of specifying the <c>SMTPAppender.SMTPHost</c> you specify
            <see cref="P:log4net.Appender.SmtpPickupDirAppender.PickupDir" />.
            </para>
        <para>
            The number of logging events delivered in this e-mail depend on
            the value of <see cref="P:log4net.Appender.BufferingAppenderSkeleton.BufferSize" /> option. The
            <see cref="T:log4net.Appender.SmtpPickupDirAppender" /> keeps only the last
            <see cref="P:log4net.Appender.BufferingAppenderSkeleton.BufferSize" /> logging events in its 
            cyclic buffer. This keeps memory requirements at a reasonable level while 
            still delivering useful application context.
            </para>
      </remarks>
      <author>Niall Daley</author>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Appender.SmtpPickupDirAppender.m_securityContext">
      <summary>
            The security context to use for privileged calls
            </summary>
    </member>
    <member name="M:log4net.Appender.SmtpPickupDirAppender.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Default constructor
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.SmtpPickupDirAppender.SendBuffer(log4net.Core.LoggingEvent[])">
      <summary>
            Sends the contents of the cyclic buffer as an e-mail message.
            </summary>
      <param name="events">The logging events to send.</param>
      <remarks>
        <para>
            Sends the contents of the cyclic buffer as an e-mail message.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.SmtpPickupDirAppender.ActivateOptions">
      <summary>
            Activate the options on this appender. 
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.SmtpPickupDirAppender.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.SmtpPickupDirAppender.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.SmtpPickupDirAppender.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.SmtpPickupDirAppender.ConvertToFullPath(System.String)">
      <summary>
            Convert a path into a fully qualified path.
            </summary>
      <param name="path">The path to convert.</param>
      <returns>The fully qualified path.</returns>
      <remarks>
        <para>
            Converts the path specified to a fully
            qualified path. If the path is relative it is
            taken as relative from the application base 
            directory.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpPickupDirAppender.To">
      <summary>
            Gets or sets a semicolon-delimited list of recipient e-mail addresses.
            </summary>
      <value>
            A semicolon-delimited list of e-mail addresses.
            </value>
      <remarks>
        <para>
            A semicolon-delimited list of e-mail addresses.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpPickupDirAppender.From">
      <summary>
            Gets or sets the e-mail address of the sender.
            </summary>
      <value>
            The e-mail address of the sender.
            </value>
      <remarks>
        <para>
            The e-mail address of the sender.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpPickupDirAppender.Subject">
      <summary>
            Gets or sets the subject line of the e-mail message.
            </summary>
      <value>
            The subject line of the e-mail message.
            </value>
      <remarks>
        <para>
            The subject line of the e-mail message.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpPickupDirAppender.PickupDir">
      <summary>
            Gets or sets the path to write the messages to.
            </summary>
      <remarks>
        <para>
            Gets or sets the path to write the messages to. This should be the same
            as that used by the agent sending the messages.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpPickupDirAppender.SecurityContext">
      <summary>
            Gets or sets the <see cref="P:log4net.Appender.SmtpPickupDirAppender.SecurityContext" /> used to write to the pickup directory.
            </summary>
      <value>
            The <see cref="P:log4net.Appender.SmtpPickupDirAppender.SecurityContext" /> used to write to the pickup directory.
            </value>
      <remarks>
        <para>
            Unless a <see cref="P:log4net.Appender.SmtpPickupDirAppender.SecurityContext" /> specified here for this appender
            the <see cref="P:log4net.Core.SecurityContextProvider.DefaultProvider" /> is queried for the
            security context to use. The default behavior is to use the security context
            of the current thread.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpPickupDirAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.TelnetAppender">
      <summary>
            Appender that allows clients to connect via Telnet to receive log messages
            </summary>
      <remarks>
        <para>
            The TelnetAppender accepts socket connections and streams logging messages
            back to the client.  
            The output is provided in a telnet-friendly way so that a log can be monitored 
            over a TCP/IP socket.
            This allows simple remote monitoring of application logging.
            </para>
        <para>
            The default <see cref="P:log4net.Appender.TelnetAppender.Port" /> is 23 (the telnet port).
            </para>
      </remarks>
      <author>Keith Long</author>
      <author>Nicko Cadell</author>
    </member>
    <member name="T:log4net.Appender.TelnetAppender.SocketHandler">
      <summary>
            Helper class to manage connected clients
            </summary>
      <remarks>
        <para>
            The SocketHandler class is used to accept connections from
            clients.  It is threaded so that clients can connect/disconnect
            asynchronously.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.TelnetAppender.SocketHandler.SocketClient">
      <summary>
            Class that represents a client connected to this handler
            </summary>
      <remarks>
        <para>
            Class that represents a client connected to this handler
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.SocketHandler.SocketClient.#ctor(System.Net.Sockets.Socket)">
      <summary>
            Create this <see cref="T:log4net.Appender.TelnetAppender.SocketHandler.SocketClient" /> for the specified <see cref="T:System.Net.Sockets.Socket" /></summary>
      <param name="socket">the client's socket</param>
      <remarks>
        <para>
            Opens a stream writer on the socket.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.SocketHandler.SocketClient.Send(System.String)">
      <summary>
            Write a string to the client
            </summary>
      <param name="message">string to send</param>
      <remarks>
        <para>
            Write a string to the client
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.SocketHandler.SocketClient.Dispose">
      <summary>
            Cleanup the clients connection
            </summary>
      <remarks>
        <para>
            Close the socket connection.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.SocketHandler.#ctor(System.Int32)">
      <summary>
            Opens a new server port on <paramref ref="port" /></summary>
      <param name="port">the local port to listen on for connections</param>
      <remarks>
        <para>
            Creates a socket handler on the specified local server port.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.SocketHandler.Send(System.String)">
      <summary>
            Sends a string message to each of the connected clients
            </summary>
      <param name="message">the text to send</param>
      <remarks>
        <para>
            Sends a string message to each of the connected clients
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.SocketHandler.AddClient(log4net.Appender.TelnetAppender.SocketHandler.SocketClient)">
      <summary>
            Add a client to the internal clients list
            </summary>
      <param name="client">client to add</param>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.SocketHandler.RemoveClient(log4net.Appender.TelnetAppender.SocketHandler.SocketClient)">
      <summary>
            Remove a client from the internal clients list
            </summary>
      <param name="client">client to remove</param>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.SocketHandler.OnConnect(System.IAsyncResult)">
      <summary>
            Callback used to accept a connection on the server socket
            </summary>
      <param name="asyncResult">The result of the asynchronous operation</param>
      <remarks>
        <para>
            On connection adds to the list of connections 
            if there are two many open connections you will be disconnected
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.SocketHandler.Dispose">
      <summary>
            Close all network connections
            </summary>
      <remarks>
        <para>
            Make sure we close all network connections
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.TelnetAppender.SocketHandler.HasConnections">
      <summary>
            Test if this handler has active connections
            </summary>
      <value>
        <c>true</c> if this handler has active connections
            </value>
      <remarks>
        <para>
            This property will be <c>true</c> while this handler has
            active connections, that is at least one connection that 
            the handler will attempt to send a message to.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.TelnetAppender.declaringType">
      <summary>
            The fully qualified type of the TelnetAppender class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Default constructor
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.OnClose">
      <summary>
            Overrides the parent method to close the socket handler
            </summary>
      <remarks>
        <para>
            Closes all the outstanding connections.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.ActivateOptions">
      <summary>
            Initialize the appender based on the options set.
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.TelnetAppender.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.TelnetAppender.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.TelnetAppender.ActivateOptions" /> must be called again.
            </para>
        <para>
            Create the socket handler and wait for connections
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            Writes the logging event to each connected client.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Writes the logging event to each connected client.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.TelnetAppender.Port">
      <summary>
            Gets or sets the TCP port number on which this <see cref="T:log4net.Appender.TelnetAppender" /> will listen for connections.
            </summary>
      <value>
            An integer value in the range <see cref="F:System.Net.IPEndPoint.MinPort" /> to <see cref="F:System.Net.IPEndPoint.MaxPort" /> 
            indicating the TCP port number on which this <see cref="T:log4net.Appender.TelnetAppender" /> will listen for connections.
            </value>
      <remarks>
        <para>
            The default value is 23 (the telnet port).
            </para>
      </remarks>
      <exception cref="T:System.ArgumentOutOfRangeException">The value specified is less than <see cref="F:System.Net.IPEndPoint.MinPort" /> 
            or greater than <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
    </member>
    <member name="P:log4net.Appender.TelnetAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.TraceAppender">
      <summary>
            Appends log events to the <see cref="T:System.Diagnostics.Trace" /> system.
            </summary>
      <remarks>
        <para>
            The application configuration file can be used to control what listeners 
            are actually used. See the MSDN documentation for the 
            <see cref="T:System.Diagnostics.Trace" /> class for details on configuring the
            trace system.
            </para>
        <para>
            Events are written using the <c>System.Diagnostics.Trace.Write(string,string)</c>
            method. The event's logger name is the default value for the category parameter 
            of the Write method. 
            </para>
        <para>
          <b>Compact Framework</b>
          <br />
            The Compact Framework does not support the <see cref="T:System.Diagnostics.Trace" />
            class for any operation except <c>Assert</c>. When using the Compact Framework this
            appender will write to the <see cref="T:System.Diagnostics.Debug" /> system rather than
            the Trace system. This appender will therefore behave like the <see cref="T:log4net.Appender.DebugAppender" />.
            </para>
      </remarks>
      <author>Douglas de la Torre</author>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Ron Grabowski</author>
    </member>
    <member name="F:log4net.Appender.TraceAppender.m_immediateFlush">
      <summary>
            Immediate flush means that the underlying writer or output stream
            will be flushed at the end of each append operation.
            </summary>
      <remarks>
        <para>
            Immediate flush is slower but ensures that each append request is 
            actually written. If <see cref="P:log4net.Appender.TraceAppender.ImmediateFlush" /> is set to
            <c>false</c>, then there is a good chance that the last few
            logs events are not actually written to persistent media if and
            when the application crashes.
            </para>
        <para>
            The default value is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.TraceAppender.m_category">
      <summary>
            Defaults to %logger
            </summary>
    </member>
    <member name="M:log4net.Appender.TraceAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.TraceAppender" />.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TraceAppender.#ctor(log4net.Layout.ILayout)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.TraceAppender" /> 
            with a specified layout.
            </summary>
      <param name="layout">The layout to use with this appender.</param>
      <remarks>
        <para>
            Obsolete constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TraceAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            Writes the logging event to the <see cref="T:System.Diagnostics.Trace" /> system.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Writes the logging event to the <see cref="T:System.Diagnostics.Trace" /> system.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.TraceAppender.ImmediateFlush">
      <summary>
            Gets or sets a value that indicates whether the appender will 
            flush at the end of each write.
            </summary>
      <remarks>
        <para>The default behavior is to flush at the end of each 
            write. If the option is set to<c>false</c>, then the underlying 
            stream can defer writing to physical medium to a later time. 
            </para>
        <para>
            Avoiding the flush operation at the end of each append results 
            in a performance gain of 10 to 20 percent. However, there is safety
            trade-off involved in skipping flushing. Indeed, when flushing is
            skipped, then it is likely that the last few log events will not
            be recorded on disk when the application exits. This is a high
            price to pay even for a 20% performance gain.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.TraceAppender.Category">
      <summary>
            The category parameter sent to the Trace method.
            </summary>
      <remarks>
        <para>
            Defaults to %logger which will use the logger name of the current 
            <see cref="T:log4net.Core.LoggingEvent" /> as the category parameter.
            </para>
        <para>
        </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.TraceAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Config.AliasRepositoryAttribute">
      <summary>
            Assembly level attribute that specifies a repository to alias to this assembly's repository.
            </summary>
      <remarks>
        <para>
            An assembly's logger repository is defined by its <see cref="T:log4net.Config.RepositoryAttribute" />,
            however this can be overridden by an assembly loaded before the target assembly.
            </para>
        <para>
            An assembly can alias another assembly's repository to its repository by
            specifying this attribute with the name of the target repository.
            </para>
        <para>
            This attribute can only be specified on the assembly and may be used
            as many times as necessary to alias all the required repositories.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Config.AliasRepositoryAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Config.AliasRepositoryAttribute" /> class with 
            the specified repository to alias to this assembly's repository.
            </summary>
      <param name="name">The repository to alias to this assemby's repository.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Config.AliasRepositoryAttribute" /> class with 
            the specified repository to alias to this assembly's repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Config.AliasRepositoryAttribute.Name">
      <summary>
            Gets or sets the repository to alias to this assemby's repository.
            </summary>
      <value>
            The repository to alias to this assemby's repository.
            </value>
      <remarks>
        <para>
            The name of the repository to alias to this assemby's repository.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Config.AliasDomainAttribute">
      <summary>
            Assembly level attribute that specifies a domain to alias to this assembly's repository.
            </summary>
      <remarks>
        <para>
          <b>AliasDomainAttribute is obsolete. Use AliasRepositoryAttribute instead of AliasDomainAttribute.</b>
        </para>
        <para>
            An assembly's logger repository is defined by its <see cref="T:log4net.Config.DomainAttribute" />,
            however this can be overridden by an assembly loaded before the target assembly.
            </para>
        <para>
            An assembly can alias another assembly's domain to its repository by
            specifying this attribute with the name of the target domain.
            </para>
        <para>
            This attribute can only be specified on the assembly and may be used
            as many times as necessary to alias all the required domains.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Config.AliasDomainAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Config.AliasDomainAttribute" /> class with 
            the specified domain to alias to this assembly's repository.
            </summary>
      <param name="name">The domain to alias to this assemby's repository.</param>
      <remarks>
        <para>
            Obsolete. Use <see cref="T:log4net.Config.AliasRepositoryAttribute" /> instead of <see cref="T:log4net.Config.AliasDomainAttribute" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Config.BasicConfigurator">
      <summary>
            Use this class to quickly configure a <see cref="T:log4net.Repository.Hierarchy.Hierarchy" />.
            </summary>
      <remarks>
        <para>
            Allows very simple programmatic configuration of log4net.
            </para>
        <para>
            Only one appender can be configured using this configurator.
            The appender is set at the root of the hierarchy and all logging
            events will be delivered to that appender.
            </para>
        <para>
            Appenders can also implement the <see cref="T:log4net.Core.IOptionHandler" /> interface. Therefore
            they would require that the <see cref="M:log4net.Core.IOptionHandler.ActivateOptions()" /> method
            be called after the appenders properties have been configured.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Config.BasicConfigurator.declaringType">
      <summary>
            The fully qualified type of the BasicConfigurator class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Config.BasicConfigurator.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Config.BasicConfigurator" /> class. 
            </summary>
      <remarks>
        <para>
            Uses a private access modifier to prevent instantiation of this class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.BasicConfigurator.Configure">
      <summary>
            Initializes the log4net system with a default configuration.
            </summary>
      <remarks>
        <para>
            Initializes the log4net logging system using a <see cref="T:log4net.Appender.ConsoleAppender" />
            that will write to <c>Console.Out</c>. The log messages are
            formatted using the <see cref="T:log4net.Layout.PatternLayout" /> layout object
            with the <see cref="F:log4net.Layout.PatternLayout.DetailConversionPattern" />
            layout style.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.BasicConfigurator.Configure(log4net.Appender.IAppender)">
      <summary>
            Initializes the log4net system using the specified appender.
            </summary>
      <param name="appender">The appender to use to log all logging events.</param>
      <remarks>
        <para>
            Initializes the log4net system using the specified appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.BasicConfigurator.Configure(log4net.Appender.IAppender[])">
      <summary>
            Initializes the log4net system using the specified appenders.
            </summary>
      <param name="appenders">The appenders to use to log all logging events.</param>
      <remarks>
        <para>
            Initializes the log4net system using the specified appenders.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.BasicConfigurator.Configure(log4net.Repository.ILoggerRepository)">
      <summary>
            Initializes the <see cref="T:log4net.Repository.ILoggerRepository" /> with a default configuration.
            </summary>
      <param name="repository">The repository to configure.</param>
      <remarks>
        <para>
            Initializes the specified repository using a <see cref="T:log4net.Appender.ConsoleAppender" />
            that will write to <c>Console.Out</c>. The log messages are
            formatted using the <see cref="T:log4net.Layout.PatternLayout" /> layout object
            with the <see cref="F:log4net.Layout.PatternLayout.DetailConversionPattern" />
            layout style.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.BasicConfigurator.Configure(log4net.Repository.ILoggerRepository,log4net.Appender.IAppender)">
      <summary>
            Initializes the <see cref="T:log4net.Repository.ILoggerRepository" /> using the specified appender.
            </summary>
      <param name="repository">The repository to configure.</param>
      <param name="appender">The appender to use to log all logging events.</param>
      <remarks>
        <para>
            Initializes the <see cref="T:log4net.Repository.ILoggerRepository" /> using the specified appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.BasicConfigurator.Configure(log4net.Repository.ILoggerRepository,log4net.Appender.IAppender[])">
      <summary>
            Initializes the <see cref="T:log4net.Repository.ILoggerRepository" /> using the specified appenders.
            </summary>
      <param name="repository">The repository to configure.</param>
      <param name="appenders">The appenders to use to log all logging events.</param>
      <remarks>
        <para>
            Initializes the <see cref="T:log4net.Repository.ILoggerRepository" /> using the specified appender.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Config.ConfiguratorAttribute">
      <summary>
            Base class for all log4net configuration attributes.
            </summary>
      <remarks>
            This is an abstract class that must be extended by 
            specific configurators. This attribute allows the
            configurator to be parameterized by an assembly level
            attribute.
            </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Config.ConfiguratorAttribute.#ctor(System.Int32)">
      <summary>
            Constructor used by subclasses.
            </summary>
      <param name="priority">the ordering priority for this configurator</param>
      <remarks>
        <para>
            The <paramref name="priority" /> is used to order the configurator
            attributes before they are invoked. Higher priority configurators are executed
            before lower priority ones.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.ConfiguratorAttribute.Configure(System.Reflection.Assembly,log4net.Repository.ILoggerRepository)">
      <summary>
            Configures the <see cref="T:log4net.Repository.ILoggerRepository" /> for the specified assembly.
            </summary>
      <param name="sourceAssembly">The assembly that this attribute was defined on.</param>
      <param name="targetRepository">The repository to configure.</param>
      <remarks>
        <para>
            Abstract method implemented by a subclass. When this method is called
            the subclass should configure the <paramref name="targetRepository" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.ConfiguratorAttribute.CompareTo(System.Object)">
      <summary>
            Compare this instance to another ConfiguratorAttribute
            </summary>
      <param name="obj">the object to compare to</param>
      <returns>see <see cref="M:System.IComparable.CompareTo(System.Object)" /></returns>
      <remarks>
        <para>
            Compares the priorities of the two <see cref="T:log4net.Config.ConfiguratorAttribute" /> instances.
            Sorts by priority in descending order. Objects with the same priority are
            randomly ordered.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Config.RepositoryAttribute">
      <summary>
            Assembly level attribute that specifies the logging repository for the assembly.
            </summary>
      <remarks>
        <para>
            Assemblies are mapped to logging repository. This attribute specified 
            on the assembly controls
            the configuration of the repository. The <see cref="P:log4net.Config.RepositoryAttribute.Name" /> property specifies the name
            of the repository that this assembly is a part of. The <see cref="P:log4net.Config.RepositoryAttribute.RepositoryType" />
            specifies the type of the <see cref="T:log4net.Repository.ILoggerRepository" /> object 
            to create for the assembly. If this attribute is not specified or a <see cref="P:log4net.Config.RepositoryAttribute.Name" /> 
            is not specified then the assembly will be part of the default shared logging repository.
            </para>
        <para>
            This attribute can only be specified on the assembly and may only be used
            once per assembly.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Config.RepositoryAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Config.RepositoryAttribute" /> class.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.RepositoryAttribute.#ctor(System.String)">
      <summary>
            Initialize a new instance of the <see cref="T:log4net.Config.RepositoryAttribute" /> class 
            with the name of the repository.
            </summary>
      <param name="name">The name of the repository.</param>
      <remarks>
        <para>
            Initialize the attribute with the name for the assembly's repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Config.RepositoryAttribute.Name">
      <summary>
            Gets or sets the name of the logging repository.
            </summary>
      <value>
            The string name to use as the name of the repository associated with this
            assembly.
            </value>
      <remarks>
        <para>
            This value does not have to be unique. Several assemblies can share the
            same repository. They will share the logging configuration of the repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Config.RepositoryAttribute.RepositoryType">
      <summary>
            Gets or sets the type of repository to create for this assembly.
            </summary>
      <value>
            The type of repository to create for this assembly.
            </value>
      <remarks>
        <para>
            The type of the repository to create for the assembly.
            The type must implement the <see cref="T:log4net.Repository.ILoggerRepository" />
            interface.
            </para>
        <para>
            This will be the type of repository created when 
            the repository is created. If multiple assemblies reference the
            same repository then the repository is only created once using the
            <see cref="P:log4net.Config.RepositoryAttribute.RepositoryType" /> of the first assembly to call into the 
            repository.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Config.DomainAttribute">
      <summary>
            Assembly level attribute that specifies the logging domain for the assembly.
            </summary>
      <remarks>
        <para>
          <b>DomainAttribute is obsolete. Use RepositoryAttribute instead of DomainAttribute.</b>
        </para>
        <para>
            Assemblies are mapped to logging domains. Each domain has its own
            logging repository. This attribute specified on the assembly controls
            the configuration of the domain. The <see cref="P:log4net.Config.RepositoryAttribute.Name" /> property specifies the name
            of the domain that this assembly is a part of. The <see cref="P:log4net.Config.RepositoryAttribute.RepositoryType" />
            specifies the type of the repository objects to create for the domain. If 
            this attribute is not specified and a <see cref="P:log4net.Config.RepositoryAttribute.Name" /> is not specified
            then the assembly will be part of the default shared logging domain.
            </para>
        <para>
            This attribute can only be specified on the assembly and may only be used
            once per assembly.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Config.DomainAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Config.DomainAttribute" /> class.
            </summary>
      <remarks>
        <para>
            Obsolete. Use RepositoryAttribute instead of DomainAttribute.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.DomainAttribute.#ctor(System.String)">
      <summary>
            Initialize a new instance of the <see cref="T:log4net.Config.DomainAttribute" /> class 
            with the name of the domain.
            </summary>
      <param name="name">The name of the domain.</param>
      <remarks>
        <para>
            Obsolete. Use RepositoryAttribute instead of DomainAttribute.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Config.DOMConfigurator">
      <summary>
            Use this class to initialize the log4net environment using an Xml tree.
            </summary>
      <remarks>
        <para>
          <b>DOMConfigurator is obsolete. Use XmlConfigurator instead of DOMConfigurator.</b>
        </para>
        <para>
            Configures a <see cref="T:log4net.Repository.ILoggerRepository" /> using an Xml tree.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Config.DOMConfigurator.#ctor">
      <summary>
            Private constructor
            </summary>
    </member>
    <member name="M:log4net.Config.DOMConfigurator.Configure">
      <summary>
            Automatically configures the log4net system based on the 
            application's configuration settings.
            </summary>
      <remarks>
        <para>
          <b>DOMConfigurator is obsolete. Use XmlConfigurator instead of DOMConfigurator.</b>
        </para>
            Each application has a configuration file. This has the
            same name as the application with '.config' appended.
            This file is XML and calling this function prompts the
            configurator to look in that file for a section called
            <c>log4net</c> that contains the configuration data.
            </remarks>
    </member>
    <member name="M:log4net.Config.DOMConfigurator.Configure(log4net.Repository.ILoggerRepository)">
      <summary>
            Automatically configures the <see cref="T:log4net.Repository.ILoggerRepository" /> using settings
            stored in the application's configuration file.
            </summary>
      <remarks>
        <para>
          <b>DOMConfigurator is obsolete. Use XmlConfigurator instead of DOMConfigurator.</b>
        </para>
            Each application has a configuration file. This has the
            same name as the application with '.config' appended.
            This file is XML and calling this function prompts the
            configurator to look in that file for a section called
            <c>log4net</c> that contains the configuration data.
            </remarks>
      <param name="repository">The repository to configure.</param>
    </member>
    <member name="M:log4net.Config.DOMConfigurator.Configure(System.Xml.XmlElement)">
      <summary>
            Configures log4net using a <c>log4net</c> element
            </summary>
      <remarks>
        <para>
          <b>DOMConfigurator is obsolete. Use XmlConfigurator instead of DOMConfigurator.</b>
        </para>
            Loads the log4net configuration from the XML element
            supplied as <paramref name="element" />.
            </remarks>
      <param name="element">The element to parse.</param>
    </member>
    <member name="M:log4net.Config.DOMConfigurator.Configure(log4net.Repository.ILoggerRepository,System.Xml.XmlElement)">
      <summary>
            Configures the <see cref="T:log4net.Repository.ILoggerRepository" /> using the specified XML 
            element.
            </summary>
      <remarks>
        <para>
          <b>DOMConfigurator is obsolete. Use XmlConfigurator instead of DOMConfigurator.</b>
        </para>
            Loads the log4net configuration from the XML element
            supplied as <paramref name="element" />.
            </remarks>
      <param name="repository">The repository to configure.</param>
      <param name="element">The element to parse.</param>
    </member>
    <member name="M:log4net.Config.DOMConfigurator.Configure(System.IO.FileInfo)">
      <summary>
            Configures log4net using the specified configuration file.
            </summary>
      <param name="configFile">The XML file to load the configuration from.</param>
      <remarks>
        <para>
          <b>DOMConfigurator is obsolete. Use XmlConfigurator instead of DOMConfigurator.</b>
        </para>
        <para>
            The configuration file must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the log4net configuration data.
            </para>
        <para>
            The log4net configuration file can possible be specified in the application's
            configuration file (either <c>MyAppName.exe.config</c> for a
            normal application on <c>Web.config</c> for an ASP.NET application).
            </para>
        <example>
            The following example configures log4net using a configuration file, of which the 
            location is stored in the application's configuration file :
            </example>
        <code lang="C#">
            using log4net.Config;
            using System.IO;
            using System.Configuration;
            
            ...
            
            DOMConfigurator.Configure(new FileInfo(ConfigurationSettings.AppSettings["log4net-config-file"]));
            </code>
        <para>
            In the <c>.config</c> file, the path to the log4net can be specified like this :
            </para>
        <code lang="XML" escaped="true">
          <configuration>
            <appSettings>
              <add key="log4net-config-file" value="log.config" />
            </appSettings>
          </configuration>
        </code>
      </remarks>
    </member>
    <member name="M:log4net.Config.DOMConfigurator.Configure(System.IO.Stream)">
      <summary>
            Configures log4net using the specified configuration file.
            </summary>
      <param name="configStream">A stream to load the XML configuration from.</param>
      <remarks>
        <para>
          <b>DOMConfigurator is obsolete. Use XmlConfigurator instead of DOMConfigurator.</b>
        </para>
        <para>
            The configuration data must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the log4net configuration data.
            </para>
        <para>
            Note that this method will NOT close the stream parameter.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.DOMConfigurator.Configure(log4net.Repository.ILoggerRepository,System.IO.FileInfo)">
      <summary>
            Configures the <see cref="T:log4net.Repository.ILoggerRepository" /> using the specified configuration 
            file.
            </summary>
      <param name="repository">The repository to configure.</param>
      <param name="configFile">The XML file to load the configuration from.</param>
      <remarks>
        <para>
          <b>DOMConfigurator is obsolete. Use XmlConfigurator instead of DOMConfigurator.</b>
        </para>
        <para>
            The configuration file must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the configuration data.
            </para>
        <para>
            The log4net configuration file can possible be specified in the application's
            configuration file (either <c>MyAppName.exe.config</c> for a
            normal application on <c>Web.config</c> for an ASP.NET application).
            </para>
        <example>
            The following example configures log4net using a configuration file, of which the 
            location is stored in the application's configuration file :
            </example>
        <code lang="C#">
            using log4net.Config;
            using System.IO;
            using System.Configuration;
            
            ...
            
            DOMConfigurator.Configure(new FileInfo(ConfigurationSettings.AppSettings["log4net-config-file"]));
            </code>
        <para>
            In the <c>.config</c> file, the path to the log4net can be specified like this :
            </para>
        <code lang="XML" escaped="true">
          <configuration>
            <appSettings>
              <add key="log4net-config-file" value="log.config" />
            </appSettings>
          </configuration>
        </code>
      </remarks>
    </member>
    <member name="M:log4net.Config.DOMConfigurator.Configure(log4net.Repository.ILoggerRepository,System.IO.Stream)">
      <summary>
            Configures the <see cref="T:log4net.Repository.ILoggerRepository" /> using the specified configuration 
            file.
            </summary>
      <param name="repository">The repository to configure.</param>
      <param name="configStream">The stream to load the XML configuration from.</param>
      <remarks>
        <para>
          <b>DOMConfigurator is obsolete. Use XmlConfigurator instead of DOMConfigurator.</b>
        </para>
        <para>
            The configuration data must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the configuration data.
            </para>
        <para>
            Note that this method will NOT close the stream parameter.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.DOMConfigurator.ConfigureAndWatch(System.IO.FileInfo)">
      <summary>
            Configures log4net using the file specified, monitors the file for changes 
            and reloads the configuration if a change is detected.
            </summary>
      <param name="configFile">The XML file to load the configuration from.</param>
      <remarks>
        <para>
          <b>DOMConfigurator is obsolete. Use XmlConfigurator instead of DOMConfigurator.</b>
        </para>
        <para>
            The configuration file must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the configuration data.
            </para>
        <para>
            The configuration file will be monitored using a <see cref="T:System.IO.FileSystemWatcher" />
            and depends on the behavior of that class.
            </para>
        <para>
            For more information on how to configure log4net using
            a separate configuration file, see <see cref="M:Configure(FileInfo)" />.
            </para>
      </remarks>
      <seealso cref="M:Configure(FileInfo)" />
    </member>
    <member name="M:log4net.Config.DOMConfigurator.ConfigureAndWatch(log4net.Repository.ILoggerRepository,System.IO.FileInfo)">
      <summary>
            Configures the <see cref="T:log4net.Repository.ILoggerRepository" /> using the file specified, 
            monitors the file for changes and reloads the configuration if a change 
            is detected.
            </summary>
      <param name="repository">The repository to configure.</param>
      <param name="configFile">The XML file to load the configuration from.</param>
      <remarks>
        <para>
          <b>DOMConfigurator is obsolete. Use XmlConfigurator instead of DOMConfigurator.</b>
        </para>
        <para>
            The configuration file must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the configuration data.
            </para>
        <para>
            The configuration file will be monitored using a <see cref="T:System.IO.FileSystemWatcher" />
            and depends on the behavior of that class.
            </para>
        <para>
            For more information on how to configure log4net using
            a separate configuration file, see <see cref="M:Configure(FileInfo)" />.
            </para>
      </remarks>
      <seealso cref="M:Configure(FileInfo)" />
    </member>
    <member name="T:log4net.Config.XmlConfiguratorAttribute">
      <summary>
            Assembly level attribute to configure the <see cref="T:log4net.Config.XmlConfigurator" />.
            </summary>
      <remarks>
        <para>
            This attribute may only be used at the assembly scope and can only
            be used once per assembly.
            </para>
        <para>
            Use this attribute to configure the <see cref="T:log4net.Config.XmlConfigurator" />
            without calling one of the <see cref="M:XmlConfigurator.Configure()" />
            methods.
            </para>
        <para>
            If neither of the <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFile" /> or <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFileExtension" />
            properties are set the configuration is loaded from the application's .config file.
            If set the <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFile" /> property takes priority over the
            <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFileExtension" /> property. The <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFile" /> property
            specifies a path to a file to load the config from. The path is relative to the
            application's base directory; <see cref="P:System.AppDomain.BaseDirectory" />.
            The <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFileExtension" /> property is used as a postfix to the assembly file name.
            The config file must be located in the  application's base directory; <see cref="P:System.AppDomain.BaseDirectory" />.
            For example in a console application setting the <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFileExtension" /> to
            <c>config</c> has the same effect as not specifying the <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFile" /> or 
            <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFileExtension" /> properties.
            </para>
        <para>
            The <see cref="P:log4net.Config.XmlConfiguratorAttribute.Watch" /> property can be set to cause the <see cref="T:log4net.Config.XmlConfigurator" />
            to watch the configuration file for changes.
            </para>
        <note>
          <para>
            Log4net will only look for assembly level configuration attributes once.
            When using the log4net assembly level attributes to control the configuration 
            of log4net you must ensure that the first call to any of the 
            <see cref="T:log4net.Core.LoggerManager" /> methods is made from the assembly with the configuration
            attributes. 
            </para>
          <para>
            If you cannot guarantee the order in which log4net calls will be made from 
            different assemblies you must use programmatic configuration instead, i.e.
            call the <see cref="M:XmlConfigurator.Configure()" /> method directly.
            </para>
        </note>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Config.XmlConfiguratorAttribute.declaringType">
      <summary>
            The fully qualified type of the XmlConfiguratorAttribute class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfiguratorAttribute.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Default constructor
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfiguratorAttribute.Configure(System.Reflection.Assembly,log4net.Repository.ILoggerRepository)">
      <summary>
            Configures the <see cref="T:log4net.Repository.ILoggerRepository" /> for the specified assembly.
            </summary>
      <param name="sourceAssembly">The assembly that this attribute was defined on.</param>
      <param name="targetRepository">The repository to configure.</param>
      <remarks>
        <para>
            Configure the repository using the <see cref="T:log4net.Config.XmlConfigurator" />.
            The <paramref name="targetRepository" /> specified must extend the <see cref="T:log4net.Repository.Hierarchy.Hierarchy" />
            class otherwise the <see cref="T:log4net.Config.XmlConfigurator" /> will not be able to
            configure it.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="targetRepository" /> does not extend <see cref="T:log4net.Repository.Hierarchy.Hierarchy" />.</exception>
    </member>
    <member name="M:log4net.Config.XmlConfiguratorAttribute.ConfigureFromFile(System.Reflection.Assembly,log4net.Repository.ILoggerRepository)">
      <summary>
            Attempt to load configuration from the local file system
            </summary>
      <param name="sourceAssembly">The assembly that this attribute was defined on.</param>
      <param name="targetRepository">The repository to configure.</param>
    </member>
    <member name="M:log4net.Config.XmlConfiguratorAttribute.ConfigureFromFile(log4net.Repository.ILoggerRepository,System.IO.FileInfo)">
      <summary>
            Configure the specified repository using a <see cref="T:System.IO.FileInfo" /></summary>
      <param name="targetRepository">The repository to configure.</param>
      <param name="configFile">the FileInfo pointing to the config file</param>
    </member>
    <member name="M:log4net.Config.XmlConfiguratorAttribute.ConfigureFromUri(System.Reflection.Assembly,log4net.Repository.ILoggerRepository)">
      <summary>
            Attempt to load configuration from a URI
            </summary>
      <param name="sourceAssembly">The assembly that this attribute was defined on.</param>
      <param name="targetRepository">The repository to configure.</param>
    </member>
    <member name="P:log4net.Config.XmlConfiguratorAttribute.ConfigFile">
      <summary>
            Gets or sets the filename of the configuration file.
            </summary>
      <value>
            The filename of the configuration file.
            </value>
      <remarks>
        <para>
            If specified, this is the name of the configuration file to use with
            the <see cref="T:log4net.Config.XmlConfigurator" />. This file path is relative to the
            <b>application base</b> directory (<see cref="P:System.AppDomain.BaseDirectory" />).
            </para>
        <para>
            The <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFile" /> takes priority over the <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFileExtension" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Config.XmlConfiguratorAttribute.ConfigFileExtension">
      <summary>
            Gets or sets the extension of the configuration file.
            </summary>
      <value>
            The extension of the configuration file.
            </value>
      <remarks>
        <para>
            If specified this is the extension for the configuration file.
            The path to the config file is built by using the <b>application 
            base</b> directory (<see cref="P:System.AppDomain.BaseDirectory" />),
            the <b>assembly file name</b> and the config file extension.
            </para>
        <para>
            If the <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFileExtension" /> is set to <c>MyExt</c> then
            possible config file names would be: <c>MyConsoleApp.exe.MyExt</c> or
            <c>MyClassLibrary.dll.MyExt</c>.
            </para>
        <para>
            The <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFile" /> takes priority over the <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFileExtension" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Config.XmlConfiguratorAttribute.Watch">
      <summary>
            Gets or sets a value indicating whether to watch the configuration file.
            </summary>
      <value>
        <c>true</c> if the configuration should be watched, <c>false</c> otherwise.
            </value>
      <remarks>
        <para>
            If this flag is specified and set to <c>true</c> then the framework
            will watch the configuration file and will reload the config each time 
            the file is modified.
            </para>
        <para>
            The config file can only be watched if it is loaded from local disk.
            In a No-Touch (Smart Client) deployment where the application is downloaded
            from a web server the config file may not reside on the local disk
            and therefore it may not be able to watch it.
            </para>
        <note>
            Watching configuration is not supported on the SSCLI.
            </note>
      </remarks>
    </member>
    <member name="T:log4net.Config.DOMConfiguratorAttribute">
      <summary>
            Assembly level attribute to configure the <see cref="T:log4net.Config.XmlConfigurator" />.
            </summary>
      <remarks>
        <para>
          <b>AliasDomainAttribute is obsolete. Use AliasRepositoryAttribute instead of AliasDomainAttribute.</b>
        </para>
        <para>
            This attribute may only be used at the assembly scope and can only
            be used once per assembly.
            </para>
        <para>
            Use this attribute to configure the <see cref="T:log4net.Config.XmlConfigurator" />
            without calling one of the <see cref="M:XmlConfigurator.Configure()" />
            methods.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="T:log4net.Config.Log4NetConfigurationSectionHandler">
      <summary>
            Class to register for the log4net section of the configuration file
            </summary>
      <remarks>
            The log4net section of the configuration file needs to have a section
            handler registered. This is the section handler used. It simply returns
            the XML element that is the root of the section.
            </remarks>
      <example>
            Example of registering the log4net section handler :
            <code lang="XML" escaped="true"><configuration><configSections><section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler, log4net" /></configSections><log4net>
            		log4net configuration XML goes here
            	</log4net></configuration></code></example>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Config.Log4NetConfigurationSectionHandler.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Config.Log4NetConfigurationSectionHandler" /> class.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.Log4NetConfigurationSectionHandler.Create(System.Object,System.Object,System.Xml.XmlNode)">
      <summary>
            Parses the configuration section.
            </summary>
      <param name="parent">The configuration settings in a corresponding parent configuration section.</param>
      <param name="configContext">The configuration context when called from the ASP.NET configuration system. Otherwise, this parameter is reserved and is a null reference.</param>
      <param name="section">The <see cref="T:System.Xml.XmlNode" /> for the log4net section.</param>
      <returns>The <see cref="T:System.Xml.XmlNode" /> for the log4net section.</returns>
      <remarks>
        <para>
            Returns the <see cref="T:System.Xml.XmlNode" /> containing the configuration data,
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Plugin.IPluginFactory">
      <summary>
            Interface used to create plugins.
            </summary>
      <remarks>
        <para>
            Interface used to create  a plugin.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Plugin.IPluginFactory.CreatePlugin">
      <summary>
            Creates the plugin object.
            </summary>
      <returns>the new plugin instance</returns>
      <remarks>
        <para>
            Create and return a new plugin instance.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Config.PluginAttribute">
      <summary>
            Assembly level attribute that specifies a plugin to attach to 
            the repository.
            </summary>
      <remarks>
        <para>
            Specifies the type of a plugin to create and attach to the
            assembly's repository. The plugin type must implement the
            <see cref="T:log4net.Plugin.IPlugin" /> interface.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Config.PluginAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Config.PluginAttribute" /> class
            with the specified type.
            </summary>
      <param name="typeName">The type name of plugin to create.</param>
      <remarks>
        <para>
            Create the attribute with the plugin type specified.
            </para>
        <para>
            Where possible use the constructor that takes a <see cref="T:System.Type" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.PluginAttribute.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Config.PluginAttribute" /> class
            with the specified type.
            </summary>
      <param name="type">The type of plugin to create.</param>
      <remarks>
        <para>
            Create the attribute with the plugin type specified.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.PluginAttribute.CreatePlugin">
      <summary>
            Creates the plugin object defined by this attribute.
            </summary>
      <remarks>
        <para>
            Creates the instance of the <see cref="T:log4net.Plugin.IPlugin" /> object as 
            specified by this attribute.
            </para>
      </remarks>
      <returns>The plugin object.</returns>
    </member>
    <member name="M:log4net.Config.PluginAttribute.ToString">
      <summary>
            Returns a representation of the properties of this object.
            </summary>
      <remarks>
        <para>
            Overrides base class <see cref="M:Object.ToString()" /> method to 
            return a representation of the properties of this object.
            </para>
      </remarks>
      <returns>A representation of the properties of this object</returns>
    </member>
    <member name="P:log4net.Config.PluginAttribute.Type">
      <summary>
            Gets or sets the type for the plugin.
            </summary>
      <value>
            The type for the plugin.
            </value>
      <remarks>
        <para>
            The type for the plugin.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Config.PluginAttribute.TypeName">
      <summary>
            Gets or sets the type name for the plugin.
            </summary>
      <value>
            The type name for the plugin.
            </value>
      <remarks>
        <para>
            The type name for the plugin.
            </para>
        <para>
            Where possible use the <see cref="P:log4net.Config.PluginAttribute.Type" /> property instead.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Config.SecurityContextProviderAttribute">
      <summary>
            Assembly level attribute to configure the <see cref="T:log4net.Core.SecurityContextProvider" />.
            </summary>
      <remarks>
        <para>
            This attribute may only be used at the assembly scope and can only
            be used once per assembly.
            </para>
        <para>
            Use this attribute to configure the <see cref="T:log4net.Config.XmlConfigurator" />
            without calling one of the <see cref="M:XmlConfigurator.Configure()" />
            methods.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Config.SecurityContextProviderAttribute.declaringType">
      <summary>
            The fully qualified type of the SecurityContextProviderAttribute class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Config.SecurityContextProviderAttribute.#ctor(System.Type)">
      <summary>
            Construct provider attribute with type specified
            </summary>
      <param name="providerType">the type of the provider to use</param>
      <remarks>
        <para>
            The provider specified must subclass the <see cref="T:log4net.Core.SecurityContextProvider" />
            class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.SecurityContextProviderAttribute.Configure(System.Reflection.Assembly,log4net.Repository.ILoggerRepository)">
      <summary>
            Configures the SecurityContextProvider
            </summary>
      <param name="sourceAssembly">The assembly that this attribute was defined on.</param>
      <param name="targetRepository">The repository to configure.</param>
      <remarks>
        <para>
            Creates a provider instance from the <see cref="P:log4net.Config.SecurityContextProviderAttribute.ProviderType" /> specified.
            Sets this as the default security context provider <see cref="P:log4net.Core.SecurityContextProvider.DefaultProvider" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Config.SecurityContextProviderAttribute.ProviderType">
      <summary>
            Gets or sets the type of the provider to use.
            </summary>
      <value>
            the type of the provider to use.
            </value>
      <remarks>
        <para>
            The provider specified must subclass the <see cref="T:log4net.Core.SecurityContextProvider" />
            class.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Config.XmlConfigurator">
      <summary>
            Use this class to initialize the log4net environment using an Xml tree.
            </summary>
      <remarks>
        <para>
            Configures a <see cref="T:log4net.Repository.ILoggerRepository" /> using an Xml tree.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="T:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler">
      <summary>
            Class used to watch config files.
            </summary>
      <remarks>
        <para>
            Uses the <see cref="T:System.IO.FileSystemWatcher" /> to monitor
            changes to a specified file. Because multiple change notifications
            may be raised when the file is modified, a timer is used to
            compress the notifications into a single event. The timer
            waits for <see cref="F:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler.TimeoutMillis" /> time before delivering
            the event notification. If any further <see cref="T:System.IO.FileSystemWatcher" />
            change notifications arrive while the timer is waiting it
            is reset and waits again for <see cref="F:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler.TimeoutMillis" /> to
            elapse.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler.#ctor(log4net.Repository.ILoggerRepository,System.IO.FileInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler" /> class to
            watch a specified config file used to configure a repository.
            </summary>
      <param name="repository">The repository to configure.</param>
      <param name="configFile">The configuration file to watch.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler_OnChanged(System.Object,System.IO.FileSystemEventArgs)">
      <summary>
            Event handler used by <see cref="T:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler" />.
            </summary>
      <param name="source">The <see cref="T:System.IO.FileSystemWatcher" /> firing the event.</param>
      <param name="e">The argument indicates the file that caused the event to be fired.</param>
      <remarks>
        <para>
            This handler reloads the configuration from the file when the event is fired.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler_OnRenamed(System.Object,System.IO.RenamedEventArgs)">
      <summary>
            Event handler used by <see cref="T:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler" />.
            </summary>
      <param name="source">The <see cref="T:System.IO.FileSystemWatcher" /> firing the event.</param>
      <param name="e">The argument indicates the file that caused the event to be fired.</param>
      <remarks>
        <para>
            This handler reloads the configuration from the file when the event is fired.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler.OnWatchedFileChange(System.Object)">
      <summary>
            Called by the timer when the configuration has been updated.
            </summary>
      <param name="state">null</param>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler.Dispose">
      <summary>
            Release the handles held by the watcher and timer.
            </summary>
    </member>
    <member name="F:log4net.Config.XmlConfigurator.m_repositoryName2ConfigAndWatchHandler">
      <summary>
            Maps repository names to ConfigAndWatchHandler instances to allow a particular
            ConfigAndWatchHandler to dispose of its FileSystemWatcher when a repository is 
            reconfigured.
            </summary>
    </member>
    <member name="F:log4net.Config.XmlConfigurator.declaringType">
      <summary>
            The fully qualified type of the XmlConfigurator class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.#ctor">
      <summary>
            Private constructor
            </summary>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.Configure">
      <summary>
            Automatically configures the log4net system based on the 
            application's configuration settings.
            </summary>
      <remarks>
        <para>
            Each application has a configuration file. This has the
            same name as the application with '.config' appended.
            This file is XML and calling this function prompts the
            configurator to look in that file for a section called
            <c>log4net</c> that contains the configuration data.
            </para>
        <para>
            To use this method to configure log4net you must specify 
            the <see cref="T:log4net.Config.Log4NetConfigurationSectionHandler" /> section
            handler for the <c>log4net</c> configuration section. See the
            <see cref="T:log4net.Config.Log4NetConfigurationSectionHandler" /> for an example.
            </para>
      </remarks>
      <seealso cref="T:log4net.Config.Log4NetConfigurationSectionHandler" />
    </member>
    <member name="M:log4net.Config.XmlConfigurator.Configure(log4net.Repository.ILoggerRepository)">
      <summary>
            Automatically configures the <see cref="T:log4net.Repository.ILoggerRepository" /> using settings
            stored in the application's configuration file.
            </summary>
      <remarks>
        <para>
            Each application has a configuration file. This has the
            same name as the application with '.config' appended.
            This file is XML and calling this function prompts the
            configurator to look in that file for a section called
            <c>log4net</c> that contains the configuration data.
            </para>
        <para>
            To use this method to configure log4net you must specify 
            the <see cref="T:log4net.Config.Log4NetConfigurationSectionHandler" /> section
            handler for the <c>log4net</c> configuration section. See the
            <see cref="T:log4net.Config.Log4NetConfigurationSectionHandler" /> for an example.
            </para>
      </remarks>
      <param name="repository">The repository to configure.</param>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.Configure(System.Xml.XmlElement)">
      <summary>
            Configures log4net using a <c>log4net</c> element
            </summary>
      <remarks>
        <para>
            Loads the log4net configuration from the XML element
            supplied as <paramref name="element" />.
            </para>
      </remarks>
      <param name="element">The element to parse.</param>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.Configure(log4net.Repository.ILoggerRepository,System.Xml.XmlElement)">
      <summary>
            Configures the <see cref="T:log4net.Repository.ILoggerRepository" /> using the specified XML 
            element.
            </summary>
      <remarks>
            Loads the log4net configuration from the XML element
            supplied as <paramref name="element" />.
            </remarks>
      <param name="repository">The repository to configure.</param>
      <param name="element">The element to parse.</param>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.Configure(System.IO.FileInfo)">
      <summary>
            Configures log4net using the specified configuration file.
            </summary>
      <param name="configFile">The XML file to load the configuration from.</param>
      <remarks>
        <para>
            The configuration file must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the log4net configuration data.
            </para>
        <para>
            The log4net configuration file can possible be specified in the application's
            configuration file (either <c>MyAppName.exe.config</c> for a
            normal application on <c>Web.config</c> for an ASP.NET application).
            </para>
        <para>
            The first element matching <c>&lt;configuration&gt;</c> will be read as the 
            configuration. If this file is also a .NET .config file then you must specify 
            a configuration section for the <c>log4net</c> element otherwise .NET will 
            complain. Set the type for the section handler to <see cref="T:System.Configuration.IgnoreSectionHandler" />, for example:
            <code lang="XML" escaped="true"><configSections><section name="log4net" type="System.Configuration.IgnoreSectionHandler" /></configSections></code></para>
        <example>
            The following example configures log4net using a configuration file, of which the 
            location is stored in the application's configuration file :
            </example>
        <code lang="C#">
            using log4net.Config;
            using System.IO;
            using System.Configuration;
            
            ...
            
            XmlConfigurator.Configure(new FileInfo(ConfigurationSettings.AppSettings["log4net-config-file"]));
            </code>
        <para>
            In the <c>.config</c> file, the path to the log4net can be specified like this :
            </para>
        <code lang="XML" escaped="true">
          <configuration>
            <appSettings>
              <add key="log4net-config-file" value="log.config" />
            </appSettings>
          </configuration>
        </code>
      </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.Configure(System.Uri)">
      <summary>
            Configures log4net using the specified configuration URI.
            </summary>
      <param name="configUri">A URI to load the XML configuration from.</param>
      <remarks>
        <para>
            The configuration data must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the log4net configuration data.
            </para>
        <para>
            The <see cref="T:System.Net.WebRequest" /> must support the URI scheme specified.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.Configure(System.IO.Stream)">
      <summary>
            Configures log4net using the specified configuration data stream.
            </summary>
      <param name="configStream">A stream to load the XML configuration from.</param>
      <remarks>
        <para>
            The configuration data must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the log4net configuration data.
            </para>
        <para>
            Note that this method will NOT close the stream parameter.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.Configure(log4net.Repository.ILoggerRepository,System.IO.FileInfo)">
      <summary>
            Configures the <see cref="T:log4net.Repository.ILoggerRepository" /> using the specified configuration 
            file.
            </summary>
      <param name="repository">The repository to configure.</param>
      <param name="configFile">The XML file to load the configuration from.</param>
      <remarks>
        <para>
            The configuration file must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the configuration data.
            </para>
        <para>
            The log4net configuration file can possible be specified in the application's
            configuration file (either <c>MyAppName.exe.config</c> for a
            normal application on <c>Web.config</c> for an ASP.NET application).
            </para>
        <para>
            The first element matching <c>&lt;configuration&gt;</c> will be read as the 
            configuration. If this file is also a .NET .config file then you must specify 
            a configuration section for the <c>log4net</c> element otherwise .NET will 
            complain. Set the type for the section handler to <see cref="T:System.Configuration.IgnoreSectionHandler" />, for example:
            <code lang="XML" escaped="true"><configSections><section name="log4net" type="System.Configuration.IgnoreSectionHandler" /></configSections></code></para>
        <example>
            The following example configures log4net using a configuration file, of which the 
            location is stored in the application's configuration file :
            </example>
        <code lang="C#">
            using log4net.Config;
            using System.IO;
            using System.Configuration;
            
            ...
            
            XmlConfigurator.Configure(new FileInfo(ConfigurationSettings.AppSettings["log4net-config-file"]));
            </code>
        <para>
            In the <c>.config</c> file, the path to the log4net can be specified like this :
            </para>
        <code lang="XML" escaped="true">
          <configuration>
            <appSettings>
              <add key="log4net-config-file" value="log.config" />
            </appSettings>
          </configuration>
        </code>
      </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.Configure(log4net.Repository.ILoggerRepository,System.Uri)">
      <summary>
            Configures the <see cref="T:log4net.Repository.ILoggerRepository" /> using the specified configuration 
            URI.
            </summary>
      <param name="repository">The repository to configure.</param>
      <param name="configUri">A URI to load the XML configuration from.</param>
      <remarks>
        <para>
            The configuration data must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the configuration data.
            </para>
        <para>
            The <see cref="T:System.Net.WebRequest" /> must support the URI scheme specified.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.Configure(log4net.Repository.ILoggerRepository,System.IO.Stream)">
      <summary>
            Configures the <see cref="T:log4net.Repository.ILoggerRepository" /> using the specified configuration 
            file.
            </summary>
      <param name="repository">The repository to configure.</param>
      <param name="configStream">The stream to load the XML configuration from.</param>
      <remarks>
        <para>
            The configuration data must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the configuration data.
            </para>
        <para>
            Note that this method will NOT close the stream parameter.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.ConfigureAndWatch(System.IO.FileInfo)">
      <summary>
            Configures log4net using the file specified, monitors the file for changes 
            and reloads the configuration if a change is detected.
            </summary>
      <param name="configFile">The XML file to load the configuration from.</param>
      <remarks>
        <para>
            The configuration file must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the configuration data.
            </para>
        <para>
            The configuration file will be monitored using a <see cref="T:System.IO.FileSystemWatcher" />
            and depends on the behavior of that class.
            </para>
        <para>
            For more information on how to configure log4net using
            a separate configuration file, see <see cref="M:Configure(FileInfo)" />.
            </para>
      </remarks>
      <seealso cref="M:Configure(FileInfo)" />
    </member>
    <member name="M:log4net.Config.XmlConfigurator.ConfigureAndWatch(log4net.Repository.ILoggerRepository,System.IO.FileInfo)">
      <summary>
            Configures the <see cref="T:log4net.Repository.ILoggerRepository" /> using the file specified, 
            monitors the file for changes and reloads the configuration if a change 
            is detected.
            </summary>
      <param name="repository">The repository to configure.</param>
      <param name="configFile">The XML file to load the configuration from.</param>
      <remarks>
        <para>
            The configuration file must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the configuration data.
            </para>
        <para>
            The configuration file will be monitored using a <see cref="T:System.IO.FileSystemWatcher" />
            and depends on the behavior of that class.
            </para>
        <para>
            For more information on how to configure log4net using
            a separate configuration file, see <see cref="M:Configure(FileInfo)" />.
            </para>
      </remarks>
      <seealso cref="M:Configure(FileInfo)" />
    </member>
    <member name="M:log4net.Config.XmlConfigurator.InternalConfigureFromXml(log4net.Repository.ILoggerRepository,System.Xml.XmlElement)">
      <summary>
            Configures the specified repository using a <c>log4net</c> element.
            </summary>
      <param name="repository">The hierarchy to configure.</param>
      <param name="element">The element to parse.</param>
      <remarks>
        <para>
            Loads the log4net configuration from the XML element
            supplied as <paramref name="element" />.
            </para>
        <para>
            This method is ultimately called by one of the Configure methods 
            to load the configuration from an <see cref="T:System.Xml.XmlElement" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.IRepositorySelector">
      <summary>
            Interface used by the <see cref="T:log4net.LogManager" /> to select the <see cref="T:log4net.Repository.ILoggerRepository" />.
            </summary>
      <remarks>
        <para>
            The <see cref="T:log4net.LogManager" /> uses a <see cref="T:log4net.Core.IRepositorySelector" /> 
            to specify the policy for selecting the correct <see cref="T:log4net.Repository.ILoggerRepository" /> 
            to return to the caller.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Core.IRepositorySelector.GetRepository(System.Reflection.Assembly)">
      <summary>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the specified assembly.
            </summary>
      <param name="assembly">The assembly to use to lookup to the <see cref="T:log4net.Repository.ILoggerRepository" /></param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> for the assembly.</returns>
      <remarks>
        <para>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the specified assembly.
            </para>
        <para>
            How the association between <see cref="T:System.Reflection.Assembly" /> and <see cref="T:log4net.Repository.ILoggerRepository" />
            is made is not defined. The implementation may choose any method for
            this association. The results of this method must be repeatable, i.e.
            when called again with the same arguments the result must be the
            save value.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.IRepositorySelector.GetRepository(System.String)">
      <summary>
            Gets the named <see cref="T:log4net.Repository.ILoggerRepository" />.
            </summary>
      <param name="repositoryName">The name to use to lookup to the <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <returns>The named <see cref="T:log4net.Repository.ILoggerRepository" /></returns>
      <remarks>
            Lookup a named <see cref="T:log4net.Repository.ILoggerRepository" />. This is the repository created by
            calling <see cref="M:CreateRepository(string,Type)" />.
            </remarks>
    </member>
    <member name="M:log4net.Core.IRepositorySelector.CreateRepository(System.Reflection.Assembly,System.Type)">
      <summary>
            Creates a new repository for the assembly specified.
            </summary>
      <param name="assembly">The assembly to use to create the domain to associate with the <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <param name="repositoryType">The type of repository to create, must implement <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <returns>The repository created.</returns>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the domain
            specified such that a call to <see cref="M:GetRepository(Assembly)" /> with the
            same assembly specified will return the same repository instance.
            </para>
        <para>
            How the association between <see cref="T:System.Reflection.Assembly" /> and <see cref="T:log4net.Repository.ILoggerRepository" />
            is made is not defined. The implementation may choose any method for
            this association.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.IRepositorySelector.CreateRepository(System.String,System.Type)">
      <summary>
            Creates a new repository with the name specified.
            </summary>
      <param name="repositoryName">The name to associate with the <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <param name="repositoryType">The type of repository to create, must implement <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <returns>The repository created.</returns>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the name
            specified such that a call to <see cref="M:GetRepository(string)" /> with the
            same name will return the same repository instance.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.IRepositorySelector.ExistsRepository(System.String)">
      <summary>
            Test if a named repository exists
            </summary>
      <param name="repositoryName">the named repository to check</param>
      <returns>
        <c>true</c> if the repository exists</returns>
      <remarks>
        <para>
            Test if a named repository exists. Use <see cref="M:CreateRepository(Assembly, Type)" />
            to create a new repository and <see cref="M:GetRepository(Assembly)" /> to retrieve 
            a repository.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.IRepositorySelector.GetAllRepositories">
      <summary>
            Gets an array of all currently defined repositories.
            </summary>
      <returns>
            An array of the <see cref="T:log4net.Repository.ILoggerRepository" /> instances created by 
            this <see cref="T:log4net.Core.IRepositorySelector" />.</returns>
      <remarks>
        <para>
            Gets an array of all of the repositories created by this selector.
            </para>
      </remarks>
    </member>
    <member name="E:log4net.Core.IRepositorySelector.LoggerRepositoryCreatedEvent">
      <summary>
            Event to notify that a logger repository has been created.
            </summary>
      <value>
            Event to notify that a logger repository has been created.
            </value>
      <remarks>
        <para>
            Event raised when a new repository is created.
            The event source will be this selector. The event args will
            be a <see cref="T:log4net.Core.LoggerRepositoryCreationEventArgs" /> which
            holds the newly created <see cref="T:log4net.Repository.ILoggerRepository" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.CompactRepositorySelector">
      <summary>
            The implementation of the <see cref="T:log4net.Core.IRepositorySelector" /> interface suitable
            for use with the compact framework
            </summary>
      <remarks>
        <para>
            This <see cref="T:log4net.Core.IRepositorySelector" /> implementation is a simple
            mapping between repository name and <see cref="T:log4net.Repository.ILoggerRepository" />
            object.
            </para>
        <para>
            The .NET Compact Framework 1.0 does not support retrieving assembly
            level attributes therefore unlike the <c>DefaultRepositorySelector</c>
            this selector does not examine the calling assembly for attributes.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Core.CompactRepositorySelector.declaringType">
      <summary>
            The fully qualified type of the CompactRepositorySelector class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Core.CompactRepositorySelector.#ctor(System.Type)">
      <summary>
            Create a new repository selector
            </summary>
      <param name="defaultRepositoryType">the type of the repositories to create, must implement <see cref="T:log4net.Repository.ILoggerRepository" /></param>
      <remarks>
        <para>
            Create an new compact repository selector.
            The default type for repositories must be specified,
            an appropriate value would be <see cref="T:log4net.Repository.Hierarchy.Hierarchy" />.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">throw if <paramref name="defaultRepositoryType" /> is null</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">throw if <paramref name="defaultRepositoryType" /> does not implement <see cref="T:log4net.Repository.ILoggerRepository" /></exception>
    </member>
    <member name="M:log4net.Core.CompactRepositorySelector.GetRepository(System.Reflection.Assembly)">
      <summary>
            Get the <see cref="T:log4net.Repository.ILoggerRepository" /> for the specified assembly
            </summary>
      <param name="assembly">not used</param>
      <returns>The default <see cref="T:log4net.Repository.ILoggerRepository" /></returns>
      <remarks>
        <para>
            The <paramref name="assembly" /> argument is not used. This selector does not create a
            separate repository for each assembly. 
            </para>
        <para>
            As a named repository is not specified the default repository is 
            returned. The default repository is named <c>log4net-default-repository</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.CompactRepositorySelector.GetRepository(System.String)">
      <summary>
            Get the named <see cref="T:log4net.Repository.ILoggerRepository" /></summary>
      <param name="repositoryName">the name of the repository to lookup</param>
      <returns>The named <see cref="T:log4net.Repository.ILoggerRepository" /></returns>
      <remarks>
        <para>
            Get the named <see cref="T:log4net.Repository.ILoggerRepository" />. The default 
            repository is <c>log4net-default-repository</c>. Other repositories 
            must be created using the <see cref="M:CreateRepository(string, Type)" />.
            If the named repository does not exist an exception is thrown.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">throw if <paramref name="repositoryName" /> is null</exception>
      <exception cref="T:log4net.Core.LogException">throw if the <paramref name="repositoryName" /> does not exist</exception>
    </member>
    <member name="M:log4net.Core.CompactRepositorySelector.CreateRepository(System.Reflection.Assembly,System.Type)">
      <summary>
            Create a new repository for the assembly specified 
            </summary>
      <param name="assembly">not used</param>
      <param name="repositoryType">the type of repository to create, must implement <see cref="T:log4net.Repository.ILoggerRepository" /></param>
      <returns>the repository created</returns>
      <remarks>
        <para>
            The <paramref name="assembly" /> argument is not used. This selector does not create a
            separate repository for each assembly. 
            </para>
        <para>
            If the <paramref name="repositoryType" /> is <c>null</c> then the
            default repository type specified to the constructor is used.
            </para>
        <para>
            As a named repository is not specified the default repository is 
            returned. The default repository is named <c>log4net-default-repository</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.CompactRepositorySelector.CreateRepository(System.String,System.Type)">
      <summary>
            Create a new repository for the repository specified
            </summary>
      <param name="repositoryName">the repository to associate with the <see cref="T:log4net.Repository.ILoggerRepository" /></param>
      <param name="repositoryType">the type of repository to create, must implement <see cref="T:log4net.Repository.ILoggerRepository" />.
            If this param is null then the default repository type is used.</param>
      <returns>the repository created</returns>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the repository
            specified such that a call to <see cref="M:GetRepository(string)" /> with the
            same repository specified will return the same repository instance.
            </para>
        <para>
            If the named repository already exists an exception will be thrown.
            </para>
        <para>
            If <paramref name="repositoryType" /> is <c>null</c> then the default 
            repository type specified to the constructor is used.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">throw if <paramref name="repositoryName" /> is null</exception>
      <exception cref="T:log4net.Core.LogException">throw if the <paramref name="repositoryName" /> already exists</exception>
    </member>
    <member name="M:log4net.Core.CompactRepositorySelector.ExistsRepository(System.String)">
      <summary>
            Test if a named repository exists
            </summary>
      <param name="repositoryName">the named repository to check</param>
      <returns>
        <c>true</c> if the repository exists</returns>
      <remarks>
        <para>
            Test if a named repository exists. Use <see cref="M:CreateRepository(string, Type)" />
            to create a new repository and <see cref="M:GetRepository(string)" /> to retrieve 
            a repository.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.CompactRepositorySelector.GetAllRepositories">
      <summary>
            Gets a list of <see cref="T:log4net.Repository.ILoggerRepository" /> objects
            </summary>
      <returns>an array of all known <see cref="T:log4net.Repository.ILoggerRepository" /> objects</returns>
      <remarks>
        <para>
            Gets an array of all of the repositories created by this selector.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.CompactRepositorySelector.OnLoggerRepositoryCreatedEvent(log4net.Repository.ILoggerRepository)">
      <summary>
            Notify the registered listeners that the repository has been created
            </summary>
      <param name="repository">The repository that has been created</param>
      <remarks>
        <para>
            Raises the <event cref="E:log4net.Core.CompactRepositorySelector.LoggerRepositoryCreatedEvent">LoggerRepositoryCreatedEvent</event>
            event.
            </para>
      </remarks>
    </member>
    <member name="E:log4net.Core.CompactRepositorySelector.LoggerRepositoryCreatedEvent">
      <summary>
            Event to notify that a logger repository has been created.
            </summary>
      <value>
            Event to notify that a logger repository has been created.
            </value>
      <remarks>
        <para>
            Event raised when a new repository is created.
            The event source will be this selector. The event args will
            be a <see cref="T:log4net.Core.LoggerRepositoryCreationEventArgs" /> which
            holds the newly created <see cref="T:log4net.Repository.ILoggerRepository" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.DefaultRepositorySelector">
      <summary>
            The default implementation of the <see cref="T:log4net.Core.IRepositorySelector" /> interface.
            </summary>
      <remarks>
        <para>
            Uses attributes defined on the calling assembly to determine how to
            configure the hierarchy for the repository.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Core.DefaultRepositorySelector.declaringType">
      <summary>
            The fully qualified type of the DefaultRepositorySelector class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.#ctor(System.Type)">
      <summary>
            Creates a new repository selector.
            </summary>
      <param name="defaultRepositoryType">The type of the repositories to create, must implement <see cref="T:log4net.Repository.ILoggerRepository" /></param>
      <remarks>
        <para>
            Create an new repository selector.
            The default type for repositories must be specified,
            an appropriate value would be <see cref="T:log4net.Repository.Hierarchy.Hierarchy" />.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="defaultRepositoryType" /> is <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="defaultRepositoryType" /> does not implement <see cref="T:log4net.Repository.ILoggerRepository" />.</exception>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.GetRepository(System.Reflection.Assembly)">
      <summary>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the specified assembly.
            </summary>
      <param name="repositoryAssembly">The assembly use to lookup the <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <remarks>
        <para>
            The type of the <see cref="T:log4net.Repository.ILoggerRepository" /> created and the repository 
            to create can be overridden by specifying the <see cref="T:log4net.Config.RepositoryAttribute" /> 
            attribute on the <paramref name="repositoryAssembly" />.
            </para>
        <para>
            The default values are to use the <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> 
            implementation of the <see cref="T:log4net.Repository.ILoggerRepository" /> interface and to use the
            <see cref="P:System.Reflection.AssemblyName.Name" /> as the name of the repository.
            </para>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be automatically configured using 
            any <see cref="T:log4net.Config.ConfiguratorAttribute" /> attributes defined on
            the <paramref name="repositoryAssembly" />.
            </para>
      </remarks>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> for the assembly</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="repositoryAssembly" /> is <see langword="null" />.</exception>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.GetRepository(System.String)">
      <summary>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the specified repository.
            </summary>
      <param name="repositoryName">The repository to use to lookup the <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> for the specified repository.</returns>
      <remarks>
        <para>
            Returns the named repository. If <paramref name="repositoryName" /> is <c>null</c>
            a <see cref="T:System.ArgumentNullException" /> is thrown. If the repository 
            does not exist a <see cref="T:log4net.Core.LogException" /> is thrown.
            </para>
        <para>
            Use <see cref="M:CreateRepository(string, Type)" /> to create a repository.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="repositoryName" /> is <see langword="null" />.</exception>
      <exception cref="T:log4net.Core.LogException">
        <paramref name="repositoryName" /> does not exist.</exception>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.CreateRepository(System.Reflection.Assembly,System.Type)">
      <summary>
            Create a new repository for the assembly specified 
            </summary>
      <param name="repositoryAssembly">the assembly to use to create the repository to associate with the <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <param name="repositoryType">The type of repository to create, must implement <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <returns>The repository created.</returns>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the repository
            specified such that a call to <see cref="M:GetRepository(Assembly)" /> with the
            same assembly specified will return the same repository instance.
            </para>
        <para>
            The type of the <see cref="T:log4net.Repository.ILoggerRepository" /> created and
            the repository to create can be overridden by specifying the
            <see cref="T:log4net.Config.RepositoryAttribute" /> attribute on the 
            <paramref name="repositoryAssembly" />.  The default values are to use the 
            <paramref name="repositoryType" /> implementation of the 
            <see cref="T:log4net.Repository.ILoggerRepository" /> interface and to use the
            <see cref="P:System.Reflection.AssemblyName.Name" /> as the name of the repository.
            </para>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be automatically
            configured using any <see cref="T:log4net.Config.ConfiguratorAttribute" /> 
            attributes defined on the <paramref name="repositoryAssembly" />.
            </para>
        <para>
            If a repository for the <paramref name="repositoryAssembly" /> already exists
            that repository will be returned. An error will not be raised and that 
            repository may be of a different type to that specified in <paramref name="repositoryType" />.
            Also the <see cref="T:log4net.Config.RepositoryAttribute" /> attribute on the
            assembly may be used to override the repository type specified in 
            <paramref name="repositoryType" />.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="repositoryAssembly" /> is <see langword="null" />.</exception>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.CreateRepository(System.Reflection.Assembly,System.Type,System.String,System.Boolean)">
      <summary>
            Creates a new repository for the assembly specified.
            </summary>
      <param name="repositoryAssembly">the assembly to use to create the repository to associate with the <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <param name="repositoryType">The type of repository to create, must implement <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <param name="repositoryName">The name to assign to the created repository</param>
      <param name="readAssemblyAttributes">Set to <c>true</c> to read and apply the assembly attributes</param>
      <returns>The repository created.</returns>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the repository
            specified such that a call to <see cref="M:GetRepository(Assembly)" /> with the
            same assembly specified will return the same repository instance.
            </para>
        <para>
            The type of the <see cref="T:log4net.Repository.ILoggerRepository" /> created and
            the repository to create can be overridden by specifying the
            <see cref="T:log4net.Config.RepositoryAttribute" /> attribute on the 
            <paramref name="repositoryAssembly" />.  The default values are to use the 
            <paramref name="repositoryType" /> implementation of the 
            <see cref="T:log4net.Repository.ILoggerRepository" /> interface and to use the
            <see cref="P:System.Reflection.AssemblyName.Name" /> as the name of the repository.
            </para>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be automatically
            configured using any <see cref="T:log4net.Config.ConfiguratorAttribute" /> 
            attributes defined on the <paramref name="repositoryAssembly" />.
            </para>
        <para>
            If a repository for the <paramref name="repositoryAssembly" /> already exists
            that repository will be returned. An error will not be raised and that 
            repository may be of a different type to that specified in <paramref name="repositoryType" />.
            Also the <see cref="T:log4net.Config.RepositoryAttribute" /> attribute on the
            assembly may be used to override the repository type specified in 
            <paramref name="repositoryType" />.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="repositoryAssembly" /> is <see langword="null" />.</exception>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.CreateRepository(System.String,System.Type)">
      <summary>
            Creates a new repository for the specified repository.
            </summary>
      <param name="repositoryName">The repository to associate with the <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <param name="repositoryType">The type of repository to create, must implement <see cref="T:log4net.Repository.ILoggerRepository" />.
            If this param is <see langword="null" /> then the default repository type is used.</param>
      <returns>The new repository.</returns>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the repository
            specified such that a call to <see cref="M:GetRepository(string)" /> with the
            same repository specified will return the same repository instance.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="repositoryName" /> is <see langword="null" />.</exception>
      <exception cref="T:log4net.Core.LogException">
        <paramref name="repositoryName" /> already exists.</exception>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.ExistsRepository(System.String)">
      <summary>
            Test if a named repository exists
            </summary>
      <param name="repositoryName">the named repository to check</param>
      <returns>
        <c>true</c> if the repository exists</returns>
      <remarks>
        <para>
            Test if a named repository exists. Use <see cref="M:CreateRepository(string, Type)" />
            to create a new repository and <see cref="M:GetRepository(string)" /> to retrieve 
            a repository.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.GetAllRepositories">
      <summary>
            Gets a list of <see cref="T:log4net.Repository.ILoggerRepository" /> objects
            </summary>
      <returns>an array of all known <see cref="T:log4net.Repository.ILoggerRepository" /> objects</returns>
      <remarks>
        <para>
            Gets an array of all of the repositories created by this selector.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.AliasRepository(System.String,log4net.Repository.ILoggerRepository)">
      <summary>
            Aliases a repository to an existing repository.
            </summary>
      <param name="repositoryAlias">The repository to alias.</param>
      <param name="repositoryTarget">The repository that the repository is aliased to.</param>
      <remarks>
        <para>
            The repository specified will be aliased to the repository when created. 
            The repository must not already exist.
            </para>
        <para>
            When the repository is created it must utilize the same repository type as 
            the repository it is aliased to, otherwise the aliasing will fail.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <para>
          <paramref name="repositoryAlias" /> is <see langword="null" />.</para>
        <para>-or-</para>
        <para>
          <paramref name="repositoryTarget" /> is <see langword="null" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.OnLoggerRepositoryCreatedEvent(log4net.Repository.ILoggerRepository)">
      <summary>
            Notifies the registered listeners that the repository has been created.
            </summary>
      <param name="repository">The repository that has been created.</param>
      <remarks>
        <para>
            Raises the <see cref="E:log4net.Core.DefaultRepositorySelector.LoggerRepositoryCreatedEvent" /> event.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.GetInfoForAssembly(System.Reflection.Assembly,System.String@,System.Type@)">
      <summary>
            Gets the repository name and repository type for the specified assembly.
            </summary>
      <param name="assembly">The assembly that has a <see cref="T:log4net.Config.RepositoryAttribute" />.</param>
      <param name="repositoryName">in/out param to hold the repository name to use for the assembly, caller should set this to the default value before calling.</param>
      <param name="repositoryType">in/out param to hold the type of the repository to create for the assembly, caller should set this to the default value before calling.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="assembly" /> is <see langword="null" />.</exception>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.ConfigureRepository(System.Reflection.Assembly,log4net.Repository.ILoggerRepository)">
      <summary>
            Configures the repository using information from the assembly.
            </summary>
      <param name="assembly">The assembly containing <see cref="T:log4net.Config.ConfiguratorAttribute" />
            attributes which define the configuration for the repository.</param>
      <param name="repository">The repository to configure.</param>
      <exception cref="T:System.ArgumentNullException">
        <para>
          <paramref name="assembly" /> is <see langword="null" />.</para>
        <para>-or-</para>
        <para>
          <paramref name="repository" /> is <see langword="null" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.LoadPlugins(System.Reflection.Assembly,log4net.Repository.ILoggerRepository)">
      <summary>
            Loads the attribute defined plugins on the assembly.
            </summary>
      <param name="assembly">The assembly that contains the attributes.</param>
      <param name="repository">The repository to add the plugins to.</param>
      <exception cref="T:System.ArgumentNullException">
        <para>
          <paramref name="assembly" /> is <see langword="null" />.</para>
        <para>-or-</para>
        <para>
          <paramref name="repository" /> is <see langword="null" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.LoadAliases(System.Reflection.Assembly,log4net.Repository.ILoggerRepository)">
      <summary>
            Loads the attribute defined aliases on the assembly.
            </summary>
      <param name="assembly">The assembly that contains the attributes.</param>
      <param name="repository">The repository to alias to.</param>
      <exception cref="T:System.ArgumentNullException">
        <para>
          <paramref name="assembly" /> is <see langword="null" />.</para>
        <para>-or-</para>
        <para>
          <paramref name="repository" /> is <see langword="null" />.</para>
      </exception>
    </member>
    <member name="E:log4net.Core.DefaultRepositorySelector.LoggerRepositoryCreatedEvent">
      <summary>
            Event to notify that a logger repository has been created.
            </summary>
      <value>
            Event to notify that a logger repository has been created.
            </value>
      <remarks>
        <para>
            Event raised when a new repository is created.
            The event source will be this selector. The event args will
            be a <see cref="T:log4net.Core.LoggerRepositoryCreationEventArgs" /> which
            holds the newly created <see cref="T:log4net.Repository.ILoggerRepository" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.ErrorCode">
      <summary>
            Defined error codes that can be passed to the <see cref="M:IErrorHandler.Error(string, Exception, ErrorCode)" /> method.
            </summary>
      <remarks>
        <para>
            Values passed to the <see cref="M:IErrorHandler.Error(string, Exception, ErrorCode)" /> method.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Core.ErrorCode.GenericFailure">
      <summary>
            A general error
            </summary>
    </member>
    <member name="F:log4net.Core.ErrorCode.WriteFailure">
      <summary>
            Error while writing output
            </summary>
    </member>
    <member name="F:log4net.Core.ErrorCode.FlushFailure">
      <summary>
            Failed to flush file
            </summary>
    </member>
    <member name="F:log4net.Core.ErrorCode.CloseFailure">
      <summary>
            Failed to close file
            </summary>
    </member>
    <member name="F:log4net.Core.ErrorCode.FileOpenFailure">
      <summary>
            Unable to open output file
            </summary>
    </member>
    <member name="F:log4net.Core.ErrorCode.MissingLayout">
      <summary>
            No layout specified
            </summary>
    </member>
    <member name="F:log4net.Core.ErrorCode.AddressParseFailure">
      <summary>
            Failed to parse address
            </summary>
    </member>
    <member name="T:log4net.Core.ITriggeringEventEvaluator">
      <summary>
            Test if an <see cref="T:log4net.Core.LoggingEvent" /> triggers an action
            </summary>
      <remarks>
        <para>
            Implementations of this interface allow certain appenders to decide
            when to perform an appender specific action.
            </para>
        <para>
            The action or behavior triggered is defined by the implementation.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Core.ITriggeringEventEvaluator.IsTriggeringEvent(log4net.Core.LoggingEvent)">
      <summary>
            Test if this event triggers the action
            </summary>
      <param name="loggingEvent">The event to check</param>
      <returns>
        <c>true</c> if this event triggers the action, otherwise <c>false</c></returns>
      <remarks>
        <para>
            Return <c>true</c> if this event triggers the action
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.ExceptionEvaluator">
      <summary>
            An evaluator that triggers on an Exception type
            </summary>
      <remarks>
        <para>
            This evaluator will trigger if the type of the Exception
            passed to <see cref="M:IsTriggeringEvent(LoggingEvent)" />
            is equal to a Type in <see cref="P:log4net.Core.ExceptionEvaluator.ExceptionType" />.    /// 
            </para>
      </remarks>
      <author>Drew Schaeffer</author>
    </member>
    <member name="F:log4net.Core.ExceptionEvaluator.m_type">
      <summary>
            The type that causes the trigger to fire.
            </summary>
    </member>
    <member name="F:log4net.Core.ExceptionEvaluator.m_triggerOnSubclass">
      <summary>
            Causes subclasses of <see cref="P:log4net.Core.ExceptionEvaluator.ExceptionType" /> to cause the trigger to fire.
            </summary>
    </member>
    <member name="M:log4net.Core.ExceptionEvaluator.#ctor">
      <summary>
            Default ctor to allow dynamic creation through a configurator.
            </summary>
    </member>
    <member name="M:log4net.Core.ExceptionEvaluator.#ctor(System.Type,System.Boolean)">
      <summary>
            Constructs an evaluator and initializes to trigger on <paramref name="exType" /></summary>
      <param name="exType">the type that triggers this evaluator.</param>
      <param name="triggerOnSubClass">If true, this evaluator will trigger on subclasses of <see cref="P:log4net.Core.ExceptionEvaluator.ExceptionType" />.</param>
    </member>
    <member name="M:log4net.Core.ExceptionEvaluator.IsTriggeringEvent(log4net.Core.LoggingEvent)">
      <summary>
            Is this <paramref name="loggingEvent" /> the triggering event?
            </summary>
      <param name="loggingEvent">The event to check</param>
      <returns>This method returns <c>true</c>, if the logging event Exception 
            Type is <see cref="P:log4net.Core.ExceptionEvaluator.ExceptionType" />. 
            Otherwise it returns <c>false</c></returns>
      <remarks>
        <para>
            This evaluator will trigger if the Exception Type of the event
            passed to <see cref="M:IsTriggeringEvent(LoggingEvent)" />
            is <see cref="P:log4net.Core.ExceptionEvaluator.ExceptionType" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.ExceptionEvaluator.ExceptionType">
      <summary>
            The type that triggers this evaluator.
            </summary>
    </member>
    <member name="P:log4net.Core.ExceptionEvaluator.TriggerOnSubclass">
      <summary>
            If true, this evaluator will trigger on subclasses of <see cref="P:log4net.Core.ExceptionEvaluator.ExceptionType" />.
            </summary>
    </member>
    <member name="T:log4net.Core.IErrorHandler">
      <summary>
            Appenders may delegate their error handling to an <see cref="T:log4net.Core.IErrorHandler" />.
            </summary>
      <remarks>
        <para>
            Error handling is a particularly tedious to get right because by
            definition errors are hard to predict and to reproduce. 
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Core.IErrorHandler.Error(System.String,System.Exception,log4net.Core.ErrorCode)">
      <summary>
            Handles the error and information about the error condition is passed as 
            a parameter.
            </summary>
      <param name="message">The message associated with the error.</param>
      <param name="e">The <see cref="T:System.Exception" /> that was thrown when the error occurred.</param>
      <param name="errorCode">The error code associated with the error.</param>
      <remarks>
        <para>
            Handles the error and information about the error condition is passed as 
            a parameter.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.IErrorHandler.Error(System.String,System.Exception)">
      <summary>
            Prints the error message passed as a parameter.
            </summary>
      <param name="message">The message associated with the error.</param>
      <param name="e">The <see cref="T:System.Exception" /> that was thrown when the error occurred.</param>
      <remarks>
        <para>
            See <see cref="M:Error(string,Exception,ErrorCode)" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.IErrorHandler.Error(System.String)">
      <summary>
            Prints the error message passed as a parameter.
            </summary>
      <param name="message">The message associated with the error.</param>
      <remarks>
        <para>
            See <see cref="M:Error(string,Exception,ErrorCode)" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.IFixingRequired">
      <summary>
            Interface for objects that require fixing.
            </summary>
      <remarks>
        <para>
            Interface that indicates that the object requires fixing before it
            can be taken outside the context of the appender's 
            <see cref="M:log4net.Appender.IAppender.DoAppend(log4net.Core.LoggingEvent)" /> method.
            </para>
        <para>
            When objects that implement this interface are stored 
            in the context properties maps <see cref="T:log4net.GlobalContext" /><see cref="P:log4net.GlobalContext.Properties" /> and <see cref="T:log4net.ThreadContext" /><see cref="P:log4net.ThreadContext.Properties" /> are fixed 
            (see <see cref="P:log4net.Core.LoggingEvent.Fix" />) the <see cref="M:log4net.Core.IFixingRequired.GetFixedObject" />
            method will be called.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Core.IFixingRequired.GetFixedObject">
      <summary>
            Get a portable version of this object
            </summary>
      <returns>the portable instance of this object</returns>
      <remarks>
        <para>
            Get a portable instance object that represents the current
            state of this object. The portable object can be stored
            and logged from any thread with identical results.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.ILogger">
      <summary>
            Interface that all loggers implement
            </summary>
      <remarks>
        <para>
            This interface supports logging events and testing if a level
            is enabled for logging.
            </para>
        <para>
            These methods will not throw exceptions. Note to implementor, ensure
            that the implementation of these methods cannot allow an exception
            to be thrown to the caller.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Core.ILogger.Log(System.Type,log4net.Core.Level,System.Object,System.Exception)">
      <summary>
            This generic form is intended to be used by wrappers.
            </summary>
      <param name="callerStackBoundaryDeclaringType">The declaring type of the method that is
            the stack boundary into the logging system for this call.</param>
      <param name="level">The level of the message to be logged.</param>
      <param name="message">The message object to log.</param>
      <param name="exception">the exception to log, including its stack trace. Pass <c>null</c> to not log an exception.</param>
      <remarks>
        <para>
            Generates a logging event for the specified <paramref name="level" /> using
            the <paramref name="message" /> and <paramref name="exception" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.ILogger.Log(log4net.Core.LoggingEvent)">
      <summary>
            This is the most generic printing method that is intended to be used 
            by wrappers.
            </summary>
      <param name="logEvent">The event being logged.</param>
      <remarks>
        <para>
            Logs the specified logging event through this logger.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.ILogger.IsEnabledFor(log4net.Core.Level)">
      <summary>
            Checks if this logger is enabled for a given <see cref="T:log4net.Core.Level" /> passed as parameter.
            </summary>
      <param name="level">The level to check.</param>
      <returns>
        <c>true</c> if this logger is enabled for <c>level</c>, otherwise <c>false</c>.
            </returns>
      <remarks>
        <para>
            Test if this logger is going to log events of the specified <paramref name="level" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.ILogger.Name">
      <summary>
            Gets the name of the logger.
            </summary>
      <value>
            The name of the logger.
            </value>
      <remarks>
        <para>
            The name of this logger
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.ILogger.Repository">
      <summary>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> where this 
            <c>Logger</c> instance is attached to.
            </summary>
      <value>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> that this logger belongs to.
            </value>
      <remarks>
        <para>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> where this 
            <c>Logger</c> instance is attached to.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.ILoggerWrapper">
      <summary>
            Base interface for all wrappers
            </summary>
      <remarks>
        <para>
            Base interface for all wrappers.
            </para>
        <para>
            All wrappers must implement this interface.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="P:log4net.Core.ILoggerWrapper.Logger">
      <summary>
            Get the implementation behind this wrapper object.
            </summary>
      <value>
            The <see cref="T:log4net.Core.ILogger" /> object that in implementing this object.
            </value>
      <remarks>
        <para>
            The <see cref="T:log4net.Core.ILogger" /> object that in implementing this
            object. The <c>Logger</c> object may not 
            be the same object as this object because of logger decorators.
            This gets the actual underlying objects that is used to process
            the log events.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.LoggerRepositoryCreationEventHandler">
      <summary>
            Delegate used to handle logger repository creation event notifications
            </summary>
      <param name="sender">The <see cref="T:log4net.Core.IRepositorySelector" /> which created the repository.</param>
      <param name="e">The <see cref="T:log4net.Core.LoggerRepositoryCreationEventArgs" /> event args
            that holds the <see cref="T:log4net.Repository.ILoggerRepository" /> instance that has been created.</param>
      <remarks>
        <para>
            Delegate used to handle logger repository creation event notifications.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.LoggerRepositoryCreationEventArgs">
      <summary>
            Provides data for the <see cref="E:log4net.Core.IRepositorySelector.LoggerRepositoryCreatedEvent" /> event.
            </summary>
      <remarks>
        <para>
            A <see cref="E:log4net.Core.IRepositorySelector.LoggerRepositoryCreatedEvent" /> 
            event is raised every time a <see cref="T:log4net.Repository.ILoggerRepository" /> is created.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Core.LoggerRepositoryCreationEventArgs.m_repository">
      <summary>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created
            </summary>
    </member>
    <member name="M:log4net.Core.LoggerRepositoryCreationEventArgs.#ctor(log4net.Repository.ILoggerRepository)">
      <summary>
            Construct instance using <see cref="T:log4net.Repository.ILoggerRepository" /> specified
            </summary>
      <param name="repository">the <see cref="T:log4net.Repository.ILoggerRepository" /> that has been created</param>
      <remarks>
        <para>
            Construct instance using <see cref="T:log4net.Repository.ILoggerRepository" /> specified
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggerRepositoryCreationEventArgs.LoggerRepository">
      <summary>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> that has been created
            </summary>
      <value>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> that has been created
            </value>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> that has been created
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.Level">
      <summary>
            Defines the default set of levels recognized by the system.
            </summary>
      <remarks>
        <para>
            Each <see cref="T:log4net.Core.LoggingEvent" /> has an associated <see cref="T:log4net.Core.Level" />.
            </para>
        <para>
            Levels have a numeric <see cref="P:log4net.Core.Level.Value" /> that defines the relative 
            ordering between levels. Two Levels with the same <see cref="P:log4net.Core.Level.Value" /> 
            are deemed to be equivalent.
            </para>
        <para>
            The levels that are recognized by log4net are set for each <see cref="T:log4net.Repository.ILoggerRepository" />
            and each repository can have different levels defined. The levels are stored
            in the <see cref="P:log4net.Repository.ILoggerRepository.LevelMap" /> on the repository. Levels are
            looked up by name from the <see cref="P:log4net.Repository.ILoggerRepository.LevelMap" />.
            </para>
        <para>
            When logging at level INFO the actual level used is not <see cref="F:log4net.Core.Level.Info" /> but
            the value of <c>LoggerRepository.LevelMap["INFO"]</c>. The default value for this is
            <see cref="F:log4net.Core.Level.Info" />, but this can be changed by reconfiguring the level map.
            </para>
        <para>
            Each level has a <see cref="P:log4net.Core.Level.DisplayName" /> in addition to its <see cref="P:log4net.Core.Level.Name" />. The 
            <see cref="P:log4net.Core.Level.DisplayName" /> is the string that is written into the output log. By default
            the display name is the same as the level name, but this can be used to alias levels
            or to localize the log output.
            </para>
        <para>
            Some of the predefined levels recognized by the system are:
            </para>
        <list type="bullet">
          <item>
            <description>
              <see cref="F:log4net.Core.Level.Off" />.</description>
          </item>
          <item>
            <description>
              <see cref="F:log4net.Core.Level.Fatal" />.</description>
          </item>
          <item>
            <description>
              <see cref="F:log4net.Core.Level.Error" />.</description>
          </item>
          <item>
            <description>
              <see cref="F:log4net.Core.Level.Warn" />.</description>
          </item>
          <item>
            <description>
              <see cref="F:log4net.Core.Level.Info" />.</description>
          </item>
          <item>
            <description>
              <see cref="F:log4net.Core.Level.Debug" />.</description>
          </item>
          <item>
            <description>
              <see cref="F:log4net.Core.Level.All" />.</description>
          </item>
        </list>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Core.Level.Off">
      <summary>
            The <see cref="F:log4net.Core.Level.Off" /> level designates a higher level than all the rest.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Log4Net_Debug">
      <summary>
            The <see cref="F:log4net.Core.Level.Emergency" /> level designates very severe error events. 
            System unusable, emergencies.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Emergency">
      <summary>
            The <see cref="F:log4net.Core.Level.Emergency" /> level designates very severe error events. 
            System unusable, emergencies.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Fatal">
      <summary>
            The <see cref="F:log4net.Core.Level.Fatal" /> level designates very severe error events 
            that will presumably lead the application to abort.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Alert">
      <summary>
            The <see cref="F:log4net.Core.Level.Alert" /> level designates very severe error events. 
            Take immediate action, alerts.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Critical">
      <summary>
            The <see cref="F:log4net.Core.Level.Critical" /> level designates very severe error events. 
            Critical condition, critical.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Severe">
      <summary>
            The <see cref="F:log4net.Core.Level.Severe" /> level designates very severe error events.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Error">
      <summary>
            The <see cref="F:log4net.Core.Level.Error" /> level designates error events that might 
            still allow the application to continue running.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Warn">
      <summary>
            The <see cref="F:log4net.Core.Level.Warn" /> level designates potentially harmful 
            situations.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Notice">
      <summary>
            The <see cref="F:log4net.Core.Level.Notice" /> level designates informational messages 
            that highlight the progress of the application at the highest level.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Info">
      <summary>
            The <see cref="F:log4net.Core.Level.Info" /> level designates informational messages that 
            highlight the progress of the application at coarse-grained level.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Debug">
      <summary>
            The <see cref="F:log4net.Core.Level.Debug" /> level designates fine-grained informational 
            events that are most useful to debug an application.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Fine">
      <summary>
            The <see cref="F:log4net.Core.Level.Fine" /> level designates fine-grained informational 
            events that are most useful to debug an application.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Trace">
      <summary>
            The <see cref="F:log4net.Core.Level.Trace" /> level designates fine-grained informational 
            events that are most useful to debug an application.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Finer">
      <summary>
            The <see cref="F:log4net.Core.Level.Finer" /> level designates fine-grained informational 
            events that are most useful to debug an application.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Verbose">
      <summary>
            The <see cref="F:log4net.Core.Level.Verbose" /> level designates fine-grained informational 
            events that are most useful to debug an application.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Finest">
      <summary>
            The <see cref="F:log4net.Core.Level.Finest" /> level designates fine-grained informational 
            events that are most useful to debug an application.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.All">
      <summary>
            The <see cref="F:log4net.Core.Level.All" /> level designates the lowest level possible.
            </summary>
    </member>
    <member name="M:log4net.Core.Level.#ctor(System.Int32,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="level">Integer value for this level, higher values represent more severe levels.</param>
      <param name="levelName">The string name of this level.</param>
      <param name="displayName">The display name for this level. This may be localized or otherwise different from the name</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Core.Level" /> class with
            the specified level name and value.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.Level.#ctor(System.Int32,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="level">Integer value for this level, higher values represent more severe levels.</param>
      <param name="levelName">The string name of this level.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Core.Level" /> class with
            the specified level name and value.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.Level.ToString">
      <summary>
            Returns the <see cref="T:System.String" /> representation of the current 
            <see cref="T:log4net.Core.Level" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> representation of the current <see cref="T:log4net.Core.Level" />.
            </returns>
      <remarks>
        <para>
            Returns the level <see cref="P:log4net.Core.Level.Name" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.Level.Equals(System.Object)">
      <summary>
            Compares levels.
            </summary>
      <param name="o">The object to compare against.</param>
      <returns>
        <c>true</c> if the objects are equal.</returns>
      <remarks>
        <para>
            Compares the levels of <see cref="T:log4net.Core.Level" /> instances, and 
            defers to base class if the target object is not a <see cref="T:log4net.Core.Level" />
            instance.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.Level.GetHashCode">
      <summary>
            Returns a hash code
            </summary>
      <returns>A hash code for the current <see cref="T:log4net.Core.Level" />.</returns>
      <remarks>
        <para>
            Returns a hash code suitable for use in hashing algorithms and data 
            structures like a hash table.
            </para>
        <para>
            Returns the hash code of the level <see cref="P:log4net.Core.Level.Value" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.Level.CompareTo(System.Object)">
      <summary>
            Compares this instance to a specified object and returns an 
            indication of their relative values.
            </summary>
      <param name="r">A <see cref="T:log4net.Core.Level" /> instance or <see langword="null" /> to compare with this instance.</param>
      <returns>
            A 32-bit signed integer that indicates the relative order of the 
            values compared. The return value has these meanings:
            <list type="table"><listheader><term>Value</term><description>Meaning</description></listheader><item><term>Less than zero</term><description>This instance is less than <paramref name="r" />.</description></item><item><term>Zero</term><description>This instance is equal to <paramref name="r" />.</description></item><item><term>Greater than zero</term><description><para>This instance is greater than <paramref name="r" />.</para><para>-or-</para><para><paramref name="r" /> is <see langword="null" />.</para></description></item></list></returns>
      <remarks>
        <para>
          <paramref name="r" /> must be an instance of <see cref="T:log4net.Core.Level" /> 
            or <see langword="null" />; otherwise, an exception is thrown.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <paramref name="r" /> is not a <see cref="T:log4net.Core.Level" />.</exception>
    </member>
    <member name="M:log4net.Core.Level.op_GreaterThan(log4net.Core.Level,log4net.Core.Level)">
      <summary>
            Returns a value indicating whether a specified <see cref="T:log4net.Core.Level" /> 
            is greater than another specified <see cref="T:log4net.Core.Level" />.
            </summary>
      <param name="l">A <see cref="T:log4net.Core.Level" /></param>
      <param name="r">A <see cref="T:log4net.Core.Level" /></param>
      <returns>
        <c>true</c> if <paramref name="l" /> is greater than 
            <paramref name="r" />; otherwise, <c>false</c>.
            </returns>
      <remarks>
        <para>
            Compares two levels.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.Level.op_LessThan(log4net.Core.Level,log4net.Core.Level)">
      <summary>
            Returns a value indicating whether a specified <see cref="T:log4net.Core.Level" /> 
            is less than another specified <see cref="T:log4net.Core.Level" />.
            </summary>
      <param name="l">A <see cref="T:log4net.Core.Level" /></param>
      <param name="r">A <see cref="T:log4net.Core.Level" /></param>
      <returns>
        <c>true</c> if <paramref name="l" /> is less than 
            <paramref name="r" />; otherwise, <c>false</c>.
            </returns>
      <remarks>
        <para>
            Compares two levels.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.Level.op_GreaterThanOrEqual(log4net.Core.Level,log4net.Core.Level)">
      <summary>
            Returns a value indicating whether a specified <see cref="T:log4net.Core.Level" /> 
            is greater than or equal to another specified <see cref="T:log4net.Core.Level" />.
            </summary>
      <param name="l">A <see cref="T:log4net.Core.Level" /></param>
      <param name="r">A <see cref="T:log4net.Core.Level" /></param>
      <returns>
        <c>true</c> if <paramref name="l" /> is greater than or equal to 
            <paramref name="r" />; otherwise, <c>false</c>.
            </returns>
      <remarks>
        <para>
            Compares two levels.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.Level.op_LessThanOrEqual(log4net.Core.Level,log4net.Core.Level)">
      <summary>
            Returns a value indicating whether a specified <see cref="T:log4net.Core.Level" /> 
            is less than or equal to another specified <see cref="T:log4net.Core.Level" />.
            </summary>
      <param name="l">A <see cref="T:log4net.Core.Level" /></param>
      <param name="r">A <see cref="T:log4net.Core.Level" /></param>
      <returns>
        <c>true</c> if <paramref name="l" /> is less than or equal to 
            <paramref name="r" />; otherwise, <c>false</c>.
            </returns>
      <remarks>
        <para>
            Compares two levels.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.Level.op_Equality(log4net.Core.Level,log4net.Core.Level)">
      <summary>
            Returns a value indicating whether two specified <see cref="T:log4net.Core.Level" /> 
            objects have the same value.
            </summary>
      <param name="l">A <see cref="T:log4net.Core.Level" /> or <see langword="null" />.</param>
      <param name="r">A <see cref="T:log4net.Core.Level" /> or <see langword="null" />.</param>
      <returns>
        <c>true</c> if the value of <paramref name="l" /> is the same as the 
            value of <paramref name="r" />; otherwise, <c>false</c>.
            </returns>
      <remarks>
        <para>
            Compares two levels.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.Level.op_Inequality(log4net.Core.Level,log4net.Core.Level)">
      <summary>
            Returns a value indicating whether two specified <see cref="T:log4net.Core.Level" /> 
            objects have different values.
            </summary>
      <param name="l">A <see cref="T:log4net.Core.Level" /> or <see langword="null" />.</param>
      <param name="r">A <see cref="T:log4net.Core.Level" /> or <see langword="null" />.</param>
      <returns>
        <c>true</c> if the value of <paramref name="l" /> is different from
            the value of <paramref name="r" />; otherwise, <c>false</c>.
            </returns>
      <remarks>
        <para>
            Compares two levels.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.Level.Compare(log4net.Core.Level,log4net.Core.Level)">
      <summary>
            Compares two specified <see cref="T:log4net.Core.Level" /> instances.
            </summary>
      <param name="l">The first <see cref="T:log4net.Core.Level" /> to compare.</param>
      <param name="r">The second <see cref="T:log4net.Core.Level" /> to compare.</param>
      <returns>
            A 32-bit signed integer that indicates the relative order of the 
            two values compared. The return value has these meanings:
            <list type="table"><listheader><term>Value</term><description>Meaning</description></listheader><item><term>Less than zero</term><description><paramref name="l" /> is less than <paramref name="r" />.</description></item><item><term>Zero</term><description><paramref name="l" /> is equal to <paramref name="r" />.</description></item><item><term>Greater than zero</term><description><paramref name="l" /> is greater than <paramref name="r" />.</description></item></list></returns>
      <remarks>
        <para>
            Compares two levels.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.Level.Name">
      <summary>
            Gets the name of this level.
            </summary>
      <value>
            The name of this level.
            </value>
      <remarks>
        <para>
            Gets the name of this level.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.Level.Value">
      <summary>
            Gets the value of this level.
            </summary>
      <value>
            The value of this level.
            </value>
      <remarks>
        <para>
            Gets the value of this level.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.Level.DisplayName">
      <summary>
            Gets the display name of this level.
            </summary>
      <value>
            The display name of this level.
            </value>
      <remarks>
        <para>
            Gets the display name of this level.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.LevelCollection">
      <summary>
            A strongly-typed collection of <see cref="T:log4net.Core.Level" /> objects.
            </summary>
      <author>Nicko Cadell</author>
    </member>
    <member name="T:log4net.Core.LevelCollection.ILevelCollectionEnumerator">
      <summary>
            Supports type-safe iteration over a <see cref="T:log4net.Core.LevelCollection" />.
            </summary>
    </member>
    <member name="M:log4net.Core.LevelCollection.ILevelCollectionEnumerator.MoveNext">
      <summary>
            Advances the enumerator to the next element in the collection.
            </summary>
      <returns>
        <c>true</c> if the enumerator was successfully advanced to the next element; 
            <c>false</c> if the enumerator has passed the end of the collection.
            </returns>
      <exception cref="T:System.InvalidOperationException">
            The collection was modified after the enumerator was created.
            </exception>
    </member>
    <member name="M:log4net.Core.LevelCollection.ILevelCollectionEnumerator.Reset">
      <summary>
            Sets the enumerator to its initial position, before the first element in the collection.
            </summary>
    </member>
    <member name="P:log4net.Core.LevelCollection.ILevelCollectionEnumerator.Current">
      <summary>
            Gets the current element in the collection.
            </summary>
    </member>
    <member name="T:log4net.Core.LevelCollection.Tag">
      <summary>
            Type visible only to our subclasses
            Used to access protected constructor
            </summary>
    </member>
    <member name="T:log4net.Core.LevelCollection.Enumerator">
      <summary>
            Supports simple iteration over a <see cref="T:log4net.Core.LevelCollection" />.
            </summary>
    </member>
    <member name="M:log4net.Core.LevelCollection.Enumerator.#ctor(log4net.Core.LevelCollection)">
      <summary>
            Initializes a new instance of the <c>Enumerator</c> class.
            </summary>
      <param name="tc">
      </param>
    </member>
    <member name="M:log4net.Core.LevelCollection.Enumerator.MoveNext">
      <summary>
            Advances the enumerator to the next element in the collection.
            </summary>
      <returns>
        <c>true</c> if the enumerator was successfully advanced to the next element; 
            <c>false</c> if the enumerator has passed the end of the collection.
            </returns>
      <exception cref="T:System.InvalidOperationException">
            The collection was modified after the enumerator was created.
            </exception>
    </member>
    <member name="M:log4net.Core.LevelCollection.Enumerator.Reset">
      <summary>
            Sets the enumerator to its initial position, before the first element in the collection.
            </summary>
    </member>
    <member name="P:log4net.Core.LevelCollection.Enumerator.Current">
      <summary>
            Gets the current element in the collection.
            </summary>
    </member>
    <member name="M:log4net.Core.LevelCollection.ReadOnly(log4net.Core.LevelCollection)">
      <summary>
            Creates a read-only wrapper for a <c>LevelCollection</c> instance.
            </summary>
      <param name="list">list to create a readonly wrapper arround</param>
      <returns>
            A <c>LevelCollection</c> wrapper that is read-only.
            </returns>
    </member>
    <member name="M:log4net.Core.LevelCollection.#ctor">
      <summary>
            Initializes a new instance of the <c>LevelCollection</c> class
            that is empty and has the default initial capacity.
            </summary>
    </member>
    <member name="M:log4net.Core.LevelCollection.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <c>LevelCollection</c> class
            that has the specified initial capacity.
            </summary>
      <param name="capacity">
            The number of elements that the new <c>LevelCollection</c> is initially capable of storing.
            </param>
    </member>
    <member name="M:log4net.Core.LevelCollection.#ctor(log4net.Core.LevelCollection)">
      <summary>
            Initializes a new instance of the <c>LevelCollection</c> class
            that contains elements copied from the specified <c>LevelCollection</c>.
            </summary>
      <param name="c">The <c>LevelCollection</c> whose elements are copied to the new collection.</param>
    </member>
    <member name="M:log4net.Core.LevelCollection.#ctor(log4net.Core.Level[])">
      <summary>
            Initializes a new instance of the <c>LevelCollection</c> class
            that contains elements copied from the specified <see cref="T:log4net.Core.Level" /> array.
            </summary>
      <param name="a">The <see cref="T:log4net.Core.Level" /> array whose elements are copied to the new list.</param>
    </member>
    <member name="M:log4net.Core.LevelCollection.#ctor(System.Collections.ICollection)">
      <summary>
            Initializes a new instance of the <c>LevelCollection</c> class
            that contains elements copied from the specified <see cref="T:log4net.Core.Level" /> collection.
            </summary>
      <param name="col">The <see cref="T:log4net.Core.Level" /> collection whose elements are copied to the new list.</param>
    </member>
    <member name="M:log4net.Core.LevelCollection.#ctor(log4net.Core.LevelCollection.Tag)">
      <summary>
            Allow subclasses to avoid our default constructors
            </summary>
      <param name="tag">
      </param>
    </member>
    <member name="M:log4net.Core.LevelCollection.CopyTo(log4net.Core.Level[])">
      <summary>
            Copies the entire <c>LevelCollection</c> to a one-dimensional
            <see cref="T:log4net.Core.Level" /> array.
            </summary>
      <param name="array">The one-dimensional <see cref="T:log4net.Core.Level" /> array to copy to.</param>
    </member>
    <member name="M:log4net.Core.LevelCollection.CopyTo(log4net.Core.Level[],System.Int32)">
      <summary>
            Copies the entire <c>LevelCollection</c> to a one-dimensional
            <see cref="T:log4net.Core.Level" /> array, starting at the specified index of the target array.
            </summary>
      <param name="array">The one-dimensional <see cref="T:log4net.Core.Level" /> array to copy to.</param>
      <param name="start">The zero-based index in <paramref name="array" /> at which copying begins.</param>
    </member>
    <member name="M:log4net.Core.LevelCollection.Add(log4net.Core.Level)">
      <summary>
            Adds a <see cref="T:log4net.Core.Level" /> to the end of the <c>LevelCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Core.Level" /> to be added to the end of the <c>LevelCollection</c>.</param>
      <returns>The index at which the value has been added.</returns>
    </member>
    <member name="M:log4net.Core.LevelCollection.Clear">
      <summary>
            Removes all elements from the <c>LevelCollection</c>.
            </summary>
    </member>
    <member name="M:log4net.Core.LevelCollection.Clone">
      <summary>
            Creates a shallow copy of the <see cref="T:log4net.Core.LevelCollection" />.
            </summary>
      <returns>A new <see cref="T:log4net.Core.LevelCollection" /> with a shallow copy of the collection data.</returns>
    </member>
    <member name="M:log4net.Core.LevelCollection.Contains(log4net.Core.Level)">
      <summary>
            Determines whether a given <see cref="T:log4net.Core.Level" /> is in the <c>LevelCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Core.Level" /> to check for.</param>
      <returns>
        <c>true</c> if <paramref name="item" /> is found in the <c>LevelCollection</c>; otherwise, <c>false</c>.</returns>
    </member>
    <member name="M:log4net.Core.LevelCollection.IndexOf(log4net.Core.Level)">
      <summary>
            Returns the zero-based index of the first occurrence of a <see cref="T:log4net.Core.Level" />
            in the <c>LevelCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Core.Level" /> to locate in the <c>LevelCollection</c>.</param>
      <returns>
            The zero-based index of the first occurrence of <paramref name="item" /> 
            in the entire <c>LevelCollection</c>, if found; otherwise, -1.
            </returns>
    </member>
    <member name="M:log4net.Core.LevelCollection.Insert(System.Int32,log4net.Core.Level)">
      <summary>
            Inserts an element into the <c>LevelCollection</c> at the specified index.
            </summary>
      <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
      <param name="item">The <see cref="T:log4net.Core.Level" /> to insert.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Core.LevelCollection.Count" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Core.LevelCollection.Remove(log4net.Core.Level)">
      <summary>
            Removes the first occurrence of a specific <see cref="T:log4net.Core.Level" /> from the <c>LevelCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Core.Level" /> to remove from the <c>LevelCollection</c>.</param>
      <exception cref="T:System.ArgumentException">
            The specified <see cref="T:log4net.Core.Level" /> was not found in the <c>LevelCollection</c>.
            </exception>
    </member>
    <member name="M:log4net.Core.LevelCollection.RemoveAt(System.Int32)">
      <summary>
            Removes the element at the specified index of the <c>LevelCollection</c>.
            </summary>
      <param name="index">The zero-based index of the element to remove.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Core.LevelCollection.Count" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Core.LevelCollection.GetEnumerator">
      <summary>
            Returns an enumerator that can iterate through the <c>LevelCollection</c>.
            </summary>
      <returns>An <see cref="T:log4net.Core.LevelCollection.Enumerator" /> for the entire <c>LevelCollection</c>.</returns>
    </member>
    <member name="M:log4net.Core.LevelCollection.AddRange(log4net.Core.LevelCollection)">
      <summary>
            Adds the elements of another <c>LevelCollection</c> to the current <c>LevelCollection</c>.
            </summary>
      <param name="x">The <c>LevelCollection</c> whose elements should be added to the end of the current <c>LevelCollection</c>.</param>
      <returns>The new <see cref="P:log4net.Core.LevelCollection.Count" /> of the <c>LevelCollection</c>.</returns>
    </member>
    <member name="M:log4net.Core.LevelCollection.AddRange(log4net.Core.Level[])">
      <summary>
            Adds the elements of a <see cref="T:log4net.Core.Level" /> array to the current <c>LevelCollection</c>.
            </summary>
      <param name="x">The <see cref="T:log4net.Core.Level" /> array whose elements should be added to the end of the <c>LevelCollection</c>.</param>
      <returns>The new <see cref="P:log4net.Core.LevelCollection.Count" /> of the <c>LevelCollection</c>.</returns>
    </member>
    <member name="M:log4net.Core.LevelCollection.AddRange(System.Collections.ICollection)">
      <summary>
            Adds the elements of a <see cref="T:log4net.Core.Level" /> collection to the current <c>LevelCollection</c>.
            </summary>
      <param name="col">The <see cref="T:log4net.Core.Level" /> collection whose elements should be added to the end of the <c>LevelCollection</c>.</param>
      <returns>The new <see cref="P:log4net.Core.LevelCollection.Count" /> of the <c>LevelCollection</c>.</returns>
    </member>
    <member name="M:log4net.Core.LevelCollection.TrimToSize">
      <summary>
            Sets the capacity to the actual number of elements.
            </summary>
    </member>
    <member name="M:log4net.Core.LevelCollection.ValidateIndex(System.Int32)">
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="i" /> is less than zero</para>
        <para>-or-</para>
        <para>
          <paramref name="i" /> is equal to or greater than <see cref="P:log4net.Core.LevelCollection.Count" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Core.LevelCollection.ValidateIndex(System.Int32,System.Boolean)">
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="i" /> is less than zero</para>
        <para>-or-</para>
        <para>
          <paramref name="i" /> is equal to or greater than <see cref="P:log4net.Core.LevelCollection.Count" />.</para>
      </exception>
    </member>
    <member name="P:log4net.Core.LevelCollection.Count">
      <summary>
            Gets the number of elements actually contained in the <c>LevelCollection</c>.
            </summary>
    </member>
    <member name="P:log4net.Core.LevelCollection.IsSynchronized">
      <summary>
            Gets a value indicating whether access to the collection is synchronized (thread-safe).
            </summary>
      <value>true if access to the ICollection is synchronized (thread-safe); otherwise, false.</value>
    </member>
    <member name="P:log4net.Core.LevelCollection.SyncRoot">
      <summary>
            Gets an object that can be used to synchronize access to the collection.
            </summary>
    </member>
    <member name="P:log4net.Core.LevelCollection.Item(System.Int32)">
      <summary>
            Gets or sets the <see cref="T:log4net.Core.Level" /> at the specified index.
            </summary>
      <param name="index">The zero-based index of the element to get or set.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Core.LevelCollection.Count" />.</para>
      </exception>
    </member>
    <member name="P:log4net.Core.LevelCollection.IsFixedSize">
      <summary>
            Gets a value indicating whether the collection has a fixed size.
            </summary>
      <value>true if the collection has a fixed size; otherwise, false. The default is false</value>
    </member>
    <member name="P:log4net.Core.LevelCollection.IsReadOnly">
      <summary>
            Gets a value indicating whether the IList is read-only.
            </summary>
      <value>true if the collection is read-only; otherwise, false. The default is false</value>
    </member>
    <member name="P:log4net.Core.LevelCollection.Capacity">
      <summary>
            Gets or sets the number of elements the <c>LevelCollection</c> can contain.
            </summary>
    </member>
    <member name="T:log4net.Core.LevelEvaluator">
      <summary>
            An evaluator that triggers at a threshold level
            </summary>
      <remarks>
        <para>
            This evaluator will trigger if the level of the event
            passed to <see cref="M:IsTriggeringEvent(LoggingEvent)" />
            is equal to or greater than the <see cref="P:log4net.Core.LevelEvaluator.Threshold" />
            level.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Core.LevelEvaluator.m_threshold">
      <summary>
            The threshold for triggering
            </summary>
    </member>
    <member name="M:log4net.Core.LevelEvaluator.#ctor">
      <summary>
            Create a new evaluator using the <see cref="F:log4net.Core.Level.Off" /> threshold.
            </summary>
      <remarks>
        <para>
            Create a new evaluator using the <see cref="F:log4net.Core.Level.Off" /> threshold.
            </para>
        <para>
            This evaluator will trigger if the level of the event
            passed to <see cref="M:IsTriggeringEvent(LoggingEvent)" />
            is equal to or greater than the <see cref="P:log4net.Core.LevelEvaluator.Threshold" />
            level.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LevelEvaluator.#ctor(log4net.Core.Level)">
      <summary>
            Create a new evaluator using the specified <see cref="T:log4net.Core.Level" /> threshold.
            </summary>
      <param name="threshold">the threshold to trigger at</param>
      <remarks>
        <para>
            Create a new evaluator using the specified <see cref="T:log4net.Core.Level" /> threshold.
            </para>
        <para>
            This evaluator will trigger if the level of the event
            passed to <see cref="M:IsTriggeringEvent(LoggingEvent)" />
            is equal to or greater than the <see cref="P:log4net.Core.LevelEvaluator.Threshold" />
            level.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LevelEvaluator.IsTriggeringEvent(log4net.Core.LoggingEvent)">
      <summary>
            Is this <paramref name="loggingEvent" /> the triggering event?
            </summary>
      <param name="loggingEvent">The event to check</param>
      <returns>This method returns <c>true</c>, if the event level
            is equal or higher than the <see cref="P:log4net.Core.LevelEvaluator.Threshold" />. 
            Otherwise it returns <c>false</c></returns>
      <remarks>
        <para>
            This evaluator will trigger if the level of the event
            passed to <see cref="M:IsTriggeringEvent(LoggingEvent)" />
            is equal to or greater than the <see cref="P:log4net.Core.LevelEvaluator.Threshold" />
            level.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LevelEvaluator.Threshold">
      <summary>
            the threshold to trigger at
            </summary>
      <value>
            The <see cref="T:log4net.Core.Level" /> that will cause this evaluator to trigger
            </value>
      <remarks>
        <para>
            This evaluator will trigger if the level of the event
            passed to <see cref="M:IsTriggeringEvent(LoggingEvent)" />
            is equal to or greater than the <see cref="P:log4net.Core.LevelEvaluator.Threshold" />
            level.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.LevelMap">
      <summary>
            Mapping between string name and Level object
            </summary>
      <remarks>
        <para>
            Mapping between string name and <see cref="T:log4net.Core.Level" /> object.
            This mapping is held separately for each <see cref="T:log4net.Repository.ILoggerRepository" />.
            The level name is case insensitive.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Core.LevelMap.m_mapName2Level">
      <summary>
            Mapping from level name to Level object. The
            level name is case insensitive
            </summary>
    </member>
    <member name="M:log4net.Core.LevelMap.#ctor">
      <summary>
            Construct the level map
            </summary>
      <remarks>
        <para>
            Construct the level map.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LevelMap.Clear">
      <summary>
            Clear the internal maps of all levels
            </summary>
      <remarks>
        <para>
            Clear the internal maps of all levels
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LevelMap.Add(System.String,System.Int32)">
      <summary>
            Create a new Level and add it to the map
            </summary>
      <param name="name">the string to display for the Level</param>
      <param name="value">the level value to give to the Level</param>
      <remarks>
        <para>
            Create a new Level and add it to the map
            </para>
      </remarks>
      <seealso cref="M:Add(string,int,string)" />
    </member>
    <member name="M:log4net.Core.LevelMap.Add(System.String,System.Int32,System.String)">
      <summary>
            Create a new Level and add it to the map
            </summary>
      <param name="name">the string to display for the Level</param>
      <param name="value">the level value to give to the Level</param>
      <param name="displayName">the display name to give to the Level</param>
      <remarks>
        <para>
            Create a new Level and add it to the map
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LevelMap.Add(log4net.Core.Level)">
      <summary>
            Add a Level to the map
            </summary>
      <param name="level">the Level to add</param>
      <remarks>
        <para>
            Add a Level to the map
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LevelMap.LookupWithDefault(log4net.Core.Level)">
      <summary>
            Lookup a named level from the map
            </summary>
      <param name="defaultLevel">the name of the level to lookup is taken from this level. 
            If the level is not set on the map then this level is added</param>
      <returns>the level in the map with the name specified</returns>
      <remarks>
        <para>
            Lookup a named level from the map. The name of the level to lookup is taken
            from the <see cref="P:log4net.Core.Level.Name" /> property of the <paramref name="defaultLevel" />
            argument.
            </para>
        <para>
            If no level with the specified name is found then the 
            <paramref name="defaultLevel" /> argument is added to the level map
            and returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LevelMap.Item(System.String)">
      <summary>
            Lookup a <see cref="T:log4net.Core.Level" /> by name
            </summary>
      <param name="name">The name of the Level to lookup</param>
      <returns>a Level from the map with the name specified</returns>
      <remarks>
        <para>
            Returns the <see cref="T:log4net.Core.Level" /> from the
            map with the name specified. If the no level is
            found then <c>null</c> is returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LevelMap.AllLevels">
      <summary>
            Return all possible levels as a list of Level objects.
            </summary>
      <returns>all possible levels as a list of Level objects</returns>
      <remarks>
        <para>
            Return all possible levels as a list of Level objects.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.LocationInfo">
      <summary>
            The internal representation of caller location information.
            </summary>
      <remarks>
        <para>
            This class uses the <c>System.Diagnostics.StackTrace</c> class to generate
            a call stack. The caller's information is then extracted from this stack.
            </para>
        <para>
            The <c>System.Diagnostics.StackTrace</c> class is not supported on the 
            .NET Compact Framework 1.0 therefore caller location information is not
            available on that framework.
            </para>
        <para>
            The <c>System.Diagnostics.StackTrace</c> class has this to say about Release builds:
            </para>
        <para>
            "StackTrace information will be most informative with Debug build configurations. 
            By default, Debug builds include debug symbols, while Release builds do not. The 
            debug symbols contain most of the file, method name, line number, and column 
            information used in constructing StackFrame and StackTrace objects. StackTrace 
            might not report as many method calls as expected, due to code transformations 
            that occur during optimization."
            </para>
        <para>
            This means that in a Release build the caller information may be incomplete or may 
            not exist at all! Therefore caller location information cannot be relied upon in a Release build.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Core.LocationInfo.NA">
      <summary>
            When location information is not available the constant
            <c>NA</c> is returned. Current value of this string
            constant is <b>?</b>.
            </summary>
    </member>
    <member name="F:log4net.Core.LocationInfo.declaringType">
      <summary>
            The fully qualified type of the LocationInfo class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Core.LocationInfo.#ctor(System.Type)">
      <summary>
            Constructor
            </summary>
      <param name="callerStackBoundaryDeclaringType">The declaring type of the method that is
            the stack boundary into the logging system for this call.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Core.LocationInfo" />
            class based on the current thread.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LocationInfo.#ctor(System.String,System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="className">The fully qualified class name.</param>
      <param name="methodName">The method name.</param>
      <param name="fileName">The file name.</param>
      <param name="lineNumber">The line number of the method within the file.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Core.LocationInfo" />
            class with the specified data.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LocationInfo.ClassName">
      <summary>
            Gets the fully qualified class name of the caller making the logging 
            request.
            </summary>
      <value>
            The fully qualified class name of the caller making the logging 
            request.
            </value>
      <remarks>
        <para>
            Gets the fully qualified class name of the caller making the logging 
            request.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LocationInfo.FileName">
      <summary>
            Gets the file name of the caller.
            </summary>
      <value>
            The file name of the caller.
            </value>
      <remarks>
        <para>
            Gets the file name of the caller.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LocationInfo.LineNumber">
      <summary>
            Gets the line number of the caller.
            </summary>
      <value>
            The line number of the caller.
            </value>
      <remarks>
        <para>
            Gets the line number of the caller.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LocationInfo.MethodName">
      <summary>
            Gets the method name of the caller.
            </summary>
      <value>
            The method name of the caller.
            </value>
      <remarks>
        <para>
            Gets the method name of the caller.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LocationInfo.FullInfo">
      <summary>
            Gets all available caller information
            </summary>
      <value>
            All available caller information, in the format
            <c>fully.qualified.classname.of.caller.methodName(Filename:line)</c></value>
      <remarks>
        <para>
            Gets all available caller information, in the format
            <c>fully.qualified.classname.of.caller.methodName(Filename:line)</c></para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LocationInfo.StackFrames">
      <summary>
            Gets the stack frames from the stack trace of the caller making the log request
            </summary>
    </member>
    <member name="T:log4net.Core.LoggerManager">
      <summary>
            Static manager that controls the creation of repositories
            </summary>
      <remarks>
        <para>
            Static manager that controls the creation of repositories
            </para>
        <para>
            This class is used by the wrapper managers (e.g. <see cref="T:log4net.LogManager" />)
            to provide access to the <see cref="T:log4net.Core.ILogger" /> objects.
            </para>
        <para>
            This manager also holds the <see cref="T:log4net.Core.IRepositorySelector" /> that is used to
            lookup and create repositories. The selector can be set either programmatically using
            the <see cref="P:log4net.Core.LoggerManager.RepositorySelector" /> property, or by setting the <c>log4net.RepositorySelector</c>
            AppSetting in the applications config file to the fully qualified type name of the
            selector to use. 
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Core.LoggerManager.declaringType">
      <summary>
            The fully qualified type of the LoggerManager class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="F:log4net.Core.LoggerManager.s_repositorySelector">
      <summary>
            Initialize the default repository selector
            </summary>
    </member>
    <member name="M:log4net.Core.LoggerManager.#ctor">
      <summary>
            Private constructor to prevent instances. Only static methods should be used.
            </summary>
      <remarks>
        <para>
            Private constructor to prevent instances. Only static methods should be used.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.RegisterAppDomainEvents">
      <summary>
            Register for ProcessExit and DomainUnload events on the AppDomain
            </summary>
      <remarks>
        <para>
            This needs to be in a separate method because the events make
            a LinkDemand for the ControlAppDomain SecurityPermission. Because
            this is a LinkDemand it is demanded at JIT time. Therefore we cannot
            catch the exception in the method itself, we have to catch it in the
            caller.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetLoggerRepository(System.String)">
      <summary>
            Return the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.
            </summary>
      <param name="repository">the repository to lookup in</param>
      <returns>Return the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance</returns>
      <remarks>
        <para>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified
            by the <paramref name="repository" /> argument.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetLoggerRepository(System.Reflection.Assembly)">
      <summary>
            Returns the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.
            </summary>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
      <returns>The default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.</returns>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetRepository(System.String)">
      <summary>
            Return the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.
            </summary>
      <param name="repository">the repository to lookup in</param>
      <returns>Return the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance</returns>
      <remarks>
        <para>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified
            by the <paramref name="repository" /> argument.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetRepository(System.Reflection.Assembly)">
      <summary>
            Returns the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.
            </summary>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
      <returns>The default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.</returns>
      <remarks>
        <para>
            Returns the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.Exists(System.String,System.String)">
      <summary>
            Returns the named logger if it exists.
            </summary>
      <param name="repository">The repository to lookup in.</param>
      <param name="name">The fully qualified logger name to look for.</param>
      <returns>
            The logger found, or <c>null</c> if the named logger does not exist in the
            specified repository.
            </returns>
      <remarks>
        <para>
            If the named logger exists (in the specified repository) then it
            returns a reference to the logger, otherwise it returns
            <c>null</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.Exists(System.Reflection.Assembly,System.String)">
      <summary>
            Returns the named logger if it exists.
            </summary>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
      <param name="name">The fully qualified logger name to look for.</param>
      <returns>
            The logger found, or <c>null</c> if the named logger does not exist in the
            specified assembly's repository.
            </returns>
      <remarks>
        <para>
            If the named logger exists (in the specified assembly's repository) then it
            returns a reference to the logger, otherwise it returns
            <c>null</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetCurrentLoggers(System.String)">
      <summary>
            Returns all the currently defined loggers in the specified repository.
            </summary>
      <param name="repository">The repository to lookup in.</param>
      <returns>All the defined loggers.</returns>
      <remarks>
        <para>
            The root logger is <b>not</b> included in the returned array.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetCurrentLoggers(System.Reflection.Assembly)">
      <summary>
            Returns all the currently defined loggers in the specified assembly's repository.
            </summary>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
      <returns>All the defined loggers.</returns>
      <remarks>
        <para>
            The root logger is <b>not</b> included in the returned array.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetLogger(System.String,System.String)">
      <summary>
            Retrieves or creates a named logger.
            </summary>
      <param name="repository">The repository to lookup in.</param>
      <param name="name">The name of the logger to retrieve.</param>
      <returns>The logger with the name specified.</returns>
      <remarks>
        <para>
            Retrieves a logger named as the <paramref name="name" />
            parameter. If the named logger already exists, then the
            existing instance will be returned. Otherwise, a new instance is
            created.
            </para>
        <para>
            By default, loggers do not have a set level but inherit
            it from the hierarchy. This is one of the central features of
            log4net.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetLogger(System.Reflection.Assembly,System.String)">
      <summary>
            Retrieves or creates a named logger.
            </summary>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
      <param name="name">The name of the logger to retrieve.</param>
      <returns>The logger with the name specified.</returns>
      <remarks>
        <para>
            Retrieves a logger named as the <paramref name="name" />
            parameter. If the named logger already exists, then the
            existing instance will be returned. Otherwise, a new instance is
            created.
            </para>
        <para>
            By default, loggers do not have a set level but inherit
            it from the hierarchy. This is one of the central features of
            log4net.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetLogger(System.String,System.Type)">
      <summary>
            Shorthand for <see cref="M:LogManager.GetLogger(string)" />.
            </summary>
      <param name="repository">The repository to lookup in.</param>
      <param name="type">The <paramref name="type" /> of which the fullname will be used as the name of the logger to retrieve.</param>
      <returns>The logger with the name specified.</returns>
      <remarks>
        <para>
            Gets the logger for the fully qualified name of the type specified.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetLogger(System.Reflection.Assembly,System.Type)">
      <summary>
            Shorthand for <see cref="M:LogManager.GetLogger(string)" />.
            </summary>
      <param name="repositoryAssembly">the assembly to use to lookup the repository</param>
      <param name="type">The <paramref name="type" /> of which the fullname will be used as the name of the logger to retrieve.</param>
      <returns>The logger with the name specified.</returns>
      <remarks>
        <para>
            Gets the logger for the fully qualified name of the type specified.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.Shutdown">
      <summary>
            Shuts down the log4net system.
            </summary>
      <remarks>
        <para>
            Calling this method will <b>safely</b> close and remove all
            appenders in all the loggers including root contained in all the
            default repositories.
            </para>
        <para>
            Some appenders need to be closed before the application exists. 
            Otherwise, pending logging events might be lost.
            </para>
        <para>
            The <c>shutdown</c> method is careful to close nested
            appenders before closing regular appenders. This is allows
            configurations where a regular appender is attached to a logger
            and again to a nested appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.ShutdownRepository(System.String)">
      <summary>
            Shuts down the repository for the repository specified.
            </summary>
      <param name="repository">The repository to shutdown.</param>
      <remarks>
        <para>
            Calling this method will <b>safely</b> close and remove all
            appenders in all the loggers including root contained in the
            repository for the <paramref name="repository" /> specified.
            </para>
        <para>
            Some appenders need to be closed before the application exists. 
            Otherwise, pending logging events might be lost.
            </para>
        <para>
            The <c>shutdown</c> method is careful to close nested
            appenders before closing regular appenders. This is allows
            configurations where a regular appender is attached to a logger
            and again to a nested appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.ShutdownRepository(System.Reflection.Assembly)">
      <summary>
            Shuts down the repository for the repository specified.
            </summary>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
      <remarks>
        <para>
            Calling this method will <b>safely</b> close and remove all
            appenders in all the loggers including root contained in the
            repository for the repository. The repository is looked up using
            the <paramref name="repositoryAssembly" /> specified.
            </para>
        <para>
            Some appenders need to be closed before the application exists. 
            Otherwise, pending logging events might be lost.
            </para>
        <para>
            The <c>shutdown</c> method is careful to close nested
            appenders before closing regular appenders. This is allows
            configurations where a regular appender is attached to a logger
            and again to a nested appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.ResetConfiguration(System.String)">
      <summary>
            Resets all values contained in this repository instance to their defaults.
            </summary>
      <param name="repository">The repository to reset.</param>
      <remarks>
        <para>
            Resets all values contained in the repository instance to their
            defaults.  This removes all appenders from all loggers, sets
            the level of all non-root loggers to <c>null</c>,
            sets their additivity flag to <c>true</c> and sets the level
            of the root logger to <see cref="F:log4net.Core.Level.Debug" />. Moreover,
            message disabling is set its default "off" value.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.ResetConfiguration(System.Reflection.Assembly)">
      <summary>
            Resets all values contained in this repository instance to their defaults.
            </summary>
      <param name="repositoryAssembly">The assembly to use to lookup the repository to reset.</param>
      <remarks>
        <para>
            Resets all values contained in the repository instance to their
            defaults.  This removes all appenders from all loggers, sets
            the level of all non-root loggers to <c>null</c>,
            sets their additivity flag to <c>true</c> and sets the level
            of the root logger to <see cref="F:log4net.Core.Level.Debug" />. Moreover,
            message disabling is set its default "off" value.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.CreateDomain(System.String)">
      <summary>
            Creates a repository with the specified name.
            </summary>
      <param name="repository">The name of the repository, this must be unique amongst repositories.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
      <remarks>
        <para>
          <b>CreateDomain is obsolete. Use CreateRepository instead of CreateDomain.</b>
        </para>
        <para>
            Creates the default type of <see cref="T:log4net.Repository.ILoggerRepository" /> which is a
            <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> object.
            </para>
        <para>
            The <paramref name="repository" /> name must be unique. Repositories cannot be redefined.
            An <see cref="T:System.Exception" /> will be thrown if the repository already exists.
            </para>
      </remarks>
      <exception cref="T:log4net.Core.LogException">The specified repository already exists.</exception>
    </member>
    <member name="M:log4net.Core.LoggerManager.CreateRepository(System.String)">
      <summary>
            Creates a repository with the specified name.
            </summary>
      <param name="repository">The name of the repository, this must be unique amongst repositories.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
      <remarks>
        <para>
            Creates the default type of <see cref="T:log4net.Repository.ILoggerRepository" /> which is a
            <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> object.
            </para>
        <para>
            The <paramref name="repository" /> name must be unique. Repositories cannot be redefined.
            An <see cref="T:System.Exception" /> will be thrown if the repository already exists.
            </para>
      </remarks>
      <exception cref="T:log4net.Core.LogException">The specified repository already exists.</exception>
    </member>
    <member name="M:log4net.Core.LoggerManager.CreateDomain(System.String,System.Type)">
      <summary>
            Creates a repository with the specified name and repository type.
            </summary>
      <param name="repository">The name of the repository, this must be unique to the repository.</param>
      <param name="repositoryType">A <see cref="T:System.Type" /> that implements <see cref="T:log4net.Repository.ILoggerRepository" />
            and has a no arg constructor. An instance of this type will be created to act
            as the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
      <remarks>
        <para>
          <b>CreateDomain is obsolete. Use CreateRepository instead of CreateDomain.</b>
        </para>
        <para>
            The <paramref name="repository" /> name must be unique. Repositories cannot be redefined.
            An Exception will be thrown if the repository already exists.
            </para>
      </remarks>
      <exception cref="T:log4net.Core.LogException">The specified repository already exists.</exception>
    </member>
    <member name="M:log4net.Core.LoggerManager.CreateRepository(System.String,System.Type)">
      <summary>
            Creates a repository with the specified name and repository type.
            </summary>
      <param name="repository">The name of the repository, this must be unique to the repository.</param>
      <param name="repositoryType">A <see cref="T:System.Type" /> that implements <see cref="T:log4net.Repository.ILoggerRepository" />
            and has a no arg constructor. An instance of this type will be created to act
            as the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
      <remarks>
        <para>
            The <paramref name="repository" /> name must be unique. Repositories cannot be redefined.
            An Exception will be thrown if the repository already exists.
            </para>
      </remarks>
      <exception cref="T:log4net.Core.LogException">The specified repository already exists.</exception>
    </member>
    <member name="M:log4net.Core.LoggerManager.CreateDomain(System.Reflection.Assembly,System.Type)">
      <summary>
            Creates a repository for the specified assembly and repository type.
            </summary>
      <param name="repositoryAssembly">The assembly to use to get the name of the repository.</param>
      <param name="repositoryType">A <see cref="T:System.Type" /> that implements <see cref="T:log4net.Repository.ILoggerRepository" />
            and has a no arg constructor. An instance of this type will be created to act
            as the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
      <remarks>
        <para>
          <b>CreateDomain is obsolete. Use CreateRepository instead of CreateDomain.</b>
        </para>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the repository
            specified such that a call to <see cref="M:GetRepository(Assembly)" /> with the
            same assembly specified will return the same repository instance.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.CreateRepository(System.Reflection.Assembly,System.Type)">
      <summary>
            Creates a repository for the specified assembly and repository type.
            </summary>
      <param name="repositoryAssembly">The assembly to use to get the name of the repository.</param>
      <param name="repositoryType">A <see cref="T:System.Type" /> that implements <see cref="T:log4net.Repository.ILoggerRepository" />
            and has a no arg constructor. An instance of this type will be created to act
            as the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the repository
            specified such that a call to <see cref="M:GetRepository(Assembly)" /> with the
            same assembly specified will return the same repository instance.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetAllRepositories">
      <summary>
            Gets an array of all currently defined repositories.
            </summary>
      <returns>An array of all the known <see cref="T:log4net.Repository.ILoggerRepository" /> objects.</returns>
      <remarks>
        <para>
            Gets an array of all currently defined repositories.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetVersionInfo">
      <summary>
            Internal method to get pertinent version info.
            </summary>
      <returns>A string of version info.</returns>
    </member>
    <member name="M:log4net.Core.LoggerManager.OnDomainUnload(System.Object,System.EventArgs)">
      <summary>
            Called when the <see cref="E:System.AppDomain.DomainUnload" /> event fires
            </summary>
      <param name="sender">the <see cref="T:System.AppDomain" /> that is exiting</param>
      <param name="e">null</param>
      <remarks>
        <para>
            Called when the <see cref="E:System.AppDomain.DomainUnload" /> event fires.
            </para>
        <para>
            When the event is triggered the log4net system is <see cref="M:Shutdown()" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.OnProcessExit(System.Object,System.EventArgs)">
      <summary>
            Called when the <see cref="E:System.AppDomain.ProcessExit" /> event fires
            </summary>
      <param name="sender">the <see cref="T:System.AppDomain" /> that is exiting</param>
      <param name="e">null</param>
      <remarks>
        <para>
            Called when the <see cref="E:System.AppDomain.ProcessExit" /> event fires.
            </para>
        <para>
            When the event is triggered the log4net system is <see cref="M:Shutdown()" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggerManager.RepositorySelector">
      <summary>
            Gets or sets the repository selector used by the <see cref="T:log4net.LogManager" />.
            </summary>
      <value>
            The repository selector used by the <see cref="T:log4net.LogManager" />.
            </value>
      <remarks>
        <para>
            The repository selector (<see cref="T:log4net.Core.IRepositorySelector" />) is used by 
            the <see cref="T:log4net.LogManager" /> to create and select repositories 
            (<see cref="T:log4net.Repository.ILoggerRepository" />).
            </para>
        <para>
            The caller to <see cref="T:log4net.LogManager" /> supplies either a string name 
            or an assembly (if not supplied the assembly is inferred using 
            <see cref="M:Assembly.GetCallingAssembly()" />).
            </para>
        <para>
            This context is used by the selector to lookup a specific repository.
            </para>
        <para>
            For the full .NET Framework, the default repository is <c>DefaultRepositorySelector</c>;
            for the .NET Compact Framework <c>CompactRepositorySelector</c> is the default
            repository.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.LoggerWrapperImpl">
      <summary>
            Implementation of the <see cref="T:log4net.Core.ILoggerWrapper" /> interface.
            </summary>
      <remarks>
        <para>
            This class should be used as the base for all wrapper implementations.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Core.LoggerWrapperImpl.m_logger">
      <summary>
            The logger that this object is wrapping
            </summary>
    </member>
    <member name="M:log4net.Core.LoggerWrapperImpl.#ctor(log4net.Core.ILogger)">
      <summary>
            Constructs a new wrapper for the specified logger.
            </summary>
      <param name="logger">The logger to wrap.</param>
      <remarks>
        <para>
            Constructs a new wrapper for the specified logger.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggerWrapperImpl.Logger">
      <summary>
            Gets the implementation behind this wrapper object.
            </summary>
      <value>
            The <see cref="T:log4net.Core.ILogger" /> object that this object is implementing.
            </value>
      <remarks>
        <para>
            The <c>Logger</c> object may not be the same object as this object 
            because of logger decorators.
            </para>
        <para>
            This gets the actual underlying objects that is used to process
            the log events.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.LoggingEventData">
      <summary>
            Portable data structure used by <see cref="T:log4net.Core.LoggingEvent" /></summary>
      <remarks>
        <para>
            Portable data structure used by <see cref="T:log4net.Core.LoggingEvent" /></para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Core.LoggingEventData.LoggerName">
      <summary>
            The logger name.
            </summary>
      <remarks>
        <para>
            The logger name.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEventData.Level">
      <summary>
            Level of logging event.
            </summary>
      <remarks>
        <para>
            Level of logging event. Level cannot be Serializable
            because it is a flyweight.  Due to its special serialization it
            cannot be declared final either.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEventData.Message">
      <summary>
            The application supplied message.
            </summary>
      <remarks>
        <para>
            The application supplied message of logging event.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEventData.ThreadName">
      <summary>
            The name of thread
            </summary>
      <remarks>
        <para>
            The name of thread in which this logging event was generated
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEventData.TimeStamp">
      <summary>
            The time the event was logged
            </summary>
      <remarks>
        <para>
            The TimeStamp is stored in the local time zone for this computer.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEventData.LocationInfo">
      <summary>
            Location information for the caller.
            </summary>
      <remarks>
        <para>
            Location information for the caller.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEventData.UserName">
      <summary>
            String representation of the user
            </summary>
      <remarks>
        <para>
            String representation of the user's windows name,
            like DOMAIN\username
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEventData.Identity">
      <summary>
            String representation of the identity.
            </summary>
      <remarks>
        <para>
            String representation of the current thread's principal identity.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEventData.ExceptionString">
      <summary>
            The string representation of the exception
            </summary>
      <remarks>
        <para>
            The string representation of the exception
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEventData.Domain">
      <summary>
            String representation of the AppDomain.
            </summary>
      <remarks>
        <para>
            String representation of the AppDomain.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEventData.Properties">
      <summary>
            Additional event specific properties
            </summary>
      <remarks>
        <para>
            A logger or an appender may attach additional
            properties to specific events. These properties
            have a string key and an object value.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.FixFlags">
      <summary>
            Flags passed to the <see cref="P:log4net.Core.LoggingEvent.Fix" /> property
            </summary>
      <remarks>
        <para>
            Flags passed to the <see cref="P:log4net.Core.LoggingEvent.Fix" /> property
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Core.FixFlags.Mdc">
      <summary>
            Fix the MDC
            </summary>
    </member>
    <member name="F:log4net.Core.FixFlags.Ndc">
      <summary>
            Fix the NDC
            </summary>
    </member>
    <member name="F:log4net.Core.FixFlags.Message">
      <summary>
            Fix the rendered message
            </summary>
    </member>
    <member name="F:log4net.Core.FixFlags.ThreadName">
      <summary>
            Fix the thread name
            </summary>
    </member>
    <member name="F:log4net.Core.FixFlags.LocationInfo">
      <summary>
            Fix the callers location information
            </summary>
      <remarks>
            CAUTION: Very slow to generate
            </remarks>
    </member>
    <member name="F:log4net.Core.FixFlags.UserName">
      <summary>
            Fix the callers windows user name
            </summary>
      <remarks>
            CAUTION: Slow to generate
            </remarks>
    </member>
    <member name="F:log4net.Core.FixFlags.Domain">
      <summary>
            Fix the domain friendly name
            </summary>
    </member>
    <member name="F:log4net.Core.FixFlags.Identity">
      <summary>
            Fix the callers principal name
            </summary>
      <remarks>
            CAUTION: May be slow to generate
            </remarks>
    </member>
    <member name="F:log4net.Core.FixFlags.Exception">
      <summary>
            Fix the exception text
            </summary>
    </member>
    <member name="F:log4net.Core.FixFlags.Properties">
      <summary>
            Fix the event properties. Active properties must implement <see cref="T:log4net.Core.IFixingRequired" /> in order to be eligible for fixing.
            </summary>
    </member>
    <member name="F:log4net.Core.FixFlags.None">
      <summary>
            No fields fixed
            </summary>
    </member>
    <member name="F:log4net.Core.FixFlags.All">
      <summary>
            All fields fixed
            </summary>
    </member>
    <member name="F:log4net.Core.FixFlags.Partial">
      <summary>
            Partial fields fixed
            </summary>
      <remarks>
        <para>
            This set of partial fields gives good performance. The following fields are fixed:
            </para>
        <list type="bullet">
          <item>
            <description>
              <see cref="F:log4net.Core.FixFlags.Message" />
            </description>
          </item>
          <item>
            <description>
              <see cref="F:log4net.Core.FixFlags.ThreadName" />
            </description>
          </item>
          <item>
            <description>
              <see cref="F:log4net.Core.FixFlags.Exception" />
            </description>
          </item>
          <item>
            <description>
              <see cref="F:log4net.Core.FixFlags.Domain" />
            </description>
          </item>
          <item>
            <description>
              <see cref="F:log4net.Core.FixFlags.Properties" />
            </description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="T:log4net.Core.LoggingEvent">
      <summary>
            The internal representation of logging events. 
            </summary>
      <remarks>
        <para>
            When an affirmative decision is made to log then a 
            <see cref="T:log4net.Core.LoggingEvent" /> instance is created. This instance 
            is passed around to the different log4net components.
            </para>
        <para>
            This class is of concern to those wishing to extend log4net.
            </para>
        <para>
            Some of the values in instances of <see cref="T:log4net.Core.LoggingEvent" />
            are considered volatile, that is the values are correct at the
            time the event is delivered to appenders, but will not be consistent
            at any time afterwards. If an event is to be stored and then processed
            at a later time these volatile values must be fixed by calling
            <see cref="M:FixVolatileData()" />. There is a performance penalty
            for incurred by calling <see cref="M:FixVolatileData()" /> but it
            is essential to maintaining data consistency.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Douglas de la Torre</author>
      <author>Daniel Cazzulino</author>
    </member>
    <member name="F:log4net.Core.LoggingEvent.HostNameProperty">
      <summary>
            The key into the Properties map for the host name value.
            </summary>
    </member>
    <member name="F:log4net.Core.LoggingEvent.IdentityProperty">
      <summary>
            The key into the Properties map for the thread identity value.
            </summary>
    </member>
    <member name="F:log4net.Core.LoggingEvent.UserNameProperty">
      <summary>
            The key into the Properties map for the user name value.
            </summary>
    </member>
    <member name="F:log4net.Core.LoggingEvent.m_data">
      <summary>
            The internal logging event data.
            </summary>
    </member>
    <member name="F:log4net.Core.LoggingEvent.m_compositeProperties">
      <summary>
            The internal logging event data.
            </summary>
    </member>
    <member name="F:log4net.Core.LoggingEvent.m_eventProperties">
      <summary>
            The internal logging event data.
            </summary>
    </member>
    <member name="F:log4net.Core.LoggingEvent.m_callerStackBoundaryDeclaringType">
      <summary>
            The fully qualified Type of the calling 
            logger class in the stack frame (i.e. the declaring type of the method).
            </summary>
    </member>
    <member name="F:log4net.Core.LoggingEvent.m_message">
      <summary>
            The application supplied message of logging event.
            </summary>
    </member>
    <member name="F:log4net.Core.LoggingEvent.m_thrownException">
      <summary>
            The exception that was thrown.
            </summary>
      <remarks>
            This is not serialized. The string representation
            is serialized instead.
            </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEvent.m_repository">
      <summary>
            The repository that generated the logging event
            </summary>
      <remarks>
            This is not serialized.
            </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEvent.m_fixFlags">
      <summary>
            The fix state for this event
            </summary>
      <remarks>
            These flags indicate which fields have been fixed.
            Not serialized.
            </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEvent.m_cacheUpdatable">
      <summary>
            Indicated that the internal cache is updateable (ie not fixed)
            </summary>
      <remarks>
            This is a seperate flag to m_fixFlags as it allows incrementel fixing and simpler
            changes in the caching strategy.
            </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.#ctor(System.Type,log4net.Repository.ILoggerRepository,System.String,log4net.Core.Level,System.Object,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Core.LoggingEvent" /> class
            from the supplied parameters.
            </summary>
      <param name="callerStackBoundaryDeclaringType">The declaring type of the method that is
            the stack boundary into the logging system for this call.</param>
      <param name="repository">The repository this event is logged in.</param>
      <param name="loggerName">The name of the logger of this event.</param>
      <param name="level">The level of this event.</param>
      <param name="message">The message of this event.</param>
      <param name="exception">The exception for this event.</param>
      <remarks>
        <para>
            Except <see cref="P:log4net.Core.LoggingEvent.TimeStamp" />, <see cref="P:log4net.Core.LoggingEvent.Level" /> and <see cref="P:log4net.Core.LoggingEvent.LoggerName" />, 
            all fields of <c>LoggingEvent</c> are filled when actually needed. Call
            <see cref="M:FixVolatileData()" /> to cache all data locally
            to prevent inconsistencies.
            </para>
        <para>This method is called by the log4net framework
            to create a logging event.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.#ctor(System.Type,log4net.Repository.ILoggerRepository,log4net.Core.LoggingEventData,log4net.Core.FixFlags)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Core.LoggingEvent" /> class 
            using specific data.
            </summary>
      <param name="callerStackBoundaryDeclaringType">The declaring type of the method that is
            the stack boundary into the logging system for this call.</param>
      <param name="repository">The repository this event is logged in.</param>
      <param name="data">Data used to initialize the logging event.</param>
      <param name="fixedData">The fields in the <paranref name="data" /> struct that have already been fixed.</param>
      <remarks>
        <para>
            This constructor is provided to allow a <see cref="T:log4net.Core.LoggingEvent" />
            to be created independently of the log4net framework. This can
            be useful if you require a custom serialization scheme.
            </para>
        <para>
            Use the <see cref="M:GetLoggingEventData(FixFlags)" /> method to obtain an 
            instance of the <see cref="T:log4net.Core.LoggingEventData" /> class.
            </para>
        <para>
            The <paramref name="fixedData" /> parameter should be used to specify which fields in the
            <paramref name="data" /> struct have been preset. Fields not specified in the <paramref name="fixedData" />
            will be captured from the environment if requested or fixed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.#ctor(System.Type,log4net.Repository.ILoggerRepository,log4net.Core.LoggingEventData)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Core.LoggingEvent" /> class 
            using specific data.
            </summary>
      <param name="callerStackBoundaryDeclaringType">The declaring type of the method that is
            the stack boundary into the logging system for this call.</param>
      <param name="repository">The repository this event is logged in.</param>
      <param name="data">Data used to initialize the logging event.</param>
      <remarks>
        <para>
            This constructor is provided to allow a <see cref="T:log4net.Core.LoggingEvent" />
            to be created independently of the log4net framework. This can
            be useful if you require a custom serialization scheme.
            </para>
        <para>
            Use the <see cref="M:GetLoggingEventData(FixFlags)" /> method to obtain an 
            instance of the <see cref="T:log4net.Core.LoggingEventData" /> class.
            </para>
        <para>
            This constructor sets this objects <see cref="P:log4net.Core.LoggingEvent.Fix" /> flags to <see cref="F:log4net.Core.FixFlags.All" />,
            this assumes that all the data relating to this event is passed in via the <paramref name="data" />
            parameter and no other data should be captured from the environment.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.#ctor(log4net.Core.LoggingEventData)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Core.LoggingEvent" /> class 
            using specific data.
            </summary>
      <param name="data">Data used to initialize the logging event.</param>
      <remarks>
        <para>
            This constructor is provided to allow a <see cref="T:log4net.Core.LoggingEvent" />
            to be created independently of the log4net framework. This can
            be useful if you require a custom serialization scheme.
            </para>
        <para>
            Use the <see cref="M:GetLoggingEventData(FixFlags)" /> method to obtain an 
            instance of the <see cref="T:log4net.Core.LoggingEventData" /> class.
            </para>
        <para>
            This constructor sets this objects <see cref="P:log4net.Core.LoggingEvent.Fix" /> flags to <see cref="F:log4net.Core.FixFlags.All" />,
            this assumes that all the data relating to this event is passed in via the <paramref name="data" />
            parameter and no other data should be captured from the environment.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Serialization constructor
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Core.LoggingEvent" /> class 
            with serialized data.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.EnsureRepository(log4net.Repository.ILoggerRepository)">
      <summary>
            Ensure that the repository is set.
            </summary>
      <param name="repository">the value for the repository</param>
    </member>
    <member name="M:log4net.Core.LoggingEvent.WriteRenderedMessage(System.IO.TextWriter)">
      <summary>
            Write the rendered message to a TextWriter
            </summary>
      <param name="writer">the writer to write the message to</param>
      <remarks>
        <para>
            Unlike the <see cref="P:log4net.Core.LoggingEvent.RenderedMessage" /> property this method
            does store the message data in the internal cache. Therefore 
            if called only once this method should be faster than the
            <see cref="P:log4net.Core.LoggingEvent.RenderedMessage" /> property, however if the message is
            to be accessed multiple times then the property will be more efficient.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Serializes this object into the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> provided.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
      <param name="context">The destination for this serialization.</param>
      <remarks>
        <para>
            The data in this event must be fixed before it can be serialized.
            </para>
        <para>
            The <see cref="M:FixVolatileData()" /> method must be called during the
            <see cref="M:log4net.Appender.IAppender.DoAppend(log4net.Core.LoggingEvent)" /> method call if this event 
            is to be used outside that method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.GetLoggingEventData">
      <summary>
            Gets the portable data for this <see cref="T:log4net.Core.LoggingEvent" />.
            </summary>
      <returns>The <see cref="T:log4net.Core.LoggingEventData" /> for this event.</returns>
      <remarks>
        <para>
            A new <see cref="T:log4net.Core.LoggingEvent" /> can be constructed using a
            <see cref="T:log4net.Core.LoggingEventData" /> instance.
            </para>
        <para>
            Does a <see cref="F:log4net.Core.FixFlags.Partial" /> fix of the data
            in the logging event before returning the event data.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.GetLoggingEventData(log4net.Core.FixFlags)">
      <summary>
            Gets the portable data for this <see cref="T:log4net.Core.LoggingEvent" />.
            </summary>
      <param name="fixFlags">The set of data to ensure is fixed in the LoggingEventData</param>
      <returns>The <see cref="T:log4net.Core.LoggingEventData" /> for this event.</returns>
      <remarks>
        <para>
            A new <see cref="T:log4net.Core.LoggingEvent" /> can be constructed using a
            <see cref="T:log4net.Core.LoggingEventData" /> instance.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.GetExceptionStrRep">
      <summary>
            Returns this event's exception's rendered using the 
            <see cref="P:log4net.Repository.ILoggerRepository.RendererMap" />.
            </summary>
      <returns>
            This event's exception's rendered using the <see cref="P:log4net.Repository.ILoggerRepository.RendererMap" />.
            </returns>
      <remarks>
        <para>
          <b>Obsolete. Use <see cref="M:log4net.Core.LoggingEvent.GetExceptionString" /> instead.</b>
        </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.GetExceptionString">
      <summary>
            Returns this event's exception's rendered using the 
            <see cref="P:log4net.Repository.ILoggerRepository.RendererMap" />.
            </summary>
      <returns>
            This event's exception's rendered using the <see cref="P:log4net.Repository.ILoggerRepository.RendererMap" />.
            </returns>
      <remarks>
        <para>
            Returns this event's exception's rendered using the 
            <see cref="P:log4net.Repository.ILoggerRepository.RendererMap" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.FixVolatileData">
      <summary>
            Fix instance fields that hold volatile data.
            </summary>
      <remarks>
        <para>
            Some of the values in instances of <see cref="T:log4net.Core.LoggingEvent" />
            are considered volatile, that is the values are correct at the
            time the event is delivered to appenders, but will not be consistent
            at any time afterwards. If an event is to be stored and then processed
            at a later time these volatile values must be fixed by calling
            <see cref="M:FixVolatileData()" />. There is a performance penalty
            incurred by calling <see cref="M:FixVolatileData()" /> but it
            is essential to maintaining data consistency.
            </para>
        <para>
            Calling <see cref="M:FixVolatileData()" /> is equivalent to
            calling <see cref="M:FixVolatileData(bool)" /> passing the parameter
            <c>false</c>.
            </para>
        <para>
            See <see cref="M:FixVolatileData(bool)" /> for more
            information.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.FixVolatileData(System.Boolean)">
      <summary>
            Fixes instance fields that hold volatile data.
            </summary>
      <param name="fastButLoose">Set to <c>true</c> to not fix data that takes a long time to fix.</param>
      <remarks>
        <para>
            Some of the values in instances of <see cref="T:log4net.Core.LoggingEvent" />
            are considered volatile, that is the values are correct at the
            time the event is delivered to appenders, but will not be consistent
            at any time afterwards. If an event is to be stored and then processed
            at a later time these volatile values must be fixed by calling
            <see cref="M:FixVolatileData()" />. There is a performance penalty
            for incurred by calling <see cref="M:FixVolatileData()" /> but it
            is essential to maintaining data consistency.
            </para>
        <para>
            The <paramref name="fastButLoose" /> param controls the data that
            is fixed. Some of the data that can be fixed takes a long time to 
            generate, therefore if you do not require those settings to be fixed
            they can be ignored by setting the <paramref name="fastButLoose" /> param
            to <c>true</c>. This setting will ignore the <see cref="P:log4net.Core.LoggingEvent.LocationInformation" />
            and <see cref="P:log4net.Core.LoggingEvent.UserName" /> settings.
            </para>
        <para>
            Set <paramref name="fastButLoose" /> to <c>false</c> to ensure that all 
            settings are fixed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.FixVolatileData(log4net.Core.FixFlags)">
      <summary>
            Fix the fields specified by the <see cref="T:log4net.Core.FixFlags" /> parameter
            </summary>
      <param name="flags">the fields to fix</param>
      <remarks>
        <para>
            Only fields specified in the <paramref name="flags" /> will be fixed.
            Fields will not be fixed if they have previously been fixed.
            It is not possible to 'unfix' a field.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.LookupProperty(System.String)">
      <summary>
            Lookup a composite property in this event
            </summary>
      <param name="key">the key for the property to lookup</param>
      <returns>the value for the property</returns>
      <remarks>
        <para>
            This event has composite properties that combine together properties from
            several different contexts in the following order:
            <list type="definition"><item><term>this events properties</term><description>
            		This event has <see cref="P:log4net.Core.LoggingEvent.Properties" /> that can be set. These 
            		properties are specific to this event only.
            		</description></item><item><term>the thread properties</term><description>
            		The <see cref="P:log4net.ThreadContext.Properties" /> that are set on the current
            		thread. These properties are shared by all events logged on this thread.
            		</description></item><item><term>the global properties</term><description>
            		The <see cref="P:log4net.GlobalContext.Properties" /> that are set globally. These 
            		properties are shared by all the threads in the AppDomain.
            		</description></item></list></para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.GetProperties">
      <summary>
            Get all the composite properties in this event
            </summary>
      <returns>the <see cref="T:log4net.Util.PropertiesDictionary" /> containing all the properties</returns>
      <remarks>
        <para>
            See <see cref="M:log4net.Core.LoggingEvent.LookupProperty(System.String)" /> for details of the composite properties 
            stored by the event.
            </para>
        <para>
            This method returns a single <see cref="T:log4net.Util.PropertiesDictionary" /> containing all the
            properties defined for this event.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.StartTime">
      <summary>
            Gets the time when the current process started.
            </summary>
      <value>
            This is the time when this process started.
            </value>
      <remarks>
        <para>
            The TimeStamp is stored in the local time zone for this computer.
            </para>
        <para>
            Tries to get the start time for the current process.
            Failing that it returns the time of the first call to
            this property.
            </para>
        <para>
            Note that AppDomains may be loaded and unloaded within the
            same process without the process terminating and therefore
            without the process start time being reset.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.Level">
      <summary>
            Gets the <see cref="P:log4net.Core.LoggingEvent.Level" /> of the logging event.
            </summary>
      <value>
            The <see cref="P:log4net.Core.LoggingEvent.Level" /> of the logging event.
            </value>
      <remarks>
        <para>
            Gets the <see cref="P:log4net.Core.LoggingEvent.Level" /> of the logging event.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.TimeStamp">
      <summary>
            Gets the time of the logging event.
            </summary>
      <value>
            The time of the logging event.
            </value>
      <remarks>
        <para>
            The TimeStamp is stored in the local time zone for this computer.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.LoggerName">
      <summary>
            Gets the name of the logger that logged the event.
            </summary>
      <value>
            The name of the logger that logged the event.
            </value>
      <remarks>
        <para>
            Gets the name of the logger that logged the event.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.LocationInformation">
      <summary>
            Gets the location information for this logging event.
            </summary>
      <value>
            The location information for this logging event.
            </value>
      <remarks>
        <para>
            The collected information is cached for future use.
            </para>
        <para>
            See the <see cref="T:log4net.Core.LocationInfo" /> class for more information on
            supported frameworks and the different behavior in Debug and
            Release builds.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.MessageObject">
      <summary>
            Gets the message object used to initialize this event.
            </summary>
      <value>
            The message object used to initialize this event.
            </value>
      <remarks>
        <para>
            Gets the message object used to initialize this event.
            Note that this event may not have a valid message object.
            If the event is serialized the message object will not 
            be transferred. To get the text of the message the
            <see cref="P:log4net.Core.LoggingEvent.RenderedMessage" /> property must be used 
            not this property.
            </para>
        <para>
            If there is no defined message object for this event then
            null will be returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.ExceptionObject">
      <summary>
            Gets the exception object used to initialize this event.
            </summary>
      <value>
            The exception object used to initialize this event.
            </value>
      <remarks>
        <para>
            Gets the exception object used to initialize this event.
            Note that this event may not have a valid exception object.
            If the event is serialized the exception object will not 
            be transferred. To get the text of the exception the
            <see cref="M:log4net.Core.LoggingEvent.GetExceptionString" /> method must be used 
            not this property.
            </para>
        <para>
            If there is no defined exception object for this event then
            null will be returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.Repository">
      <summary>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> that this event was created in.
            </summary>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> that this event was created in.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.RenderedMessage">
      <summary>
            Gets the message, rendered through the <see cref="P:log4net.Repository.ILoggerRepository.RendererMap" />.
            </summary>
      <value>
            The message rendered through the <see cref="P:log4net.Repository.ILoggerRepository.RendererMap" />.
            </value>
      <remarks>
        <para>
            The collected information is cached for future use.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.ThreadName">
      <summary>
            Gets the name of the current thread.  
            </summary>
      <value>
            The name of the current thread, or the thread ID when 
            the name is not available.
            </value>
      <remarks>
        <para>
            The collected information is cached for future use.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.UserName">
      <summary>
            Gets the name of the current user.
            </summary>
      <value>
            The name of the current user, or <c>NOT AVAILABLE</c> when the 
            underlying runtime has no support for retrieving the name of the 
            current user.
            </value>
      <remarks>
        <para>
            Calls <c>WindowsIdentity.GetCurrent().Name</c> to get the name of
            the current windows user.
            </para>
        <para>
            To improve performance, we could cache the string representation of 
            the name, and reuse that as long as the identity stayed constant.  
            Once the identity changed, we would need to re-assign and re-render 
            the string.
            </para>
        <para>
            However, the <c>WindowsIdentity.GetCurrent()</c> call seems to 
            return different objects every time, so the current implementation 
            doesn't do this type of caching.
            </para>
        <para>
            Timing for these operations:
            </para>
        <list type="table">
          <listheader>
            <term>Method</term>
            <description>Results</description>
          </listheader>
          <item>
            <term>
              <c>WindowsIdentity.GetCurrent()</c>
            </term>
            <description>10000 loops, 00:00:00.2031250 seconds</description>
          </item>
          <item>
            <term>
              <c>WindowsIdentity.GetCurrent().Name</c>
            </term>
            <description>10000 loops, 00:00:08.0468750 seconds</description>
          </item>
        </list>
        <para>
            This means we could speed things up almost 40 times by caching the 
            value of the <c>WindowsIdentity.GetCurrent().Name</c> property, since 
            this takes (8.04-0.20) = 7.84375 seconds.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.Identity">
      <summary>
            Gets the identity of the current thread principal.
            </summary>
      <value>
            The string name of the identity of the current thread principal.
            </value>
      <remarks>
        <para>
            Calls <c>System.Threading.Thread.CurrentPrincipal.Identity.Name</c> to get
            the name of the current thread principal.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.Domain">
      <summary>
            Gets the AppDomain friendly name.
            </summary>
      <value>
            The AppDomain friendly name.
            </value>
      <remarks>
        <para>
            Gets the AppDomain friendly name.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.Properties">
      <summary>
            Additional event specific properties.
            </summary>
      <value>
            Additional event specific properties.
            </value>
      <remarks>
        <para>
            A logger or an appender may attach additional
            properties to specific events. These properties
            have a string key and an object value.
            </para>
        <para>
            This property is for events that have been added directly to
            this event. The aggregate properties (which include these
            event properties) can be retrieved using <see cref="M:log4net.Core.LoggingEvent.LookupProperty(System.String)" />
            and <see cref="M:log4net.Core.LoggingEvent.GetProperties" />.
            </para>
        <para>
            Once the properties have been fixed <see cref="P:log4net.Core.LoggingEvent.Fix" /> this property
            returns the combined cached properties. This ensures that updates to
            this property are always reflected in the underlying storage. When
            returning the combined properties there may be more keys in the
            Dictionary than expected.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.Fix">
      <summary>
            The fixed fields in this event
            </summary>
      <value>
            The set of fields that are fixed in this event
            </value>
      <remarks>
        <para>
            Fields will not be fixed if they have previously been fixed.
            It is not possible to 'unfix' a field.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.ILog">
      <summary>
            The ILog interface is use by application to log messages into
            the log4net framework.
            </summary>
      <remarks>
        <para>
            Use the <see cref="T:log4net.LogManager" /> to obtain logger instances
            that implement this interface. The <see cref="M:LogManager.GetLogger(Assembly,Type)" />
            static method is used to get logger instances.
            </para>
        <para>
            This class contains methods for logging at different levels and also
            has properties for determining if those logging levels are
            enabled in the current configuration.
            </para>
        <para>
            This interface can be implemented in different ways. This documentation
            specifies reasonable behavior that a caller can expect from the actual
            implementation, however different implementations reserve the right to
            do things differently.
            </para>
      </remarks>
      <example>Simple example of logging messages
            <code lang="C#">
            ILog log = LogManager.GetLogger("application-log");
            
            log.Info("Application Start");
            log.Debug("This is a debug message");
            
            if (log.IsDebugEnabled)
            {
            	log.Debug("This is another debug message");
            }
            </code></example>
      <seealso cref="T:log4net.LogManager" />
      <seealso cref="M:LogManager.GetLogger(Assembly, Type)" />
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.ILog.Debug(System.Object)">
      <overloads>Log a message object with the <see cref="F:log4net.Core.Level.Debug" /> level.</overloads>
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Debug" /> level.
            </summary>
      <param name="message">The message object to log.</param>
      <remarks>
        <para>
            This method first checks if this logger is <c>DEBUG</c>
            enabled by comparing the level of this logger with the 
            <see cref="F:log4net.Core.Level.Debug" /> level. If this logger is
            <c>DEBUG</c> enabled, then it converts the message object
            (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of 
            the additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:Debug(object,Exception)" /> form instead.
            </para>
      </remarks>
      <seealso cref="M:Debug(object,Exception)" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="M:log4net.ILog.Debug(System.Object,System.Exception)">
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Debug" /> level including
            the stack trace of the <see cref="T:System.Exception" /> passed
            as a parameter.
            </summary>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            See the <see cref="M:Debug(object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:Debug(object)" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="M:log4net.ILog.DebugFormat(System.String,System.Object[])">
      <overloads>Log a formatted string with the <see cref="F:log4net.Core.Level.Debug" /> level.</overloads>
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Debug" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Debug(object,Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Debug(object)" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="M:log4net.ILog.DebugFormat(System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Debug" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Debug(object,Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Debug(object)" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="M:log4net.ILog.DebugFormat(System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Debug" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Debug(object,Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Debug(object)" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="M:log4net.ILog.DebugFormat(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Debug" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Debug(object,Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Debug(object)" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="M:log4net.ILog.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Debug" /> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Debug(object,Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Debug(object)" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="M:log4net.ILog.Info(System.Object)">
      <overloads>Log a message object with the <see cref="F:log4net.Core.Level.Info" /> level.</overloads>
      <summary>
            Logs a message object with the <see cref="F:log4net.Core.Level.Info" /> level.
            </summary>
      <remarks>
        <para>
            This method first checks if this logger is <c>INFO</c>
            enabled by comparing the level of this logger with the 
            <see cref="F:log4net.Core.Level.Info" /> level. If this logger is
            <c>INFO</c> enabled, then it converts the message object
            (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of the 
            additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:Info(object,Exception)" /> form instead.
            </para>
      </remarks>
      <param name="message">The message object to log.</param>
      <seealso cref="M:Info(object,Exception)" />
      <seealso cref="P:log4net.ILog.IsInfoEnabled" />
    </member>
    <member name="M:log4net.ILog.Info(System.Object,System.Exception)">
      <summary>
            Logs a message object with the <c>INFO</c> level including
            the stack trace of the <see cref="T:System.Exception" /> passed
            as a parameter.
            </summary>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            See the <see cref="M:Info(object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:Info(object)" />
      <seealso cref="P:log4net.ILog.IsInfoEnabled" />
    </member>
    <member name="M:log4net.ILog.InfoFormat(System.String,System.Object[])">
      <overloads>Log a formatted message string with the <see cref="F:log4net.Core.Level.Info" /> level.</overloads>
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Info" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Info(object)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Info(object,Exception)" />
      <seealso cref="P:log4net.ILog.IsInfoEnabled" />
    </member>
    <member name="M:log4net.ILog.InfoFormat(System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Info" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Info(object,Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Info(object)" />
      <seealso cref="P:log4net.ILog.IsInfoEnabled" />
    </member>
    <member name="M:log4net.ILog.InfoFormat(System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Info" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Info(object,Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Info(object)" />
      <seealso cref="P:log4net.ILog.IsInfoEnabled" />
    </member>
    <member name="M:log4net.ILog.InfoFormat(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Info" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Info(object,Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Info(object)" />
      <seealso cref="P:log4net.ILog.IsInfoEnabled" />
    </member>
    <member name="M:log4net.ILog.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Info" /> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Info(object)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Info(object,Exception)" />
      <seealso cref="P:log4net.ILog.IsInfoEnabled" />
    </member>
    <member name="M:log4net.ILog.Warn(System.Object)">
      <overloads>Log a message object with the <see cref="F:log4net.Core.Level.Warn" /> level.</overloads>
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Warn" /> level.
            </summary>
      <remarks>
        <para>
            This method first checks if this logger is <c>WARN</c>
            enabled by comparing the level of this logger with the 
            <see cref="F:log4net.Core.Level.Warn" /> level. If this logger is
            <c>WARN</c> enabled, then it converts the message object
            (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of the 
            additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:Warn(object,Exception)" /> form instead.
            </para>
      </remarks>
      <param name="message">The message object to log.</param>
      <seealso cref="M:Warn(object,Exception)" />
      <seealso cref="P:log4net.ILog.IsWarnEnabled" />
    </member>
    <member name="M:log4net.ILog.Warn(System.Object,System.Exception)">
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Warn" /> level including
            the stack trace of the <see cref="T:System.Exception" /> passed
            as a parameter.
            </summary>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            See the <see cref="M:Warn(object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:Warn(object)" />
      <seealso cref="P:log4net.ILog.IsWarnEnabled" />
    </member>
    <member name="M:log4net.ILog.WarnFormat(System.String,System.Object[])">
      <overloads>Log a formatted message string with the <see cref="F:log4net.Core.Level.Warn" /> level.</overloads>
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Warn" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Warn(object)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Warn(object,Exception)" />
      <seealso cref="P:log4net.ILog.IsWarnEnabled" />
    </member>
    <member name="M:log4net.ILog.WarnFormat(System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Warn" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Warn(object,Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Warn(object)" />
      <seealso cref="P:log4net.ILog.IsWarnEnabled" />
    </member>
    <member name="M:log4net.ILog.WarnFormat(System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Warn" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Warn(object,Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Warn(object)" />
      <seealso cref="P:log4net.ILog.IsWarnEnabled" />
    </member>
    <member name="M:log4net.ILog.WarnFormat(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Warn" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Warn(object,Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Warn(object)" />
      <seealso cref="P:log4net.ILog.IsWarnEnabled" />
    </member>
    <member name="M:log4net.ILog.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Warn" /> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Warn(object)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Warn(object,Exception)" />
      <seealso cref="P:log4net.ILog.IsWarnEnabled" />
    </member>
    <member name="M:log4net.ILog.Error(System.Object)">
      <overloads>Log a message object with the <see cref="F:log4net.Core.Level.Error" /> level.</overloads>
      <summary>
            Logs a message object with the <see cref="F:log4net.Core.Level.Error" /> level.
            </summary>
      <param name="message">The message object to log.</param>
      <remarks>
        <para>
            This method first checks if this logger is <c>ERROR</c>
            enabled by comparing the level of this logger with the 
            <see cref="F:log4net.Core.Level.Error" /> level. If this logger is
            <c>ERROR</c> enabled, then it converts the message object
            (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of the 
            additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:Error(object,Exception)" /> form instead.
            </para>
      </remarks>
      <seealso cref="M:Error(object,Exception)" />
      <seealso cref="P:log4net.ILog.IsErrorEnabled" />
    </member>
    <member name="M:log4net.ILog.Error(System.Object,System.Exception)">
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Error" /> level including
            the stack trace of the <see cref="T:System.Exception" /> passed
            as a parameter.
            </summary>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            See the <see cref="M:Error(object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:Error(object)" />
      <seealso cref="P:log4net.ILog.IsErrorEnabled" />
    </member>
    <member name="M:log4net.ILog.ErrorFormat(System.String,System.Object[])">
      <overloads>Log a formatted message string with the <see cref="F:log4net.Core.Level.Error" /> level.</overloads>
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Error" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Error(object)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Error(object,Exception)" />
      <seealso cref="P:log4net.ILog.IsErrorEnabled" />
    </member>
    <member name="M:log4net.ILog.ErrorFormat(System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Error" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Error(object,Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Error(object)" />
      <seealso cref="P:log4net.ILog.IsErrorEnabled" />
    </member>
    <member name="M:log4net.ILog.ErrorFormat(System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Error" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Error(object,Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Error(object)" />
      <seealso cref="P:log4net.ILog.IsErrorEnabled" />
    </member>
    <member name="M:log4net.ILog.ErrorFormat(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Error" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Error(object,Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Error(object)" />
      <seealso cref="P:log4net.ILog.IsErrorEnabled" />
    </member>
    <member name="M:log4net.ILog.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Error" /> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Error(object)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Error(object,Exception)" />
      <seealso cref="P:log4net.ILog.IsErrorEnabled" />
    </member>
    <member name="M:log4net.ILog.Fatal(System.Object)">
      <overloads>Log a message object with the <see cref="F:log4net.Core.Level.Fatal" /> level.</overloads>
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Fatal" /> level.
            </summary>
      <remarks>
        <para>
            This method first checks if this logger is <c>FATAL</c>
            enabled by comparing the level of this logger with the 
            <see cref="F:log4net.Core.Level.Fatal" /> level. If this logger is
            <c>FATAL</c> enabled, then it converts the message object
            (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of the 
            additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:Fatal(object,Exception)" /> form instead.
            </para>
      </remarks>
      <param name="message">The message object to log.</param>
      <seealso cref="M:Fatal(object,Exception)" />
      <seealso cref="P:log4net.ILog.IsFatalEnabled" />
    </member>
    <member name="M:log4net.ILog.Fatal(System.Object,System.Exception)">
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Fatal" /> level including
            the stack trace of the <see cref="T:System.Exception" /> passed
            as a parameter.
            </summary>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            See the <see cref="M:Fatal(object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:Fatal(object)" />
      <seealso cref="P:log4net.ILog.IsFatalEnabled" />
    </member>
    <member name="M:log4net.ILog.FatalFormat(System.String,System.Object[])">
      <overloads>Log a formatted message string with the <see cref="F:log4net.Core.Level.Fatal" /> level.</overloads>
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Fatal" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Fatal(object)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Fatal(object,Exception)" />
      <seealso cref="P:log4net.ILog.IsFatalEnabled" />
    </member>
    <member name="M:log4net.ILog.FatalFormat(System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Fatal" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Fatal(object,Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Fatal(object)" />
      <seealso cref="P:log4net.ILog.IsFatalEnabled" />
    </member>
    <member name="M:log4net.ILog.FatalFormat(System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Fatal" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Fatal(object,Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Fatal(object)" />
      <seealso cref="P:log4net.ILog.IsFatalEnabled" />
    </member>
    <member name="M:log4net.ILog.FatalFormat(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Fatal" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Fatal(object,Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Fatal(object)" />
      <seealso cref="P:log4net.ILog.IsFatalEnabled" />
    </member>
    <member name="M:log4net.ILog.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Fatal" /> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:String.Format(string, object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Fatal(object)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:Fatal(object,Exception)" />
      <seealso cref="P:log4net.ILog.IsFatalEnabled" />
    </member>
    <member name="P:log4net.ILog.IsDebugEnabled">
      <summary>
            Checks if this logger is enabled for the <see cref="F:log4net.Core.Level.Debug" /> level.
            </summary>
      <value>
        <c>true</c> if this logger is enabled for <see cref="F:log4net.Core.Level.Debug" /> events, <c>false</c> otherwise.
            </value>
      <remarks>
        <para>
            This function is intended to lessen the computational cost of
            disabled log debug statements.
            </para>
        <para> For some ILog interface <c>log</c>, when you write:</para>
        <code lang="C#">
            log.Debug("This is entry number: " + i );
            </code>
        <para>
            You incur the cost constructing the message, string construction and concatenation in
            this case, regardless of whether the message is logged or not.
            </para>
        <para>
            If you are worried about speed (who isn't), then you should write:
            </para>
        <code lang="C#">
            if (log.IsDebugEnabled)
            { 
                log.Debug("This is entry number: " + i );
            }
            </code>
        <para>
            This way you will not incur the cost of parameter
            construction if debugging is disabled for <c>log</c>. On
            the other hand, if the <c>log</c> is debug enabled, you
            will incur the cost of evaluating whether the logger is debug
            enabled twice. Once in <see cref="P:log4net.ILog.IsDebugEnabled" /> and once in
            the <see cref="M:Debug(object)" />.  This is an insignificant overhead
            since evaluating a logger takes about 1% of the time it
            takes to actually log. This is the preferred style of logging.
            </para>
        <para>Alternatively if your logger is available statically then the is debug
            enabled state can be stored in a static variable like this:
            </para>
        <code lang="C#">
            private static readonly bool isDebugEnabled = log.IsDebugEnabled;
            </code>
        <para>
            Then when you come to log you can write:
            </para>
        <code lang="C#">
            if (isDebugEnabled)
            { 
                log.Debug("This is entry number: " + i );
            }
            </code>
        <para>
            This way the debug enabled state is only queried once
            when the class is loaded. Using a <c>private static readonly</c>
            variable is the most efficient because it is a run time constant
            and can be heavily optimized by the JIT compiler.
            </para>
        <para>
            Of course if you use a static readonly variable to
            hold the enabled state of the logger then you cannot
            change the enabled state at runtime to vary the logging
            that is produced. You have to decide if you need absolute
            speed or runtime flexibility.
            </para>
      </remarks>
      <seealso cref="M:Debug(object)" />
      <seealso cref="M:DebugFormat(IFormatProvider, string, object[])" />
    </member>
    <member name="P:log4net.ILog.IsInfoEnabled">
      <summary>
            Checks if this logger is enabled for the <see cref="F:log4net.Core.Level.Info" /> level.
            </summary>
      <value>
        <c>true</c> if this logger is enabled for <see cref="F:log4net.Core.Level.Info" /> events, <c>false</c> otherwise.
            </value>
      <remarks>
            For more information see <see cref="P:log4net.ILog.IsDebugEnabled" />.
            </remarks>
      <seealso cref="M:Info(object)" />
      <seealso cref="M:InfoFormat(IFormatProvider, string, object[])" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="P:log4net.ILog.IsWarnEnabled">
      <summary>
            Checks if this logger is enabled for the <see cref="F:log4net.Core.Level.Warn" /> level.
            </summary>
      <value>
        <c>true</c> if this logger is enabled for <see cref="F:log4net.Core.Level.Warn" /> events, <c>false</c> otherwise.
            </value>
      <remarks>
            For more information see <see cref="P:log4net.ILog.IsDebugEnabled" />.
            </remarks>
      <seealso cref="M:Warn(object)" />
      <seealso cref="M:WarnFormat(IFormatProvider, string, object[])" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="P:log4net.ILog.IsErrorEnabled">
      <summary>
            Checks if this logger is enabled for the <see cref="F:log4net.Core.Level.Error" /> level.
            </summary>
      <value>
        <c>true</c> if this logger is enabled for <see cref="F:log4net.Core.Level.Error" /> events, <c>false</c> otherwise.
            </value>
      <remarks>
            For more information see <see cref="P:log4net.ILog.IsDebugEnabled" />.
            </remarks>
      <seealso cref="M:Error(object)" />
      <seealso cref="M:ErrorFormat(IFormatProvider, string, object[])" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="P:log4net.ILog.IsFatalEnabled">
      <summary>
            Checks if this logger is enabled for the <see cref="F:log4net.Core.Level.Fatal" /> level.
            </summary>
      <value>
        <c>true</c> if this logger is enabled for <see cref="F:log4net.Core.Level.Fatal" /> events, <c>false</c> otherwise.
            </value>
      <remarks>
            For more information see <see cref="P:log4net.ILog.IsDebugEnabled" />.
            </remarks>
      <seealso cref="M:Fatal(object)" />
      <seealso cref="M:FatalFormat(IFormatProvider, string, object[])" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="T:log4net.Core.LogImpl">
      <summary>
            Implementation of <see cref="T:log4net.ILog" /> wrapper interface.
            </summary>
      <remarks>
        <para>
            This implementation of the <see cref="T:log4net.ILog" /> interface
            forwards to the <see cref="T:log4net.Core.ILogger" /> held by the base class.
            </para>
        <para>
            This logger has methods to allow the caller to log at the following
            levels:
            </para>
        <list type="definition">
          <item>
            <term>DEBUG</term>
            <description>
                The <see cref="M:Debug(object)" /> and <see cref="M:DebugFormat(string, object[])" /> methods log messages
                at the <c>DEBUG</c> level. That is the level with that name defined in the
                repositories <see cref="P:log4net.Repository.ILoggerRepository.LevelMap" />. The default value
                for this level is <see cref="F:log4net.Core.Level.Debug" />. The <see cref="P:log4net.Core.LogImpl.IsDebugEnabled" />
                property tests if this level is enabled for logging.
                </description>
          </item>
          <item>
            <term>INFO</term>
            <description>
                The <see cref="M:Info(object)" /> and <see cref="M:InfoFormat(string, object[])" /> methods log messages
                at the <c>INFO</c> level. That is the level with that name defined in the
                repositories <see cref="P:log4net.Repository.ILoggerRepository.LevelMap" />. The default value
                for this level is <see cref="F:log4net.Core.Level.Info" />. The <see cref="P:log4net.Core.LogImpl.IsInfoEnabled" />
                property tests if this level is enabled for logging.
                </description>
          </item>
          <item>
            <term>WARN</term>
            <description>
                The <see cref="M:Warn(object)" /> and <see cref="M:WarnFormat(string, object[])" /> methods log messages
                at the <c>WARN</c> level. That is the level with that name defined in the
                repositories <see cref="P:log4net.Repository.ILoggerRepository.LevelMap" />. The default value
                for this level is <see cref="F:log4net.Core.Level.Warn" />. The <see cref="P:log4net.Core.LogImpl.IsWarnEnabled" />
                property tests if this level is enabled for logging.
                </description>
          </item>
          <item>
            <term>ERROR</term>
            <description>
                The <see cref="M:Error(object)" /> and <see cref="M:ErrorFormat(string, object[])" /> methods log messages
                at the <c>ERROR</c> level. That is the level with that name defined in the
                repositories <see cref="P:log4net.Repository.ILoggerRepository.LevelMap" />. The default value
                for this level is <see cref="F:log4net.Core.Level.Error" />. The <see cref="P:log4net.Core.LogImpl.IsErrorEnabled" />
                property tests if this level is enabled for logging.
                </description>
          </item>
          <item>
            <term>FATAL</term>
            <description>
                The <see cref="M:Fatal(object)" /> and <see cref="M:FatalFormat(string, object[])" /> methods log messages
                at the <c>FATAL</c> level. That is the level with that name defined in the
                repositories <see cref="P:log4net.Repository.ILoggerRepository.LevelMap" />. The default value
                for this level is <see cref="F:log4net.Core.Level.Fatal" />. The <see cref="P:log4net.Core.LogImpl.IsFatalEnabled" />
                property tests if this level is enabled for logging.
                </description>
          </item>
        </list>
        <para>
            The values for these levels and their semantic meanings can be changed by 
            configuring the <see cref="P:log4net.Repository.ILoggerRepository.LevelMap" /> for the repository.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Core.LogImpl.ThisDeclaringType">
      <summary>
            The fully qualified name of this declaring type not the type of any subclass.
            </summary>
    </member>
    <member name="M:log4net.Core.LogImpl.#ctor(log4net.Core.ILogger)">
      <summary>
            Construct a new wrapper for the specified logger.
            </summary>
      <param name="logger">The logger to wrap.</param>
      <remarks>
        <para>
            Construct a new wrapper for the specified logger.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.ReloadLevels(log4net.Repository.ILoggerRepository)">
      <summary>
            Virtual method called when the configuration of the repository changes
            </summary>
      <param name="repository">the repository holding the levels</param>
      <remarks>
        <para>
            Virtual method called when the configuration of the repository changes
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.Debug(System.Object)">
      <summary>
            Logs a message object with the <c>DEBUG</c> level.
            </summary>
      <param name="message">The message object to log.</param>
      <remarks>
        <para>
            This method first checks if this logger is <c>DEBUG</c>
            enabled by comparing the level of this logger with the 
            <c>DEBUG</c> level. If this logger is
            <c>DEBUG</c> enabled, then it converts the message object
            (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of the 
            additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:Debug(object,Exception)" /> form instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.Debug(System.Object,System.Exception)">
      <summary>
            Logs a message object with the <c>DEBUG</c> level
            </summary>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            Logs a message object with the <c>DEBUG</c> level including
            the stack trace of the <see cref="T:System.Exception" /><paramref name="exception" /> passed
            as a parameter.
            </para>
        <para>
            See the <see cref="M:Debug(object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:Debug(object)" />
    </member>
    <member name="M:log4net.Core.LogImpl.DebugFormat(System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <c>DEBUG</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:DebugFormat(IFormatProvider,string,object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Debug(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.DebugFormat(System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <c>DEBUG</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:DebugFormat(IFormatProvider,string,object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Debug(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.DebugFormat(System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <c>DEBUG</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:DebugFormat(IFormatProvider,string,object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Debug(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.DebugFormat(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <c>DEBUG</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:DebugFormat(IFormatProvider,string,object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Debug(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <c>DEBUG</c> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Debug(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.Info(System.Object)">
      <summary>
            Logs a message object with the <c>INFO</c> level.
            </summary>
      <param name="message">The message object to log.</param>
      <remarks>
        <para>
            This method first checks if this logger is <c>INFO</c>
            enabled by comparing the level of this logger with the 
            <c>INFO</c> level. If this logger is
            <c>INFO</c> enabled, then it converts the message object
            (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of 
            the additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:Info(object,Exception)" /> form instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.Info(System.Object,System.Exception)">
      <summary>
            Logs a message object with the <c>INFO</c> level.
            </summary>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            Logs a message object with the <c>INFO</c> level including
            the stack trace of the <see cref="T:System.Exception" /><paramref name="exception" /> 
            passed as a parameter.
            </para>
        <para>
            See the <see cref="M:Info(object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:Info(object)" />
    </member>
    <member name="M:log4net.Core.LogImpl.InfoFormat(System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <c>INFO</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:InfoFormat(IFormatProvider,string,object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Info(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.InfoFormat(System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <c>INFO</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:InfoFormat(IFormatProvider,string,object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Info(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.InfoFormat(System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <c>INFO</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:InfoFormat(IFormatProvider,string,object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Info(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.InfoFormat(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <c>INFO</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:InfoFormat(IFormatProvider,string,object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Info(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <c>INFO</c> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Info(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.Warn(System.Object)">
      <summary>
            Logs a message object with the <c>WARN</c> level.
            </summary>
      <param name="message">the message object to log</param>
      <remarks>
        <para>
            This method first checks if this logger is <c>WARN</c>
            enabled by comparing the level of this logger with the 
            <c>WARN</c> level. If this logger is
            <c>WARN</c> enabled, then it converts the message object
            (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger and 
            also higher in the hierarchy depending on the value of the 
            additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> to this
            method will print the name of the <see cref="T:System.Exception" /> but no
            stack trace. To print a stack trace use the 
            <see cref="M:Warn(object,Exception)" /> form instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.Warn(System.Object,System.Exception)">
      <summary>
            Logs a message object with the <c>WARN</c> level
            </summary>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            Logs a message object with the <c>WARN</c> level including
            the stack trace of the <see cref="T:System.Exception" /><paramref name="exception" /> 
            passed as a parameter.
            </para>
        <para>
            See the <see cref="M:Warn(object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:Warn(object)" />
    </member>
    <member name="M:log4net.Core.LogImpl.WarnFormat(System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <c>WARN</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:WarnFormat(IFormatProvider,string,object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Warn(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.WarnFormat(System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <c>WARN</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:WarnFormat(IFormatProvider,string,object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Warn(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.WarnFormat(System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <c>WARN</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:WarnFormat(IFormatProvider,string,object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Warn(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.WarnFormat(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <c>WARN</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:WarnFormat(IFormatProvider,string,object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Warn(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <c>WARN</c> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Warn(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.Error(System.Object)">
      <summary>
            Logs a message object with the <c>ERROR</c> level.
            </summary>
      <param name="message">The message object to log.</param>
      <remarks>
        <para>
            This method first checks if this logger is <c>ERROR</c>
            enabled by comparing the level of this logger with the 
            <c>ERROR</c> level. If this logger is
            <c>ERROR</c> enabled, then it converts the message object
            (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger and 
            also higher in the hierarchy depending on the value of the 
            additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> to this
            method will print the name of the <see cref="T:System.Exception" /> but no
            stack trace. To print a stack trace use the 
            <see cref="M:Error(object,Exception)" /> form instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.Error(System.Object,System.Exception)">
      <summary>
            Logs a message object with the <c>ERROR</c> level
            </summary>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            Logs a message object with the <c>ERROR</c> level including
            the stack trace of the <see cref="T:System.Exception" /><paramref name="exception" /> 
            passed as a parameter.
            </para>
        <para>
            See the <see cref="M:Error(object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:Error(object)" />
    </member>
    <member name="M:log4net.Core.LogImpl.ErrorFormat(System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <c>ERROR</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:ErrorFormat(IFormatProvider,string,object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Error(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.ErrorFormat(System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <c>ERROR</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:ErrorFormat(IFormatProvider,string,object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Error(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.ErrorFormat(System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <c>ERROR</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:ErrorFormat(IFormatProvider,string,object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Error(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.ErrorFormat(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <c>ERROR</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:ErrorFormat(IFormatProvider,string,object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Error(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <c>ERROR</c> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Error(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.Fatal(System.Object)">
      <summary>
            Logs a message object with the <c>FATAL</c> level.
            </summary>
      <param name="message">The message object to log.</param>
      <remarks>
        <para>
            This method first checks if this logger is <c>FATAL</c>
            enabled by comparing the level of this logger with the 
            <c>FATAL</c> level. If this logger is
            <c>FATAL</c> enabled, then it converts the message object
            (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger and 
            also higher in the hierarchy depending on the value of the 
            additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> to this
            method will print the name of the <see cref="T:System.Exception" /> but no
            stack trace. To print a stack trace use the 
            <see cref="M:Fatal(object,Exception)" /> form instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.Fatal(System.Object,System.Exception)">
      <summary>
            Logs a message object with the <c>FATAL</c> level
            </summary>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            Logs a message object with the <c>FATAL</c> level including
            the stack trace of the <see cref="T:System.Exception" /><paramref name="exception" /> 
            passed as a parameter.
            </para>
        <para>
            See the <see cref="M:Fatal(object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:Fatal(object)" />
    </member>
    <member name="M:log4net.Core.LogImpl.FatalFormat(System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <c>FATAL</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:FatalFormat(IFormatProvider,string,object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Fatal(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.FatalFormat(System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <c>FATAL</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:FatalFormat(IFormatProvider,string,object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Fatal(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.FatalFormat(System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <c>FATAL</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:FatalFormat(IFormatProvider,string,object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Fatal(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.FatalFormat(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <c>FATAL</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:FatalFormat(IFormatProvider,string,object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Fatal(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <c>FATAL</c> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:String.Format(IFormatProvider, string, object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:Fatal(object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.LoggerRepositoryConfigurationChanged(System.Object,System.EventArgs)">
      <summary>
            Event handler for the <see cref="E:log4net.Repository.ILoggerRepository.ConfigurationChanged" /> event
            </summary>
      <param name="sender">the repository</param>
      <param name="e">Empty</param>
    </member>
    <member name="P:log4net.Core.LogImpl.IsDebugEnabled">
      <summary>
            Checks if this logger is enabled for the <c>DEBUG</c>
            level.
            </summary>
      <value>
        <c>true</c> if this logger is enabled for <c>DEBUG</c> events,
            <c>false</c> otherwise.
            </value>
      <remarks>
        <para>
            This function is intended to lessen the computational cost of
            disabled log debug statements.
            </para>
        <para>
            For some <c>log</c> Logger object, when you write:
            </para>
        <code lang="C#">
            log.Debug("This is entry number: " + i );
            </code>
        <para>
            You incur the cost constructing the message, concatenation in
            this case, regardless of whether the message is logged or not.
            </para>
        <para>
            If you are worried about speed, then you should write:
            </para>
        <code lang="C#">
            if (log.IsDebugEnabled())
            { 
             log.Debug("This is entry number: " + i );
            }
            </code>
        <para>
            This way you will not incur the cost of parameter
            construction if debugging is disabled for <c>log</c>. On
            the other hand, if the <c>log</c> is debug enabled, you
            will incur the cost of evaluating whether the logger is debug
            enabled twice. Once in <c>IsDebugEnabled</c> and once in
            the <c>Debug</c>.  This is an insignificant overhead
            since evaluating a logger takes about 1% of the time it
            takes to actually log.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LogImpl.IsInfoEnabled">
      <summary>
            Checks if this logger is enabled for the <c>INFO</c> level.
            </summary>
      <value>
        <c>true</c> if this logger is enabled for <c>INFO</c> events,
            <c>false</c> otherwise.
            </value>
      <remarks>
        <para>
            See <see cref="P:log4net.Core.LogImpl.IsDebugEnabled" /> for more information and examples 
            of using this method.
            </para>
      </remarks>
      <seealso cref="P:log4net.Core.LogImpl.IsDebugEnabled" />
    </member>
    <member name="P:log4net.Core.LogImpl.IsWarnEnabled">
      <summary>
            Checks if this logger is enabled for the <c>WARN</c> level.
            </summary>
      <value>
        <c>true</c> if this logger is enabled for <c>WARN</c> events,
            <c>false</c> otherwise.
            </value>
      <remarks>
        <para>
            See <see cref="P:log4net.Core.LogImpl.IsDebugEnabled" /> for more information and examples 
            of using this method.
            </para>
      </remarks>
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="P:log4net.Core.LogImpl.IsErrorEnabled">
      <summary>
            Checks if this logger is enabled for the <c>ERROR</c> level.
            </summary>
      <value>
        <c>true</c> if this logger is enabled for <c>ERROR</c> events,
            <c>false</c> otherwise.
            </value>
      <remarks>
        <para>
            See <see cref="P:log4net.Core.LogImpl.IsDebugEnabled" /> for more information and examples of using this method.
            </para>
      </remarks>
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="P:log4net.Core.LogImpl.IsFatalEnabled">
      <summary>
            Checks if this logger is enabled for the <c>FATAL</c> level.
            </summary>
      <value>
        <c>true</c> if this logger is enabled for <c>FATAL</c> events,
            <c>false</c> otherwise.
            </value>
      <remarks>
        <para>
            See <see cref="P:log4net.Core.LogImpl.IsDebugEnabled" /> for more information and examples of using this method.
            </para>
      </remarks>
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="T:log4net.Core.MethodItem">
      <summary>
            provides method information without actually referencing a System.Reflection.MethodBase
            as that would require that the containing assembly is loaded.
            </summary>
    </member>
    <member name="F:log4net.Core.MethodItem.NA">
      <summary>
            When location information is not available the constant
            <c>NA</c> is returned. Current value of this string
            constant is <b>?</b>.
            </summary>
    </member>
    <member name="F:log4net.Core.MethodItem.declaringType">
      <summary>
            The fully qualified type of the StackFrameItem class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Core.MethodItem.#ctor">
      <summary>
            constructs a method item for an unknown method.
            </summary>
    </member>
    <member name="M:log4net.Core.MethodItem.#ctor(System.String)">
      <summary>
            constructs a method item from the name of the method.
            </summary>
      <param name="name">
      </param>
    </member>
    <member name="M:log4net.Core.MethodItem.#ctor(System.String,System.String[])">
      <summary>
            constructs a method item from the name of the method and its parameters.
            </summary>
      <param name="name">
      </param>
      <param name="parameters">
      </param>
    </member>
    <member name="M:log4net.Core.MethodItem.#ctor(System.Reflection.MethodBase)">
      <summary>
            constructs a method item from a method base by determining the method name and its parameters.
            </summary>
      <param name="methodBase">
      </param>
    </member>
    <member name="P:log4net.Core.MethodItem.Name">
      <summary>
            Gets the method name of the caller making the logging 
            request.
            </summary>
      <value>
            The method name of the caller making the logging 
            request.
            </value>
      <remarks>
        <para>
            Gets the method name of the caller making the logging 
            request.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.MethodItem.Parameters">
      <summary>
            Gets the method parameters of the caller making
            the logging request.
            </summary>
      <value>
            The method parameters of the caller making
            the logging request
            </value>
      <remarks>
        <para>
            Gets the method parameters of the caller making
            the logging request.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.SecurityContext">
      <summary>
            A SecurityContext used by log4net when interacting with protected resources
            </summary>
      <remarks>
        <para>
            A SecurityContext used by log4net when interacting with protected resources
            for example with operating system services. This can be used to impersonate
            a principal that has been granted privileges on the system resources.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Core.SecurityContext.Impersonate(System.Object)">
      <summary>
            Impersonate this SecurityContext
            </summary>
      <param name="state">State supplied by the caller</param>
      <returns>An <see cref="T:System.IDisposable" /> instance that will
            revoke the impersonation of this SecurityContext, or <c>null</c></returns>
      <remarks>
        <para>
            Impersonate this security context. Further calls on the current
            thread should now be made in the security context provided
            by this object. When the <see cref="T:System.IDisposable" /> result 
            <see cref="M:System.IDisposable.Dispose" /> method is called the security
            context of the thread should be reverted to the state it was in
            before <see cref="M:log4net.Core.SecurityContext.Impersonate(System.Object)" /> was called.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.SecurityContextProvider">
      <summary>
            The <see cref="T:log4net.Core.SecurityContextProvider" /> providers default <see cref="T:log4net.Core.SecurityContext" /> instances.
            </summary>
      <remarks>
        <para>
            A configured component that interacts with potentially protected system
            resources uses a <see cref="T:log4net.Core.SecurityContext" /> to provide the elevated
            privileges required. If the <see cref="T:log4net.Core.SecurityContext" /> object has
            been not been explicitly provided to the component then the component
            will request one from this <see cref="T:log4net.Core.SecurityContextProvider" />.
            </para>
        <para>
            By default the <see cref="P:log4net.Core.SecurityContextProvider.DefaultProvider" /> is
            an instance of <see cref="T:log4net.Core.SecurityContextProvider" /> which returns only
            <see cref="T:log4net.Util.NullSecurityContext" /> objects. This is a reasonable default
            where the privileges required are not know by the system.
            </para>
        <para>
            This default behavior can be overridden by subclassing the <see cref="T:log4net.Core.SecurityContextProvider" />
            and overriding the <see cref="M:log4net.Core.SecurityContextProvider.CreateSecurityContext(System.Object)" /> method to return
            the desired <see cref="T:log4net.Core.SecurityContext" /> objects. The default provider
            can be replaced by programmatically setting the value of the 
            <see cref="P:log4net.Core.SecurityContextProvider.DefaultProvider" /> property.
            </para>
        <para>
            An alternative is to use the <c>log4net.Config.SecurityContextProviderAttribute</c>
            This attribute can be applied to an assembly in the same way as the
            <c>log4net.Config.XmlConfiguratorAttribute"</c>. The attribute takes
            the type to use as the <see cref="T:log4net.Core.SecurityContextProvider" /> as an argument.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Core.SecurityContextProvider.s_defaultProvider">
      <summary>
            The default provider
            </summary>
    </member>
    <member name="M:log4net.Core.SecurityContextProvider.#ctor">
      <summary>
            Protected default constructor to allow subclassing
            </summary>
      <remarks>
        <para>
            Protected default constructor to allow subclassing
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.SecurityContextProvider.CreateSecurityContext(System.Object)">
      <summary>
            Create a SecurityContext for a consumer
            </summary>
      <param name="consumer">The consumer requesting the SecurityContext</param>
      <returns>An impersonation context</returns>
      <remarks>
        <para>
            The default implementation is to return a <see cref="T:log4net.Util.NullSecurityContext" />.
            </para>
        <para>
            Subclasses should override this method to provide their own
            behavior.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.SecurityContextProvider.DefaultProvider">
      <summary>
            Gets or sets the default SecurityContextProvider
            </summary>
      <value>
            The default SecurityContextProvider
            </value>
      <remarks>
        <para>
            The default provider is used by configured components that
            require a <see cref="T:log4net.Core.SecurityContext" /> and have not had one
            given to them.
            </para>
        <para>
            By default this is an instance of <see cref="T:log4net.Core.SecurityContextProvider" />
            that returns <see cref="T:log4net.Util.NullSecurityContext" /> objects.
            </para>
        <para>
            The default provider can be set programmatically by setting
            the value of this property to a sub class of <see cref="T:log4net.Core.SecurityContextProvider" />
            that has the desired behavior.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.StackFrameItem">
      <summary>
            provides stack frame information without actually referencing a System.Diagnostics.StackFrame
            as that would require that the containing assembly is loaded.
            </summary>
    </member>
    <member name="F:log4net.Core.StackFrameItem.NA">
      <summary>
            When location information is not available the constant
            <c>NA</c> is returned. Current value of this string
            constant is <b>?</b>.
            </summary>
    </member>
    <member name="F:log4net.Core.StackFrameItem.declaringType">
      <summary>
            The fully qualified type of the StackFrameItem class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Core.StackFrameItem.#ctor(System.Diagnostics.StackFrame)">
      <summary>
            returns a stack frame item from a stack frame. This 
            </summary>
      <param name="frame">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:log4net.Core.StackFrameItem.ClassName">
      <summary>
            Gets the fully qualified class name of the caller making the logging 
            request.
            </summary>
      <value>
            The fully qualified class name of the caller making the logging 
            request.
            </value>
      <remarks>
        <para>
            Gets the fully qualified class name of the caller making the logging 
            request.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.StackFrameItem.FileName">
      <summary>
            Gets the file name of the caller.
            </summary>
      <value>
            The file name of the caller.
            </value>
      <remarks>
        <para>
            Gets the file name of the caller.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.StackFrameItem.LineNumber">
      <summary>
            Gets the line number of the caller.
            </summary>
      <value>
            The line number of the caller.
            </value>
      <remarks>
        <para>
            Gets the line number of the caller.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.StackFrameItem.Method">
      <summary>
            Gets the method name of the caller.
            </summary>
      <value>
            The method name of the caller.
            </value>
      <remarks>
        <para>
            Gets the method name of the caller.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.StackFrameItem.FullInfo">
      <summary>
            Gets all available caller information
            </summary>
      <value>
            All available caller information, in the format
            <c>fully.qualified.classname.of.caller.methodName(Filename:line)</c></value>
      <remarks>
        <para>
            Gets all available caller information, in the format
            <c>fully.qualified.classname.of.caller.methodName(Filename:line)</c></para>
      </remarks>
    </member>
    <member name="T:log4net.Core.TimeEvaluator">
      <summary>
            An evaluator that triggers after specified number of seconds.
            </summary>
      <remarks>
        <para>
            This evaluator will trigger if the specified time period 
            <see cref="P:log4net.Core.TimeEvaluator.Interval" /> has passed since last check.
            </para>
      </remarks>
      <author>Robert Sevcik</author>
    </member>
    <member name="F:log4net.Core.TimeEvaluator.DEFAULT_INTERVAL">
      <summary>
            The default time threshold for triggering in seconds. Zero means it won't trigger at all.
            </summary>
    </member>
    <member name="F:log4net.Core.TimeEvaluator.m_interval">
      <summary>
            The time threshold for triggering in seconds. Zero means it won't trigger at all.
            </summary>
    </member>
    <member name="F:log4net.Core.TimeEvaluator.m_lasttime">
      <summary>
            The time of last check. This gets updated when the object is created and when the evaluator triggers.
            </summary>
    </member>
    <member name="M:log4net.Core.TimeEvaluator.#ctor">
      <summary>
            Create a new evaluator using the <see cref="F:log4net.Core.TimeEvaluator.DEFAULT_INTERVAL" /> time threshold in seconds.
            </summary>
      <remarks>
        <para>
            Create a new evaluator using the <see cref="F:log4net.Core.TimeEvaluator.DEFAULT_INTERVAL" /> time threshold in seconds.
            </para>
        <para>
            This evaluator will trigger if the specified time period 
            <see cref="P:log4net.Core.TimeEvaluator.Interval" /> has passed since last check.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.TimeEvaluator.#ctor(System.Int32)">
      <summary>
            Create a new evaluator using the specified time threshold in seconds.
            </summary>
      <param name="interval">
            The time threshold in seconds to trigger after.
            Zero means it won't trigger at all.
            </param>
      <remarks>
        <para>
            Create a new evaluator using the specified time threshold in seconds.
            </para>
        <para>
            This evaluator will trigger if the specified time period 
            <see cref="P:log4net.Core.TimeEvaluator.Interval" /> has passed since last check.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.TimeEvaluator.IsTriggeringEvent(log4net.Core.LoggingEvent)">
      <summary>
            Is this <paramref name="loggingEvent" /> the triggering event?
            </summary>
      <param name="loggingEvent">The event to check</param>
      <returns>This method returns <c>true</c>, if the specified time period 
            <see cref="P:log4net.Core.TimeEvaluator.Interval" /> has passed since last check.. 
            Otherwise it returns <c>false</c></returns>
      <remarks>
        <para>
            This evaluator will trigger if the specified time period 
            <see cref="P:log4net.Core.TimeEvaluator.Interval" /> has passed since last check.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.TimeEvaluator.Interval">
      <summary>
            The time threshold in seconds to trigger after
            </summary>
      <value>
            The time threshold in seconds to trigger after.
            Zero means it won't trigger at all.
            </value>
      <remarks>
        <para>
            This evaluator will trigger if the specified time period 
            <see cref="P:log4net.Core.TimeEvaluator.Interval" /> has passed since last check.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.WrapperCreationHandler">
      <summary>
            Delegate used to handle creation of new wrappers.
            </summary>
      <param name="logger">The logger to wrap in a wrapper.</param>
      <remarks>
        <para>
            Delegate used to handle creation of new wrappers. This delegate
            is called from the <see cref="M:log4net.Core.WrapperMap.CreateNewWrapperObject(log4net.Core.ILogger)" />
            method to construct the wrapper for the specified logger.
            </para>
        <para>
            The delegate to use is supplied to the <see cref="T:log4net.Core.WrapperMap" />
            constructor.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.WrapperMap">
      <summary>
            Maps between logger objects and wrapper objects.
            </summary>
      <remarks>
        <para>
            This class maintains a mapping between <see cref="T:log4net.Core.ILogger" /> objects and
            <see cref="T:log4net.Core.ILoggerWrapper" /> objects. Use the <see cref="M:log4net.Core.WrapperMap.GetWrapper(log4net.Core.ILogger)" /> method to 
            lookup the <see cref="T:log4net.Core.ILoggerWrapper" /> for the specified <see cref="T:log4net.Core.ILogger" />.
            </para>
        <para>
            New wrapper instances are created by the <see cref="M:log4net.Core.WrapperMap.CreateNewWrapperObject(log4net.Core.ILogger)" />
            method. The default behavior is for this method to delegate construction
            of the wrapper to the <see cref="T:log4net.Core.WrapperCreationHandler" /> delegate supplied
            to the constructor. This allows specialization of the behavior without
            requiring subclassing of this type.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Core.WrapperMap.m_repositories">
      <summary>
            Map of logger repositories to hashtables of ILogger to ILoggerWrapper mappings
            </summary>
    </member>
    <member name="F:log4net.Core.WrapperMap.m_createWrapperHandler">
      <summary>
            The handler to use to create the extension wrapper objects.
            </summary>
    </member>
    <member name="F:log4net.Core.WrapperMap.m_shutdownHandler">
      <summary>
            Internal reference to the delegate used to register for repository shutdown events.
            </summary>
    </member>
    <member name="M:log4net.Core.WrapperMap.#ctor(log4net.Core.WrapperCreationHandler)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Core.WrapperMap" /></summary>
      <param name="createWrapperHandler">The handler to use to create the wrapper objects.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Core.WrapperMap" /> class with 
            the specified handler to create the wrapper objects.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.WrapperMap.GetWrapper(log4net.Core.ILogger)">
      <summary>
            Gets the wrapper object for the specified logger.
            </summary>
      <returns>The wrapper object for the specified logger</returns>
      <remarks>
        <para>
            If the logger is null then the corresponding wrapper is null.
            </para>
        <para>
            Looks up the wrapper it it has previously been requested and
            returns it. If the wrapper has never been requested before then
            the <see cref="M:log4net.Core.WrapperMap.CreateNewWrapperObject(log4net.Core.ILogger)" /> virtual method is
            called.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.WrapperMap.CreateNewWrapperObject(log4net.Core.ILogger)">
      <summary>
            Creates the wrapper object for the specified logger.
            </summary>
      <param name="logger">The logger to wrap in a wrapper.</param>
      <returns>The wrapper object for the logger.</returns>
      <remarks>
        <para>
            This implementation uses the <see cref="T:log4net.Core.WrapperCreationHandler" />
            passed to the constructor to create the wrapper. This method
            can be overridden in a subclass.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.WrapperMap.RepositoryShutdown(log4net.Repository.ILoggerRepository)">
      <summary>
            Called when a monitored repository shutdown event is received.
            </summary>
      <param name="repository">The <see cref="T:log4net.Repository.ILoggerRepository" /> that is shutting down</param>
      <remarks>
        <para>
            This method is called when a <see cref="T:log4net.Repository.ILoggerRepository" /> that this
            <see cref="T:log4net.Core.WrapperMap" /> is holding loggers for has signaled its shutdown
            event <see cref="E:log4net.Repository.ILoggerRepository.ShutdownEvent" />. The default
            behavior of this method is to release the references to the loggers
            and their wrappers generated for this repository.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.WrapperMap.ILoggerRepository_Shutdown(System.Object,System.EventArgs)">
      <summary>
            Event handler for repository shutdown event.
            </summary>
      <param name="sender">The sender of the event.</param>
      <param name="e">The event args.</param>
    </member>
    <member name="P:log4net.Core.WrapperMap.Repositories">
      <summary>
            Gets the map of logger repositories.
            </summary>
      <value>
            Map of logger repositories.
            </value>
      <remarks>
        <para>
            Gets the hashtable that is keyed on <see cref="T:log4net.Repository.ILoggerRepository" />. The
            values are hashtables keyed on <see cref="T:log4net.Core.ILogger" /> with the
            value being the corresponding <see cref="T:log4net.Core.ILoggerWrapper" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.DateFormatter.IDateFormatter">
      <summary>
            Render a <see cref="T:System.DateTime" /> as a string.
            </summary>
      <remarks>
        <para>
            Interface to abstract the rendering of a <see cref="T:System.DateTime" />
            instance into a string.
            </para>
        <para>
            The <see cref="M:log4net.DateFormatter.IDateFormatter.FormatDate(System.DateTime,System.IO.TextWriter)" /> method is used to render the
            date to a text writer.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.DateFormatter.IDateFormatter.FormatDate(System.DateTime,System.IO.TextWriter)">
      <summary>
            Formats the specified date as a string.
            </summary>
      <param name="dateToFormat">The date to format.</param>
      <param name="writer">The writer to write to.</param>
      <remarks>
        <para>
            Format the <see cref="T:System.DateTime" /> as a string and write it
            to the <see cref="T:System.IO.TextWriter" /> provided.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.DateFormatter.AbsoluteTimeDateFormatter">
      <summary>
            Formats a <see cref="T:System.DateTime" /> as <c>"HH:mm:ss,fff"</c>.
            </summary>
      <remarks>
        <para>
            Formats a <see cref="T:System.DateTime" /> in the format <c>"HH:mm:ss,fff"</c> for example, <c>"15:49:37,459"</c>.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.DateFormatter.AbsoluteTimeDateFormatter.AbsoluteTimeDateFormat">
      <summary>
            String constant used to specify AbsoluteTimeDateFormat in layouts. Current value is <b>ABSOLUTE</b>.
            </summary>
    </member>
    <member name="F:log4net.DateFormatter.AbsoluteTimeDateFormatter.DateAndTimeDateFormat">
      <summary>
            String constant used to specify DateTimeDateFormat in layouts.  Current value is <b>DATE</b>.
            </summary>
    </member>
    <member name="F:log4net.DateFormatter.AbsoluteTimeDateFormatter.Iso8601TimeDateFormat">
      <summary>
            String constant used to specify ISO8601DateFormat in layouts. Current value is <b>ISO8601</b>.
            </summary>
    </member>
    <member name="F:log4net.DateFormatter.AbsoluteTimeDateFormatter.s_lastTimeToTheSecond">
      <summary>
            Last stored time with precision up to the second.
            </summary>
    </member>
    <member name="F:log4net.DateFormatter.AbsoluteTimeDateFormatter.s_lastTimeBuf">
      <summary>
            Last stored time with precision up to the second, formatted
            as a string.
            </summary>
    </member>
    <member name="F:log4net.DateFormatter.AbsoluteTimeDateFormatter.s_lastTimeStrings">
      <summary>
            Last stored time with precision up to the second, formatted
            as a string.
            </summary>
    </member>
    <member name="M:log4net.DateFormatter.AbsoluteTimeDateFormatter.FormatDateWithoutMillis(System.DateTime,System.Text.StringBuilder)">
      <summary>
            Renders the date into a string. Format is <c>"HH:mm:ss"</c>.
            </summary>
      <param name="dateToFormat">The date to render into a string.</param>
      <param name="buffer">The string builder to write to.</param>
      <remarks>
        <para>
            Subclasses should override this method to render the date
            into a string using a precision up to the second. This method
            will be called at most once per second and the result will be
            reused if it is needed again during the same second.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.DateFormatter.AbsoluteTimeDateFormatter.FormatDate(System.DateTime,System.IO.TextWriter)">
      <summary>
            Renders the date into a string. Format is "HH:mm:ss,fff".
            </summary>
      <param name="dateToFormat">The date to render into a string.</param>
      <param name="writer">The writer to write to.</param>
      <remarks>
        <para>
            Uses the <see cref="M:log4net.DateFormatter.AbsoluteTimeDateFormatter.FormatDateWithoutMillis(System.DateTime,System.Text.StringBuilder)" /> method to generate the
            time string up to the seconds and then appends the current
            milliseconds. The results from <see cref="M:log4net.DateFormatter.AbsoluteTimeDateFormatter.FormatDateWithoutMillis(System.DateTime,System.Text.StringBuilder)" /> are
            cached and <see cref="M:log4net.DateFormatter.AbsoluteTimeDateFormatter.FormatDateWithoutMillis(System.DateTime,System.Text.StringBuilder)" /> is called at most once
            per second.
            </para>
        <para>
            Sub classes should override <see cref="M:log4net.DateFormatter.AbsoluteTimeDateFormatter.FormatDateWithoutMillis(System.DateTime,System.Text.StringBuilder)" />
            rather than <see cref="M:log4net.DateFormatter.AbsoluteTimeDateFormatter.FormatDate(System.DateTime,System.IO.TextWriter)" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.DateFormatter.DateTimeDateFormatter">
      <summary>
            Formats a <see cref="T:System.DateTime" /> as <c>"dd MMM yyyy HH:mm:ss,fff"</c></summary>
      <remarks>
        <para>
            Formats a <see cref="T:System.DateTime" /> in the format 
            <c>"dd MMM yyyy HH:mm:ss,fff"</c> for example, 
            <c>"06 Nov 1994 15:49:37,459"</c>.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Angelika Schnagl</author>
    </member>
    <member name="F:log4net.DateFormatter.DateTimeDateFormatter.m_dateTimeFormatInfo">
      <summary>
            The format info for the invariant culture.
            </summary>
    </member>
    <member name="M:log4net.DateFormatter.DateTimeDateFormatter.#ctor">
      <summary>
            Default constructor.
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.DateFormatter.DateTimeDateFormatter" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.DateFormatter.DateTimeDateFormatter.FormatDateWithoutMillis(System.DateTime,System.Text.StringBuilder)">
      <summary>
            Formats the date without the milliseconds part
            </summary>
      <param name="dateToFormat">The date to format.</param>
      <param name="buffer">The string builder to write to.</param>
      <remarks>
        <para>
            Formats a DateTime in the format <c>"dd MMM yyyy HH:mm:ss"</c>
            for example, <c>"06 Nov 1994 15:49:37"</c>.
            </para>
        <para>
            The base class will append the <c>",fff"</c> milliseconds section.
            This method will only be called at most once per second.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.DateFormatter.Iso8601DateFormatter">
      <summary>
            Formats the <see cref="T:System.DateTime" /> as <c>"yyyy-MM-dd HH:mm:ss,fff"</c>.
            </summary>
      <remarks>
        <para>
            Formats the <see cref="T:System.DateTime" /> specified as a string: <c>"yyyy-MM-dd HH:mm:ss,fff"</c>.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.DateFormatter.Iso8601DateFormatter.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.DateFormatter.Iso8601DateFormatter" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.DateFormatter.Iso8601DateFormatter.FormatDateWithoutMillis(System.DateTime,System.Text.StringBuilder)">
      <summary>
            Formats the date without the milliseconds part
            </summary>
      <param name="dateToFormat">The date to format.</param>
      <param name="buffer">The string builder to write to.</param>
      <remarks>
        <para>
            Formats the date specified as a string: <c>"yyyy-MM-dd HH:mm:ss"</c>.
            </para>
        <para>
            The base class will append the <c>",fff"</c> milliseconds section.
            This method will only be called at most once per second.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.DateFormatter.SimpleDateFormatter">
      <summary>
            Formats the <see cref="T:System.DateTime" /> using the <see cref="M:DateTime.ToString(string, IFormatProvider)" /> method.
            </summary>
      <remarks>
        <para>
            Formats the <see cref="T:System.DateTime" /> using the <see cref="T:System.DateTime" /><see cref="M:DateTime.ToString(string, IFormatProvider)" /> method.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.DateFormatter.SimpleDateFormatter.m_formatString">
      <summary>
            The format string used to format the <see cref="T:System.DateTime" />.
            </summary>
      <remarks>
        <para>
            The format string must be compatible with the options
            that can be supplied to <see cref="M:DateTime.ToString(string, IFormatProvider)" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.DateFormatter.SimpleDateFormatter.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="format">The format string.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.DateFormatter.SimpleDateFormatter" /> class 
            with the specified format string.
            </para>
        <para>
            The format string must be compatible with the options
            that can be supplied to <see cref="M:DateTime.ToString(string, IFormatProvider)" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.DateFormatter.SimpleDateFormatter.FormatDate(System.DateTime,System.IO.TextWriter)">
      <summary>
            Formats the date using <see cref="M:DateTime.ToString(string, IFormatProvider)" />.
            </summary>
      <param name="dateToFormat">The date to convert to a string.</param>
      <param name="writer">The writer to write to.</param>
      <remarks>
        <para>
            Uses the date format string supplied to the constructor to call
            the <see cref="M:DateTime.ToString(string, IFormatProvider)" /> method to format the date.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Filter.IFilter">
      <summary>
            Implement this interface to provide customized logging event filtering
            </summary>
      <remarks>
        <para>
            Users should implement this interface to implement customized logging
            event filtering. Note that <see cref="T:log4net.Repository.Hierarchy.Logger" /> and 
            <see cref="T:log4net.Appender.AppenderSkeleton" />, the parent class of all standard
            appenders, have built-in filtering rules. It is suggested that you
            first use and understand the built-in rules before rushing to write
            your own custom filters.
            </para>
        <para>
            This abstract class assumes and also imposes that filters be
            organized in a linear chain. The <see cref="M:log4net.Filter.IFilter.Decide(log4net.Core.LoggingEvent)" />
            method of each filter is called sequentially, in the order of their 
            addition to the chain.
            </para>
        <para>
            The <see cref="M:log4net.Filter.IFilter.Decide(log4net.Core.LoggingEvent)" /> method must return one
            of the integer constants <see cref="F:log4net.Filter.FilterDecision.Deny" />, 
            <see cref="F:log4net.Filter.FilterDecision.Neutral" /> or <see cref="F:log4net.Filter.FilterDecision.Accept" />.
            </para>
        <para>
            If the value <see cref="F:log4net.Filter.FilterDecision.Deny" /> is returned, then the log event is dropped 
            immediately without consulting with the remaining filters.
            </para>
        <para>
            If the value <see cref="F:log4net.Filter.FilterDecision.Neutral" /> is returned, then the next filter
            in the chain is consulted. If there are no more filters in the
            chain, then the log event is logged. Thus, in the presence of no
            filters, the default behavior is to log all logging events.
            </para>
        <para>
            If the value <see cref="F:log4net.Filter.FilterDecision.Accept" /> is returned, then the log
            event is logged without consulting the remaining filters.
            </para>
        <para>
            The philosophy of log4net filters is largely inspired from the
            Linux ipchains.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Filter.IFilter.Decide(log4net.Core.LoggingEvent)">
      <summary>
            Decide if the logging event should be logged through an appender.
            </summary>
      <param name="loggingEvent">The LoggingEvent to decide upon</param>
      <returns>The decision of the filter</returns>
      <remarks>
        <para>
            If the decision is <see cref="F:log4net.Filter.FilterDecision.Deny" />, then the event will be
            dropped. If the decision is <see cref="F:log4net.Filter.FilterDecision.Neutral" />, then the next
            filter, if any, will be invoked. If the decision is <see cref="F:log4net.Filter.FilterDecision.Accept" /> then
            the event will be logged without consulting with other filters in
            the chain.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.IFilter.Next">
      <summary>
            Property to get and set the next filter
            </summary>
      <value>
            The next filter in the chain
            </value>
      <remarks>
        <para>
            Filters are typically composed into chains. This property allows the next filter in 
            the chain to be accessed.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Filter.FilterSkeleton">
      <summary>
            Subclass this type to implement customized logging event filtering
            </summary>
      <remarks>
        <para>
            Users should extend this class to implement customized logging
            event filtering. Note that <see cref="T:log4net.Repository.Hierarchy.Logger" /> and 
            <see cref="T:log4net.Appender.AppenderSkeleton" />, the parent class of all standard
            appenders, have built-in filtering rules. It is suggested that you
            first use and understand the built-in rules before rushing to write
            your own custom filters.
            </para>
        <para>
            This abstract class assumes and also imposes that filters be
            organized in a linear chain. The <see cref="M:log4net.Filter.FilterSkeleton.Decide(log4net.Core.LoggingEvent)" />
            method of each filter is called sequentially, in the order of their 
            addition to the chain.
            </para>
        <para>
            The <see cref="M:log4net.Filter.FilterSkeleton.Decide(log4net.Core.LoggingEvent)" /> method must return one
            of the integer constants <see cref="F:log4net.Filter.FilterDecision.Deny" />, 
            <see cref="F:log4net.Filter.FilterDecision.Neutral" /> or <see cref="F:log4net.Filter.FilterDecision.Accept" />.
            </para>
        <para>
            If the value <see cref="F:log4net.Filter.FilterDecision.Deny" /> is returned, then the log event is dropped 
            immediately without consulting with the remaining filters.
            </para>
        <para>
            If the value <see cref="F:log4net.Filter.FilterDecision.Neutral" /> is returned, then the next filter
            in the chain is consulted. If there are no more filters in the
            chain, then the log event is logged. Thus, in the presence of no
            filters, the default behavior is to log all logging events.
            </para>
        <para>
            If the value <see cref="F:log4net.Filter.FilterDecision.Accept" /> is returned, then the log
            event is logged without consulting the remaining filters.
            </para>
        <para>
            The philosophy of log4net filters is largely inspired from the
            Linux ipchains.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Filter.FilterSkeleton.m_next">
      <summary>
            Points to the next filter in the filter chain.
            </summary>
      <remarks>
        <para>
            See <see cref="P:log4net.Filter.FilterSkeleton.Next" /> for more information.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Filter.FilterSkeleton.ActivateOptions">
      <summary>
            Initialize the filter with the options set
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Filter.FilterSkeleton.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Filter.FilterSkeleton.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Filter.FilterSkeleton.ActivateOptions" /> must be called again.
            </para>
        <para>
            Typically filter's options become active immediately on set, 
            however this method must still be called. 
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Filter.FilterSkeleton.Decide(log4net.Core.LoggingEvent)">
      <summary>
            Decide if the <see cref="T:log4net.Core.LoggingEvent" /> should be logged through an appender.
            </summary>
      <param name="loggingEvent">The <see cref="T:log4net.Core.LoggingEvent" /> to decide upon</param>
      <returns>The decision of the filter</returns>
      <remarks>
        <para>
            If the decision is <see cref="F:log4net.Filter.FilterDecision.Deny" />, then the event will be
            dropped. If the decision is <see cref="F:log4net.Filter.FilterDecision.Neutral" />, then the next
            filter, if any, will be invoked. If the decision is <see cref="F:log4net.Filter.FilterDecision.Accept" /> then
            the event will be logged without consulting with other filters in
            the chain.
            </para>
        <para>
            This method is marked <c>abstract</c> and must be implemented
            in a subclass.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.FilterSkeleton.Next">
      <summary>
            Property to get and set the next filter
            </summary>
      <value>
            The next filter in the chain
            </value>
      <remarks>
        <para>
            Filters are typically composed into chains. This property allows the next filter in 
            the chain to be accessed.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Filter.DenyAllFilter">
      <summary>
            This filter drops all <see cref="T:log4net.Core.LoggingEvent" />. 
            </summary>
      <remarks>
        <para>
            You can add this filter to the end of a filter chain to
            switch from the default "accept all unless instructed otherwise"
            filtering behavior to a "deny all unless instructed otherwise"
            behavior.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Filter.DenyAllFilter.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:log4net.Filter.DenyAllFilter.Decide(log4net.Core.LoggingEvent)">
      <summary>
            Always returns the integer constant <see cref="F:log4net.Filter.FilterDecision.Deny" /></summary>
      <param name="loggingEvent">the LoggingEvent to filter</param>
      <returns>Always returns <see cref="F:log4net.Filter.FilterDecision.Deny" /></returns>
      <remarks>
        <para>
            Ignores the event being logged and just returns
            <see cref="F:log4net.Filter.FilterDecision.Deny" />. This can be used to change the default filter
            chain behavior from <see cref="F:log4net.Filter.FilterDecision.Accept" /> to <see cref="F:log4net.Filter.FilterDecision.Deny" />. This filter
            should only be used as the last filter in the chain
            as any further filters will be ignored!
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Filter.FilterDecision">
      <summary>
            The return result from <see cref="M:log4net.Filter.IFilter.Decide(log4net.Core.LoggingEvent)" /></summary>
      <remarks>
        <para>
            The return result from <see cref="M:log4net.Filter.IFilter.Decide(log4net.Core.LoggingEvent)" /></para>
      </remarks>
    </member>
    <member name="F:log4net.Filter.FilterDecision.Deny">
      <summary>
            The log event must be dropped immediately without 
            consulting with the remaining filters, if any, in the chain.
            </summary>
    </member>
    <member name="F:log4net.Filter.FilterDecision.Neutral">
      <summary>
            This filter is neutral with respect to the log event. 
            The remaining filters, if any, should be consulted for a final decision.
            </summary>
    </member>
    <member name="F:log4net.Filter.FilterDecision.Accept">
      <summary>
            The log event must be logged immediately without 
            consulting with the remaining filters, if any, in the chain.
            </summary>
    </member>
    <member name="T:log4net.Filter.LevelMatchFilter">
      <summary>
            This is a very simple filter based on <see cref="T:log4net.Core.Level" /> matching.
            </summary>
      <remarks>
        <para>
            The filter admits two options <see cref="P:log4net.Filter.LevelMatchFilter.LevelToMatch" /> and
            <see cref="P:log4net.Filter.LevelMatchFilter.AcceptOnMatch" />. If there is an exact match between the value
            of the <see cref="P:log4net.Filter.LevelMatchFilter.LevelToMatch" /> option and the <see cref="T:log4net.Core.Level" /> of the 
            <see cref="T:log4net.Core.LoggingEvent" />, then the <see cref="M:log4net.Filter.LevelMatchFilter.Decide(log4net.Core.LoggingEvent)" /> method returns <see cref="F:log4net.Filter.FilterDecision.Accept" /> in 
            case the <see cref="P:log4net.Filter.LevelMatchFilter.AcceptOnMatch" /> option value is set
            to <c>true</c>, if it is <c>false</c> then 
            <see cref="F:log4net.Filter.FilterDecision.Deny" /> is returned. If the <see cref="T:log4net.Core.Level" /> does not match then
            the result will be <see cref="F:log4net.Filter.FilterDecision.Neutral" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Filter.LevelMatchFilter.m_acceptOnMatch">
      <summary>
            flag to indicate if the filter should <see cref="F:log4net.Filter.FilterDecision.Accept" /> on a match
            </summary>
    </member>
    <member name="F:log4net.Filter.LevelMatchFilter.m_levelToMatch">
      <summary>
            the <see cref="T:log4net.Core.Level" /> to match against
            </summary>
    </member>
    <member name="M:log4net.Filter.LevelMatchFilter.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:log4net.Filter.LevelMatchFilter.Decide(log4net.Core.LoggingEvent)">
      <summary>
            Tests if the <see cref="T:log4net.Core.Level" /> of the logging event matches that of the filter
            </summary>
      <param name="loggingEvent">the event to filter</param>
      <returns>see remarks</returns>
      <remarks>
        <para>
            If the <see cref="T:log4net.Core.Level" /> of the event matches the level of the
            filter then the result of the function depends on the
            value of <see cref="P:log4net.Filter.LevelMatchFilter.AcceptOnMatch" />. If it is true then
            the function will return <see cref="F:log4net.Filter.FilterDecision.Accept" />, it it is false then it
            will return <see cref="F:log4net.Filter.FilterDecision.Deny" />. If the <see cref="T:log4net.Core.Level" /> does not match then
            the result will be <see cref="F:log4net.Filter.FilterDecision.Neutral" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.LevelMatchFilter.AcceptOnMatch">
      <summary>
        <see cref="F:log4net.Filter.FilterDecision.Accept" /> when matching <see cref="P:log4net.Filter.LevelMatchFilter.LevelToMatch" /></summary>
      <remarks>
        <para>
            The <see cref="P:log4net.Filter.LevelMatchFilter.AcceptOnMatch" /> property is a flag that determines
            the behavior when a matching <see cref="T:log4net.Core.Level" /> is found. If the
            flag is set to true then the filter will <see cref="F:log4net.Filter.FilterDecision.Accept" /> the 
            logging event, otherwise it will <see cref="F:log4net.Filter.FilterDecision.Deny" /> the event.
            </para>
        <para>
            The default is <c>true</c> i.e. to <see cref="F:log4net.Filter.FilterDecision.Accept" /> the event.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.LevelMatchFilter.LevelToMatch">
      <summary>
            The <see cref="T:log4net.Core.Level" /> that the filter will match
            </summary>
      <remarks>
        <para>
            The level that this filter will attempt to match against the 
            <see cref="T:log4net.Core.LoggingEvent" /> level. If a match is found then
            the result depends on the value of <see cref="P:log4net.Filter.LevelMatchFilter.AcceptOnMatch" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Filter.LevelRangeFilter">
      <summary>
            This is a simple filter based on <see cref="T:log4net.Core.Level" /> matching.
            </summary>
      <remarks>
        <para>
            The filter admits three options <see cref="P:log4net.Filter.LevelRangeFilter.LevelMin" /> and <see cref="P:log4net.Filter.LevelRangeFilter.LevelMax" />
            that determine the range of priorities that are matched, and
            <see cref="P:log4net.Filter.LevelRangeFilter.AcceptOnMatch" />. If there is a match between the range
            of priorities and the <see cref="T:log4net.Core.Level" /> of the <see cref="T:log4net.Core.LoggingEvent" />, then the 
            <see cref="M:log4net.Filter.LevelRangeFilter.Decide(log4net.Core.LoggingEvent)" /> method returns <see cref="F:log4net.Filter.FilterDecision.Accept" /> in case the <see cref="P:log4net.Filter.LevelRangeFilter.AcceptOnMatch" /> 
            option value is set to <c>true</c>, if it is <c>false</c>
            then <see cref="F:log4net.Filter.FilterDecision.Deny" /> is returned. If there is no match, <see cref="F:log4net.Filter.FilterDecision.Deny" /> is returned.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Filter.LevelRangeFilter.m_acceptOnMatch">
      <summary>
            Flag to indicate the behavior when matching a <see cref="T:log4net.Core.Level" /></summary>
    </member>
    <member name="F:log4net.Filter.LevelRangeFilter.m_levelMin">
      <summary>
            the minimum <see cref="T:log4net.Core.Level" /> value to match
            </summary>
    </member>
    <member name="F:log4net.Filter.LevelRangeFilter.m_levelMax">
      <summary>
            the maximum <see cref="T:log4net.Core.Level" /> value to match
            </summary>
    </member>
    <member name="M:log4net.Filter.LevelRangeFilter.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:log4net.Filter.LevelRangeFilter.Decide(log4net.Core.LoggingEvent)">
      <summary>
            Check if the event should be logged.
            </summary>
      <param name="loggingEvent">the logging event to check</param>
      <returns>see remarks</returns>
      <remarks>
        <para>
            If the <see cref="T:log4net.Core.Level" /> of the logging event is outside the range
            matched by this filter then <see cref="F:log4net.Filter.FilterDecision.Deny" />
            is returned. If the <see cref="T:log4net.Core.Level" /> is matched then the value of
            <see cref="P:log4net.Filter.LevelRangeFilter.AcceptOnMatch" /> is checked. If it is true then
            <see cref="F:log4net.Filter.FilterDecision.Accept" /> is returned, otherwise
            <see cref="F:log4net.Filter.FilterDecision.Neutral" /> is returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.LevelRangeFilter.AcceptOnMatch">
      <summary>
        <see cref="F:log4net.Filter.FilterDecision.Accept" /> when matching <see cref="P:log4net.Filter.LevelRangeFilter.LevelMin" /> and <see cref="P:log4net.Filter.LevelRangeFilter.LevelMax" /></summary>
      <remarks>
        <para>
            The <see cref="P:log4net.Filter.LevelRangeFilter.AcceptOnMatch" /> property is a flag that determines
            the behavior when a matching <see cref="T:log4net.Core.Level" /> is found. If the
            flag is set to true then the filter will <see cref="F:log4net.Filter.FilterDecision.Accept" /> the 
            logging event, otherwise it will <see cref="F:log4net.Filter.FilterDecision.Neutral" /> the event.
            </para>
        <para>
            The default is <c>true</c> i.e. to <see cref="F:log4net.Filter.FilterDecision.Accept" /> the event.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.LevelRangeFilter.LevelMin">
      <summary>
            Set the minimum matched <see cref="T:log4net.Core.Level" /></summary>
      <remarks>
        <para>
            The minimum level that this filter will attempt to match against the 
            <see cref="T:log4net.Core.LoggingEvent" /> level. If a match is found then
            the result depends on the value of <see cref="P:log4net.Filter.LevelRangeFilter.AcceptOnMatch" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.LevelRangeFilter.LevelMax">
      <summary>
            Sets the maximum matched <see cref="T:log4net.Core.Level" /></summary>
      <remarks>
        <para>
            The maximum level that this filter will attempt to match against the 
            <see cref="T:log4net.Core.LoggingEvent" /> level. If a match is found then
            the result depends on the value of <see cref="P:log4net.Filter.LevelRangeFilter.AcceptOnMatch" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Filter.LoggerMatchFilter">
      <summary>
            Simple filter to match a string in the event's logger name.
            </summary>
      <remarks>
        <para>
            The works very similar to the <see cref="T:log4net.Filter.LevelMatchFilter" />. It admits two 
            options <see cref="P:log4net.Filter.LoggerMatchFilter.LoggerToMatch" /> and <see cref="P:log4net.Filter.LoggerMatchFilter.AcceptOnMatch" />. If the 
            <see cref="P:log4net.Core.LoggingEvent.LoggerName" /> of the <see cref="T:log4net.Core.LoggingEvent" /> starts 
            with the value of the <see cref="P:log4net.Filter.LoggerMatchFilter.LoggerToMatch" /> option, then the 
            <see cref="M:log4net.Filter.LoggerMatchFilter.Decide(log4net.Core.LoggingEvent)" /> method returns <see cref="F:log4net.Filter.FilterDecision.Accept" /> in 
            case the <see cref="P:log4net.Filter.LoggerMatchFilter.AcceptOnMatch" /> option value is set to <c>true</c>, 
            if it is <c>false</c> then <see cref="F:log4net.Filter.FilterDecision.Deny" /> is returned.
            </para>
      </remarks>
      <author>Daniel Cazzulino</author>
    </member>
    <member name="F:log4net.Filter.LoggerMatchFilter.m_acceptOnMatch">
      <summary>
            Flag to indicate the behavior when we have a match
            </summary>
    </member>
    <member name="F:log4net.Filter.LoggerMatchFilter.m_loggerToMatch">
      <summary>
            The logger name string to substring match against the event
            </summary>
    </member>
    <member name="M:log4net.Filter.LoggerMatchFilter.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:log4net.Filter.LoggerMatchFilter.Decide(log4net.Core.LoggingEvent)">
      <summary>
            Check if this filter should allow the event to be logged
            </summary>
      <param name="loggingEvent">the event being logged</param>
      <returns>see remarks</returns>
      <remarks>
        <para>
            The rendered message is matched against the <see cref="P:log4net.Filter.LoggerMatchFilter.LoggerToMatch" />.
            If the <see cref="P:log4net.Filter.LoggerMatchFilter.LoggerToMatch" /> equals the beginning of 
            the incoming <see cref="P:log4net.Core.LoggingEvent.LoggerName" /> (<see cref="M:String.StartsWith(string)" />)
            then a match will have occurred. If no match occurs
            this function will return <see cref="F:log4net.Filter.FilterDecision.Neutral" />
            allowing other filters to check the event. If a match occurs then
            the value of <see cref="P:log4net.Filter.LoggerMatchFilter.AcceptOnMatch" /> is checked. If it is
            true then <see cref="F:log4net.Filter.FilterDecision.Accept" /> is returned otherwise
            <see cref="F:log4net.Filter.FilterDecision.Deny" /> is returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.LoggerMatchFilter.AcceptOnMatch">
      <summary>
        <see cref="F:log4net.Filter.FilterDecision.Accept" /> when matching <see cref="P:log4net.Filter.LoggerMatchFilter.LoggerToMatch" /></summary>
      <remarks>
        <para>
            The <see cref="P:log4net.Filter.LoggerMatchFilter.AcceptOnMatch" /> property is a flag that determines
            the behavior when a matching <see cref="T:log4net.Core.Level" /> is found. If the
            flag is set to true then the filter will <see cref="F:log4net.Filter.FilterDecision.Accept" /> the 
            logging event, otherwise it will <see cref="F:log4net.Filter.FilterDecision.Deny" /> the event.
            </para>
        <para>
            The default is <c>true</c> i.e. to <see cref="F:log4net.Filter.FilterDecision.Accept" /> the event.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.LoggerMatchFilter.LoggerToMatch">
      <summary>
            The <see cref="P:log4net.Core.LoggingEvent.LoggerName" /> that the filter will match
            </summary>
      <remarks>
        <para>
            This filter will attempt to match this value against logger name in
            the following way. The match will be done against the beginning of the
            logger name (using <see cref="M:String.StartsWith(string)" />). The match is
            case sensitive. If a match is found then
            the result depends on the value of <see cref="P:log4net.Filter.LoggerMatchFilter.AcceptOnMatch" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Filter.StringMatchFilter">
      <summary>
            Simple filter to match a string in the rendered message
            </summary>
      <remarks>
        <para>
            Simple filter to match a string in the rendered message
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Filter.StringMatchFilter.m_acceptOnMatch">
      <summary>
            Flag to indicate the behavior when we have a match
            </summary>
    </member>
    <member name="F:log4net.Filter.StringMatchFilter.m_stringToMatch">
      <summary>
            The string to substring match against the message
            </summary>
    </member>
    <member name="F:log4net.Filter.StringMatchFilter.m_stringRegexToMatch">
      <summary>
            A string regex to match
            </summary>
    </member>
    <member name="F:log4net.Filter.StringMatchFilter.m_regexToMatch">
      <summary>
            A regex object to match (generated from m_stringRegexToMatch)
            </summary>
    </member>
    <member name="M:log4net.Filter.StringMatchFilter.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:log4net.Filter.StringMatchFilter.ActivateOptions">
      <summary>
            Initialize and precompile the Regex if required
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Filter.StringMatchFilter.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Filter.StringMatchFilter.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Filter.StringMatchFilter.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Filter.StringMatchFilter.Decide(log4net.Core.LoggingEvent)">
      <summary>
            Check if this filter should allow the event to be logged
            </summary>
      <param name="loggingEvent">the event being logged</param>
      <returns>see remarks</returns>
      <remarks>
        <para>
            The rendered message is matched against the <see cref="P:log4net.Filter.StringMatchFilter.StringToMatch" />.
            If the <see cref="P:log4net.Filter.StringMatchFilter.StringToMatch" /> occurs as a substring within
            the message then a match will have occurred. If no match occurs
            this function will return <see cref="F:log4net.Filter.FilterDecision.Neutral" />
            allowing other filters to check the event. If a match occurs then
            the value of <see cref="P:log4net.Filter.StringMatchFilter.AcceptOnMatch" /> is checked. If it is
            true then <see cref="F:log4net.Filter.FilterDecision.Accept" /> is returned otherwise
            <see cref="F:log4net.Filter.FilterDecision.Deny" /> is returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.StringMatchFilter.AcceptOnMatch">
      <summary>
        <see cref="F:log4net.Filter.FilterDecision.Accept" /> when matching <see cref="P:log4net.Filter.StringMatchFilter.StringToMatch" /> or <see cref="P:log4net.Filter.StringMatchFilter.RegexToMatch" /></summary>
      <remarks>
        <para>
            The <see cref="P:log4net.Filter.StringMatchFilter.AcceptOnMatch" /> property is a flag that determines
            the behavior when a matching <see cref="T:log4net.Core.Level" /> is found. If the
            flag is set to true then the filter will <see cref="F:log4net.Filter.FilterDecision.Accept" /> the 
            logging event, otherwise it will <see cref="F:log4net.Filter.FilterDecision.Neutral" /> the event.
            </para>
        <para>
            The default is <c>true</c> i.e. to <see cref="F:log4net.Filter.FilterDecision.Accept" /> the event.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.StringMatchFilter.StringToMatch">
      <summary>
            Sets the static string to match
            </summary>
      <remarks>
        <para>
            The string that will be substring matched against
            the rendered message. If the message contains this
            string then the filter will match. If a match is found then
            the result depends on the value of <see cref="P:log4net.Filter.StringMatchFilter.AcceptOnMatch" />.
            </para>
        <para>
            One of <see cref="P:log4net.Filter.StringMatchFilter.StringToMatch" /> or <see cref="P:log4net.Filter.StringMatchFilter.RegexToMatch" />
            must be specified.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.StringMatchFilter.RegexToMatch">
      <summary>
            Sets the regular expression to match
            </summary>
      <remarks>
        <para>
            The regular expression pattern that will be matched against
            the rendered message. If the message matches this
            pattern then the filter will match. If a match is found then
            the result depends on the value of <see cref="P:log4net.Filter.StringMatchFilter.AcceptOnMatch" />.
            </para>
        <para>
            One of <see cref="P:log4net.Filter.StringMatchFilter.StringToMatch" /> or <see cref="P:log4net.Filter.StringMatchFilter.RegexToMatch" />
            must be specified.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Filter.PropertyFilter">
      <summary>
            Simple filter to match a string an event property
            </summary>
      <remarks>
        <para>
            Simple filter to match a string in the value for a
            specific event property
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Filter.PropertyFilter.m_key">
      <summary>
            The key to use to lookup the string from the event properties
            </summary>
    </member>
    <member name="M:log4net.Filter.PropertyFilter.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:log4net.Filter.PropertyFilter.Decide(log4net.Core.LoggingEvent)">
      <summary>
            Check if this filter should allow the event to be logged
            </summary>
      <param name="loggingEvent">the event being logged</param>
      <returns>see remarks</returns>
      <remarks>
        <para>
            The event property for the <see cref="P:log4net.Filter.PropertyFilter.Key" /> is matched against 
            the <see cref="P:log4net.Filter.StringMatchFilter.StringToMatch" />.
            If the <see cref="P:log4net.Filter.StringMatchFilter.StringToMatch" /> occurs as a substring within
            the property value then a match will have occurred. If no match occurs
            this function will return <see cref="F:log4net.Filter.FilterDecision.Neutral" />
            allowing other filters to check the event. If a match occurs then
            the value of <see cref="P:log4net.Filter.StringMatchFilter.AcceptOnMatch" /> is checked. If it is
            true then <see cref="F:log4net.Filter.FilterDecision.Accept" /> is returned otherwise
            <see cref="F:log4net.Filter.FilterDecision.Deny" /> is returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.PropertyFilter.Key">
      <summary>
            The key to lookup in the event properties and then match against.
            </summary>
      <remarks>
        <para>
            The key name to use to lookup in the properties map of the
            <see cref="T:log4net.Core.LoggingEvent" />. The match will be performed against 
            the value of this property if it exists.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Filter.MdcFilter">
      <summary>
            Simple filter to match a keyed string in the <see cref="T:log4net.MDC" /></summary>
      <remarks>
        <para>
            Simple filter to match a keyed string in the <see cref="T:log4net.MDC" /></para>
        <para>
            As the MDC has been replaced with layered properties the
            <see cref="T:log4net.Filter.PropertyFilter" /> should be used instead.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="T:log4net.Filter.NdcFilter">
      <summary>
            Simple filter to match a string in the <see cref="T:log4net.NDC" /></summary>
      <remarks>
        <para>
            Simple filter to match a string in the <see cref="T:log4net.NDC" /></para>
        <para>
            As the MDC has been replaced with named stacks stored in the
            properties collections the <see cref="T:log4net.Filter.PropertyFilter" /> should 
            be used instead.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Filter.NdcFilter.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Sets the <see cref="P:log4net.Filter.PropertyFilter.Key" /> to <c>"NDC"</c>.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternConverter">
      <summary>
            Abstract class that provides the formatting functionality that 
            derived classes need.
            </summary>
      <remarks>
        <para>
            Conversion specifiers in a conversion patterns are parsed to
            individual PatternConverters. Each of which is responsible for
            converting a logging event in a converter specific manner.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.PatternConverter.c_renderBufferSize">
      <summary>
            Initial buffer size
            </summary>
    </member>
    <member name="F:log4net.Util.PatternConverter.c_renderBufferMaxCapacity">
      <summary>
            Maximum buffer size before it is recycled
            </summary>
    </member>
    <member name="F:log4net.Util.PatternConverter.m_option">
      <summary>
            The option string to the converter
            </summary>
    </member>
    <member name="M:log4net.Util.PatternConverter.#ctor">
      <summary>
            Protected constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.PatternConverter" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Evaluate this pattern converter and write the output to a writer.
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="state">The state object on which the pattern converter should be executed.</param>
      <remarks>
        <para>
            Derived pattern converters must override this method in order to
            convert conversion specifiers in the appropriate way.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternConverter.SetNext(log4net.Util.PatternConverter)">
      <summary>
            Set the next pattern converter in the chains
            </summary>
      <param name="patternConverter">the pattern converter that should follow this converter in the chain</param>
      <returns>the next converter</returns>
      <remarks>
        <para>
            The PatternConverter can merge with its neighbor during this method (or a sub class).
            Therefore the return value may or may not be the value of the argument passed in.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternConverter.Format(System.IO.TextWriter,System.Object)">
      <summary>
            Write the pattern converter to the writer with appropriate formatting
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="state">The state object on which the pattern converter should be executed.</param>
      <remarks>
        <para>
            This method calls <see cref="M:log4net.Util.PatternConverter.Convert(System.IO.TextWriter,System.Object)" /> to allow the subclass to perform
            appropriate conversion of the pattern converter. If formatting options have
            been specified via the <see cref="P:log4net.Util.PatternConverter.FormattingInfo" /> then this method will
            apply those formattings before writing the output.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternConverter.SpacePad(System.IO.TextWriter,System.Int32)">
      <summary>
            Fast space padding method.
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> to which the spaces will be appended.</param>
      <param name="length">The number of spaces to be padded.</param>
      <remarks>
        <para>
            Fast space padding method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternConverter.WriteDictionary(System.IO.TextWriter,log4net.Repository.ILoggerRepository,System.Collections.IDictionary)">
      <summary>
            Write an dictionary to a <see cref="T:System.IO.TextWriter" /></summary>
      <param name="writer">the writer to write to</param>
      <param name="repository">a <see cref="T:log4net.Repository.ILoggerRepository" /> to use for object conversion</param>
      <param name="value">the value to write to the writer</param>
      <remarks>
        <para>
            Writes the <see cref="T:System.Collections.IDictionary" /> to a writer in the form:
            </para>
        <code>
            {key1=value1, key2=value2, key3=value3}
            </code>
        <para>
            If the <see cref="T:log4net.Repository.ILoggerRepository" /> specified
            is not null then it is used to render the key and value to text, otherwise
            the object's ToString method is called.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternConverter.WriteDictionary(System.IO.TextWriter,log4net.Repository.ILoggerRepository,System.Collections.IDictionaryEnumerator)">
      <summary>
            Write an dictionary to a <see cref="T:System.IO.TextWriter" /></summary>
      <param name="writer">the writer to write to</param>
      <param name="repository">a <see cref="T:log4net.Repository.ILoggerRepository" /> to use for object conversion</param>
      <param name="value">the value to write to the writer</param>
      <remarks>
        <para>
            Writes the <see cref="T:System.Collections.IDictionaryEnumerator" /> to a writer in the form:
            </para>
        <code>
            {key1=value1, key2=value2, key3=value3}
            </code>
        <para>
            If the <see cref="T:log4net.Repository.ILoggerRepository" /> specified
            is not null then it is used to render the key and value to text, otherwise
            the object's ToString method is called.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternConverter.WriteObject(System.IO.TextWriter,log4net.Repository.ILoggerRepository,System.Object)">
      <summary>
            Write an object to a <see cref="T:System.IO.TextWriter" /></summary>
      <param name="writer">the writer to write to</param>
      <param name="repository">a <see cref="T:log4net.Repository.ILoggerRepository" /> to use for object conversion</param>
      <param name="value">the value to write to the writer</param>
      <remarks>
        <para>
            Writes the Object to a writer. If the <see cref="T:log4net.Repository.ILoggerRepository" /> specified
            is not null then it is used to render the object to text, otherwise
            the object's ToString method is called.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.PatternConverter.Next">
      <summary>
            Get the next pattern converter in the chain
            </summary>
      <value>
            the next pattern converter in the chain
            </value>
      <remarks>
        <para>
            Get the next pattern converter in the chain
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.PatternConverter.FormattingInfo">
      <summary>
            Gets or sets the formatting info for this converter
            </summary>
      <value>
            The formatting info for this converter
            </value>
      <remarks>
        <para>
            Gets or sets the formatting info for this converter
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.PatternConverter.Option">
      <summary>
            Gets or sets the option value for this converter
            </summary>
      <summary>
            The option for this converter
            </summary>
      <remarks>
        <para>
            Gets or sets the option value for this converter
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.PatternConverter.Properties">
      <summary>
      </summary>
    </member>
    <member name="T:log4net.Layout.Pattern.PatternLayoutConverter">
      <summary>
            Abstract class that provides the formatting functionality that 
            derived classes need.
            </summary>
      <remarks>
            Conversion specifiers in a conversion patterns are parsed to
            individual PatternConverters. Each of which is responsible for
            converting a logging event in a converter specific manner.
            </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Layout.Pattern.PatternLayoutConverter.m_ignoresException">
      <summary>
            Flag indicating if this converter handles exceptions
            </summary>
      <remarks>
        <c>false</c> if this converter handles exceptions
            </remarks>
    </member>
    <member name="M:log4net.Layout.Pattern.PatternLayoutConverter.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Layout.Pattern.PatternLayoutConverter" /> class.
            </summary>
    </member>
    <member name="M:log4net.Layout.Pattern.PatternLayoutConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Derived pattern converters must override this method in order to
            convert conversion specifiers in the correct way.
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">The <see cref="T:log4net.Core.LoggingEvent" /> on which the pattern converter should be executed.</param>
    </member>
    <member name="M:log4net.Layout.Pattern.PatternLayoutConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Derived pattern converters must override this method in order to
            convert conversion specifiers in the correct way.
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="state">The state object on which the pattern converter should be executed.</param>
    </member>
    <member name="P:log4net.Layout.Pattern.PatternLayoutConverter.IgnoresException">
      <summary>
            Flag indicating if this converter handles the logging event exception
            </summary>
      <value>
        <c>false</c> if this converter handles the logging event exception</value>
      <remarks>
        <para>
            If this converter handles the exception object contained within
            <see cref="T:log4net.Core.LoggingEvent" />, then this property should be set to
            <c>false</c>. Otherwise, if the layout ignores the exception
            object, then the property should be set to <c>true</c>.
            </para>
        <para>
            Set this value to override a this default setting. The default
            value is <c>true</c>, this converter does not handle the exception.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.AppDomainPatternConverter">
      <summary>
            Write the event appdomain name to the output
            </summary>
      <remarks>
        <para>
            Writes the <see cref="P:log4net.Core.LoggingEvent.Domain" /> to the output writer.
            </para>
      </remarks>
      <author>Daniel Cazzulino</author>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.AppDomainPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the event appdomain name to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Writes the <see cref="P:log4net.Core.LoggingEvent.Domain" /> to the output <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.AspNetPatternLayoutConverter">
      <summary>
            Abstract class that provides access to the current HttpContext (<see cref="P:System.Web.HttpContext.Current" />) that 
            derived classes need.
            </summary>
      <remarks>
            This class handles the case when HttpContext.Current is null by writing
            <see cref="P:log4net.Util.SystemInfo.NotAvailableText" /> to the writer.
            </remarks>
      <author>Ron Grabowski</author>
    </member>
    <member name="M:log4net.Layout.Pattern.AspNetPatternLayoutConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent,System.Web.HttpContext)">
      <summary>
            Derived pattern converters must override this method in order to
            convert conversion specifiers in the correct way.
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">The <see cref="T:log4net.Core.LoggingEvent" /> on which the pattern converter should be executed.</param>
      <param name="httpContext">The <see cref="T:System.Web.HttpContext" /> under which the ASP.Net request is running.</param>
    </member>
    <member name="T:log4net.Layout.Pattern.AspNetCachePatternConverter">
      <summary>
            Converter for items in the ASP.Net Cache.
            </summary>
      <remarks>
        <para>
            Outputs an item from the <see cref="P:System.Web.HttpRuntime.Cache" />.
            </para>
      </remarks>
      <author>Ron Grabowski</author>
    </member>
    <member name="M:log4net.Layout.Pattern.AspNetCachePatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent,System.Web.HttpContext)">
      <summary>
            Write the ASP.Net Cache item to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">The <see cref="T:log4net.Core.LoggingEvent" /> on which the pattern converter should be executed.</param>
      <param name="httpContext">The <see cref="T:System.Web.HttpContext" /> under which the ASP.Net request is running.</param>
      <remarks>
        <para>
            Writes out the value of a named property. The property name
            should be set in the <see cref="P:log4net.Util.PatternConverter.Option" />
            property. If no property has been set, all key value pairs from the Cache will
            be written to the output.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.AspNetContextPatternConverter">
      <summary>
            Converter for items in the <see cref="T:System.Web.HttpContext" />.
            </summary>
      <remarks>
        <para>
            Outputs an item from the <see cref="T:System.Web.HttpContext" />.
            </para>
      </remarks>
      <author>Ron Grabowski</author>
    </member>
    <member name="M:log4net.Layout.Pattern.AspNetContextPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent,System.Web.HttpContext)">
      <summary>
            Write the ASP.Net HttpContext item to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">The <see cref="T:log4net.Core.LoggingEvent" /> on which the pattern converter should be executed.</param>
      <param name="httpContext">The <see cref="T:System.Web.HttpContext" /> under which the ASP.Net request is running.</param>
      <remarks>
        <para>
            Writes out the value of a named property. The property name
            should be set in the <see cref="P:log4net.Util.PatternConverter.Option" />
            property.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.AspNetRequestPatternConverter">
      <summary>
            Converter for items in the ASP.Net Cache.
            </summary>
      <remarks>
        <para>
            Outputs an item from the <see cref="P:System.Web.HttpRuntime.Cache" />.
            </para>
      </remarks>
      <author>Ron Grabowski</author>
    </member>
    <member name="M:log4net.Layout.Pattern.AspNetRequestPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent,System.Web.HttpContext)">
      <summary>
            Write the ASP.Net Cache item to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">The <see cref="T:log4net.Core.LoggingEvent" /> on which the pattern converter should be executed.</param>
      <param name="httpContext">The <see cref="T:System.Web.HttpContext" /> under which the ASP.Net request is running.</param>
      <remarks>
        <para>
            Writes out the value of a named property. The property name
            should be set in the <see cref="P:log4net.Util.PatternConverter.Option" />
            property.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.AspNetSessionPatternConverter">
      <summary>
            Converter for items in the ASP.Net Cache.
            </summary>
      <remarks>
        <para>
            Outputs an item from the <see cref="P:System.Web.HttpRuntime.Cache" />.
            </para>
      </remarks>
      <author>Ron Grabowski</author>
    </member>
    <member name="M:log4net.Layout.Pattern.AspNetSessionPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent,System.Web.HttpContext)">
      <summary>
            Write the ASP.Net Cache item to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">The <see cref="T:log4net.Core.LoggingEvent" /> on which the pattern converter should be executed.</param>
      <param name="httpContext">The <see cref="T:System.Web.HttpContext" /> under which the ASP.Net request is running.</param>
      <remarks>
        <para>
            Writes out the value of a named property. The property name
            should be set in the <see cref="P:log4net.Util.PatternConverter.Option" />
            property. If no property has been set, all key value pairs from the Session will
            be written to the output.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.DatePatternConverter">
      <summary>
            Date pattern converter, uses a <see cref="T:log4net.DateFormatter.IDateFormatter" /> to format 
            the date of a <see cref="T:log4net.Core.LoggingEvent" />.
            </summary>
      <remarks>
        <para>
            Render the <see cref="P:log4net.Core.LoggingEvent.TimeStamp" /> to the writer as a string.
            </para>
        <para>
            The value of the <see cref="P:log4net.Util.PatternConverter.Option" /> determines 
            the formatting of the date. The following values are allowed:
            <list type="definition"><listheader><term>Option value</term><description>Output</description></listheader><item><term>ISO8601</term><description>
            		Uses the <see cref="T:log4net.DateFormatter.Iso8601DateFormatter" /> formatter. 
            		Formats using the <c>"yyyy-MM-dd HH:mm:ss,fff"</c> pattern.
            		</description></item><item><term>DATE</term><description>
            		Uses the <see cref="T:log4net.DateFormatter.DateTimeDateFormatter" /> formatter. 
            		Formats using the <c>"dd MMM yyyy HH:mm:ss,fff"</c> for example, <c>"06 Nov 1994 15:49:37,459"</c>.
            		</description></item><item><term>ABSOLUTE</term><description>
            		Uses the <see cref="T:log4net.DateFormatter.AbsoluteTimeDateFormatter" /> formatter. 
            		Formats using the <c>"HH:mm:ss,yyyy"</c> for example, <c>"15:49:37,459"</c>.
            		</description></item><item><term>other</term><description>
            		Any other pattern string uses the <see cref="T:log4net.DateFormatter.SimpleDateFormatter" /> formatter. 
            		This formatter passes the pattern string to the <see cref="T:System.DateTime" /><see cref="M:DateTime.ToString(string)" /> method.
            		For details on valid patterns see 
            		<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemglobalizationdatetimeformatinfoclasstopic.asp">DateTimeFormatInfo Class</a>.
            		</description></item></list></para>
        <para>
            The <see cref="P:log4net.Core.LoggingEvent.TimeStamp" /> is in the local time zone and is rendered in that zone.
            To output the time in Universal time see <see cref="T:log4net.Layout.Pattern.UtcDatePatternConverter" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Layout.Pattern.DatePatternConverter.m_dateFormatter">
      <summary>
            The <see cref="T:log4net.DateFormatter.IDateFormatter" /> used to render the date to a string
            </summary>
      <remarks>
        <para>
            The <see cref="T:log4net.DateFormatter.IDateFormatter" /> used to render the date to a string
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Layout.Pattern.DatePatternConverter.declaringType">
      <summary>
            The fully qualified type of the DatePatternConverter class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Layout.Pattern.DatePatternConverter.ActivateOptions">
      <summary>
            Initialize the converter pattern based on the <see cref="P:log4net.Util.PatternConverter.Option" /> property.
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Layout.Pattern.DatePatternConverter.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Layout.Pattern.DatePatternConverter.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Layout.Pattern.DatePatternConverter.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.Pattern.DatePatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Convert the pattern into the rendered message
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Pass the <see cref="P:log4net.Core.LoggingEvent.TimeStamp" /> to the <see cref="T:log4net.DateFormatter.IDateFormatter" />
            for it to render it to the writer.
            </para>
        <para>
            The <see cref="P:log4net.Core.LoggingEvent.TimeStamp" /> passed is in the local time zone.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.ExceptionPatternConverter">
      <summary>
            Write the exception text to the output
            </summary>
      <remarks>
        <para>
            If an exception object is stored in the logging event
            it will be rendered into the pattern output with a
            trailing newline.
            </para>
        <para>
            If there is no exception then nothing will be output
            and no trailing newline will be appended.
            It is typical to put a newline before the exception
            and to have the exception as the last data in the pattern.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.ExceptionPatternConverter.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:log4net.Layout.Pattern.ExceptionPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the exception text to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            If an exception object is stored in the logging event
            it will be rendered into the pattern output with a
            trailing newline.
            </para>
        <para>
            If there is no exception or the exception property specified
            by the Option value does not exist then nothing will be output
            and no trailing newline will be appended.
            It is typical to put a newline before the exception
            and to have the exception as the last data in the pattern.
            </para>
        <para>
            Recognized values for the Option parameter are:
            </para>
        <list type="bullet">
          <item>
            <description>Message</description>
          </item>
          <item>
            <description>Source</description>
          </item>
          <item>
            <description>StackTrace</description>
          </item>
          <item>
            <description>TargetSite</description>
          </item>
          <item>
            <description>HelpLink</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.FileLocationPatternConverter">
      <summary>
            Writes the caller location file name to the output
            </summary>
      <remarks>
        <para>
            Writes the value of the <see cref="P:log4net.Core.LocationInfo.FileName" /> for
            the event to the output writer.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.FileLocationPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the caller location file name to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Writes the value of the <see cref="P:log4net.Core.LocationInfo.FileName" /> for
            the <paramref name="loggingEvent" /> to the output <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.FullLocationPatternConverter">
      <summary>
            Write the caller location info to the output
            </summary>
      <remarks>
        <para>
            Writes the <see cref="P:log4net.Core.LocationInfo.FullInfo" /> to the output writer.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.FullLocationPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the caller location info to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Writes the <see cref="P:log4net.Core.LocationInfo.FullInfo" /> to the output writer.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.IdentityPatternConverter">
      <summary>
            Writes the event identity to the output
            </summary>
      <remarks>
        <para>
            Writes the value of the <see cref="P:log4net.Core.LoggingEvent.Identity" /> to
            the output writer.
            </para>
      </remarks>
      <author>Daniel Cazzulino</author>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.IdentityPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Writes the event identity to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Writes the value of the <paramref name="loggingEvent" /><see cref="P:log4net.Core.LoggingEvent.Identity" /> to
            the output <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.LevelPatternConverter">
      <summary>
            Write the event level to the output
            </summary>
      <remarks>
        <para>
            Writes the display name of the event <see cref="P:log4net.Core.LoggingEvent.Level" />
            to the writer.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.LevelPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the event level to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Writes the <see cref="P:log4net.Core.Level.DisplayName" /> of the <paramref name="loggingEvent" /><see cref="P:log4net.Core.LoggingEvent.Level" />
            to the <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.LineLocationPatternConverter">
      <summary>
            Write the caller location line number to the output
            </summary>
      <remarks>
        <para>
            Writes the value of the <see cref="P:log4net.Core.LocationInfo.LineNumber" /> for
            the event to the output writer.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.LineLocationPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the caller location line number to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Writes the value of the <see cref="P:log4net.Core.LocationInfo.LineNumber" /> for
            the <paramref name="loggingEvent" /> to the output <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.NamedPatternConverter">
      <summary>
            Converter to output and truncate <c>'.'</c> separated strings
            </summary>
      <remarks>
        <para>
            This abstract class supports truncating a <c>'.'</c> separated string
            to show a specified number of elements from the right hand side.
            This is used to truncate class names that are fully qualified.
            </para>
        <para>
            Subclasses should override the <see cref="M:log4net.Layout.Pattern.NamedPatternConverter.GetFullyQualifiedName(log4net.Core.LoggingEvent)" /> method to
            return the fully qualified string.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Layout.Pattern.NamedPatternConverter.declaringType">
      <summary>
            The fully qualified type of the NamedPatternConverter class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Layout.Pattern.NamedPatternConverter.ActivateOptions">
      <summary>
            Initialize the converter 
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Layout.Pattern.NamedPatternConverter.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Layout.Pattern.NamedPatternConverter.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Layout.Pattern.NamedPatternConverter.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.Pattern.NamedPatternConverter.GetFullyQualifiedName(log4net.Core.LoggingEvent)">
      <summary>
            Get the fully qualified string data
            </summary>
      <param name="loggingEvent">the event being logged</param>
      <returns>the fully qualified name</returns>
      <remarks>
        <para>
            Overridden by subclasses to get the fully qualified name before the
            precision is applied to it.
            </para>
        <para>
            Return the fully qualified <c>'.'</c> (dot/period) separated string.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.Pattern.NamedPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Convert the pattern to the rendered message
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
            Render the <see cref="M:log4net.Layout.Pattern.NamedPatternConverter.GetFullyQualifiedName(log4net.Core.LoggingEvent)" /> to the precision
            specified by the <see cref="P:log4net.Util.PatternConverter.Option" /> property.
            </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.LoggerPatternConverter">
      <summary>
            Converter for logger name
            </summary>
      <remarks>
        <para>
            Outputs the <see cref="P:log4net.Core.LoggingEvent.LoggerName" /> of the event.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.LoggerPatternConverter.GetFullyQualifiedName(log4net.Core.LoggingEvent)">
      <summary>
            Gets the fully qualified name of the logger
            </summary>
      <param name="loggingEvent">the event being logged</param>
      <returns>The fully qualified logger name</returns>
      <remarks>
        <para>
            Returns the <see cref="P:log4net.Core.LoggingEvent.LoggerName" /> of the <paramref name="loggingEvent" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.MessagePatternConverter">
      <summary>
            Writes the event message to the output
            </summary>
      <remarks>
        <para>
            Uses the <see cref="M:log4net.Core.LoggingEvent.WriteRenderedMessage(System.IO.TextWriter)" /> method
            to write out the event message.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.MessagePatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Writes the event message to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Uses the <see cref="M:log4net.Core.LoggingEvent.WriteRenderedMessage(System.IO.TextWriter)" /> method
            to write out the event message.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.MethodLocationPatternConverter">
      <summary>
            Write the method name to the output
            </summary>
      <remarks>
        <para>
            Writes the caller location <see cref="P:log4net.Core.LocationInfo.MethodName" /> to
            the output.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.MethodLocationPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the method name to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Writes the caller location <see cref="P:log4net.Core.LocationInfo.MethodName" /> to
            the output.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.NdcPatternConverter">
      <summary>
            Converter to include event NDC
            </summary>
      <remarks>
        <para>
            Outputs the value of the event property named <c>NDC</c>.
            </para>
        <para>
            The <see cref="T:log4net.Layout.Pattern.PropertyPatternConverter" /> should be used instead.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.NdcPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the event NDC to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            As the thread context stacks are now stored in named event properties
            this converter simply looks up the value of the <c>NDC</c> property.
            </para>
        <para>
            The <see cref="T:log4net.Layout.Pattern.PropertyPatternConverter" /> should be used instead.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.PropertyPatternConverter">
      <summary>
            Property pattern converter
            </summary>
      <remarks>
        <para>
            Writes out the value of a named property. The property name
            should be set in the <see cref="P:log4net.Util.PatternConverter.Option" />
            property.
            </para>
        <para>
            If the <see cref="P:log4net.Util.PatternConverter.Option" /> is set to <c>null</c>
            then all the properties are written as key value pairs.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.PropertyPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the property value to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Writes out the value of a named property. The property name
            should be set in the <see cref="P:log4net.Util.PatternConverter.Option" />
            property.
            </para>
        <para>
            If the <see cref="P:log4net.Util.PatternConverter.Option" /> is set to <c>null</c>
            then all the properties are written as key value pairs.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.RelativeTimePatternConverter">
      <summary>
            Converter to output the relative time of the event
            </summary>
      <remarks>
        <para>
            Converter to output the time of the event relative to the start of the program.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.RelativeTimePatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the relative time to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Writes out the relative time of the event in milliseconds.
            That is the number of milliseconds between the event <see cref="P:log4net.Core.LoggingEvent.TimeStamp" />
            and the <see cref="P:log4net.Core.LoggingEvent.StartTime" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.Pattern.RelativeTimePatternConverter.TimeDifferenceInMillis(System.DateTime,System.DateTime)">
      <summary>
            Helper method to get the time difference between two DateTime objects
            </summary>
      <param name="start">start time (in the current local time zone)</param>
      <param name="end">end time (in the current local time zone)</param>
      <returns>the time difference in milliseconds</returns>
    </member>
    <member name="T:log4net.Layout.Pattern.StackTracePatternConverter">
      <summary>
            Write the caller stack frames to the output
            </summary>
      <remarks>
        <para>
            Writes the <see cref="P:log4net.Core.LocationInfo.StackFrames" /> to the output writer, using format:
            type3.MethodCall3 &gt; type2.MethodCall2 &gt; type1.MethodCall1
            </para>
      </remarks>
      <author>Michael Cromwell</author>
    </member>
    <member name="F:log4net.Layout.Pattern.StackTracePatternConverter.declaringType">
      <summary>
            The fully qualified type of the StackTracePatternConverter class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Layout.Pattern.StackTracePatternConverter.ActivateOptions">
      <summary>
            Initialize the converter
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Layout.Pattern.StackTracePatternConverter.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Layout.Pattern.StackTracePatternConverter.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Layout.Pattern.StackTracePatternConverter.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.Pattern.StackTracePatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the strack frames to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Writes the <see cref="P:log4net.Core.LocationInfo.StackFrames" /> to the output writer.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.Pattern.StackTracePatternConverter.GetMethodInformation(log4net.Core.MethodItem)">
      <summary>
            Returns the Name of the method
            </summary>
      <param name="method">
      </param>
      <remarks>This method was created, so this class could be used as a base class for StackTraceDetailPatternConverter</remarks>
      <returns>string</returns>
    </member>
    <member name="T:log4net.Layout.Pattern.StackTraceDetailPatternConverter">
      <summary>
            Write the caller stack frames to the output
            </summary>
      <remarks>
        <para>
            Writes the <see cref="P:log4net.Core.LocationInfo.StackFrames" /> to the output writer, using format:
            type3.MethodCall3(type param,...) &gt; type2.MethodCall2(type param,...) &gt; type1.MethodCall1(type param,...)
            </para>
      </remarks>
      <author>Adam Davies</author>
    </member>
    <member name="F:log4net.Layout.Pattern.StackTraceDetailPatternConverter.declaringType">
      <summary>
            The fully qualified type of the StackTraceDetailPatternConverter class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.ThreadPatternConverter">
      <summary>
            Converter to include event thread name
            </summary>
      <remarks>
        <para>
            Writes the <see cref="P:log4net.Core.LoggingEvent.ThreadName" /> to the output.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.ThreadPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the ThreadName to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Writes the <see cref="P:log4net.Core.LoggingEvent.ThreadName" /> to the <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.TypeNamePatternConverter">
      <summary>
            Pattern converter for the class name
            </summary>
      <remarks>
        <para>
            Outputs the <see cref="P:log4net.Core.LocationInfo.ClassName" /> of the event.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.TypeNamePatternConverter.GetFullyQualifiedName(log4net.Core.LoggingEvent)">
      <summary>
            Gets the fully qualified name of the class
            </summary>
      <param name="loggingEvent">the event being logged</param>
      <returns>The fully qualified type name for the caller location</returns>
      <remarks>
        <para>
            Returns the <see cref="P:log4net.Core.LocationInfo.ClassName" /> of the <paramref name="loggingEvent" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.UserNamePatternConverter">
      <summary>
            Converter to include event user name
            </summary>
      <author>Douglas de la Torre</author>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.UserNamePatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Convert the pattern to the rendered message
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
    </member>
    <member name="T:log4net.Layout.Pattern.UtcDatePatternConverter">
      <summary>
            Write the TimeStamp to the output
            </summary>
      <remarks>
        <para>
            Date pattern converter, uses a <see cref="T:log4net.DateFormatter.IDateFormatter" /> to format 
            the date of a <see cref="T:log4net.Core.LoggingEvent" />.
            </para>
        <para>
            Uses a <see cref="T:log4net.DateFormatter.IDateFormatter" /> to format the <see cref="P:log4net.Core.LoggingEvent.TimeStamp" /> 
            in Universal time.
            </para>
        <para>
            See the <see cref="T:log4net.Layout.Pattern.DatePatternConverter" /> for details on the date pattern syntax.
            </para>
      </remarks>
      <seealso cref="T:log4net.Layout.Pattern.DatePatternConverter" />
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Layout.Pattern.UtcDatePatternConverter.declaringType">
      <summary>
            The fully qualified type of the UtcDatePatternConverter class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Layout.Pattern.UtcDatePatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the TimeStamp to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Pass the <see cref="P:log4net.Core.LoggingEvent.TimeStamp" /> to the <see cref="T:log4net.DateFormatter.IDateFormatter" />
            for it to render it to the writer.
            </para>
        <para>
            The <see cref="P:log4net.Core.LoggingEvent.TimeStamp" /> passed is in the local time zone, this is converted
            to Universal time before it is rendered.
            </para>
      </remarks>
      <seealso cref="T:log4net.Layout.Pattern.DatePatternConverter" />
    </member>
    <member name="T:log4net.Layout.ILayout">
      <summary>
            Interface implemented by layout objects
            </summary>
      <remarks>
        <para>
            An <see cref="T:log4net.Layout.ILayout" /> object is used to format a <see cref="T:log4net.Core.LoggingEvent" />
            as text. The <see cref="M:Format(TextWriter,LoggingEvent)" /> method is called by an
            appender to transform the <see cref="T:log4net.Core.LoggingEvent" /> into a string.
            </para>
        <para>
            The layout can also supply <see cref="P:log4net.Layout.ILayout.Header" /> and <see cref="P:log4net.Layout.ILayout.Footer" />
            text that is appender before any events and after all the events respectively.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Layout.ILayout.Format(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Implement this method to create your own layout format.
            </summary>
      <param name="writer">The TextWriter to write the formatted event to</param>
      <param name="loggingEvent">The event to format</param>
      <remarks>
        <para>
            This method is called by an appender to format
            the <paramref name="loggingEvent" /> as text and output to a writer.
            </para>
        <para>
            If the caller does not have a <see cref="T:System.IO.TextWriter" /> and prefers the
            event to be formatted as a <see cref="T:System.String" /> then the following
            code can be used to format the event into a <see cref="T:System.IO.StringWriter" />.
            </para>
        <code lang="C#">
            StringWriter writer = new StringWriter();
            Layout.Format(writer, loggingEvent);
            string formattedEvent = writer.ToString();
            </code>
      </remarks>
    </member>
    <member name="P:log4net.Layout.ILayout.ContentType">
      <summary>
            The content type output by this layout. 
            </summary>
      <value>The content type</value>
      <remarks>
        <para>
            The content type output by this layout.
            </para>
        <para>
            This is a MIME type e.g. <c>"text/plain"</c>.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.ILayout.Header">
      <summary>
            The header for the layout format.
            </summary>
      <value>the layout header</value>
      <remarks>
        <para>
            The Header text will be appended before any logging events
            are formatted and appended.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.ILayout.Footer">
      <summary>
            The footer for the layout format.
            </summary>
      <value>the layout footer</value>
      <remarks>
        <para>
            The Footer text will be appended after all the logging events
            have been formatted and appended.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.ILayout.IgnoresException">
      <summary>
            Flag indicating if this layout handle exceptions
            </summary>
      <value>
        <c>false</c> if this layout handles exceptions</value>
      <remarks>
        <para>
            If this layout handles the exception object contained within
            <see cref="T:log4net.Core.LoggingEvent" />, then the layout should return
            <c>false</c>. Otherwise, if the layout ignores the exception
            object, then the layout should return <c>true</c>.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.LayoutSkeleton">
      <summary>
            Extend this abstract class to create your own log layout format.
            </summary>
      <remarks>
        <para>
            This is the base implementation of the <see cref="T:log4net.Layout.ILayout" />
            interface. Most layout objects should extend this class.
            </para>
      </remarks>
      <remarks>
        <note type="inheritinfo">
          <para>
            Subclasses must implement the <see cref="M:Format(TextWriter,LoggingEvent)" />
            method.
            </para>
          <para>
            Subclasses should set the <see cref="P:log4net.Layout.LayoutSkeleton.IgnoresException" /> in their default
            constructor.
            </para>
        </note>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Layout.LayoutSkeleton.m_header">
      <summary>
            The header text
            </summary>
      <remarks>
        <para>
            See <see cref="P:log4net.Layout.LayoutSkeleton.Header" /> for more information.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Layout.LayoutSkeleton.m_footer">
      <summary>
            The footer text
            </summary>
      <remarks>
        <para>
            See <see cref="P:log4net.Layout.LayoutSkeleton.Footer" /> for more information.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Layout.LayoutSkeleton.m_ignoresException">
      <summary>
            Flag indicating if this layout handles exceptions
            </summary>
      <remarks>
        <para>
          <c>false</c> if this layout handles exceptions
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.LayoutSkeleton.#ctor">
      <summary>
            Empty default constructor
            </summary>
      <remarks>
        <para>
            Empty default constructor
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.LayoutSkeleton.ActivateOptions">
      <summary>
            Activate component options
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Layout.LayoutSkeleton.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Layout.LayoutSkeleton.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Layout.LayoutSkeleton.ActivateOptions" /> must be called again.
            </para>
        <para>
            This method must be implemented by the subclass.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.LayoutSkeleton.Format(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Implement this method to create your own layout format.
            </summary>
      <param name="writer">The TextWriter to write the formatted event to</param>
      <param name="loggingEvent">The event to format</param>
      <remarks>
        <para>
            This method is called by an appender to format
            the <paramref name="loggingEvent" /> as text.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.LayoutSkeleton.Format(log4net.Core.LoggingEvent)">
      <summary>
            Convenience method for easily formatting the logging event into a string variable.
            </summary>
      <param name="loggingEvent">
      </param>
      <remarks>
            Creates a new StringWriter instance to store the formatted logging event.
            </remarks>
    </member>
    <member name="P:log4net.Layout.LayoutSkeleton.ContentType">
      <summary>
            The content type output by this layout. 
            </summary>
      <value>The content type is <c>"text/plain"</c></value>
      <remarks>
        <para>
            The content type output by this layout.
            </para>
        <para>
            This base class uses the value <c>"text/plain"</c>.
            To change this value a subclass must override this
            property.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.LayoutSkeleton.Header">
      <summary>
            The header for the layout format.
            </summary>
      <value>the layout header</value>
      <remarks>
        <para>
            The Header text will be appended before any logging events
            are formatted and appended.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.LayoutSkeleton.Footer">
      <summary>
            The footer for the layout format.
            </summary>
      <value>the layout footer</value>
      <remarks>
        <para>
            The Footer text will be appended after all the logging events
            have been formatted and appended.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.LayoutSkeleton.IgnoresException">
      <summary>
            Flag indicating if this layout handles exceptions
            </summary>
      <value>
        <c>false</c> if this layout handles exceptions</value>
      <remarks>
        <para>
            If this layout handles the exception object contained within
            <see cref="T:log4net.Core.LoggingEvent" />, then the layout should return
            <c>false</c>. Otherwise, if the layout ignores the exception
            object, then the layout should return <c>true</c>.
            </para>
        <para>
            Set this value to override a this default setting. The default
            value is <c>true</c>, this layout does not handle the exception.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.PatternLayout">
      <summary>
            A flexible layout configurable with pattern string.
            </summary>
      <remarks>
        <para>
            The goal of this class is to <see cref="M:PatternLayout.Format(TextWriter,LoggingEvent)" /> a 
            <see cref="T:log4net.Core.LoggingEvent" /> as a string. The results
            depend on the <i>conversion pattern</i>.
            </para>
        <para>
            The conversion pattern is closely related to the conversion
            pattern of the printf function in C. A conversion pattern is
            composed of literal text and format control expressions called
            <i>conversion specifiers</i>.
            </para>
        <para>
          <i>You are free to insert any literal text within the conversion
            pattern.</i>
        </para>
        <para>
            Each conversion specifier starts with a percent sign (%) and is
            followed by optional <i>format modifiers</i> and a <i>conversion
            pattern name</i>. The conversion pattern name specifies the type of
            data, e.g. logger, level, date, thread name. The format
            modifiers control such things as field width, padding, left and
            right justification. The following is a simple example.
            </para>
        <para>
            Let the conversion pattern be <b>"%-5level [%thread]: %message%newline"</b> and assume
            that the log4net environment was set to use a PatternLayout. Then the
            statements
            </para>
        <code lang="C#">
            ILog log = LogManager.GetLogger(typeof(TestApp));
            log.Debug("Message 1");
            log.Warn("Message 2");   
            </code>
        <para>would yield the output</para>
        <code>
            DEBUG [main]: Message 1
            WARN  [main]: Message 2  
            </code>
        <para>
            Note that there is no explicit separator between text and
            conversion specifiers. The pattern parser knows when it has reached
            the end of a conversion specifier when it reads a conversion
            character. In the example above the conversion specifier
            <b>%-5level</b> means the level of the logging event should be left
            justified to a width of five characters.
            </para>
        <para>
            The recognized conversion pattern names are:
            </para>
        <list type="table">
          <listheader>
            <term>Conversion Pattern Name</term>
            <description>Effect</description>
          </listheader>
          <item>
            <term>a</term>
            <description>Equivalent to <b>appdomain</b></description>
          </item>
          <item>
            <term>appdomain</term>
            <description>
            			Used to output the friendly name of the AppDomain where the 
            			logging event was generated. 
                    </description>
          </item>
          <item>
            <term>aspnet-cache</term>
            <description>
              <para>
                        Used to output all cache items in the case of <b>%aspnet-cache</b> or just one named item if used as <b>%aspnet-cache{key}</b></para>
              <para>
                        This pattern is not available for Compact Framework or Client Profile assemblies.
                        </para>
            </description>
          </item>
          <item>
            <term>aspnet-context</term>
            <description>
              <para>
                        Used to output all context items in the case of <b>%aspnet-context</b> or just one named item if used as <b>%aspnet-context{key}</b></para>
              <para>
                        This pattern is not available for Compact Framework or Client Profile assemblies.
                        </para>
            </description>
          </item>
          <item>
            <term>aspnet-request</term>
            <description>
              <para>
                        Used to output all request parameters in the case of <b>%aspnet-request</b> or just one named param if used as <b>%aspnet-request{key}</b></para>
              <para>
                        This pattern is not available for Compact Framework or Client Profile assemblies.
                        </para>
            </description>
          </item>
          <item>
            <term>aspnet-session</term>
            <description>
              <para>
                        Used to output all session items in the case of <b>%aspnet-session</b> or just one named item if used as <b>%aspnet-session{key}</b></para>
              <para>
                        This pattern is not available for Compact Framework or Client Profile assemblies.
                        </para>
            </description>
          </item>
          <item>
            <term>c</term>
            <description>Equivalent to <b>logger</b></description>
          </item>
          <item>
            <term>C</term>
            <description>Equivalent to <b>type</b></description>
          </item>
          <item>
            <term>class</term>
            <description>Equivalent to <b>type</b></description>
          </item>
          <item>
            <term>d</term>
            <description>Equivalent to <b>date</b></description>
          </item>
          <item>
            <term>date</term>
            <description>
              <para>
            			Used to output the date of the logging event in the local time zone. 
            			To output the date in universal time use the <c>%utcdate</c> pattern.
            			The date conversion 
            			specifier may be followed by a <i>date format specifier</i> enclosed 
            			between braces. For example, <b>%date{HH:mm:ss,fff}</b> or
            			<b>%date{dd MMM yyyy HH:mm:ss,fff}</b>.  If no date format specifier is 
            			given then ISO8601 format is
            			assumed (<see cref="T:log4net.DateFormatter.Iso8601DateFormatter" />).
            			</para>
              <para>
            			The date format specifier admits the same syntax as the
            			time pattern string of the <see cref="M:DateTime.ToString(string)" />.
            			</para>
              <para>
            			For better results it is recommended to use the log4net date
            			formatters. These can be specified using one of the strings
            			"ABSOLUTE", "DATE" and "ISO8601" for specifying 
            			<see cref="T:log4net.DateFormatter.AbsoluteTimeDateFormatter" />, 
            			<see cref="T:log4net.DateFormatter.DateTimeDateFormatter" /> and respectively 
            			<see cref="T:log4net.DateFormatter.Iso8601DateFormatter" />. For example, 
            			<b>%date{ISO8601}</b> or <b>%date{ABSOLUTE}</b>.
            			</para>
              <para>
            			These dedicated date formatters perform significantly
            			better than <see cref="M:DateTime.ToString(string)" />.
            			</para>
            </description>
          </item>
          <item>
            <term>exception</term>
            <description>
              <para>
            			Used to output the exception passed in with the log message.
            			</para>
              <para>
            			If an exception object is stored in the logging event
            			it will be rendered into the pattern output with a
            			trailing newline.
            			If there is no exception then nothing will be output
            			and no trailing newline will be appended.
            			It is typical to put a newline before the exception
            			and to have the exception as the last data in the pattern.
            			</para>
            </description>
          </item>
          <item>
            <term>F</term>
            <description>Equivalent to <b>file</b></description>
          </item>
          <item>
            <term>file</term>
            <description>
              <para>
            			Used to output the file name where the logging request was
            			issued.
            			</para>
              <para>
                <b>WARNING</b> Generating caller location information is
            			extremely slow. Its use should be avoided unless execution speed
            			is not an issue.
            			</para>
              <para>
            			See the note below on the availability of caller location information.
            			</para>
            </description>
          </item>
          <item>
            <term>identity</term>
            <description>
              <para>
            			Used to output the user name for the currently active user
            			(Principal.Identity.Name).
            			</para>
              <para>
                <b>WARNING</b> Generating caller information is
            			extremely slow. Its use should be avoided unless execution speed
            			is not an issue.
            			</para>
            </description>
          </item>
          <item>
            <term>l</term>
            <description>Equivalent to <b>location</b></description>
          </item>
          <item>
            <term>L</term>
            <description>Equivalent to <b>line</b></description>
          </item>
          <item>
            <term>location</term>
            <description>
              <para>
            			Used to output location information of the caller which generated
            			the logging event.
            			</para>
              <para>
            			The location information depends on the CLI implementation but
            			usually consists of the fully qualified name of the calling
            			method followed by the callers source the file name and line
            			number between parentheses.
            			</para>
              <para>
            			The location information can be very useful. However, its
            			generation is <b>extremely</b> slow. Its use should be avoided
            			unless execution speed is not an issue.
            			</para>
              <para>
            			See the note below on the availability of caller location information.
            			</para>
            </description>
          </item>
          <item>
            <term>level</term>
            <description>
              <para>
            			Used to output the level of the logging event.
            			</para>
            </description>
          </item>
          <item>
            <term>line</term>
            <description>
              <para>
            			Used to output the line number from where the logging request
            			was issued.
            			</para>
              <para>
                <b>WARNING</b> Generating caller location information is
            			extremely slow. Its use should be avoided unless execution speed
            			is not an issue.
            			</para>
              <para>
            			See the note below on the availability of caller location information.
            			</para>
            </description>
          </item>
          <item>
            <term>logger</term>
            <description>
              <para>
            			Used to output the logger of the logging event. The
            			logger conversion specifier can be optionally followed by
            			<i>precision specifier</i>, that is a decimal constant in
            			brackets.
                        </para>
              <para>
            			If a precision specifier is given, then only the corresponding
            			number of right most components of the logger name will be
            			printed. By default the logger name is printed in full.
            			</para>
              <para>
            			For example, for the logger name "a.b.c" the pattern
            			<b>%logger{2}</b> will output "b.c".
            			</para>
            </description>
          </item>
          <item>
            <term>m</term>
            <description>Equivalent to <b>message</b></description>
          </item>
          <item>
            <term>M</term>
            <description>Equivalent to <b>method</b></description>
          </item>
          <item>
            <term>message</term>
            <description>
              <para>
            			Used to output the application supplied message associated with 
            			the logging event.
            			</para>
            </description>
          </item>
          <item>
            <term>mdc</term>
            <description>
              <para>
            			The MDC (old name for the ThreadContext.Properties) is now part of the
            			combined event properties. This pattern is supported for compatibility
            			but is equivalent to <b>property</b>.
            			</para>
            </description>
          </item>
          <item>
            <term>method</term>
            <description>
              <para>
            			Used to output the method name where the logging request was
            			issued.
            			</para>
              <para>
                <b>WARNING</b> Generating caller location information is
            			extremely slow. Its use should be avoided unless execution speed
            			is not an issue.
            			</para>
              <para>
            			See the note below on the availability of caller location information.
            			</para>
            </description>
          </item>
          <item>
            <term>n</term>
            <description>Equivalent to <b>newline</b></description>
          </item>
          <item>
            <term>newline</term>
            <description>
              <para>
            			Outputs the platform dependent line separator character or
            			characters.
            			</para>
              <para>
            			This conversion pattern offers the same performance as using 
            			non-portable line separator strings such as	"\n", or "\r\n". 
            			Thus, it is the preferred way of specifying a line separator.
            			</para>
            </description>
          </item>
          <item>
            <term>ndc</term>
            <description>
              <para>
            			Used to output the NDC (nested diagnostic context) associated
            			with the thread that generated the logging event.
            			</para>
            </description>
          </item>
          <item>
            <term>p</term>
            <description>Equivalent to <b>level</b></description>
          </item>
          <item>
            <term>P</term>
            <description>Equivalent to <b>property</b></description>
          </item>
          <item>
            <term>properties</term>
            <description>Equivalent to <b>property</b></description>
          </item>
          <item>
            <term>property</term>
            <description>
              <para>
            			Used to output the an event specific property. The key to 
            			lookup must be specified within braces and directly following the
            			pattern specifier, e.g. <b>%property{user}</b> would include the value
            			from the property that is keyed by the string 'user'. Each property value
            			that is to be included in the log must be specified separately.
            			Properties are added to events by loggers or appenders. By default 
            			the <c>log4net:HostName</c> property is set to the name of machine on 
            			which the event was originally logged.
            			</para>
              <para>
            			If no key is specified, e.g. <b>%property</b> then all the keys and their
            			values are printed in a comma separated list.
            			</para>
              <para>
            			The properties of an event are combined from a number of different
            			contexts. These are listed below in the order in which they are searched.
            			</para>
              <list type="definition">
                <item>
                  <term>the event properties</term>
                  <description>
            					The event has <see cref="P:log4net.Core.LoggingEvent.Properties" /> that can be set. These 
            					properties are specific to this event only.
            					</description>
                </item>
                <item>
                  <term>the thread properties</term>
                  <description>
            					The <see cref="P:log4net.ThreadContext.Properties" /> that are set on the current
            					thread. These properties are shared by all events logged on this thread.
            					</description>
                </item>
                <item>
                  <term>the global properties</term>
                  <description>
            					The <see cref="P:log4net.GlobalContext.Properties" /> that are set globally. These 
            					properties are shared by all the threads in the AppDomain.
            					</description>
                </item>
              </list>
            </description>
          </item>
          <item>
            <term>r</term>
            <description>Equivalent to <b>timestamp</b></description>
          </item>
          <item>
            <term>stacktrace</term>
            <description>
              <para>
            			Used to output the stack trace of the logging event
            			The stack trace level specifier may be enclosed 
            			between braces. For example, <b>%stacktrace{level}</b>.  
            			If no stack trace level specifier is given then 1 is assumed 
            			</para>
              <para>
            			Output uses the format:
            			type3.MethodCall3 &gt; type2.MethodCall2 &gt; type1.MethodCall1
            			</para>
              <para>
                        This pattern is not available for Compact Framework assemblies.
                        </para>
            </description>
          </item>
          <item>
            <term>stacktracedetail</term>
            <description>
              <para>
            			Used to output the stack trace of the logging event
            			The stack trace level specifier may be enclosed 
            			between braces. For example, <b>%stacktracedetail{level}</b>.  
            			If no stack trace level specifier is given then 1 is assumed 
            			</para>
              <para>
            			Output uses the format:
                        type3.MethodCall3(type param,...) &gt; type2.MethodCall2(type param,...) &gt; type1.MethodCall1(type param,...)
            			</para>
              <para>
                        This pattern is not available for Compact Framework assemblies.
                        </para>
            </description>
          </item>
          <item>
            <term>t</term>
            <description>Equivalent to <b>thread</b></description>
          </item>
          <item>
            <term>timestamp</term>
            <description>
              <para>
            			Used to output the number of milliseconds elapsed since the start
            			of the application until the creation of the logging event.
            			</para>
            </description>
          </item>
          <item>
            <term>thread</term>
            <description>
              <para>
            			Used to output the name of the thread that generated the
            			logging event. Uses the thread number if no name is available.
            			</para>
            </description>
          </item>
          <item>
            <term>type</term>
            <description>
              <para>
            			Used to output the fully qualified type name of the caller
            			issuing the logging request. This conversion specifier
            			can be optionally followed by <i>precision specifier</i>, that
            			is a decimal constant in brackets.
            			</para>
              <para>
            			If a precision specifier is given, then only the corresponding
            			number of right most components of the class name will be
            			printed. By default the class name is output in fully qualified form.
            			</para>
              <para>
            			For example, for the class name "log4net.Layout.PatternLayout", the
            			pattern <b>%type{1}</b> will output "PatternLayout".
            			</para>
              <para>
                <b>WARNING</b> Generating the caller class information is
            			slow. Thus, its use should be avoided unless execution speed is
            			not an issue.
            			</para>
              <para>
            			See the note below on the availability of caller location information.
            			</para>
            </description>
          </item>
          <item>
            <term>u</term>
            <description>Equivalent to <b>identity</b></description>
          </item>
          <item>
            <term>username</term>
            <description>
              <para>
            			Used to output the WindowsIdentity for the currently
            			active user.
            			</para>
              <para>
                <b>WARNING</b> Generating caller WindowsIdentity information is
            			extremely slow. Its use should be avoided unless execution speed
            			is not an issue.
            			</para>
            </description>
          </item>
          <item>
            <term>utcdate</term>
            <description>
              <para>
            			Used to output the date of the logging event in universal time. 
            			The date conversion 
            			specifier may be followed by a <i>date format specifier</i> enclosed 
            			between braces. For example, <b>%utcdate{HH:mm:ss,fff}</b> or
            			<b>%utcdate{dd MMM yyyy HH:mm:ss,fff}</b>.  If no date format specifier is 
            			given then ISO8601 format is
            			assumed (<see cref="T:log4net.DateFormatter.Iso8601DateFormatter" />).
            			</para>
              <para>
            			The date format specifier admits the same syntax as the
            			time pattern string of the <see cref="M:DateTime.ToString(string)" />.
            			</para>
              <para>
            			For better results it is recommended to use the log4net date
            			formatters. These can be specified using one of the strings
            			"ABSOLUTE", "DATE" and "ISO8601" for specifying 
            			<see cref="T:log4net.DateFormatter.AbsoluteTimeDateFormatter" />, 
            			<see cref="T:log4net.DateFormatter.DateTimeDateFormatter" /> and respectively 
            			<see cref="T:log4net.DateFormatter.Iso8601DateFormatter" />. For example, 
            			<b>%utcdate{ISO8601}</b> or <b>%utcdate{ABSOLUTE}</b>.
            			</para>
              <para>
            			These dedicated date formatters perform significantly
            			better than <see cref="M:DateTime.ToString(string)" />.
            			</para>
            </description>
          </item>
          <item>
            <term>w</term>
            <description>Equivalent to <b>username</b></description>
          </item>
          <item>
            <term>x</term>
            <description>Equivalent to <b>ndc</b></description>
          </item>
          <item>
            <term>X</term>
            <description>Equivalent to <b>mdc</b></description>
          </item>
          <item>
            <term>%</term>
            <description>
              <para>
            			The sequence %% outputs a single percent sign.
            			</para>
            </description>
          </item>
        </list>
        <para>
            The single letter patterns are deprecated in favor of the 
            longer more descriptive pattern names.
            </para>
        <para>
            By default the relevant information is output as is. However,
            with the aid of format modifiers it is possible to change the
            minimum field width, the maximum field width and justification.
            </para>
        <para>
            The optional format modifier is placed between the percent sign
            and the conversion pattern name.
            </para>
        <para>
            The first optional format modifier is the <i>left justification
            flag</i> which is just the minus (-) character. Then comes the
            optional <i>minimum field width</i> modifier. This is a decimal
            constant that represents the minimum number of characters to
            output. If the data item requires fewer characters, it is padded on
            either the left or the right until the minimum width is
            reached. The default is to pad on the left (right justify) but you
            can specify right padding with the left justification flag. The
            padding character is space. If the data item is larger than the
            minimum field width, the field is expanded to accommodate the
            data. The value is never truncated.
            </para>
        <para>
            This behavior can be changed using the <i>maximum field
            width</i> modifier which is designated by a period followed by a
            decimal constant. If the data item is longer than the maximum
            field, then the extra characters are removed from the
            <i>beginning</i> of the data item and not from the end. For
            example, it the maximum field width is eight and the data item is
            ten characters long, then the first two characters of the data item
            are dropped. This behavior deviates from the printf function in C
            where truncation is done from the end.
            </para>
        <para>
            Below are various format modifier examples for the logger
            conversion specifier.
            </para>
        <div class="tablediv">
          <table class="dtTABLE" cellspacing="0">
            <tr>
              <th>Format modifier</th>
              <th>left justify</th>
              <th>minimum width</th>
              <th>maximum width</th>
              <th>comment</th>
            </tr>
            <tr>
              <td align="center">%20logger</td>
              <td align="center">false</td>
              <td align="center">20</td>
              <td align="center">none</td>
              <td>
                <para>
            				Left pad with spaces if the logger name is less than 20
            				characters long.
            				</para>
              </td>
            </tr>
            <tr>
              <td align="center">%-20logger</td>
              <td align="center">true</td>
              <td align="center">20</td>
              <td align="center">none</td>
              <td>
                <para>
            				Right pad with spaces if the logger 
            				name is less than 20 characters long.
            				</para>
              </td>
            </tr>
            <tr>
              <td align="center">%.30logger</td>
              <td align="center">NA</td>
              <td align="center">none</td>
              <td align="center">30</td>
              <td>
                <para>
            				Truncate from the beginning if the logger 
            				name is longer than 30 characters.
            				</para>
              </td>
            </tr>
            <tr>
              <td align="center">
                <nobr>%20.30logger</nobr>
              </td>
              <td align="center">false</td>
              <td align="center">20</td>
              <td align="center">30</td>
              <td>
                <para>
            				Left pad with spaces if the logger name is shorter than 20
            				characters. However, if logger name is longer than 30 characters,
            				then truncate from the beginning.
            				</para>
              </td>
            </tr>
            <tr>
              <td align="center">%-20.30logger</td>
              <td align="center">true</td>
              <td align="center">20</td>
              <td align="center">30</td>
              <td>
                <para>
            				Right pad with spaces if the logger name is shorter than 20
            				characters. However, if logger name is longer than 30 characters,
            				then truncate from the beginning.
            				</para>
              </td>
            </tr>
          </table>
        </div>
        <para>
          <b>Note about caller location information.</b>
          <br />
            The following patterns <c>%type %file %line %method %location %class %C %F %L %l %M</c> 
            all generate caller location information.
            Location information uses the <c>System.Diagnostics.StackTrace</c> class to generate
            a call stack. The caller's information is then extracted from this stack.
            </para>
        <note type="caution">
          <para>
            The <c>System.Diagnostics.StackTrace</c> class is not supported on the 
            .NET Compact Framework 1.0 therefore caller location information is not
            available on that framework.
            </para>
        </note>
        <note type="caution">
          <para>
            The <c>System.Diagnostics.StackTrace</c> class has this to say about Release builds:
            </para>
          <para>
            "StackTrace information will be most informative with Debug build configurations. 
            By default, Debug builds include debug symbols, while Release builds do not. The 
            debug symbols contain most of the file, method name, line number, and column 
            information used in constructing StackFrame and StackTrace objects. StackTrace 
            might not report as many method calls as expected, due to code transformations 
            that occur during optimization."
            </para>
          <para>
            This means that in a Release build the caller information may be incomplete or may 
            not exist at all! Therefore caller location information cannot be relied upon in a Release build.
            </para>
        </note>
        <para>
            Additional pattern converters may be registered with a specific <see cref="T:log4net.Layout.PatternLayout" />
            instance using the <see cref="M:AddConverter(string, Type)" /> method.
            </para>
      </remarks>
      <example>
            This is a more detailed pattern.
            <code><b>%timestamp [%thread] %level %logger %ndc - %message%newline</b></code></example>
      <example>
            A similar pattern except that the relative time is
            right padded if less than 6 digits, thread name is right padded if
            less than 15 characters and truncated if longer and the logger
            name is left padded if shorter than 30 characters and truncated if
            longer.
            <code><b>%-6timestamp [%15.15thread] %-5level %30.30logger %ndc - %message%newline</b></code></example>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Douglas de la Torre</author>
      <author>Daniel Cazzulino</author>
    </member>
    <member name="F:log4net.Layout.PatternLayout.DefaultConversionPattern">
      <summary>
            Default pattern string for log output. 
            </summary>
      <remarks>
        <para>
            Default pattern string for log output. 
            Currently set to the string <b>"%message%newline"</b> 
            which just prints the application supplied message. 
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Layout.PatternLayout.DetailConversionPattern">
      <summary>
            A detailed conversion pattern
            </summary>
      <remarks>
        <para>
            A conversion pattern which includes Time, Thread, Logger, and Nested Context.
            Current value is <b>%timestamp [%thread] %level %logger %ndc - %message%newline</b>.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Layout.PatternLayout.s_globalRulesRegistry">
      <summary>
            Internal map of converter identifiers to converter types.
            </summary>
      <remarks>
        <para>
            This static map is overridden by the m_converterRegistry instance map
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Layout.PatternLayout.m_pattern">
      <summary>
            the pattern
            </summary>
    </member>
    <member name="F:log4net.Layout.PatternLayout.m_head">
      <summary>
            the head of the pattern converter chain
            </summary>
    </member>
    <member name="F:log4net.Layout.PatternLayout.m_instanceRulesRegistry">
      <summary>
            patterns defined on this PatternLayout only
            </summary>
    </member>
    <member name="M:log4net.Layout.PatternLayout.#ctor">
      <summary>
            Constructs a PatternLayout using the DefaultConversionPattern
            </summary>
      <remarks>
        <para>
            The default pattern just produces the application supplied message.
            </para>
        <para>
            Note to Inheritors: This constructor calls the virtual method
            <see cref="M:log4net.Layout.PatternLayout.CreatePatternParser(System.String)" />. If you override this method be
            aware that it will be called before your is called constructor.
            </para>
        <para>
            As per the <see cref="T:log4net.Core.IOptionHandler" /> contract the <see cref="M:log4net.Layout.PatternLayout.ActivateOptions" />
            method must be called after the properties on this object have been
            configured.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.PatternLayout.#ctor(System.String)">
      <summary>
            Constructs a PatternLayout using the supplied conversion pattern
            </summary>
      <param name="pattern">the pattern to use</param>
      <remarks>
        <para>
            Note to Inheritors: This constructor calls the virtual method
            <see cref="M:log4net.Layout.PatternLayout.CreatePatternParser(System.String)" />. If you override this method be
            aware that it will be called before your is called constructor.
            </para>
        <para>
            When using this constructor the <see cref="M:log4net.Layout.PatternLayout.ActivateOptions" /> method 
            need not be called. This may not be the case when using a subclass.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.PatternLayout.CreatePatternParser(System.String)">
      <summary>
            Create the pattern parser instance
            </summary>
      <param name="pattern">the pattern to parse</param>
      <returns>The <see cref="T:log4net.Util.PatternParser" /> that will format the event</returns>
      <remarks>
        <para>
            Creates the <see cref="T:log4net.Util.PatternParser" /> used to parse the conversion string. Sets the
            global and instance rules on the <see cref="T:log4net.Util.PatternParser" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.PatternLayout.ActivateOptions">
      <summary>
            Initialize layout options
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Layout.PatternLayout.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Layout.PatternLayout.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Layout.PatternLayout.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.PatternLayout.Format(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Produces a formatted string as specified by the conversion pattern.
            </summary>
      <param name="loggingEvent">the event being logged</param>
      <param name="writer">The TextWriter to write the formatted event to</param>
      <remarks>
        <para>
            Parse the <see cref="T:log4net.Core.LoggingEvent" /> using the patter format
            specified in the <see cref="P:log4net.Layout.PatternLayout.ConversionPattern" /> property.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.PatternLayout.AddConverter(log4net.Util.ConverterInfo)">
      <summary>
            Add a converter to this PatternLayout
            </summary>
      <param name="converterInfo">the converter info</param>
      <remarks>
        <para>
            This version of the method is used by the configurator.
            Programmatic users should use the alternative <see cref="M:AddConverter(string,Type)" /> method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.PatternLayout.AddConverter(System.String,System.Type)">
      <summary>
            Add a converter to this PatternLayout
            </summary>
      <param name="name">the name of the conversion pattern for this converter</param>
      <param name="type">the type of the converter</param>
      <remarks>
        <para>
            Add a named pattern converter to this instance. This
            converter will be used in the formatting of the event.
            This method must be called before <see cref="M:log4net.Layout.PatternLayout.ActivateOptions" />.
            </para>
        <para>
            The <paramref name="type" /> specified must extend the 
            <see cref="T:log4net.Util.PatternConverter" /> type.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.PatternLayout.ConversionPattern">
      <summary>
            The pattern formatting string
            </summary>
      <remarks>
        <para>
            The <b>ConversionPattern</b> option. This is the string which
            controls formatting and consists of a mix of literal content and
            conversion specifiers.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.DynamicPatternLayout">
      <summary>
            A flexible layout configurable with pattern string that re-evaluates on each call.
            </summary>
      <remarks>
        <para>This class is built on <see cref="T:log4net.Layout.PatternLayout"></see> and provides all the
            features and capabilities of PatternLayout.  PatternLayout is a 'static' class
            in that its layout is done once at configuration time.  This class will recreate
            the layout on each reference.</para>
        <para>One important difference between PatternLayout and DynamicPatternLayout is the
            treatment of the Header and Footer parameters in the configuration.  The Header and Footer
            parameters for DynamicPatternLayout must be syntactically in the form of a PatternString,
            but should not be marked as type log4net.Util.PatternString.  Doing so causes the
            pattern to be statically converted at configuration time and causes DynamicPatternLayout
            to perform the same as PatternLayout.</para>
        <para>Please see <see cref="T:log4net.Layout.PatternLayout" /> for complete documentation.</para>
        <example>
            &lt;layout type="log4net.Layout.DynamicPatternLayout"&gt;
              &lt;param name="Header" value="%newline**** Trace Opened     Local: %date{yyyy-MM-dd HH:mm:ss.fff}     UTC: %utcdate{yyyy-MM-dd HH:mm:ss.fff} ****%newline" /&gt;
              &lt;param name="Footer" value="**** Trace Closed %date{yyyy-MM-dd HH:mm:ss.fff} ****%newline" /&gt;
            &lt;/layout&gt;
            </example>
      </remarks>
    </member>
    <member name="F:log4net.Layout.DynamicPatternLayout.m_headerPatternString">
      <summary>
            The header PatternString
            </summary>
    </member>
    <member name="F:log4net.Layout.DynamicPatternLayout.m_footerPatternString">
      <summary>
            The footer PatternString
            </summary>
    </member>
    <member name="M:log4net.Layout.DynamicPatternLayout.#ctor">
      <summary>
            Constructs a DynamicPatternLayout using the DefaultConversionPattern
            </summary>
      <remarks>
        <para>
            The default pattern just produces the application supplied message.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.DynamicPatternLayout.#ctor(System.String)">
      <summary>
            Constructs a DynamicPatternLayout using the supplied conversion pattern
            </summary>
      <param name="pattern">the pattern to use</param>
      <remarks>
      </remarks>
    </member>
    <member name="P:log4net.Layout.DynamicPatternLayout.Header">
      <summary>
            The header for the layout format.
            </summary>
      <value>the layout header</value>
      <remarks>
        <para>
            The Header text will be appended before any logging events
            are formatted and appended.
            </para>
            The pattern will be formatted on each get operation.
            </remarks>
    </member>
    <member name="P:log4net.Layout.DynamicPatternLayout.Footer">
      <summary>
            The footer for the layout format.
            </summary>
      <value>the layout footer</value>
      <remarks>
        <para>
            The Footer text will be appended after all the logging events
            have been formatted and appended.
            </para>
            The pattern will be formatted on each get operation.
            </remarks>
    </member>
    <member name="T:log4net.Layout.ExceptionLayout">
      <summary>
            A Layout that renders only the Exception text from the logging event
            </summary>
      <remarks>
        <para>
            A Layout that renders only the Exception text from the logging event.
            </para>
        <para>
            This Layout should only be used with appenders that utilize multiple
            layouts (e.g. <see cref="T:log4net.Appender.AdoNetAppender" />).
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Layout.ExceptionLayout.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Constructs a ExceptionLayout
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.ExceptionLayout.ActivateOptions">
      <summary>
            Activate component options
            </summary>
      <remarks>
        <para>
            Part of the <see cref="T:log4net.Core.IOptionHandler" /> component activation
            framework.
            </para>
        <para>
            This method does nothing as options become effective immediately.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.ExceptionLayout.Format(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Gets the exception text from the logging event
            </summary>
      <param name="writer">The TextWriter to write the formatted event to</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Write the exception string to the <see cref="T:System.IO.TextWriter" />.
            The exception string is retrieved from <see cref="M:LoggingEvent.GetExceptionString()" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.IRawLayout">
      <summary>
            Interface for raw layout objects
            </summary>
      <remarks>
        <para>
            Interface used to format a <see cref="T:log4net.Core.LoggingEvent" />
            to an object.
            </para>
        <para>
            This interface should not be confused with the
            <see cref="T:log4net.Layout.ILayout" /> interface. This interface is used in
            only certain specialized situations where a raw object is
            required rather than a formatted string. The <see cref="T:log4net.Layout.ILayout" />
            is not generally useful than this interface.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Layout.IRawLayout.Format(log4net.Core.LoggingEvent)">
      <summary>
            Implement this method to create your own layout format.
            </summary>
      <param name="loggingEvent">The event to format</param>
      <returns>returns the formatted event</returns>
      <remarks>
        <para>
            Implement this method to create your own layout format.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Layout2RawLayoutAdapter">
      <summary>
            Adapts any <see cref="T:log4net.Layout.ILayout" /> to a <see cref="T:log4net.Layout.IRawLayout" /></summary>
      <remarks>
        <para>
            Where an <see cref="T:log4net.Layout.IRawLayout" /> is required this adapter
            allows a <see cref="T:log4net.Layout.ILayout" /> to be specified.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Layout.Layout2RawLayoutAdapter.m_layout">
      <summary>
            The layout to adapt
            </summary>
    </member>
    <member name="M:log4net.Layout.Layout2RawLayoutAdapter.#ctor(log4net.Layout.ILayout)">
      <summary>
            Construct a new adapter
            </summary>
      <param name="layout">the layout to adapt</param>
      <remarks>
        <para>
            Create the adapter for the specified <paramref name="layout" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.Layout2RawLayoutAdapter.Format(log4net.Core.LoggingEvent)">
      <summary>
            Format the logging event as an object.
            </summary>
      <param name="loggingEvent">The event to format</param>
      <returns>returns the formatted event</returns>
      <remarks>
        <para>
            Format the logging event as an object.
            </para>
        <para>
            Uses the <see cref="T:log4net.Layout.ILayout" /> object supplied to 
            the constructor to perform the formatting.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.TypeConverters.IConvertFrom">
      <summary>
            Interface supported by type converters
            </summary>
      <remarks>
        <para>
            This interface supports conversion from arbitrary types
            to a single target type. See <see cref="T:log4net.Util.TypeConverters.TypeConverterAttribute" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Util.TypeConverters.IConvertFrom.CanConvertFrom(System.Type)">
      <summary>
            Can the source type be converted to the type supported by this object
            </summary>
      <param name="sourceType">the type to convert</param>
      <returns>true if the conversion is possible</returns>
      <remarks>
        <para>
            Test if the <paramref name="sourceType" /> can be converted to the
            type supported by this converter.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.IConvertFrom.ConvertFrom(System.Object)">
      <summary>
            Convert the source object to the type supported by this object
            </summary>
      <param name="source">the object to convert</param>
      <returns>the converted object</returns>
      <remarks>
        <para>
            Converts the <paramref name="source" /> to the type supported
            by this converter.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.RawLayoutConverter">
      <summary>
            Type converter for the <see cref="T:log4net.Layout.IRawLayout" /> interface
            </summary>
      <remarks>
        <para>
            Used to convert objects to the <see cref="T:log4net.Layout.IRawLayout" /> interface.
            Supports converting from the <see cref="T:log4net.Layout.ILayout" /> interface to
            the <see cref="T:log4net.Layout.IRawLayout" /> interface using the <see cref="T:log4net.Layout.Layout2RawLayoutAdapter" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Layout.RawLayoutConverter.CanConvertFrom(System.Type)">
      <summary>
            Can the sourceType be converted to an <see cref="T:log4net.Layout.IRawLayout" /></summary>
      <param name="sourceType">the source to be to be converted</param>
      <returns>
        <c>true</c> if the source type can be converted to <see cref="T:log4net.Layout.IRawLayout" /></returns>
      <remarks>
        <para>
            Test if the <paramref name="sourceType" /> can be converted to a
            <see cref="T:log4net.Layout.IRawLayout" />. Only <see cref="T:log4net.Layout.ILayout" /> is supported
            as the <paramref name="sourceType" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.RawLayoutConverter.ConvertFrom(System.Object)">
      <summary>
            Convert the value to a <see cref="T:log4net.Layout.IRawLayout" /> object
            </summary>
      <param name="source">the value to convert</param>
      <returns>the <see cref="T:log4net.Layout.IRawLayout" /> object</returns>
      <remarks>
        <para>
            Convert the <paramref name="source" /> object to a 
            <see cref="T:log4net.Layout.IRawLayout" /> object. If the <paramref name="source" /> object
            is a <see cref="T:log4net.Layout.ILayout" /> then the <see cref="T:log4net.Layout.Layout2RawLayoutAdapter" />
            is used to adapt between the two interfaces, otherwise an
            exception is thrown.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.RawPropertyLayout">
      <summary>
            Extract the value of a property from the <see cref="T:log4net.Core.LoggingEvent" /></summary>
      <remarks>
        <para>
            Extract the value of a property from the <see cref="T:log4net.Core.LoggingEvent" /></para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.RawPropertyLayout.#ctor">
      <summary>
            Constructs a RawPropertyLayout
            </summary>
    </member>
    <member name="M:log4net.Layout.RawPropertyLayout.Format(log4net.Core.LoggingEvent)">
      <summary>
            Lookup the property for <see cref="P:log4net.Layout.RawPropertyLayout.Key" /></summary>
      <param name="loggingEvent">The event to format</param>
      <returns>returns property value</returns>
      <remarks>
        <para>
            Looks up and returns the object value of the property
            named <see cref="P:log4net.Layout.RawPropertyLayout.Key" />. If there is no property defined
            with than name then <c>null</c> will be returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.RawPropertyLayout.Key">
      <summary>
            The name of the value to lookup in the LoggingEvent Properties collection.
            </summary>
      <value>
            Value to lookup in the LoggingEvent Properties collection
            </value>
      <remarks>
        <para>
            String name of the property to lookup in the <see cref="T:log4net.Core.LoggingEvent" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.RawTimeStampLayout">
      <summary>
            Extract the date from the <see cref="T:log4net.Core.LoggingEvent" /></summary>
      <remarks>
        <para>
            Extract the date from the <see cref="T:log4net.Core.LoggingEvent" /></para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Layout.RawTimeStampLayout.#ctor">
      <summary>
            Constructs a RawTimeStampLayout
            </summary>
    </member>
    <member name="M:log4net.Layout.RawTimeStampLayout.Format(log4net.Core.LoggingEvent)">
      <summary>
            Gets the <see cref="P:log4net.Core.LoggingEvent.TimeStamp" /> as a <see cref="T:System.DateTime" />.
            </summary>
      <param name="loggingEvent">The event to format</param>
      <returns>returns the time stamp</returns>
      <remarks>
        <para>
            Gets the <see cref="P:log4net.Core.LoggingEvent.TimeStamp" /> as a <see cref="T:System.DateTime" />.
            </para>
        <para>
            The time stamp is in local time. To format the time stamp
            in universal time use <see cref="T:log4net.Layout.RawUtcTimeStampLayout" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.RawUtcTimeStampLayout">
      <summary>
            Extract the date from the <see cref="T:log4net.Core.LoggingEvent" /></summary>
      <remarks>
        <para>
            Extract the date from the <see cref="T:log4net.Core.LoggingEvent" /></para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Layout.RawUtcTimeStampLayout.#ctor">
      <summary>
            Constructs a RawUtcTimeStampLayout
            </summary>
    </member>
    <member name="M:log4net.Layout.RawUtcTimeStampLayout.Format(log4net.Core.LoggingEvent)">
      <summary>
            Gets the <see cref="P:log4net.Core.LoggingEvent.TimeStamp" /> as a <see cref="T:System.DateTime" />.
            </summary>
      <param name="loggingEvent">The event to format</param>
      <returns>returns the time stamp</returns>
      <remarks>
        <para>
            Gets the <see cref="P:log4net.Core.LoggingEvent.TimeStamp" /> as a <see cref="T:System.DateTime" />.
            </para>
        <para>
            The time stamp is in universal time. To format the time stamp
            in local time use <see cref="T:log4net.Layout.RawTimeStampLayout" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.SimpleLayout">
      <summary>
            A very simple layout
            </summary>
      <remarks>
        <para>
            SimpleLayout consists of the level of the log statement,
            followed by " - " and then the log message itself. For example,
            <code>
            DEBUG - Hello world
            </code></para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Layout.SimpleLayout.#ctor">
      <summary>
            Constructs a SimpleLayout
            </summary>
    </member>
    <member name="M:log4net.Layout.SimpleLayout.ActivateOptions">
      <summary>
            Initialize layout options
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Layout.SimpleLayout.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Layout.SimpleLayout.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Layout.SimpleLayout.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.SimpleLayout.Format(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Produces a simple formatted output.
            </summary>
      <param name="loggingEvent">the event being logged</param>
      <param name="writer">The TextWriter to write the formatted event to</param>
      <remarks>
        <para>
            Formats the event as the level of the even,
            followed by " - " and then the log message itself. The
            output is terminated by a newline.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.XmlLayoutBase">
      <summary>
            Layout that formats the log events as XML elements.
            </summary>
      <remarks>
        <para>
            This is an abstract class that must be subclassed by an implementation 
            to conform to a specific schema.
            </para>
        <para>
            Deriving classes must implement the <see cref="M:log4net.Layout.XmlLayoutBase.FormatXml(System.Xml.XmlWriter,log4net.Core.LoggingEvent)" /> method.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Layout.XmlLayoutBase.m_locationInfo">
      <summary>
            Flag to indicate if location information should be included in
            the XML events.
            </summary>
    </member>
    <member name="F:log4net.Layout.XmlLayoutBase.m_invalidCharReplacement">
      <summary>
            The string to replace invalid chars with
            </summary>
    </member>
    <member name="M:log4net.Layout.XmlLayoutBase.#ctor">
      <summary>
            Protected constructor to support subclasses
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Layout.XmlLayoutBase" /> class
            with no location info.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.XmlLayoutBase.#ctor(System.Boolean)">
      <summary>
            Protected constructor to support subclasses
            </summary>
      <remarks>
        <para>
            The <paramref name="locationInfo" /> parameter determines whether 
            location information will be output by the layout. If 
            <paramref name="locationInfo" /> is set to <c>true</c>, then the 
            file name and line number of the statement at the origin of the log 
            statement will be output. 
            </para>
        <para>
            If you are embedding this layout within an SMTPAppender
            then make sure to set the <b>LocationInfo</b> option of that 
            appender as well.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.XmlLayoutBase.ActivateOptions">
      <summary>
            Initialize layout options
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Layout.XmlLayoutBase.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Layout.XmlLayoutBase.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Layout.XmlLayoutBase.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.XmlLayoutBase.Format(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Produces a formatted string.
            </summary>
      <param name="loggingEvent">The event being logged.</param>
      <param name="writer">The TextWriter to write the formatted event to</param>
      <remarks>
        <para>
            Format the <see cref="T:log4net.Core.LoggingEvent" /> and write it to the <see cref="T:System.IO.TextWriter" />.
            </para>
        <para>
            This method creates an <see cref="T:System.Xml.XmlTextWriter" /> that writes to the
            <paramref name="writer" />. The <see cref="T:System.Xml.XmlTextWriter" /> is passed 
            to the <see cref="M:log4net.Layout.XmlLayoutBase.FormatXml(System.Xml.XmlWriter,log4net.Core.LoggingEvent)" /> method. Subclasses should override the
            <see cref="M:log4net.Layout.XmlLayoutBase.FormatXml(System.Xml.XmlWriter,log4net.Core.LoggingEvent)" /> method rather than this method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.XmlLayoutBase.FormatXml(System.Xml.XmlWriter,log4net.Core.LoggingEvent)">
      <summary>
            Does the actual writing of the XML.
            </summary>
      <param name="writer">The writer to use to output the event to.</param>
      <param name="loggingEvent">The event to write.</param>
      <remarks>
        <para>
            Subclasses should override this method to format
            the <see cref="T:log4net.Core.LoggingEvent" /> as XML.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.XmlLayoutBase.LocationInfo">
      <summary>
            Gets a value indicating whether to include location information in 
            the XML events.
            </summary>
      <value>
        <c>true</c> if location information should be included in the XML 
            events; otherwise, <c>false</c>.
            </value>
      <remarks>
        <para>
            If <see cref="P:log4net.Layout.XmlLayoutBase.LocationInfo" /> is set to <c>true</c>, then the file 
            name and line number of the statement at the origin of the log 
            statement will be output. 
            </para>
        <para>
            If you are embedding this layout within an <c>SMTPAppender</c>
            then make sure to set the <b>LocationInfo</b> option of that 
            appender as well.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.XmlLayoutBase.InvalidCharReplacement">
      <summary>
            The string to replace characters that can not be expressed in XML with.
            <remarks><para>
            Not all characters may be expressed in XML. This property contains the
            string to replace those that can not with. This defaults to a ?. Set it
            to the empty string to simply remove offending characters. For more
            details on the allowed character ranges see http://www.w3.org/TR/REC-xml/#charsets
            Character replacement will occur in  the log message, the property names 
            and the property values.
            </para></remarks></summary>
    </member>
    <member name="P:log4net.Layout.XmlLayoutBase.ContentType">
      <summary>
            Gets the content type output by this layout. 
            </summary>
      <value>
            As this is the XML layout, the value is always <c>"text/xml"</c>.
            </value>
      <remarks>
        <para>
            As this is the XML layout, the value is always <c>"text/xml"</c>.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.XmlLayout">
      <summary>
             Layout that formats the log events as XML elements.
             </summary>
      <remarks>
        <para>
             The output of the <see cref="T:log4net.Layout.XmlLayout" /> consists of a series of 
             log4net:event elements. It does not output a complete well-formed XML 
             file. The output is designed to be included as an <em>external entity</em>
             in a separate file to form a correct XML file.
             </para>
        <para>
             For example, if <c>abc</c> is the name of the file where
             the <see cref="T:log4net.Layout.XmlLayout" /> output goes, then a well-formed XML file would 
             be:
             </para>
        <code lang="XML">
             &lt;?xml version="1.0" ?&gt;
             
             &lt;!DOCTYPE log4net:events SYSTEM "log4net-events.dtd" [&lt;!ENTITY data SYSTEM "abc"&gt;]&gt;
            
             &lt;log4net:events version="1.2" xmlns:log4net="http://logging.apache.org/log4net/schemas/log4net-events-1.2&gt;
                 &amp;data;
             &lt;/log4net:events&gt;
             </code>
        <para>
             This approach enforces the independence of the <see cref="T:log4net.Layout.XmlLayout" /> 
             and the appender where it is embedded.
             </para>
        <para>
             The <c>version</c> attribute helps components to correctly
             interpret output generated by <see cref="T:log4net.Layout.XmlLayout" />. The value of 
             this attribute should be "1.2" for release 1.2 and later.
             </para>
        <para>
             Alternatively the <c>Header</c> and <c>Footer</c> properties can be
             configured to output the correct XML header, open tag and close tag.
             When setting the <c>Header</c> and <c>Footer</c> properties it is essential
             that the underlying data store not be appendable otherwise the data
             will become invalid XML.
             </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Layout.XmlLayout.m_prefix">
      <summary>
            The prefix to use for all generated element names
            </summary>
    </member>
    <member name="M:log4net.Layout.XmlLayout.#ctor">
      <summary>
            Constructs an XmlLayout
            </summary>
    </member>
    <member name="M:log4net.Layout.XmlLayout.#ctor(System.Boolean)">
      <summary>
            Constructs an XmlLayout.
            </summary>
      <remarks>
        <para>
            The <b>LocationInfo</b> option takes a boolean value. By
            default, it is set to false which means there will be no location
            information output by this layout. If the the option is set to
            true, then the file name and line number of the statement
            at the origin of the log statement will be output. 
            </para>
        <para>
            If you are embedding this layout within an SmtpAppender
            then make sure to set the <b>LocationInfo</b> option of that 
            appender as well.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.XmlLayout.ActivateOptions">
      <summary>
            Initialize layout options
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Layout.XmlLayout.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Layout.XmlLayout.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Layout.XmlLayout.ActivateOptions" /> must be called again.
            </para>
        <para>
            Builds a cache of the element names
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.XmlLayout.FormatXml(System.Xml.XmlWriter,log4net.Core.LoggingEvent)">
      <summary>
            Does the actual writing of the XML.
            </summary>
      <param name="writer">The writer to use to output the event to.</param>
      <param name="loggingEvent">The event to write.</param>
      <remarks>
        <para>
            Override the base class <see cref="M:log4net.Layout.XmlLayoutBase.FormatXml(System.Xml.XmlWriter,log4net.Core.LoggingEvent)" /> method
            to write the <see cref="T:log4net.Core.LoggingEvent" /> to the <see cref="T:System.Xml.XmlWriter" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.XmlLayout.Prefix">
      <summary>
            The prefix to use for all element names
            </summary>
      <remarks>
        <para>
            The default prefix is <b>log4net</b>. Set this property
            to change the prefix. If the prefix is set to an empty string
            then no prefix will be written.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.XmlLayout.Base64EncodeMessage">
      <summary>
            Set whether or not to base64 encode the message.
            </summary>
      <remarks>
        <para>
            By default the log message will be written as text to the xml
            output. This can cause problems when the message contains binary
            data. By setting this to true the contents of the message will be
            base64 encoded. If this is set then invalid character replacement
            (see <see cref="P:log4net.Layout.XmlLayoutBase.InvalidCharReplacement" />) will not be performed
            on the log message.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.XmlLayout.Base64EncodeProperties">
      <summary>
            Set whether or not to base64 encode the property values.
            </summary>
      <remarks>
        <para>
            By default the properties will be written as text to the xml
            output. This can cause problems when one or more properties contain
            binary data. By setting this to true the values of the properties
            will be base64 encoded. If this is set then invalid character replacement
            (see <see cref="P:log4net.Layout.XmlLayoutBase.InvalidCharReplacement" />) will not be performed
            on the property values.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.XmlLayoutSchemaLog4j">
      <summary>
            Layout that formats the log events as XML elements compatible with the log4j schema
            </summary>
      <remarks>
        <para>
            Formats the log events according to the http://logging.apache.org/log4j schema.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Layout.XmlLayoutSchemaLog4j.s_date1970">
      <summary>
            The 1st of January 1970 in UTC
            </summary>
    </member>
    <member name="M:log4net.Layout.XmlLayoutSchemaLog4j.#ctor">
      <summary>
            Constructs an XMLLayoutSchemaLog4j
            </summary>
    </member>
    <member name="M:log4net.Layout.XmlLayoutSchemaLog4j.#ctor(System.Boolean)">
      <summary>
            Constructs an XMLLayoutSchemaLog4j.
            </summary>
      <remarks>
        <para>
            The <b>LocationInfo</b> option takes a boolean value. By
            default, it is set to false which means there will be no location
            information output by this layout. If the the option is set to
            true, then the file name and line number of the statement
            at the origin of the log statement will be output. 
            </para>
        <para>
            If you are embedding this layout within an SMTPAppender
            then make sure to set the <b>LocationInfo</b> option of that 
            appender as well.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.XmlLayoutSchemaLog4j.FormatXml(System.Xml.XmlWriter,log4net.Core.LoggingEvent)">
      <summary>
            Actually do the writing of the xml
            </summary>
      <param name="writer">the writer to use</param>
      <param name="loggingEvent">the event to write</param>
      <remarks>
        <para>
            Generate XML that is compatible with the log4j schema.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.XmlLayoutSchemaLog4j.Version">
      <summary>
            The version of the log4j schema to use.
            </summary>
      <remarks>
        <para>
            Only version 1.2 of the log4j schema is supported.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.ObjectRenderer.IObjectRenderer">
      <summary>
            Implement this interface in order to render objects as strings
            </summary>
      <remarks>
        <para>
            Certain types require special case conversion to
            string form. This conversion is done by an object renderer.
            Object renderers implement the <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />
            interface.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.ObjectRenderer.IObjectRenderer.RenderObject(log4net.ObjectRenderer.RendererMap,System.Object,System.IO.TextWriter)">
      <summary>
            Render the object <paramref name="obj" /> to a string
            </summary>
      <param name="rendererMap">The map used to lookup renderers</param>
      <param name="obj">The object to render</param>
      <param name="writer">The writer to render to</param>
      <remarks>
        <para>
            Render the object <paramref name="obj" /> to a 
            string.
            </para>
        <para>
            The <paramref name="rendererMap" /> parameter is
            provided to lookup and render other objects. This is
            very useful where <paramref name="obj" /> contains
            nested objects of unknown type. The <see cref="M:RendererMap.FindAndRender(object, TextWriter)" />
            method can be used to render these objects.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.ObjectRenderer.DefaultRenderer">
      <summary>
            The default object Renderer.
            </summary>
      <remarks>
        <para>
            The default renderer supports rendering objects and collections to strings.
            </para>
        <para>
            See the <see cref="M:log4net.ObjectRenderer.DefaultRenderer.RenderObject(log4net.ObjectRenderer.RendererMap,System.Object,System.IO.TextWriter)" /> method for details of the output.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.ObjectRenderer.DefaultRenderer.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Default constructor
            </para>
      </remarks>
    </member>
    <member name="M:log4net.ObjectRenderer.DefaultRenderer.RenderObject(log4net.ObjectRenderer.RendererMap,System.Object,System.IO.TextWriter)">
      <summary>
            Render the object <paramref name="obj" /> to a string
            </summary>
      <param name="rendererMap">The map used to lookup renderers</param>
      <param name="obj">The object to render</param>
      <param name="writer">The writer to render to</param>
      <remarks>
        <para>
            Render the object <paramref name="obj" /> to a string.
            </para>
        <para>
            The <paramref name="rendererMap" /> parameter is
            provided to lookup and render other objects. This is
            very useful where <paramref name="obj" /> contains
            nested objects of unknown type. The <see cref="M:RendererMap.FindAndRender(object)" />
            method can be used to render these objects.
            </para>
        <para>
            The default renderer supports rendering objects to strings as follows:
            </para>
        <list type="table">
          <listheader>
            <term>Value</term>
            <description>Rendered String</description>
          </listheader>
          <item>
            <term>
              <c>null</c>
            </term>
            <description>
              <para>"(null)"</para>
            </description>
          </item>
          <item>
            <term>
              <see cref="T:System.Array" />
            </term>
            <description>
              <para>
            		For a one dimensional array this is the
            		array type name, an open brace, followed by a comma
            		separated list of the elements (using the appropriate
            		renderer), followed by a close brace. 
            		</para>
              <para>
            		For example: <c>int[] {1, 2, 3}</c>.
            		</para>
              <para>
            		If the array is not one dimensional the 
            		<c>Array.ToString()</c> is returned.
            		</para>
            </description>
          </item>
          <item>
            <term>
              <see cref="T:System.Collections.IEnumerable" />, <see cref="T:System.Collections.ICollection" /> &amp; <see cref="T:System.Collections.IEnumerator" /></term>
            <description>
              <para>
            		Rendered as an open brace, followed by a comma
            		separated list of the elements (using the appropriate
            		renderer), followed by a close brace.
            		</para>
              <para>
            		For example: <c>{a, b, c}</c>.
            		</para>
              <para>
            		All collection classes that implement <see cref="T:System.Collections.ICollection" /> its subclasses, 
            		or generic equivalents all implement the <see cref="T:System.Collections.IEnumerable" /> interface.
            		</para>
            </description>
          </item>
          <item>
            <term>
              <see cref="T:System.Collections.DictionaryEntry" />
            </term>
            <description>
              <para>
            		Rendered as the key, an equals sign ('='), and the value (using the appropriate
            		renderer). 
            		</para>
              <para>
            		For example: <c>key=value</c>.
            		</para>
            </description>
          </item>
          <item>
            <term>other</term>
            <description>
              <para>
                <c>Object.ToString()</c>
              </para>
            </description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:log4net.ObjectRenderer.DefaultRenderer.RenderArray(log4net.ObjectRenderer.RendererMap,System.Array,System.IO.TextWriter)">
      <summary>
            Render the array argument into a string
            </summary>
      <param name="rendererMap">The map used to lookup renderers</param>
      <param name="array">the array to render</param>
      <param name="writer">The writer to render to</param>
      <remarks>
        <para>
            For a one dimensional array this is the
            array type name, an open brace, followed by a comma
            separated list of the elements (using the appropriate
            renderer), followed by a close brace. For example:
            <c>int[] {1, 2, 3}</c>.
            </para>
        <para>
            If the array is not one dimensional the 
            <c>Array.ToString()</c> is returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.ObjectRenderer.DefaultRenderer.RenderEnumerator(log4net.ObjectRenderer.RendererMap,System.Collections.IEnumerator,System.IO.TextWriter)">
      <summary>
            Render the enumerator argument into a string
            </summary>
      <param name="rendererMap">The map used to lookup renderers</param>
      <param name="enumerator">the enumerator to render</param>
      <param name="writer">The writer to render to</param>
      <remarks>
        <para>
            Rendered as an open brace, followed by a comma
            separated list of the elements (using the appropriate
            renderer), followed by a close brace. For example:
            <c>{a, b, c}</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.ObjectRenderer.DefaultRenderer.RenderDictionaryEntry(log4net.ObjectRenderer.RendererMap,System.Collections.DictionaryEntry,System.IO.TextWriter)">
      <summary>
            Render the DictionaryEntry argument into a string
            </summary>
      <param name="rendererMap">The map used to lookup renderers</param>
      <param name="entry">the DictionaryEntry to render</param>
      <param name="writer">The writer to render to</param>
      <remarks>
        <para>
            Render the key, an equals sign ('='), and the value (using the appropriate
            renderer). For example: <c>key=value</c>.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.ObjectRenderer.RendererMap">
      <summary>
            Map class objects to an <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />.
            </summary>
      <remarks>
        <para>
            Maintains a mapping between types that require special
            rendering and the <see cref="T:log4net.ObjectRenderer.IObjectRenderer" /> that
            is used to render them.
            </para>
        <para>
            The <see cref="M:FindAndRender(object)" /> method is used to render an
            <c>object</c> using the appropriate renderers defined in this map.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.ObjectRenderer.RendererMap.#ctor">
      <summary>
            Default Constructor
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.ObjectRenderer.RendererMap.FindAndRender(System.Object)">
      <summary>
            Render <paramref name="obj" /> using the appropriate renderer.
            </summary>
      <param name="obj">the object to render to a string</param>
      <returns>the object rendered as a string</returns>
      <remarks>
        <para>
            This is a convenience method used to render an object to a string.
            The alternative method <see cref="M:FindAndRender(object,TextWriter)" />
            should be used when streaming output to a <see cref="T:System.IO.TextWriter" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.ObjectRenderer.RendererMap.FindAndRender(System.Object,System.IO.TextWriter)">
      <summary>
            Render <paramref name="obj" /> using the appropriate renderer.
            </summary>
      <param name="obj">the object to render to a string</param>
      <param name="writer">The writer to render to</param>
      <remarks>
        <para>
            Find the appropriate renderer for the type of the
            <paramref name="obj" /> parameter. This is accomplished by calling the
            <see cref="M:Get(Type)" /> method. Once a renderer is found, it is
            applied on the object <paramref name="obj" /> and the result is returned
            as a <see cref="T:System.String" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.ObjectRenderer.RendererMap.Get(System.Object)">
      <summary>
            Gets the renderer for the specified object type
            </summary>
      <param name="obj">the object to lookup the renderer for</param>
      <returns>the renderer for <paramref name="obj" /></returns>
      <remarks>
        <param>
            Gets the renderer for the specified object type.
            </param>
        <param>
            Syntactic sugar method that calls <see cref="M:Get(Type)" /> 
            with the type of the object parameter.
            </param>
      </remarks>
    </member>
    <member name="M:log4net.ObjectRenderer.RendererMap.Get(System.Type)">
      <summary>
            Gets the renderer for the specified type
            </summary>
      <param name="type">the type to lookup the renderer for</param>
      <returns>the renderer for the specified type</returns>
      <remarks>
        <para>
            Returns the renderer for the specified type.
            If no specific renderer has been defined the
            <see cref="P:log4net.ObjectRenderer.RendererMap.DefaultRenderer" /> will be returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.ObjectRenderer.RendererMap.SearchTypeAndInterfaces(System.Type)">
      <summary>
            Internal function to recursively search interfaces
            </summary>
      <param name="type">the type to lookup the renderer for</param>
      <returns>the renderer for the specified type</returns>
    </member>
    <member name="M:log4net.ObjectRenderer.RendererMap.Clear">
      <summary>
            Clear the map of renderers
            </summary>
      <remarks>
        <para>
            Clear the custom renderers defined by using
            <see cref="M:log4net.ObjectRenderer.RendererMap.Put(System.Type,log4net.ObjectRenderer.IObjectRenderer)" />. The <see cref="P:log4net.ObjectRenderer.RendererMap.DefaultRenderer" />
            cannot be removed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.ObjectRenderer.RendererMap.Put(System.Type,log4net.ObjectRenderer.IObjectRenderer)">
      <summary>
            Register an <see cref="T:log4net.ObjectRenderer.IObjectRenderer" /> for <paramref name="typeToRender" />. 
            </summary>
      <param name="typeToRender">the type that will be rendered by <paramref name="renderer" /></param>
      <param name="renderer">the renderer for <paramref name="typeToRender" /></param>
      <remarks>
        <para>
            Register an object renderer for a specific source type.
            This renderer will be returned from a call to <see cref="M:Get(Type)" />
            specifying the same <paramref name="typeToRender" /> as an argument.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.ObjectRenderer.RendererMap.DefaultRenderer">
      <summary>
            Get the default renderer instance
            </summary>
      <value>the default renderer</value>
      <remarks>
        <para>
            Get the default renderer
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Plugin.IPlugin">
      <summary>
            Interface implemented by logger repository plugins.
            </summary>
      <remarks>
        <para>
            Plugins define additional behavior that can be associated
            with a <see cref="T:log4net.Repository.ILoggerRepository" />.
            The <see cref="T:log4net.Plugin.PluginMap" /> held by the <see cref="P:log4net.Repository.ILoggerRepository.PluginMap" />
            property is used to store the plugins for a repository.
            </para>
        <para>
            The <c>log4net.Config.PluginAttribute</c> can be used to
            attach plugins to repositories created using configuration
            attributes.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Plugin.IPlugin.Attach(log4net.Repository.ILoggerRepository)">
      <summary>
            Attaches the plugin to the specified <see cref="T:log4net.Repository.ILoggerRepository" />.
            </summary>
      <param name="repository">The <see cref="T:log4net.Repository.ILoggerRepository" /> that this plugin should be attached to.</param>
      <remarks>
        <para>
            A plugin may only be attached to a single repository.
            </para>
        <para>
            This method is called when the plugin is attached to the repository.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Plugin.IPlugin.Shutdown">
      <summary>
            Is called when the plugin is to shutdown.
            </summary>
      <remarks>
        <para>
            This method is called to notify the plugin that 
            it should stop operating and should detach from
            the repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Plugin.IPlugin.Name">
      <summary>
            Gets the name of the plugin.
            </summary>
      <value>
            The name of the plugin.
            </value>
      <remarks>
        <para>
            Plugins are stored in the <see cref="T:log4net.Plugin.PluginMap" />
            keyed by name. Each plugin instance attached to a
            repository must be a unique name.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Plugin.PluginCollection">
      <summary>
            A strongly-typed collection of <see cref="T:log4net.Plugin.IPlugin" /> objects.
            </summary>
      <author>Nicko Cadell</author>
    </member>
    <member name="T:log4net.Plugin.PluginCollection.IPluginCollectionEnumerator">
      <summary>
            Supports type-safe iteration over a <see cref="T:log4net.Plugin.PluginCollection" />.
            </summary>
      <exclude />
    </member>
    <member name="M:log4net.Plugin.PluginCollection.IPluginCollectionEnumerator.MoveNext">
      <summary>
            Advances the enumerator to the next element in the collection.
            </summary>
      <returns>
        <c>true</c> if the enumerator was successfully advanced to the next element; 
            <c>false</c> if the enumerator has passed the end of the collection.
            </returns>
      <exception cref="T:System.InvalidOperationException">
            The collection was modified after the enumerator was created.
            </exception>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.IPluginCollectionEnumerator.Reset">
      <summary>
            Sets the enumerator to its initial position, before the first element in the collection.
            </summary>
    </member>
    <member name="P:log4net.Plugin.PluginCollection.IPluginCollectionEnumerator.Current">
      <summary>
            Gets the current element in the collection.
            </summary>
    </member>
    <member name="T:log4net.Plugin.PluginCollection.Tag">
      <summary>
            Type visible only to our subclasses
            Used to access protected constructor
            </summary>
      <exclude />
    </member>
    <member name="T:log4net.Plugin.PluginCollection.Enumerator">
      <summary>
            Supports simple iteration over a <see cref="T:log4net.Plugin.PluginCollection" />.
            </summary>
      <exclude />
    </member>
    <member name="M:log4net.Plugin.PluginCollection.Enumerator.#ctor(log4net.Plugin.PluginCollection)">
      <summary>
            Initializes a new instance of the <c>Enumerator</c> class.
            </summary>
      <param name="tc">
      </param>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.Enumerator.MoveNext">
      <summary>
            Advances the enumerator to the next element in the collection.
            </summary>
      <returns>
        <c>true</c> if the enumerator was successfully advanced to the next element; 
            <c>false</c> if the enumerator has passed the end of the collection.
            </returns>
      <exception cref="T:System.InvalidOperationException">
            The collection was modified after the enumerator was created.
            </exception>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.Enumerator.Reset">
      <summary>
            Sets the enumerator to its initial position, before the first element in the collection.
            </summary>
    </member>
    <member name="P:log4net.Plugin.PluginCollection.Enumerator.Current">
      <summary>
            Gets the current element in the collection.
            </summary>
      <value>
            The current element in the collection.
            </value>
    </member>
    <member name="T:log4net.Plugin.PluginCollection.ReadOnlyPluginCollection">
      <exclude />
    </member>
    <member name="M:log4net.Plugin.PluginCollection.ReadOnly(log4net.Plugin.PluginCollection)">
      <summary>
            Creates a read-only wrapper for a <c>PluginCollection</c> instance.
            </summary>
      <param name="list">list to create a readonly wrapper arround</param>
      <returns>
            A <c>PluginCollection</c> wrapper that is read-only.
            </returns>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.#ctor">
      <summary>
            Initializes a new instance of the <c>PluginCollection</c> class
            that is empty and has the default initial capacity.
            </summary>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <c>PluginCollection</c> class
            that has the specified initial capacity.
            </summary>
      <param name="capacity">
            The number of elements that the new <c>PluginCollection</c> is initially capable of storing.
            </param>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.#ctor(log4net.Plugin.PluginCollection)">
      <summary>
            Initializes a new instance of the <c>PluginCollection</c> class
            that contains elements copied from the specified <c>PluginCollection</c>.
            </summary>
      <param name="c">The <c>PluginCollection</c> whose elements are copied to the new collection.</param>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.#ctor(log4net.Plugin.IPlugin[])">
      <summary>
            Initializes a new instance of the <c>PluginCollection</c> class
            that contains elements copied from the specified <see cref="T:log4net.Plugin.IPlugin" /> array.
            </summary>
      <param name="a">The <see cref="T:log4net.Plugin.IPlugin" /> array whose elements are copied to the new list.</param>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.#ctor(System.Collections.ICollection)">
      <summary>
            Initializes a new instance of the <c>PluginCollection</c> class
            that contains elements copied from the specified <see cref="T:log4net.Plugin.IPlugin" /> collection.
            </summary>
      <param name="col">The <see cref="T:log4net.Plugin.IPlugin" /> collection whose elements are copied to the new list.</param>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.#ctor(log4net.Plugin.PluginCollection.Tag)">
      <summary>
            Allow subclasses to avoid our default constructors
            </summary>
      <param name="tag">
      </param>
      <exclude />
    </member>
    <member name="M:log4net.Plugin.PluginCollection.CopyTo(log4net.Plugin.IPlugin[])">
      <summary>
            Copies the entire <c>PluginCollection</c> to a one-dimensional
            <see cref="T:log4net.Plugin.IPlugin" /> array.
            </summary>
      <param name="array">The one-dimensional <see cref="T:log4net.Plugin.IPlugin" /> array to copy to.</param>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.CopyTo(log4net.Plugin.IPlugin[],System.Int32)">
      <summary>
            Copies the entire <c>PluginCollection</c> to a one-dimensional
            <see cref="T:log4net.Plugin.IPlugin" /> array, starting at the specified index of the target array.
            </summary>
      <param name="array">The one-dimensional <see cref="T:log4net.Plugin.IPlugin" /> array to copy to.</param>
      <param name="start">The zero-based index in <paramref name="array" /> at which copying begins.</param>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.Add(log4net.Plugin.IPlugin)">
      <summary>
            Adds a <see cref="T:log4net.Plugin.IPlugin" /> to the end of the <c>PluginCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Plugin.IPlugin" /> to be added to the end of the <c>PluginCollection</c>.</param>
      <returns>The index at which the value has been added.</returns>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.Clear">
      <summary>
            Removes all elements from the <c>PluginCollection</c>.
            </summary>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.Clone">
      <summary>
            Creates a shallow copy of the <see cref="T:log4net.Plugin.PluginCollection" />.
            </summary>
      <returns>A new <see cref="T:log4net.Plugin.PluginCollection" /> with a shallow copy of the collection data.</returns>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.Contains(log4net.Plugin.IPlugin)">
      <summary>
            Determines whether a given <see cref="T:log4net.Plugin.IPlugin" /> is in the <c>PluginCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Plugin.IPlugin" /> to check for.</param>
      <returns>
        <c>true</c> if <paramref name="item" /> is found in the <c>PluginCollection</c>; otherwise, <c>false</c>.</returns>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.IndexOf(log4net.Plugin.IPlugin)">
      <summary>
            Returns the zero-based index of the first occurrence of a <see cref="T:log4net.Plugin.IPlugin" />
            in the <c>PluginCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Plugin.IPlugin" /> to locate in the <c>PluginCollection</c>.</param>
      <returns>
            The zero-based index of the first occurrence of <paramref name="item" /> 
            in the entire <c>PluginCollection</c>, if found; otherwise, -1.
            </returns>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.Insert(System.Int32,log4net.Plugin.IPlugin)">
      <summary>
            Inserts an element into the <c>PluginCollection</c> at the specified index.
            </summary>
      <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
      <param name="item">The <see cref="T:log4net.Plugin.IPlugin" /> to insert.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Plugin.PluginCollection.Count" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.Remove(log4net.Plugin.IPlugin)">
      <summary>
            Removes the first occurrence of a specific <see cref="T:log4net.Plugin.IPlugin" /> from the <c>PluginCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Plugin.IPlugin" /> to remove from the <c>PluginCollection</c>.</param>
      <exception cref="T:System.ArgumentException">
            The specified <see cref="T:log4net.Plugin.IPlugin" /> was not found in the <c>PluginCollection</c>.
            </exception>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.RemoveAt(System.Int32)">
      <summary>
            Removes the element at the specified index of the <c>PluginCollection</c>.
            </summary>
      <param name="index">The zero-based index of the element to remove.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero.</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Plugin.PluginCollection.Count" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.GetEnumerator">
      <summary>
            Returns an enumerator that can iterate through the <c>PluginCollection</c>.
            </summary>
      <returns>An <see cref="T:log4net.Plugin.PluginCollection.Enumerator" /> for the entire <c>PluginCollection</c>.</returns>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.AddRange(log4net.Plugin.PluginCollection)">
      <summary>
            Adds the elements of another <c>PluginCollection</c> to the current <c>PluginCollection</c>.
            </summary>
      <param name="x">The <c>PluginCollection</c> whose elements should be added to the end of the current <c>PluginCollection</c>.</param>
      <returns>The new <see cref="P:log4net.Plugin.PluginCollection.Count" /> of the <c>PluginCollection</c>.</returns>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.AddRange(log4net.Plugin.IPlugin[])">
      <summary>
            Adds the elements of a <see cref="T:log4net.Plugin.IPlugin" /> array to the current <c>PluginCollection</c>.
            </summary>
      <param name="x">The <see cref="T:log4net.Plugin.IPlugin" /> array whose elements should be added to the end of the <c>PluginCollection</c>.</param>
      <returns>The new <see cref="P:log4net.Plugin.PluginCollection.Count" /> of the <c>PluginCollection</c>.</returns>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.AddRange(System.Collections.ICollection)">
      <summary>
            Adds the elements of a <see cref="T:log4net.Plugin.IPlugin" /> collection to the current <c>PluginCollection</c>.
            </summary>
      <param name="col">The <see cref="T:log4net.Plugin.IPlugin" /> collection whose elements should be added to the end of the <c>PluginCollection</c>.</param>
      <returns>The new <see cref="P:log4net.Plugin.PluginCollection.Count" /> of the <c>PluginCollection</c>.</returns>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.TrimToSize">
      <summary>
            Sets the capacity to the actual number of elements.
            </summary>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.ValidateIndex(System.Int32)">
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="i" /> is less than zero.</para>
        <para>-or-</para>
        <para>
          <paramref name="i" /> is equal to or greater than <see cref="P:log4net.Plugin.PluginCollection.Count" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.ValidateIndex(System.Int32,System.Boolean)">
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="i" /> is less than zero.</para>
        <para>-or-</para>
        <para>
          <paramref name="i" /> is equal to or greater than <see cref="P:log4net.Plugin.PluginCollection.Count" />.</para>
      </exception>
    </member>
    <member name="P:log4net.Plugin.PluginCollection.Count">
      <summary>
            Gets the number of elements actually contained in the <c>PluginCollection</c>.
            </summary>
    </member>
    <member name="P:log4net.Plugin.PluginCollection.IsSynchronized">
      <summary>
            Gets a value indicating whether access to the collection is synchronized (thread-safe).
            </summary>
      <returns>true if access to the ICollection is synchronized (thread-safe); otherwise, false.</returns>
    </member>
    <member name="P:log4net.Plugin.PluginCollection.SyncRoot">
      <summary>
            Gets an object that can be used to synchronize access to the collection.
            </summary>
      <value>
            An object that can be used to synchronize access to the collection.
            </value>
    </member>
    <member name="P:log4net.Plugin.PluginCollection.Item(System.Int32)">
      <summary>
            Gets or sets the <see cref="T:log4net.Plugin.IPlugin" /> at the specified index.
            </summary>
      <value>
            The <see cref="T:log4net.Plugin.IPlugin" /> at the specified index.
            </value>
      <param name="index">The zero-based index of the element to get or set.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero.</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Plugin.PluginCollection.Count" />.</para>
      </exception>
    </member>
    <member name="P:log4net.Plugin.PluginCollection.IsFixedSize">
      <summary>
            Gets a value indicating whether the collection has a fixed size.
            </summary>
      <value>
        <c>true</c> if the collection has a fixed size; otherwise, <c>false</c>. The default is <c>false</c>.</value>
    </member>
    <member name="P:log4net.Plugin.PluginCollection.IsReadOnly">
      <summary>
            Gets a value indicating whether the IList is read-only.
            </summary>
      <value>
        <c>true</c> if the collection is read-only; otherwise, <c>false</c>. The default is <c>false</c>.</value>
    </member>
    <member name="P:log4net.Plugin.PluginCollection.Capacity">
      <summary>
            Gets or sets the number of elements the <c>PluginCollection</c> can contain.
            </summary>
      <value>
            The number of elements the <c>PluginCollection</c> can contain.
            </value>
    </member>
    <member name="T:log4net.Plugin.PluginMap">
      <summary>
            Map of repository plugins.
            </summary>
      <remarks>
        <para>
            This class is a name keyed map of the plugins that are
            attached to a repository.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Plugin.PluginMap.#ctor(log4net.Repository.ILoggerRepository)">
      <summary>
            Constructor
            </summary>
      <param name="repository">The repository that the plugins should be attached to.</param>
      <remarks>
        <para>
            Initialize a new instance of the <see cref="T:log4net.Plugin.PluginMap" /> class with a 
            repository that the plugins should be attached to.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Plugin.PluginMap.Add(log4net.Plugin.IPlugin)">
      <summary>
            Adds a <see cref="T:log4net.Plugin.IPlugin" /> to the map.
            </summary>
      <param name="plugin">The <see cref="T:log4net.Plugin.IPlugin" /> to add to the map.</param>
      <remarks>
        <para>
            The <see cref="T:log4net.Plugin.IPlugin" /> will be attached to the repository when added.
            </para>
        <para>
            If there already exists a plugin with the same name 
            attached to the repository then the old plugin will
            be <see cref="M:log4net.Plugin.IPlugin.Shutdown" /> and replaced with
            the new plugin.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Plugin.PluginMap.Remove(log4net.Plugin.IPlugin)">
      <summary>
            Removes a <see cref="T:log4net.Plugin.IPlugin" /> from the map.
            </summary>
      <param name="plugin">The <see cref="T:log4net.Plugin.IPlugin" /> to remove from the map.</param>
      <remarks>
        <para>
            Remove a specific plugin from this map.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Plugin.PluginMap.Item(System.String)">
      <summary>
            Gets a <see cref="T:log4net.Plugin.IPlugin" /> by name.
            </summary>
      <param name="name">The name of the <see cref="T:log4net.Plugin.IPlugin" /> to lookup.</param>
      <returns>
            The <see cref="T:log4net.Plugin.IPlugin" /> from the map with the name specified, or 
            <c>null</c> if no plugin is found.
            </returns>
      <remarks>
        <para>
            Lookup a plugin by name. If the plugin is not found <c>null</c>
            will be returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Plugin.PluginMap.AllPlugins">
      <summary>
            Gets all possible plugins as a list of <see cref="T:log4net.Plugin.IPlugin" /> objects.
            </summary>
      <value>All possible plugins as a list of <see cref="T:log4net.Plugin.IPlugin" /> objects.</value>
      <remarks>
        <para>
            Get a collection of all the plugins defined in this map.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Plugin.PluginSkeleton">
      <summary>
            Base implementation of <see cref="T:log4net.Plugin.IPlugin" /></summary>
      <remarks>
        <para>
            Default abstract implementation of the <see cref="T:log4net.Plugin.IPlugin" />
            interface. This base class can be used by implementors
            of the <see cref="T:log4net.Plugin.IPlugin" /> interface.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Plugin.PluginSkeleton.m_name">
      <summary>
            The name of this plugin.
            </summary>
    </member>
    <member name="F:log4net.Plugin.PluginSkeleton.m_repository">
      <summary>
            The repository this plugin is attached to.
            </summary>
    </member>
    <member name="M:log4net.Plugin.PluginSkeleton.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="name">the name of the plugin</param>
      <remarks>
            Initializes a new Plugin with the specified name.
            </remarks>
    </member>
    <member name="M:log4net.Plugin.PluginSkeleton.Attach(log4net.Repository.ILoggerRepository)">
      <summary>
            Attaches this plugin to a <see cref="T:log4net.Repository.ILoggerRepository" />.
            </summary>
      <param name="repository">The <see cref="T:log4net.Repository.ILoggerRepository" /> that this plugin should be attached to.</param>
      <remarks>
        <para>
            A plugin may only be attached to a single repository.
            </para>
        <para>
            This method is called when the plugin is attached to the repository.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Plugin.PluginSkeleton.Shutdown">
      <summary>
            Is called when the plugin is to shutdown.
            </summary>
      <remarks>
        <para>
            This method is called to notify the plugin that 
            it should stop operating and should detach from
            the repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Plugin.PluginSkeleton.Name">
      <summary>
            Gets or sets the name of the plugin.
            </summary>
      <value>
            The name of the plugin.
            </value>
      <remarks>
        <para>
            Plugins are stored in the <see cref="T:log4net.Plugin.PluginMap" />
            keyed by name. Each plugin instance attached to a
            repository must be a unique name.
            </para>
        <para>
            The name of the plugin must not change one the 
            plugin has been attached to a repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Plugin.PluginSkeleton.LoggerRepository">
      <summary>
            The repository for this plugin
            </summary>
      <value>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> that this plugin is attached to.
            </value>
      <remarks>
        <para>
            Gets or sets the <see cref="T:log4net.Repository.ILoggerRepository" /> that this plugin is 
            attached to.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Plugin.RemoteLoggingServerPlugin">
      <summary>
            Plugin that listens for events from the <see cref="T:log4net.Appender.RemotingAppender" /></summary>
      <remarks>
        <para>
            This plugin publishes an instance of <see cref="T:log4net.Appender.RemotingAppender.IRemoteLoggingSink" /> 
            on a specified <see cref="P:log4net.Plugin.RemoteLoggingServerPlugin.SinkUri" />. This listens for logging events delivered from
            a remote <see cref="T:log4net.Appender.RemotingAppender" />.
            </para>
        <para>
            When an event is received it is relogged within the attached repository
            as if it had been raised locally.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="T:log4net.Plugin.RemoteLoggingServerPlugin.RemoteLoggingSinkImpl">
      <summary>
            Delivers <see cref="T:log4net.Core.LoggingEvent" /> objects to a remote sink.
            </summary>
      <remarks>
        <para>
            Internal class used to listen for logging events
            and deliver them to the local repository.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Plugin.RemoteLoggingServerPlugin.RemoteLoggingSinkImpl.#ctor(log4net.Repository.ILoggerRepository)">
      <summary>
            Constructor
            </summary>
      <param name="repository">The repository to log to.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Plugin.RemoteLoggingServerPlugin.RemoteLoggingSinkImpl" /> for the
            specified <see cref="T:log4net.Repository.ILoggerRepository" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Plugin.RemoteLoggingServerPlugin.RemoteLoggingSinkImpl.LogEvents(log4net.Core.LoggingEvent[])">
      <summary>
            Logs the events to the repository.
            </summary>
      <param name="events">The events to log.</param>
      <remarks>
        <para>
            The events passed are logged to the <see cref="T:log4net.Repository.ILoggerRepository" /></para>
      </remarks>
    </member>
    <member name="M:log4net.Plugin.RemoteLoggingServerPlugin.RemoteLoggingSinkImpl.InitializeLifetimeService">
      <summary>
            Obtains a lifetime service object to control the lifetime 
            policy for this instance.
            </summary>
      <returns>
        <c>null</c> to indicate that this instance should live forever.</returns>
      <remarks>
        <para>
            Obtains a lifetime service object to control the lifetime 
            policy for this instance. This object should live forever
            therefore this implementation returns <c>null</c>.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Plugin.RemoteLoggingServerPlugin.declaringType">
      <summary>
            The fully qualified type of the RemoteLoggingServerPlugin class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Plugin.RemoteLoggingServerPlugin.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Plugin.RemoteLoggingServerPlugin" /> class.
            </para>
        <para>
            The <see cref="P:log4net.Plugin.RemoteLoggingServerPlugin.SinkUri" /> property must be set.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Plugin.RemoteLoggingServerPlugin.#ctor(System.String)">
      <summary>
            Construct with sink Uri.
            </summary>
      <param name="sinkUri">The name to publish the sink under in the remoting infrastructure. 
            See <see cref="P:log4net.Plugin.RemoteLoggingServerPlugin.SinkUri" /> for more details.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Plugin.RemoteLoggingServerPlugin" /> class
            with specified name.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Plugin.RemoteLoggingServerPlugin.Attach(log4net.Repository.ILoggerRepository)">
      <summary>
            Attaches this plugin to a <see cref="T:log4net.Repository.ILoggerRepository" />.
            </summary>
      <param name="repository">The <see cref="T:log4net.Repository.ILoggerRepository" /> that this plugin should be attached to.</param>
      <remarks>
        <para>
            A plugin may only be attached to a single repository.
            </para>
        <para>
            This method is called when the plugin is attached to the repository.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Plugin.RemoteLoggingServerPlugin.Shutdown">
      <summary>
            Is called when the plugin is to shutdown.
            </summary>
      <remarks>
        <para>
            When the plugin is shutdown the remote logging
            sink is disconnected.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Plugin.RemoteLoggingServerPlugin.SinkUri">
      <summary>
            Gets or sets the URI of this sink.
            </summary>
      <value>
            The URI of this sink.
            </value>
      <remarks>
        <para>
            This is the name under which the object is marshaled.
            <see cref="M:RemotingServices.Marshal(MarshalByRefObject,String,Type)" /></para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.Hierarchy.ILoggerFactory">
      <summary>
            Interface abstracts creation of <see cref="T:log4net.Repository.Hierarchy.Logger" /> instances
            </summary>
      <remarks>
        <para>
            This interface is used by the <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> to 
            create new <see cref="T:log4net.Repository.Hierarchy.Logger" /> objects.
            </para>
        <para>
            The <see cref="M:log4net.Repository.Hierarchy.ILoggerFactory.CreateLogger(log4net.Repository.ILoggerRepository,System.String)" /> method is called
            to create a named <see cref="T:log4net.Repository.Hierarchy.Logger" />.
            </para>
        <para>
            Implement this interface to create new subclasses of <see cref="T:log4net.Repository.Hierarchy.Logger" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Repository.Hierarchy.ILoggerFactory.CreateLogger(log4net.Repository.ILoggerRepository,System.String)">
      <summary>
            Create a new <see cref="T:log4net.Repository.Hierarchy.Logger" /> instance
            </summary>
      <param name="repository">The <see cref="T:log4net.Repository.ILoggerRepository" /> that will own the <see cref="T:log4net.Repository.Hierarchy.Logger" />.</param>
      <param name="name">The name of the <see cref="T:log4net.Repository.Hierarchy.Logger" />.</param>
      <returns>The <see cref="T:log4net.Repository.Hierarchy.Logger" /> instance for the specified name.</returns>
      <remarks>
        <para>
            Create a new <see cref="T:log4net.Repository.Hierarchy.Logger" /> instance with the 
            specified name.
            </para>
        <para>
            Called by the <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> to create
            new named <see cref="T:log4net.Repository.Hierarchy.Logger" /> instances.
            </para>
        <para>
            If the <paramref name="name" /> is <c>null</c> then the root logger
            must be returned.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.Hierarchy.DefaultLoggerFactory">
      <summary>
            Default implementation of <see cref="T:log4net.Repository.Hierarchy.ILoggerFactory" /></summary>
      <remarks>
        <para>
            This default implementation of the <see cref="T:log4net.Repository.Hierarchy.ILoggerFactory" />
            interface is used to create the default subclass
            of the <see cref="T:log4net.Repository.Hierarchy.Logger" /> object.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="T:log4net.Repository.Hierarchy.DefaultLoggerFactory.LoggerImpl">
      <summary>
            Default internal subclass of <see cref="T:log4net.Repository.Hierarchy.Logger" /></summary>
      <remarks>
        <para>
            This subclass has no additional behavior over the
            <see cref="T:log4net.Repository.Hierarchy.Logger" /> class but does allow instances
            to be created.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.DefaultLoggerFactory.LoggerImpl.#ctor(System.String)">
      <summary>
            Construct a new Logger
            </summary>
      <param name="name">the name of the logger</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Repository.Hierarchy.DefaultLoggerFactory.LoggerImpl" /> class
            with the specified name. 
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.DefaultLoggerFactory.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Repository.Hierarchy.DefaultLoggerFactory" /> class. 
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.DefaultLoggerFactory.CreateLogger(log4net.Repository.ILoggerRepository,System.String)">
      <summary>
            Create a new <see cref="T:log4net.Repository.Hierarchy.Logger" /> instance
            </summary>
      <param name="repository">The <see cref="T:log4net.Repository.ILoggerRepository" /> that will own the <see cref="T:log4net.Repository.Hierarchy.Logger" />.</param>
      <param name="name">The name of the <see cref="T:log4net.Repository.Hierarchy.Logger" />.</param>
      <returns>The <see cref="T:log4net.Repository.Hierarchy.Logger" /> instance for the specified name.</returns>
      <remarks>
        <para>
            Create a new <see cref="T:log4net.Repository.Hierarchy.Logger" /> instance with the 
            specified name.
            </para>
        <para>
            Called by the <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> to create
            new named <see cref="T:log4net.Repository.Hierarchy.Logger" /> instances.
            </para>
        <para>
            If the <paramref name="name" /> is <c>null</c> then the root logger
            must be returned.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.Hierarchy.Logger">
      <summary>
            Implementation of <see cref="T:log4net.Core.ILogger" /> used by <see cref="P:log4net.Repository.Hierarchy.Logger.Hierarchy" /></summary>
      <remarks>
        <para>
            Internal class used to provide implementation of <see cref="T:log4net.Core.ILogger" />
            interface. Applications should use <see cref="T:log4net.LogManager" /> to get
            logger instances.
            </para>
        <para>
            This is one of the central classes in the log4net implementation. One of the
            distinctive features of log4net are hierarchical loggers and their
            evaluation. The <see cref="P:log4net.Repository.Hierarchy.Logger.Hierarchy" /> organizes the <see cref="T:log4net.Repository.Hierarchy.Logger" />
            instances into a rooted tree hierarchy.
            </para>
        <para>
            The <see cref="T:log4net.Repository.Hierarchy.Logger" /> class is abstract. Only concrete subclasses of
            <see cref="T:log4net.Repository.Hierarchy.Logger" /> can be created. The <see cref="T:log4net.Repository.Hierarchy.ILoggerFactory" />
            is used to create instances of this type for the <see cref="P:log4net.Repository.Hierarchy.Logger.Hierarchy" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Aspi Havewala</author>
      <author>Douglas de la Torre</author>
    </member>
    <member name="F:log4net.Repository.Hierarchy.Logger.declaringType">
      <summary>
            The fully qualified type of the Logger class.
            </summary>
    </member>
    <member name="F:log4net.Repository.Hierarchy.Logger.m_name">
      <summary>
            The name of this logger.
            </summary>
    </member>
    <member name="F:log4net.Repository.Hierarchy.Logger.m_level">
      <summary>
            The assigned level of this logger. 
            </summary>
      <remarks>
        <para>
            The <c>level</c> variable need not be 
            assigned a value in which case it is inherited 
            form the hierarchy.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Repository.Hierarchy.Logger.m_parent">
      <summary>
            The parent of this logger.
            </summary>
      <remarks>
        <para>
            The parent of this logger. 
            All loggers have at least one ancestor which is the root logger.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Repository.Hierarchy.Logger.m_hierarchy">
      <summary>
            Loggers need to know what Hierarchy they are in.
            </summary>
      <remarks>
        <para>
            Loggers need to know what Hierarchy they are in.
            The hierarchy that this logger is a member of is stored
            here.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Repository.Hierarchy.Logger.m_appenderAttachedImpl">
      <summary>
            Helper implementation of the <see cref="T:log4net.Core.IAppenderAttachable" /> interface
            </summary>
    </member>
    <member name="F:log4net.Repository.Hierarchy.Logger.m_additive">
      <summary>
            Flag indicating if child loggers inherit their parents appenders
            </summary>
      <remarks>
        <para>
            Additivity is set to true by default, that is children inherit
            the appenders of their ancestors by default. If this variable is
            set to <c>false</c> then the appenders found in the
            ancestors of this logger are not used. However, the children
            of this logger will inherit its appenders, unless the children
            have their additivity flag set to <c>false</c> too. See
            the user manual for more details.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Repository.Hierarchy.Logger.m_appenderLock">
      <summary>
            Lock to protect AppenderAttachedImpl variable m_appenderAttachedImpl
            </summary>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.#ctor(System.String)">
      <summary>
            This constructor created a new <see cref="T:log4net.Repository.Hierarchy.Logger" /> instance and
            sets its name.
            </summary>
      <param name="name">The name of the <see cref="T:log4net.Repository.Hierarchy.Logger" />.</param>
      <remarks>
        <para>
            This constructor is protected and designed to be used by
            a subclass that is not abstract.
            </para>
        <para>
            Loggers are constructed by <see cref="T:log4net.Repository.Hierarchy.ILoggerFactory" /> 
            objects. See <see cref="T:log4net.Repository.Hierarchy.DefaultLoggerFactory" /> for the default
            logger creator.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.AddAppender(log4net.Appender.IAppender)">
      <summary>
            Add <paramref name="newAppender" /> to the list of appenders of this
            Logger instance.
            </summary>
      <param name="newAppender">An appender to add to this logger</param>
      <remarks>
        <para>
            Add <paramref name="newAppender" /> to the list of appenders of this
            Logger instance.
            </para>
        <para>
            If <paramref name="newAppender" /> is already in the list of
            appenders, then it won't be added again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.GetAppender(System.String)">
      <summary>
            Look for the appender named as <c>name</c></summary>
      <param name="name">The name of the appender to lookup</param>
      <returns>The appender with the name specified, or <c>null</c>.</returns>
      <remarks>
        <para>
            Returns the named appender, or null if the appender is not found.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.RemoveAllAppenders">
      <summary>
            Remove all previously added appenders from this Logger instance.
            </summary>
      <remarks>
        <para>
            Remove all previously added appenders from this Logger instance.
            </para>
        <para>
            This is useful when re-reading configuration information.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.RemoveAppender(log4net.Appender.IAppender)">
      <summary>
            Remove the appender passed as parameter form the list of appenders.
            </summary>
      <param name="appender">The appender to remove</param>
      <returns>The appender removed from the list</returns>
      <remarks>
        <para>
            Remove the appender passed as parameter form the list of appenders.
            The appender removed is not closed.
            If you are discarding the appender you must call
            <see cref="M:log4net.Appender.IAppender.Close" /> on the appender removed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.RemoveAppender(System.String)">
      <summary>
            Remove the appender passed as parameter form the list of appenders.
            </summary>
      <param name="name">The name of the appender to remove</param>
      <returns>The appender removed from the list</returns>
      <remarks>
        <para>
            Remove the named appender passed as parameter form the list of appenders.
            The appender removed is not closed.
            If you are discarding the appender you must call
            <see cref="M:log4net.Appender.IAppender.Close" /> on the appender removed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.Log(System.Type,log4net.Core.Level,System.Object,System.Exception)">
      <summary>
            This generic form is intended to be used by wrappers.
            </summary>
      <param name="callerStackBoundaryDeclaringType">The declaring type of the method that is
            the stack boundary into the logging system for this call.</param>
      <param name="level">The level of the message to be logged.</param>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            Generate a logging event for the specified <paramref name="level" /> using
            the <paramref name="message" /> and <paramref name="exception" />.
            </para>
        <para>
            This method must not throw any exception to the caller.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.Log(log4net.Core.LoggingEvent)">
      <summary>
            This is the most generic printing method that is intended to be used 
            by wrappers.
            </summary>
      <param name="logEvent">The event being logged.</param>
      <remarks>
        <para>
            Logs the specified logging event through this logger.
            </para>
        <para>
            This method must not throw any exception to the caller.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.IsEnabledFor(log4net.Core.Level)">
      <summary>
            Checks if this logger is enabled for a given <see cref="P:log4net.Repository.Hierarchy.Logger.Level" /> passed as parameter.
            </summary>
      <param name="level">The level to check.</param>
      <returns>
        <c>true</c> if this logger is enabled for <c>level</c>, otherwise <c>false</c>.
            </returns>
      <remarks>
        <para>
            Test if this logger is going to log events of the specified <paramref name="level" />.
            </para>
        <para>
            This method must not throw any exception to the caller.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.CallAppenders(log4net.Core.LoggingEvent)">
      <summary>
            Deliver the <see cref="T:log4net.Core.LoggingEvent" /> to the attached appenders.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Call the appenders in the hierarchy starting at
            <c>this</c>. If no appenders could be found, emit a
            warning.
            </para>
        <para>
            This method calls all the appenders inherited from the
            hierarchy circumventing any evaluation of whether to log or not
            to log the particular log request.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.CloseNestedAppenders">
      <summary>
            Closes all attached appenders implementing the <see cref="T:log4net.Core.IAppenderAttachable" /> interface.
            </summary>
      <remarks>
        <para>
            Used to ensure that the appenders are correctly shutdown.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.Log(log4net.Core.Level,System.Object,System.Exception)">
      <summary>
            This is the most generic printing method. This generic form is intended to be used by wrappers
            </summary>
      <param name="level">The level of the message to be logged.</param>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            Generate a logging event for the specified <paramref name="level" /> using
            the <paramref name="message" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.ForcedLog(System.Type,log4net.Core.Level,System.Object,System.Exception)">
      <summary>
            Creates a new logging event and logs the event without further checks.
            </summary>
      <param name="callerStackBoundaryDeclaringType">The declaring type of the method that is
            the stack boundary into the logging system for this call.</param>
      <param name="level">The level of the message to be logged.</param>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            Generates a logging event and delivers it to the attached
            appenders.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.ForcedLog(log4net.Core.LoggingEvent)">
      <summary>
            Creates a new logging event and logs the event without further checks.
            </summary>
      <param name="logEvent">The event being logged.</param>
      <remarks>
        <para>
            Delivers the logging event to the attached appenders.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Logger.Parent">
      <summary>
            Gets or sets the parent logger in the hierarchy.
            </summary>
      <value>
            The parent logger in the hierarchy.
            </value>
      <remarks>
        <para>
            Part of the Composite pattern that makes the hierarchy.
            The hierarchy is parent linked rather than child linked.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Logger.Additivity">
      <summary>
            Gets or sets a value indicating if child loggers inherit their parent's appenders.
            </summary>
      <value>
        <c>true</c> if child loggers inherit their parent's appenders.
            </value>
      <remarks>
        <para>
            Additivity is set to <c>true</c> by default, that is children inherit
            the appenders of their ancestors by default. If this variable is
            set to <c>false</c> then the appenders found in the
            ancestors of this logger are not used. However, the children
            of this logger will inherit its appenders, unless the children
            have their additivity flag set to <c>false</c> too. See
            the user manual for more details.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Logger.EffectiveLevel">
      <summary>
            Gets the effective level for this logger.
            </summary>
      <returns>The nearest level in the logger hierarchy.</returns>
      <remarks>
        <para>
            Starting from this logger, searches the logger hierarchy for a
            non-null level and returns it. Otherwise, returns the level of the
            root logger.
            </para>
        <para>The Logger class is designed so that this method executes as
            quickly as possible.</para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Logger.Hierarchy">
      <summary>
            Gets or sets the <see cref="P:log4net.Repository.Hierarchy.Logger.Hierarchy" /> where this 
            <c>Logger</c> instance is attached to.
            </summary>
      <value>The hierarchy that this logger belongs to.</value>
      <remarks>
        <para>
            This logger must be attached to a single <see cref="P:log4net.Repository.Hierarchy.Logger.Hierarchy" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Logger.Level">
      <summary>
            Gets or sets the assigned <see cref="P:log4net.Repository.Hierarchy.Logger.Level" />, if any, for this Logger.  
            </summary>
      <value>
            The <see cref="P:log4net.Repository.Hierarchy.Logger.Level" /> of this logger.
            </value>
      <remarks>
        <para>
            The assigned <see cref="P:log4net.Repository.Hierarchy.Logger.Level" /> can be <c>null</c>.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Logger.Appenders">
      <summary>
            Get the appenders contained in this logger as an 
            <see cref="T:System.Collections.ICollection" />.
            </summary>
      <returns>A collection of the appenders in this logger</returns>
      <remarks>
        <para>
            Get the appenders contained in this logger as an 
            <see cref="T:System.Collections.ICollection" />. If no appenders 
            can be found, then a <see cref="T:log4net.Util.EmptyCollection" /> is returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Logger.Name">
      <summary>
            Gets the logger name.
            </summary>
      <value>
            The name of the logger.
            </value>
      <remarks>
        <para>
            The name of this logger
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Logger.Repository">
      <summary>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> where this 
            <c>Logger</c> instance is attached to.
            </summary>
      <value>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> that this logger belongs to.
            </value>
      <remarks>
        <para>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> where this 
            <c>Logger</c> instance is attached to.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.Hierarchy.LoggerCreationEventHandler">
      <summary>
            Delegate used to handle logger creation event notifications.
            </summary>
      <param name="sender">The <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> in which the <see cref="T:log4net.Repository.Hierarchy.Logger" /> has been created.</param>
      <param name="e">The <see cref="T:log4net.Repository.Hierarchy.LoggerCreationEventArgs" /> event args that hold the <see cref="T:log4net.Repository.Hierarchy.Logger" /> instance that has been created.</param>
      <remarks>
        <para>
            Delegate used to handle logger creation event notifications.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.Hierarchy.LoggerCreationEventArgs">
      <summary>
            Provides data for the <see cref="E:log4net.Repository.Hierarchy.Hierarchy.LoggerCreatedEvent" /> event.
            </summary>
      <remarks>
        <para>
            A <see cref="E:log4net.Repository.Hierarchy.Hierarchy.LoggerCreatedEvent" /> event is raised every time a
            <see cref="P:log4net.Repository.Hierarchy.LoggerCreationEventArgs.Logger" /> is created.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Repository.Hierarchy.LoggerCreationEventArgs.m_log">
      <summary>
            The <see cref="P:log4net.Repository.Hierarchy.LoggerCreationEventArgs.Logger" /> created
            </summary>
    </member>
    <member name="M:log4net.Repository.Hierarchy.LoggerCreationEventArgs.#ctor(log4net.Repository.Hierarchy.Logger)">
      <summary>
            Constructor
            </summary>
      <param name="log">The <see cref="P:log4net.Repository.Hierarchy.LoggerCreationEventArgs.Logger" /> that has been created.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Repository.Hierarchy.LoggerCreationEventArgs" /> event argument 
            class,with the specified <see cref="P:log4net.Repository.Hierarchy.LoggerCreationEventArgs.Logger" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.LoggerCreationEventArgs.Logger">
      <summary>
            Gets the <see cref="P:log4net.Repository.Hierarchy.LoggerCreationEventArgs.Logger" /> that has been created.
            </summary>
      <value>
            The <see cref="P:log4net.Repository.Hierarchy.LoggerCreationEventArgs.Logger" /> that has been created.
            </value>
      <remarks>
        <para>
            The <see cref="P:log4net.Repository.Hierarchy.LoggerCreationEventArgs.Logger" /> that has been created.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.ILoggerRepository">
      <summary>
            Interface implemented by logger repositories.
            </summary>
      <remarks>
        <para>
            This interface is implemented by logger repositories. e.g. 
            <see cref="N:log4net.Repository.Hierarchy" />.
            </para>
        <para>
            This interface is used by the <see cref="T:log4net.LogManager" />
            to obtain <see cref="T:log4net.ILog" /> interfaces.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Repository.ILoggerRepository.Exists(System.String)">
      <summary>
            Check if the named logger exists in the repository. If so return
            its reference, otherwise returns <c>null</c>.
            </summary>
      <param name="name">The name of the logger to lookup</param>
      <returns>The Logger object with the name specified</returns>
      <remarks>
        <para>
            If the names logger exists it is returned, otherwise
            <c>null</c> is returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.ILoggerRepository.GetCurrentLoggers">
      <summary>
            Returns all the currently defined loggers as an Array.
            </summary>
      <returns>All the defined loggers</returns>
      <remarks>
        <para>
            Returns all the currently defined loggers as an Array.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.ILoggerRepository.GetLogger(System.String)">
      <summary>
            Returns a named logger instance
            </summary>
      <param name="name">The name of the logger to retrieve</param>
      <returns>The logger object with the name specified</returns>
      <remarks>
        <para>
            Returns a named logger instance.
            </para>
        <para>
            If a logger of that name already exists, then it will be
            returned.  Otherwise, a new logger will be instantiated and
            then linked with its existing ancestors as well as children.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.ILoggerRepository.Shutdown">
      <summary>Shutdown the repository</summary>
      <remarks>
        <para>
            Shutting down a repository will <i>safely</i> close and remove
            all appenders in all loggers including the root logger.
            </para>
        <para>
            Some appenders need to be closed before the
            application exists. Otherwise, pending logging events might be
            lost.
            </para>
        <para>
            The <see cref="M:Shutdown()" /> method is careful to close nested
            appenders before closing regular appenders. This is allows
            configurations where a regular appender is attached to a logger
            and again to a nested appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.ILoggerRepository.ResetConfiguration">
      <summary>
            Reset the repositories configuration to a default state
            </summary>
      <remarks>
        <para>
            Reset all values contained in this instance to their
            default state.
            </para>
        <para>
            Existing loggers are not removed. They are just reset.
            </para>
        <para>
            This method should be used sparingly and with care as it will
            block all logging until it is completed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.ILoggerRepository.Log(log4net.Core.LoggingEvent)">
      <summary>
            Log the <see cref="T:log4net.Core.LoggingEvent" /> through this repository.
            </summary>
      <param name="logEvent">the event to log</param>
      <remarks>
        <para>
            This method should not normally be used to log.
            The <see cref="T:log4net.ILog" /> interface should be used 
            for routine logging. This interface can be obtained
            using the <see cref="M:log4net.LogManager.GetLogger(string)" /> method.
            </para>
        <para>
            The <c>logEvent</c> is delivered to the appropriate logger and
            that logger is then responsible for logging the event.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.ILoggerRepository.GetAppenders">
      <summary>
            Returns all the Appenders that are configured as an Array.
            </summary>
      <returns>All the Appenders</returns>
      <remarks>
        <para>
            Returns all the Appenders that are configured as an Array.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.ILoggerRepository.Name">
      <summary>
            The name of the repository
            </summary>
      <value>
            The name of the repository
            </value>
      <remarks>
        <para>
            The name of the repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.ILoggerRepository.RendererMap">
      <summary>
            RendererMap accesses the object renderer map for this repository.
            </summary>
      <value>
            RendererMap accesses the object renderer map for this repository.
            </value>
      <remarks>
        <para>
            RendererMap accesses the object renderer map for this repository.
            </para>
        <para>
            The RendererMap holds a mapping between types and
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" /> objects.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.ILoggerRepository.PluginMap">
      <summary>
            The plugin map for this repository.
            </summary>
      <value>
            The plugin map for this repository.
            </value>
      <remarks>
        <para>
            The plugin map holds the <see cref="T:log4net.Plugin.IPlugin" /> instances
            that have been attached to this repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.ILoggerRepository.LevelMap">
      <summary>
            Get the level map for the Repository.
            </summary>
      <remarks>
        <para>
            Get the level map for the Repository.
            </para>
        <para>
            The level map defines the mappings between
            level names and <see cref="T:log4net.Core.Level" /> objects in
            this repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.ILoggerRepository.Threshold">
      <summary>
            The threshold for all events in this repository
            </summary>
      <value>
            The threshold for all events in this repository
            </value>
      <remarks>
        <para>
            The threshold for all events in this repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.ILoggerRepository.Configured">
      <summary>
            Flag indicates if this repository has been configured.
            </summary>
      <value>
            Flag indicates if this repository has been configured.
            </value>
      <remarks>
        <para>
            Flag indicates if this repository has been configured.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.ILoggerRepository.ConfigurationMessages">
      <summary>
            Collection of internal messages captured during the most 
            recent configuration process.
            </summary>
    </member>
    <member name="P:log4net.Repository.ILoggerRepository.Properties">
      <summary>
            Repository specific properties
            </summary>
      <value>
            Repository specific properties
            </value>
      <remarks>
        <para>
            These properties can be specified on a repository specific basis.
            </para>
      </remarks>
    </member>
    <member name="E:log4net.Repository.ILoggerRepository.ShutdownEvent">
      <summary>
            Event to notify that the repository has been shutdown.
            </summary>
      <value>
            Event to notify that the repository has been shutdown.
            </value>
      <remarks>
        <para>
            Event raised when the repository has been shutdown.
            </para>
      </remarks>
    </member>
    <member name="E:log4net.Repository.ILoggerRepository.ConfigurationReset">
      <summary>
            Event to notify that the repository has had its configuration reset.
            </summary>
      <value>
            Event to notify that the repository has had its configuration reset.
            </value>
      <remarks>
        <para>
            Event raised when the repository's configuration has been
            reset to default.
            </para>
      </remarks>
    </member>
    <member name="E:log4net.Repository.ILoggerRepository.ConfigurationChanged">
      <summary>
            Event to notify that the repository has had its configuration changed.
            </summary>
      <value>
            Event to notify that the repository has had its configuration changed.
            </value>
      <remarks>
        <para>
            Event raised when the repository's configuration has been changed.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.LoggerRepositorySkeleton">
      <summary>
            Base implementation of <see cref="T:log4net.Repository.ILoggerRepository" /></summary>
      <remarks>
        <para>
            Default abstract implementation of the <see cref="T:log4net.Repository.ILoggerRepository" /> interface.
            </para>
        <para>
            Skeleton implementation of the <see cref="T:log4net.Repository.ILoggerRepository" /> interface.
            All <see cref="T:log4net.Repository.ILoggerRepository" /> types can extend this type.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Repository.LoggerRepositorySkeleton.declaringType">
      <summary>
            The fully qualified type of the LoggerRepositorySkeleton class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.#ctor">
      <summary>
            Default Constructor
            </summary>
      <remarks>
        <para>
            Initializes the repository with default (empty) properties.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.#ctor(log4net.Util.PropertiesDictionary)">
      <summary>
            Construct the repository using specific properties
            </summary>
      <param name="properties">the properties to set for this repository</param>
      <remarks>
        <para>
            Initializes the repository with specified properties.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.Exists(System.String)">
      <summary>
            Test if logger exists
            </summary>
      <param name="name">The name of the logger to lookup</param>
      <returns>The Logger object with the name specified</returns>
      <remarks>
        <para>
            Check if the named logger exists in the repository. If so return
            its reference, otherwise returns <c>null</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.GetCurrentLoggers">
      <summary>
            Returns all the currently defined loggers in the repository
            </summary>
      <returns>All the defined loggers</returns>
      <remarks>
        <para>
            Returns all the currently defined loggers in the repository as an Array.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.GetLogger(System.String)">
      <summary>
            Return a new logger instance
            </summary>
      <param name="name">The name of the logger to retrieve</param>
      <returns>The logger object with the name specified</returns>
      <remarks>
        <para>
            Return a new logger instance.
            </para>
        <para>
            If a logger of that name already exists, then it will be
            returned. Otherwise, a new logger will be instantiated and
            then linked with its existing ancestors as well as children.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.Shutdown">
      <summary>
            Shutdown the repository
            </summary>
      <remarks>
        <para>
            Shutdown the repository. Can be overridden in a subclass.
            This base class implementation notifies the <see cref="E:log4net.Repository.LoggerRepositorySkeleton.ShutdownEvent" />
            listeners and all attached plugins of the shutdown event.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.ResetConfiguration">
      <summary>
            Reset the repositories configuration to a default state
            </summary>
      <remarks>
        <para>
            Reset all values contained in this instance to their
            default state.
            </para>
        <para>
            Existing loggers are not removed. They are just reset.
            </para>
        <para>
            This method should be used sparingly and with care as it will
            block all logging until it is completed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.Log(log4net.Core.LoggingEvent)">
      <summary>
            Log the logEvent through this repository.
            </summary>
      <param name="logEvent">the event to log</param>
      <remarks>
        <para>
            This method should not normally be used to log.
            The <see cref="T:log4net.ILog" /> interface should be used 
            for routine logging. This interface can be obtained
            using the <see cref="M:log4net.LogManager.GetLogger(string)" /> method.
            </para>
        <para>
            The <c>logEvent</c> is delivered to the appropriate logger and
            that logger is then responsible for logging the event.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.GetAppenders">
      <summary>
            Returns all the Appenders that are configured as an Array.
            </summary>
      <returns>All the Appenders</returns>
      <remarks>
        <para>
            Returns all the Appenders that are configured as an Array.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.AddRenderer(System.Type,log4net.ObjectRenderer.IObjectRenderer)">
      <summary>
            Adds an object renderer for a specific class. 
            </summary>
      <param name="typeToRender">The type that will be rendered by the renderer supplied.</param>
      <param name="rendererInstance">The object renderer used to render the object.</param>
      <remarks>
        <para>
            Adds an object renderer for a specific class. 
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.OnShutdown(System.EventArgs)">
      <summary>
            Notify the registered listeners that the repository is shutting down
            </summary>
      <param name="e">Empty EventArgs</param>
      <remarks>
        <para>
            Notify any listeners that this repository is shutting down.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.OnConfigurationReset(System.EventArgs)">
      <summary>
            Notify the registered listeners that the repository has had its configuration reset
            </summary>
      <param name="e">Empty EventArgs</param>
      <remarks>
        <para>
            Notify any listeners that this repository's configuration has been reset.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.OnConfigurationChanged(System.EventArgs)">
      <summary>
            Notify the registered listeners that the repository has had its configuration changed
            </summary>
      <param name="e">Empty EventArgs</param>
      <remarks>
        <para>
            Notify any listeners that this repository's configuration has changed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.RaiseConfigurationChanged(System.EventArgs)">
      <summary>
            Raise a configuration changed event on this repository
            </summary>
      <param name="e">EventArgs.Empty</param>
      <remarks>
        <para>
            Applications that programmatically change the configuration of the repository should
            raise this event notification to notify listeners.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.LoggerRepositorySkeleton.Name">
      <summary>
            The name of the repository
            </summary>
      <value>
            The string name of the repository
            </value>
      <remarks>
        <para>
            The name of this repository. The name is
            used to store and lookup the repositories 
            stored by the <see cref="T:log4net.Core.IRepositorySelector" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.LoggerRepositorySkeleton.Threshold">
      <summary>
            The threshold for all events in this repository
            </summary>
      <value>
            The threshold for all events in this repository
            </value>
      <remarks>
        <para>
            The threshold for all events in this repository
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.LoggerRepositorySkeleton.RendererMap">
      <summary>
            RendererMap accesses the object renderer map for this repository.
            </summary>
      <value>
            RendererMap accesses the object renderer map for this repository.
            </value>
      <remarks>
        <para>
            RendererMap accesses the object renderer map for this repository.
            </para>
        <para>
            The RendererMap holds a mapping between types and
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" /> objects.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.LoggerRepositorySkeleton.PluginMap">
      <summary>
            The plugin map for this repository.
            </summary>
      <value>
            The plugin map for this repository.
            </value>
      <remarks>
        <para>
            The plugin map holds the <see cref="T:log4net.Plugin.IPlugin" /> instances
            that have been attached to this repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.LoggerRepositorySkeleton.LevelMap">
      <summary>
            Get the level map for the Repository.
            </summary>
      <remarks>
        <para>
            Get the level map for the Repository.
            </para>
        <para>
            The level map defines the mappings between
            level names and <see cref="T:log4net.Core.Level" /> objects in
            this repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.LoggerRepositorySkeleton.Configured">
      <summary>
            Flag indicates if this repository has been configured.
            </summary>
      <value>
            Flag indicates if this repository has been configured.
            </value>
      <remarks>
        <para>
            Flag indicates if this repository has been configured.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.LoggerRepositorySkeleton.ConfigurationMessages">
      <summary>
            Contains a list of internal messages captures during the 
            last configuration.
            </summary>
    </member>
    <member name="P:log4net.Repository.LoggerRepositorySkeleton.Properties">
      <summary>
            Repository specific properties
            </summary>
      <value>
            Repository specific properties
            </value>
      <remarks>
            These properties can be specified on a repository specific basis
            </remarks>
    </member>
    <member name="E:log4net.Repository.LoggerRepositorySkeleton.ShutdownEvent">
      <summary>
            Event to notify that the repository has been shutdown.
            </summary>
      <value>
            Event to notify that the repository has been shutdown.
            </value>
      <remarks>
        <para>
            Event raised when the repository has been shutdown.
            </para>
      </remarks>
    </member>
    <member name="E:log4net.Repository.LoggerRepositorySkeleton.ConfigurationReset">
      <summary>
            Event to notify that the repository has had its configuration reset.
            </summary>
      <value>
            Event to notify that the repository has had its configuration reset.
            </value>
      <remarks>
        <para>
            Event raised when the repository's configuration has been
            reset to default.
            </para>
      </remarks>
    </member>
    <member name="E:log4net.Repository.LoggerRepositorySkeleton.ConfigurationChanged">
      <summary>
            Event to notify that the repository has had its configuration changed.
            </summary>
      <value>
            Event to notify that the repository has had its configuration changed.
            </value>
      <remarks>
        <para>
            Event raised when the repository's configuration has been changed.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.IBasicRepositoryConfigurator">
      <summary>
            Basic Configurator interface for repositories
            </summary>
      <remarks>
        <para>
            Interface used by basic configurator to configure a <see cref="T:log4net.Repository.ILoggerRepository" />
            with a default <see cref="T:log4net.Appender.IAppender" />.
            </para>
        <para>
            A <see cref="T:log4net.Repository.ILoggerRepository" /> should implement this interface to support
            configuration by the <see cref="T:log4net.Config.BasicConfigurator" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Repository.IBasicRepositoryConfigurator.Configure(log4net.Appender.IAppender)">
      <summary>
            Initialize the repository using the specified appender
            </summary>
      <param name="appender">the appender to use to log all logging events</param>
      <remarks>
        <para>
            Configure the repository to route all logging events to the
            specified appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.IBasicRepositoryConfigurator.Configure(log4net.Appender.IAppender[])">
      <summary>
            Initialize the repository using the specified appenders
            </summary>
      <param name="appenders">the appenders to use to log all logging events</param>
      <remarks>
        <para>
            Configure the repository to route all logging events to the
            specified appenders.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.IXmlRepositoryConfigurator">
      <summary>
            Configure repository using XML
            </summary>
      <remarks>
        <para>
            Interface used by Xml configurator to configure a <see cref="T:log4net.Repository.ILoggerRepository" />.
            </para>
        <para>
            A <see cref="T:log4net.Repository.ILoggerRepository" /> should implement this interface to support
            configuration by the <see cref="T:log4net.Config.XmlConfigurator" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Repository.IXmlRepositoryConfigurator.Configure(System.Xml.XmlElement)">
      <summary>
            Initialize the repository using the specified config
            </summary>
      <param name="element">the element containing the root of the config</param>
      <remarks>
        <para>
            The schema for the XML configuration data is defined by
            the implementation.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.Hierarchy.Hierarchy">
      <summary>
            Hierarchical organization of loggers
            </summary>
      <remarks>
        <para>
          <i>The casual user should not have to deal with this class
            directly.</i>
        </para>
        <para>
            This class is specialized in retrieving loggers by name and
            also maintaining the logger hierarchy. Implements the 
            <see cref="T:log4net.Repository.ILoggerRepository" /> interface.
            </para>
        <para>
            The structure of the logger hierarchy is maintained by the
            <see cref="M:GetLogger(string)" /> method. The hierarchy is such that children
            link to their parent but parents do not have any references to their
            children. Moreover, loggers can be instantiated in any order, in
            particular descendant before ancestor.
            </para>
        <para>
            In case a descendant is created before a particular ancestor,
            then it creates a provision node for the ancestor and adds itself
            to the provision node. Other descendants of the same ancestor add
            themselves to the previously created provision node.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="T:log4net.Repository.Hierarchy.Hierarchy.LevelEntry">
      <summary>
            A class to hold the value, name and display name for a level
            </summary>
      <remarks>
        <para>
            A class to hold the value, name and display name for a level
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.LevelEntry.ToString">
      <summary>
            Override <c>Object.ToString</c> to return sensible debug info
            </summary>
      <returns>string info about this object</returns>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Hierarchy.LevelEntry.Value">
      <summary>
            Value of the level
            </summary>
      <remarks>
        <para>
            If the value is not set (defaults to -1) the value will be looked
            up for the current level with the same name.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Hierarchy.LevelEntry.Name">
      <summary>
            Name of the level
            </summary>
      <value>
            The name of the level
            </value>
      <remarks>
        <para>
            The name of the level.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Hierarchy.LevelEntry.DisplayName">
      <summary>
            Display name for the level
            </summary>
      <value>
            The display name of the level
            </value>
      <remarks>
        <para>
            The display name of the level.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Repository.Hierarchy.Hierarchy.declaringType">
      <summary>
            The fully qualified type of the Hierarchy class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.#ctor(log4net.Util.PropertiesDictionary)">
      <summary>
            Construct with properties
            </summary>
      <param name="properties">The properties to pass to this repository.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.#ctor(log4net.Repository.Hierarchy.ILoggerFactory)">
      <summary>
            Construct with a logger factory
            </summary>
      <param name="loggerFactory">The factory to use to create new logger instances.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> class with 
            the specified <see cref="T:log4net.Repository.Hierarchy.ILoggerFactory" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.#ctor(log4net.Util.PropertiesDictionary,log4net.Repository.Hierarchy.ILoggerFactory)">
      <summary>
            Construct with properties and a logger factory
            </summary>
      <param name="properties">The properties to pass to this repository.</param>
      <param name="loggerFactory">The factory to use to create new logger instances.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> class with 
            the specified <see cref="T:log4net.Repository.Hierarchy.ILoggerFactory" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.Exists(System.String)">
      <summary>
            Test if a logger exists
            </summary>
      <param name="name">The name of the logger to lookup</param>
      <returns>The Logger object with the name specified</returns>
      <remarks>
        <para>
            Check if the named logger exists in the hierarchy. If so return
            its reference, otherwise returns <c>null</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.GetCurrentLoggers">
      <summary>
            Returns all the currently defined loggers in the hierarchy as an Array
            </summary>
      <returns>All the defined loggers</returns>
      <remarks>
        <para>
            Returns all the currently defined loggers in the hierarchy as an Array.
            The root logger is <b>not</b> included in the returned
            enumeration.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.GetLogger(System.String)">
      <summary>
            Return a new logger instance named as the first parameter using
            the default factory.
            </summary>
      <remarks>
        <para>
            Return a new logger instance named as the first parameter using
            the default factory.
            </para>
        <para>
            If a logger of that name already exists, then it will be
            returned.  Otherwise, a new logger will be instantiated and
            then linked with its existing ancestors as well as children.
            </para>
      </remarks>
      <param name="name">The name of the logger to retrieve</param>
      <returns>The logger object with the name specified</returns>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.Shutdown">
      <summary>
            Shutting down a hierarchy will <i>safely</i> close and remove
            all appenders in all loggers including the root logger.
            </summary>
      <remarks>
        <para>
            Shutting down a hierarchy will <i>safely</i> close and remove
            all appenders in all loggers including the root logger.
            </para>
        <para>
            Some appenders need to be closed before the
            application exists. Otherwise, pending logging events might be
            lost.
            </para>
        <para>
            The <c>Shutdown</c> method is careful to close nested
            appenders before closing regular appenders. This is allows
            configurations where a regular appender is attached to a logger
            and again to a nested appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.ResetConfiguration">
      <summary>
            Reset all values contained in this hierarchy instance to their default.
            </summary>
      <remarks>
        <para>
            Reset all values contained in this hierarchy instance to their
            default.  This removes all appenders from all loggers, sets
            the level of all non-root loggers to <c>null</c>,
            sets their additivity flag to <c>true</c> and sets the level
            of the root logger to <see cref="F:log4net.Core.Level.Debug" />. Moreover,
            message disabling is set its default "off" value.
            </para>
        <para>
            Existing loggers are not removed. They are just reset.
            </para>
        <para>
            This method should be used sparingly and with care as it will
            block all logging until it is completed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.Log(log4net.Core.LoggingEvent)">
      <summary>
            Log the logEvent through this hierarchy.
            </summary>
      <param name="logEvent">the event to log</param>
      <remarks>
        <para>
            This method should not normally be used to log.
            The <see cref="T:log4net.ILog" /> interface should be used 
            for routine logging. This interface can be obtained
            using the <see cref="M:log4net.LogManager.GetLogger(string)" /> method.
            </para>
        <para>
            The <c>logEvent</c> is delivered to the appropriate logger and
            that logger is then responsible for logging the event.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.GetAppenders">
      <summary>
            Returns all the Appenders that are currently configured
            </summary>
      <returns>An array containing all the currently configured appenders</returns>
      <remarks>
        <para>
            Returns all the <see cref="T:log4net.Appender.IAppender" /> instances that are currently configured.
            All the loggers are searched for appenders. The appenders may also be containers
            for appenders and these are also searched for additional loggers.
            </para>
        <para>
            The list returned is unordered but does not contain duplicates.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.CollectAppender(System.Collections.ArrayList,log4net.Appender.IAppender)">
      <summary>
            Collect the appenders from an <see cref="T:log4net.Core.IAppenderAttachable" />.
            The appender may also be a container.
            </summary>
      <param name="appenderList">
      </param>
      <param name="appender">
      </param>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.CollectAppenders(System.Collections.ArrayList,log4net.Core.IAppenderAttachable)">
      <summary>
            Collect the appenders from an <see cref="T:log4net.Core.IAppenderAttachable" /> container
            </summary>
      <param name="appenderList">
      </param>
      <param name="container">
      </param>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.BasicRepositoryConfigure(log4net.Appender.IAppender[])">
      <summary>
            Initialize the log4net system using the specified appenders
            </summary>
      <param name="appenders">the appenders to use to log all logging events</param>
      <remarks>
        <para>
            This method provides the same functionality as the 
            <see cref="M:IBasicRepositoryConfigurator.Configure(IAppender)" /> method implemented
            on this object, but it is protected and therefore can be called by subclasses.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.XmlRepositoryConfigure(System.Xml.XmlElement)">
      <summary>
            Initialize the log4net system using the specified config
            </summary>
      <param name="element">the element containing the root of the config</param>
      <remarks>
        <para>
            This method provides the same functionality as the 
            <see cref="M:IBasicRepositoryConfigurator.Configure(IAppender)" /> method implemented
            on this object, but it is protected and therefore can be called by subclasses.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.IsDisabled(log4net.Core.Level)">
      <summary>
            Test if this hierarchy is disabled for the specified <see cref="T:log4net.Core.Level" />.
            </summary>
      <param name="level">The level to check against.</param>
      <returns>
        <c>true</c> if the repository is disabled for the level argument, <c>false</c> otherwise.
            </returns>
      <remarks>
        <para>
            If this hierarchy has not been configured then this method will
            always return <c>true</c>.
            </para>
        <para>
            This method will return <c>true</c> if this repository is
            disabled for <c>level</c> object passed as parameter and
            <c>false</c> otherwise.
            </para>
        <para>
            See also the <see cref="P:log4net.Repository.ILoggerRepository.Threshold" /> property.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.Clear">
      <summary>
            Clear all logger definitions from the internal hashtable
            </summary>
      <remarks>
        <para>
            This call will clear all logger definitions from the internal
            hashtable. Invoking this method will irrevocably mess up the
            logger hierarchy.
            </para>
        <para>
            You should <b>really</b> know what you are doing before
            invoking this method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.GetLogger(System.String,log4net.Repository.Hierarchy.ILoggerFactory)">
      <summary>
            Return a new logger instance named as the first parameter using
            <paramref name="factory" />.
            </summary>
      <param name="name">The name of the logger to retrieve</param>
      <param name="factory">The factory that will make the new logger instance</param>
      <returns>The logger object with the name specified</returns>
      <remarks>
        <para>
            If a logger of that name already exists, then it will be
            returned. Otherwise, a new logger will be instantiated by the
            <paramref name="factory" /> parameter and linked with its existing
            ancestors as well as children.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.OnLoggerCreationEvent(log4net.Repository.Hierarchy.Logger)">
      <summary>
            Sends a logger creation event to all registered listeners
            </summary>
      <param name="logger">The newly created logger</param>
      <remarks>
            Raises the logger creation event.
            </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.UpdateParents(log4net.Repository.Hierarchy.Logger)">
      <summary>
            Updates all the parents of the specified logger
            </summary>
      <param name="log">The logger to update the parents for</param>
      <remarks>
        <para>
            This method loops through all the <i>potential</i> parents of
            <paramref name="log" />. There 3 possible cases:
            </para>
        <list type="number">
          <item>
            <term>No entry for the potential parent of <paramref name="log" /> exists</term>
            <description>
            		We create a ProvisionNode for this potential 
            		parent and insert <paramref name="log" /> in that provision node.
            		</description>
          </item>
          <item>
            <term>The entry is of type Logger for the potential parent.</term>
            <description>
            		The entry is <paramref name="log" />'s nearest existing parent. We 
            		update <paramref name="log" />'s parent field with this entry. We also break from 
            		he loop because updating our parent's parent is our parent's 
            		responsibility.
            		</description>
          </item>
          <item>
            <term>The entry is of type ProvisionNode for this potential parent.</term>
            <description>
            		We add <paramref name="log" /> to the list of children for this 
            		potential parent.
            		</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.UpdateChildren(log4net.Repository.Hierarchy.ProvisionNode,log4net.Repository.Hierarchy.Logger)">
      <summary>
            Replace a <see cref="T:log4net.Repository.Hierarchy.ProvisionNode" /> with a <see cref="T:log4net.Repository.Hierarchy.Logger" /> in the hierarchy.
            </summary>
      <param name="pn">
      </param>
      <param name="log">
      </param>
      <remarks>
        <para>
            We update the links for all the children that placed themselves
            in the provision node 'pn'. The second argument 'log' is a
            reference for the newly created Logger, parent of all the
            children in 'pn'.
            </para>
        <para>
            We loop on all the children 'c' in 'pn'.
            </para>
        <para>
            If the child 'c' has been already linked to a child of
            'log' then there is no need to update 'c'.
            </para>
        <para>
            Otherwise, we set log's parent field to c's parent and set
            c's parent field to log.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.AddLevel(log4net.Repository.Hierarchy.Hierarchy.LevelEntry)">
      <summary>
            Define or redefine a Level using the values in the <see cref="T:log4net.Repository.Hierarchy.Hierarchy.LevelEntry" /> argument
            </summary>
      <param name="levelEntry">the level values</param>
      <remarks>
        <para>
            Define or redefine a Level using the values in the <see cref="T:log4net.Repository.Hierarchy.Hierarchy.LevelEntry" /> argument
            </para>
        <para>
            Supports setting levels via the configuration file.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.AddProperty(log4net.Util.PropertyEntry)">
      <summary>
            Set a Property using the values in the <see cref="T:log4net.Repository.Hierarchy.Hierarchy.LevelEntry" /> argument
            </summary>
      <param name="propertyEntry">the property value</param>
      <remarks>
        <para>
            Set a Property using the values in the <see cref="T:log4net.Repository.Hierarchy.Hierarchy.LevelEntry" /> argument.
            </para>
        <para>
            Supports setting property values via the configuration file.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Hierarchy.EmittedNoAppenderWarning">
      <summary>
            Has no appender warning been emitted
            </summary>
      <remarks>
        <para>
            Flag to indicate if we have already issued a warning
            about not having an appender warning.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Hierarchy.Root">
      <summary>
            Get the root of this hierarchy
            </summary>
      <remarks>
        <para>
            Get the root of this hierarchy.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Hierarchy.LoggerFactory">
      <summary>
            Gets or sets the default <see cref="T:log4net.Repository.Hierarchy.ILoggerFactory" /> instance.
            </summary>
      <value>The default <see cref="T:log4net.Repository.Hierarchy.ILoggerFactory" /></value>
      <remarks>
        <para>
            The logger factory is used to create logger instances.
            </para>
      </remarks>
    </member>
    <member name="E:log4net.Repository.Hierarchy.Hierarchy.LoggerCreatedEvent">
      <summary>
            Event used to notify that a logger has been created.
            </summary>
      <remarks>
        <para>
            Event raised when a logger is created.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.Hierarchy.LoggerKey">
      <summary>
            Used internally to accelerate hash table searches.
            </summary>
      <remarks>
        <para>
            Internal class used to improve performance of 
            string keyed hashtables.
            </para>
        <para>
            The hashcode of the string is cached for reuse.
            The string is stored as an interned value.
            When comparing two <see cref="T:log4net.Repository.Hierarchy.LoggerKey" /> objects for equality 
            the reference equality of the interned strings is compared.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Repository.Hierarchy.LoggerKey.#ctor(System.String)">
      <summary>
            Construct key with string name
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Repository.Hierarchy.LoggerKey" /> class 
            with the specified name.
            </para>
        <para>
            Stores the hashcode of the string and interns
            the string key to optimize comparisons.
            </para>
        <note>
            The Compact Framework 1.0 the <see cref="M:System.String.Intern(System.String)" />
            method does not work. On the Compact Framework
            the string keys are not interned nor are they
            compared by reference.
            </note>
      </remarks>
      <param name="name">The name of the logger.</param>
    </member>
    <member name="M:log4net.Repository.Hierarchy.LoggerKey.GetHashCode">
      <summary>
            Returns a hash code for the current instance.
            </summary>
      <returns>A hash code for the current instance.</returns>
      <remarks>
        <para>
            Returns the cached hashcode.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.LoggerKey.Equals(System.Object)">
      <summary>
            Determines whether two <see cref="T:log4net.Repository.Hierarchy.LoggerKey" /> instances 
            are equal.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:log4net.Repository.Hierarchy.LoggerKey" />.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:log4net.Repository.Hierarchy.LoggerKey" />; otherwise, <c>false</c>.
            </returns>
      <remarks>
        <para>
            Compares the references of the interned strings.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.Hierarchy.ProvisionNode">
      <summary>
            Provision nodes are used where no logger instance has been specified
            </summary>
      <remarks>
        <para>
          <see cref="T:log4net.Repository.Hierarchy.ProvisionNode" /> instances are used in the 
            <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> when there is no specified 
            <see cref="T:log4net.Repository.Hierarchy.Logger" /> for that node.
            </para>
        <para>
            A provision node holds a list of child loggers on behalf of
            a logger that does not exist.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Repository.Hierarchy.ProvisionNode.#ctor(log4net.Repository.Hierarchy.Logger)">
      <summary>
            Create a new provision node with child node
            </summary>
      <param name="log">A child logger to add to this node.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Repository.Hierarchy.ProvisionNode" /> class 
            with the specified child logger.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.Hierarchy.RootLogger">
      <summary>
            The <see cref="T:log4net.Repository.Hierarchy.RootLogger" /> sits at the root of the logger hierarchy tree. 
            </summary>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.Hierarchy.RootLogger" /> is a regular <see cref="T:log4net.Repository.Hierarchy.Logger" /> except 
            that it provides several guarantees.
            </para>
        <para>
            First, it cannot be assigned a <c>null</c>
            level. Second, since the root logger cannot have a parent, the
            <see cref="P:log4net.Repository.Hierarchy.RootLogger.EffectiveLevel" /> property always returns the value of the
            level field without walking the hierarchy.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Repository.Hierarchy.RootLogger.declaringType">
      <summary>
            The fully qualified type of the RootLogger class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.RootLogger.#ctor(log4net.Core.Level)">
      <summary>
            Construct a <see cref="T:log4net.Repository.Hierarchy.RootLogger" /></summary>
      <param name="level">The level to assign to the root logger.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Repository.Hierarchy.RootLogger" /> class with
            the specified logging level.
            </para>
        <para>
            The root logger names itself as "root". However, the root
            logger cannot be retrieved by name.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.RootLogger.EffectiveLevel">
      <summary>
            Gets the assigned level value without walking the logger hierarchy.
            </summary>
      <value>The assigned level value without walking the logger hierarchy.</value>
      <remarks>
        <para>
            Because the root logger cannot have a parent and its level
            must not be <c>null</c> this property just returns the
            value of <see cref="P:log4net.Repository.Hierarchy.Logger.Level" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.RootLogger.Level">
      <summary>
            Gets or sets the assigned <see cref="P:log4net.Repository.Hierarchy.RootLogger.Level" /> for the root logger.  
            </summary>
      <value>
            The <see cref="P:log4net.Repository.Hierarchy.RootLogger.Level" /> of the root logger.
            </value>
      <remarks>
        <para>
            Setting the level of the root logger to a <c>null</c> reference
            may have catastrophic results. We prevent this here.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.Hierarchy.XmlHierarchyConfigurator">
      <summary>
            Initializes the log4net environment using an XML DOM.
            </summary>
      <remarks>
        <para>
            Configures a <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> using an XML DOM.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.m_appenderBag">
      <summary>
            key: appenderName, value: appender.
            </summary>
    </member>
    <member name="F:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.m_hierarchy">
      <summary>
            The Hierarchy being configured.
            </summary>
    </member>
    <member name="F:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.declaringType">
      <summary>
            The fully qualified type of the XmlHierarchyConfigurator class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.#ctor(log4net.Repository.Hierarchy.Hierarchy)">
      <summary>
            Construct the configurator for a hierarchy
            </summary>
      <param name="hierarchy">The hierarchy to build.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Repository.Hierarchy.XmlHierarchyConfigurator" /> class
            with the specified <see cref="T:log4net.Repository.Hierarchy.Hierarchy" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.Configure(System.Xml.XmlElement)">
      <summary>
            Configure the hierarchy by parsing a DOM tree of XML elements.
            </summary>
      <param name="element">The root element to parse.</param>
      <remarks>
        <para>
            Configure the hierarchy by parsing a DOM tree of XML elements.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.FindAppenderByReference(System.Xml.XmlElement)">
      <summary>
            Parse appenders by IDREF.
            </summary>
      <param name="appenderRef">The appender ref element.</param>
      <returns>The instance of the appender that the ref refers to.</returns>
      <remarks>
        <para>
            Parse an XML element that represents an appender and return 
            the appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.ParseAppender(System.Xml.XmlElement)">
      <summary>
            Parses an appender element.
            </summary>
      <param name="appenderElement">The appender element.</param>
      <returns>The appender instance or <c>null</c> when parsing failed.</returns>
      <remarks>
        <para>
            Parse an XML element that represents an appender and return
            the appender instance.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.ParseLogger(System.Xml.XmlElement)">
      <summary>
            Parses a logger element.
            </summary>
      <param name="loggerElement">The logger element.</param>
      <remarks>
        <para>
            Parse an XML element that represents a logger.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.ParseRoot(System.Xml.XmlElement)">
      <summary>
            Parses the root logger element.
            </summary>
      <param name="rootElement">The root element.</param>
      <remarks>
        <para>
            Parse an XML element that represents the root logger.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.ParseChildrenOfLoggerElement(System.Xml.XmlElement,log4net.Repository.Hierarchy.Logger,System.Boolean)">
      <summary>
            Parses the children of a logger element.
            </summary>
      <param name="catElement">The category element.</param>
      <param name="log">The logger instance.</param>
      <param name="isRoot">Flag to indicate if the logger is the root logger.</param>
      <remarks>
        <para>
            Parse the child elements of a &lt;logger&gt; element.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.ParseRenderer(System.Xml.XmlElement)">
      <summary>
            Parses an object renderer.
            </summary>
      <param name="element">The renderer element.</param>
      <remarks>
        <para>
            Parse an XML element that represents a renderer.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.ParseLevel(System.Xml.XmlElement,log4net.Repository.Hierarchy.Logger,System.Boolean)">
      <summary>
            Parses a level element.
            </summary>
      <param name="element">The level element.</param>
      <param name="log">The logger object to set the level on.</param>
      <param name="isRoot">Flag to indicate if the logger is the root logger.</param>
      <remarks>
        <para>
            Parse an XML element that represents a level.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.SetParameter(System.Xml.XmlElement,System.Object)">
      <summary>
            Sets a parameter on an object.
            </summary>
      <param name="element">The parameter element.</param>
      <param name="target">The object to set the parameter on.</param>
      <remarks>
            The parameter name must correspond to a writable property
            on the object. The value of the parameter is a string,
            therefore this function will attempt to set a string
            property first. If unable to set a string property it
            will inspect the property and its argument type. It will
            attempt to call a static method called <c>Parse</c> on the
            type of the property. This method will take a single
            string argument and return a value that can be used to
            set the property.
            </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.HasAttributesOrElements(System.Xml.XmlElement)">
      <summary>
            Test if an element has no attributes or child elements
            </summary>
      <param name="element">the element to inspect</param>
      <returns>
        <c>true</c> if the element has any attributes or child elements, <c>false</c> otherwise</returns>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.IsTypeConstructible(System.Type)">
      <summary>
            Test if a <see cref="T:System.Type" /> is constructible with <c>Activator.CreateInstance</c>.
            </summary>
      <param name="type">the type to inspect</param>
      <returns>
        <c>true</c> if the type is creatable using a default constructor, <c>false</c> otherwise</returns>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.FindMethodInfo(System.Type,System.String)">
      <summary>
            Look for a method on the <paramref name="targetType" /> that matches the <paramref name="name" /> supplied
            </summary>
      <param name="targetType">the type that has the method</param>
      <param name="name">the name of the method</param>
      <returns>the method info found</returns>
      <remarks>
        <para>
            The method must be a public instance method on the <paramref name="targetType" />.
            The method must be named <paramref name="name" /> or "Add" followed by <paramref name="name" />.
            The method must take a single parameter.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.ConvertStringTo(System.Type,System.String)">
      <summary>
            Converts a string value to a target type.
            </summary>
      <param name="type">The type of object to convert the string to.</param>
      <param name="value">The string value to use as the value of the object.</param>
      <returns>
        <para>
            An object of type <paramref name="type" /> with value <paramref name="value" /> or 
            <c>null</c> when the conversion could not be performed.
            </para>
      </returns>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.CreateObjectFromXml(System.Xml.XmlElement,System.Type,System.Type)">
      <summary>
            Creates an object as specified in XML.
            </summary>
      <param name="element">The XML element that contains the definition of the object.</param>
      <param name="defaultTargetType">The object type to use if not explicitly specified.</param>
      <param name="typeConstraint">The type that the returned object must be or must inherit from.</param>
      <returns>The object or <c>null</c></returns>
      <remarks>
        <para>
            Parse an XML element and create an object instance based on the configuration
            data.
            </para>
        <para>
            The type of the instance may be specified in the XML. If not
            specified then the <paramref name="defaultTargetType" /> is used
            as the type. However the type is specified it must support the
            <paramref name="typeConstraint" /> type.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.ConfigurationChangedEventArgs">
      <summary>
      </summary>
    </member>
    <member name="M:log4net.Repository.ConfigurationChangedEventArgs.#ctor(System.Collections.ICollection)">
      <summary>
      </summary>
      <param name="configurationMessages">
      </param>
    </member>
    <member name="P:log4net.Repository.ConfigurationChangedEventArgs.ConfigurationMessages">
      <summary>
      </summary>
    </member>
    <member name="T:log4net.Repository.LoggerRepositoryShutdownEventHandler">
      <summary>
            Delegate used to handle logger repository shutdown event notifications
            </summary>
      <param name="sender">The <see cref="T:log4net.Repository.ILoggerRepository" /> that is shutting down.</param>
      <param name="e">Empty event args</param>
      <remarks>
        <para>
            Delegate used to handle logger repository shutdown event notifications.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.LoggerRepositoryConfigurationResetEventHandler">
      <summary>
            Delegate used to handle logger repository configuration reset event notifications
            </summary>
      <param name="sender">The <see cref="T:log4net.Repository.ILoggerRepository" /> that has had its configuration reset.</param>
      <param name="e">Empty event args</param>
      <remarks>
        <para>
            Delegate used to handle logger repository configuration reset event notifications.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.LoggerRepositoryConfigurationChangedEventHandler">
      <summary>
            Delegate used to handle event notifications for logger repository configuration changes.
            </summary>
      <param name="sender">The <see cref="T:log4net.Repository.ILoggerRepository" /> that has had its configuration changed.</param>
      <param name="e">Empty event arguments.</param>
      <remarks>
        <para>
            Delegate used to handle event notifications for logger repository configuration changes.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternStringConverters.AppDomainPatternConverter">
      <summary>
            Write the name of the current AppDomain to the output
            </summary>
      <remarks>
        <para>
            Write the name of the current AppDomain to the output writer
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.AppDomainPatternConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Write the name of the current AppDomain to the output
            </summary>
      <param name="writer">the writer to write to</param>
      <param name="state">null, state is not set</param>
      <remarks>
        <para>
            Writes name of the current AppDomain to the output <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternStringConverters.DatePatternConverter">
      <summary>
            Write the current date to the output
            </summary>
      <remarks>
        <para>
            Date pattern converter, uses a <see cref="T:log4net.DateFormatter.IDateFormatter" /> to format 
            the current date and time to the writer as a string.
            </para>
        <para>
            The value of the <see cref="P:log4net.Util.PatternConverter.Option" /> determines 
            the formatting of the date. The following values are allowed:
            <list type="definition"><listheader><term>Option value</term><description>Output</description></listheader><item><term>ISO8601</term><description>
            		Uses the <see cref="T:log4net.DateFormatter.Iso8601DateFormatter" /> formatter. 
            		Formats using the <c>"yyyy-MM-dd HH:mm:ss,fff"</c> pattern.
            		</description></item><item><term>DATE</term><description>
            		Uses the <see cref="T:log4net.DateFormatter.DateTimeDateFormatter" /> formatter. 
            		Formats using the <c>"dd MMM yyyy HH:mm:ss,fff"</c> for example, <c>"06 Nov 1994 15:49:37,459"</c>.
            		</description></item><item><term>ABSOLUTE</term><description>
            		Uses the <see cref="T:log4net.DateFormatter.AbsoluteTimeDateFormatter" /> formatter. 
            		Formats using the <c>"HH:mm:ss,fff"</c> for example, <c>"15:49:37,459"</c>.
            		</description></item><item><term>other</term><description>
            		Any other pattern string uses the <see cref="T:log4net.DateFormatter.SimpleDateFormatter" /> formatter. 
            		This formatter passes the pattern string to the <see cref="T:System.DateTime" /><see cref="M:DateTime.ToString(string)" /> method.
            		For details on valid patterns see 
            		<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemglobalizationdatetimeformatinfoclasstopic.asp">DateTimeFormatInfo Class</a>.
            		</description></item></list></para>
        <para>
            The date and time is in the local time zone and is rendered in that zone.
            To output the time in Universal time see <see cref="T:log4net.Util.PatternStringConverters.UtcDatePatternConverter" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Util.PatternStringConverters.DatePatternConverter.m_dateFormatter">
      <summary>
            The <see cref="T:log4net.DateFormatter.IDateFormatter" /> used to render the date to a string
            </summary>
      <remarks>
        <para>
            The <see cref="T:log4net.DateFormatter.IDateFormatter" /> used to render the date to a string
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Util.PatternStringConverters.DatePatternConverter.declaringType">
      <summary>
            The fully qualified type of the DatePatternConverter class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.DatePatternConverter.ActivateOptions">
      <summary>
            Initialize the converter options
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Util.PatternStringConverters.DatePatternConverter.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Util.PatternStringConverters.DatePatternConverter.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Util.PatternStringConverters.DatePatternConverter.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.DatePatternConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Write the current date to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="state">null, state is not set</param>
      <remarks>
        <para>
            Pass the current date and time to the <see cref="T:log4net.DateFormatter.IDateFormatter" />
            for it to render it to the writer.
            </para>
        <para>
            The date and time passed is in the local time zone.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternStringConverters.EnvironmentFolderPathPatternConverter">
      <summary>
            Write an <see cref="T:System.Environment.SpecialFolder" /> folder path to the output
            </summary>
      <remarks>
        <para>
            Write an special path environment folder path to the output writer.
            The value of the <see cref="P:log4net.Util.PatternConverter.Option" /> determines 
            the name of the variable to output. <see cref="P:log4net.Util.PatternConverter.Option" />
            should be a value in the <see cref="T:System.Environment.SpecialFolder" /> enumeration.
            </para>
      </remarks>
      <author>Ron Grabowski</author>
    </member>
    <member name="F:log4net.Util.PatternStringConverters.EnvironmentFolderPathPatternConverter.declaringType">
      <summary>
            The fully qualified type of the EnvironmentFolderPathPatternConverter class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.EnvironmentFolderPathPatternConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Write an special path environment folder path to the output
            </summary>
      <param name="writer">the writer to write to</param>
      <param name="state">null, state is not set</param>
      <remarks>
        <para>
            Writes the special path environment folder path to the output <paramref name="writer" />.
            The name of the special path environment folder path to output must be set
            using the <see cref="P:log4net.Util.PatternConverter.Option" />
            property.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternStringConverters.EnvironmentPatternConverter">
      <summary>
            Write an environment variable to the output
            </summary>
      <remarks>
        <para>
            Write an environment variable to the output writer.
            The value of the <see cref="P:log4net.Util.PatternConverter.Option" /> determines 
            the name of the variable to output.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Util.PatternStringConverters.EnvironmentPatternConverter.declaringType">
      <summary>
            The fully qualified type of the EnvironmentPatternConverter class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.EnvironmentPatternConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Write an environment variable to the output
            </summary>
      <param name="writer">the writer to write to</param>
      <param name="state">null, state is not set</param>
      <remarks>
        <para>
            Writes the environment variable to the output <paramref name="writer" />.
            The name of the environment variable to output must be set
            using the <see cref="P:log4net.Util.PatternConverter.Option" />
            property.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternStringConverters.IdentityPatternConverter">
      <summary>
            Write the current thread identity to the output
            </summary>
      <remarks>
        <para>
            Write the current thread identity to the output writer
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Util.PatternStringConverters.IdentityPatternConverter.declaringType">
      <summary>
            The fully qualified type of the IdentityPatternConverter class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.IdentityPatternConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Write the current thread identity to the output
            </summary>
      <param name="writer">the writer to write to</param>
      <param name="state">null, state is not set</param>
      <remarks>
        <para>
            Writes the current thread identity to the output <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternStringConverters.LiteralPatternConverter">
      <summary>
            Pattern converter for literal string instances in the pattern
            </summary>
      <remarks>
        <para>
            Writes the literal string value specified in the 
            <see cref="P:log4net.Util.PatternConverter.Option" /> property to 
            the output.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.LiteralPatternConverter.SetNext(log4net.Util.PatternConverter)">
      <summary>
            Set the next converter in the chain
            </summary>
      <param name="pc">The next pattern converter in the chain</param>
      <returns>The next pattern converter</returns>
      <remarks>
        <para>
            Special case the building of the pattern converter chain
            for <see cref="T:log4net.Util.PatternStringConverters.LiteralPatternConverter" /> instances. Two adjacent
            literals in the pattern can be represented by a single combined
            pattern converter. This implementation detects when a 
            <see cref="T:log4net.Util.PatternStringConverters.LiteralPatternConverter" /> is added to the chain
            after this converter and combines its value with this converter's
            literal value.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.LiteralPatternConverter.Format(System.IO.TextWriter,System.Object)">
      <summary>
            Write the literal to the output
            </summary>
      <param name="writer">the writer to write to</param>
      <param name="state">null, not set</param>
      <remarks>
        <para>
            Override the formatting behavior to ignore the FormattingInfo
            because we have a literal instead.
            </para>
        <para>
            Writes the value of <see cref="P:log4net.Util.PatternConverter.Option" />
            to the output <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.LiteralPatternConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Convert this pattern into the rendered message
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="state">null, not set</param>
      <remarks>
        <para>
            This method is not used.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternStringConverters.NewLinePatternConverter">
      <summary>
            Writes a newline to the output
            </summary>
      <remarks>
        <para>
            Writes the system dependent line terminator to the output.
            This behavior can be overridden by setting the <see cref="P:log4net.Util.PatternConverter.Option" />:
            </para>
        <list type="definition">
          <listheader>
            <term>Option Value</term>
            <description>Output</description>
          </listheader>
          <item>
            <term>DOS</term>
            <description>DOS or Windows line terminator <c>"\r\n"</c></description>
          </item>
          <item>
            <term>UNIX</term>
            <description>UNIX line terminator <c>"\n"</c></description>
          </item>
        </list>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.NewLinePatternConverter.ActivateOptions">
      <summary>
            Initialize the converter
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Util.PatternStringConverters.NewLinePatternConverter.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Util.PatternStringConverters.NewLinePatternConverter.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Util.PatternStringConverters.NewLinePatternConverter.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternStringConverters.ProcessIdPatternConverter">
      <summary>
            Write the current process ID to the output
            </summary>
      <remarks>
        <para>
            Write the current process ID to the output writer
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Util.PatternStringConverters.ProcessIdPatternConverter.declaringType">
      <summary>
            The fully qualified type of the ProcessIdPatternConverter class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.ProcessIdPatternConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Write the current process ID to the output
            </summary>
      <param name="writer">the writer to write to</param>
      <param name="state">null, state is not set</param>
      <remarks>
        <para>
            Write the current process ID to the output <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternStringConverters.PropertyPatternConverter">
      <summary>
            Property pattern converter
            </summary>
      <remarks>
        <para>
            This pattern converter reads the thread and global properties.
            The thread properties take priority over global properties.
            See <see cref="P:log4net.ThreadContext.Properties" /> for details of the 
            thread properties. See <see cref="P:log4net.GlobalContext.Properties" /> for
            details of the global properties.
            </para>
        <para>
            If the <see cref="P:log4net.Util.PatternConverter.Option" /> is specified then that will be used to
            lookup a single property. If no <see cref="P:log4net.Util.PatternConverter.Option" /> is specified
            then all properties will be dumped as a list of key value pairs.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.PropertyPatternConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Write the property value to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="state">null, state is not set</param>
      <remarks>
        <para>
            Writes out the value of a named property. The property name
            should be set in the <see cref="P:log4net.Util.PatternConverter.Option" />
            property.
            </para>
        <para>
            If the <see cref="P:log4net.Util.PatternConverter.Option" /> is set to <c>null</c>
            then all the properties are written as key value pairs.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternStringConverters.RandomStringPatternConverter">
      <summary>
            A Pattern converter that generates a string of random characters
            </summary>
      <remarks>
        <para>
            The converter generates a string of random characters. By default
            the string is length 4. This can be changed by setting the <see cref="P:log4net.Util.PatternConverter.Option" />
            to the string value of the length required.
            </para>
        <para>
            The random characters in the string are limited to uppercase letters
            and numbers only.
            </para>
        <para>
            The random number generator used by this class is not cryptographically secure.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Util.PatternStringConverters.RandomStringPatternConverter.s_random">
      <summary>
            Shared random number generator
            </summary>
    </member>
    <member name="F:log4net.Util.PatternStringConverters.RandomStringPatternConverter.m_length">
      <summary>
            Length of random string to generate. Default length 4.
            </summary>
    </member>
    <member name="F:log4net.Util.PatternStringConverters.RandomStringPatternConverter.declaringType">
      <summary>
            The fully qualified type of the RandomStringPatternConverter class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.RandomStringPatternConverter.ActivateOptions">
      <summary>
            Initialize the converter options
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Util.PatternStringConverters.RandomStringPatternConverter.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Util.PatternStringConverters.RandomStringPatternConverter.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Util.PatternStringConverters.RandomStringPatternConverter.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.RandomStringPatternConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Write a randoim string to the output
            </summary>
      <param name="writer">the writer to write to</param>
      <param name="state">null, state is not set</param>
      <remarks>
        <para>
            Write a randoim string to the output <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternStringConverters.UserNamePatternConverter">
      <summary>
            Write the current threads username to the output
            </summary>
      <remarks>
        <para>
            Write the current threads username to the output writer
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Util.PatternStringConverters.UserNamePatternConverter.declaringType">
      <summary>
            The fully qualified type of the UserNamePatternConverter class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.UserNamePatternConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Write the current threads username to the output
            </summary>
      <param name="writer">the writer to write to</param>
      <param name="state">null, state is not set</param>
      <remarks>
        <para>
            Write the current threads username to the output <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternStringConverters.UtcDatePatternConverter">
      <summary>
            Write the UTC date time to the output
            </summary>
      <remarks>
        <para>
            Date pattern converter, uses a <see cref="T:log4net.DateFormatter.IDateFormatter" /> to format 
            the current date and time in Universal time.
            </para>
        <para>
            See the <see cref="T:log4net.Util.PatternStringConverters.DatePatternConverter" /> for details on the date pattern syntax.
            </para>
      </remarks>
      <seealso cref="T:log4net.Util.PatternStringConverters.DatePatternConverter" />
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Util.PatternStringConverters.UtcDatePatternConverter.declaringType">
      <summary>
            The fully qualified type of the UtcDatePatternConverter class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.UtcDatePatternConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Write the current date and time to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="state">null, state is not set</param>
      <remarks>
        <para>
            Pass the current date and time to the <see cref="T:log4net.DateFormatter.IDateFormatter" />
            for it to render it to the writer.
            </para>
        <para>
            The date is in Universal time when it is rendered.
            </para>
      </remarks>
      <seealso cref="T:log4net.Util.PatternStringConverters.DatePatternConverter" />
    </member>
    <member name="T:log4net.Util.TypeConverters.BooleanConverter">
      <summary>
            Type converter for Boolean.
            </summary>
      <remarks>
        <para>
            Supports conversion from string to <c>bool</c> type.
            </para>
      </remarks>
      <seealso cref="T:log4net.Util.TypeConverters.ConverterRegistry" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertFrom" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertTo" />
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Util.TypeConverters.BooleanConverter.CanConvertFrom(System.Type)">
      <summary>
            Can the source type be converted to the type supported by this object
            </summary>
      <param name="sourceType">the type to convert</param>
      <returns>true if the conversion is possible</returns>
      <remarks>
        <para>
            Returns <c>true</c> if the <paramref name="sourceType" /> is
            the <see cref="T:System.String" /> type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.BooleanConverter.ConvertFrom(System.Object)">
      <summary>
            Convert the source object to the type supported by this object
            </summary>
      <param name="source">the object to convert</param>
      <returns>the converted object</returns>
      <remarks>
        <para>
            Uses the <see cref="M:System.Boolean.Parse(System.String)" /> method to convert the
            <see cref="T:System.String" /> argument to a <see cref="T:System.Boolean" />.
            </para>
      </remarks>
      <exception cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException">
            The <paramref name="source" /> object cannot be converted to the
            target type. To check for this condition use the <see cref="M:log4net.Util.TypeConverters.BooleanConverter.CanConvertFrom(System.Type)" />
            method.
            </exception>
    </member>
    <member name="T:log4net.Util.TypeConverters.ConversionNotSupportedException">
      <summary>
            Exception base type for conversion errors.
            </summary>
      <remarks>
        <para>
            This type extends <see cref="T:System.ApplicationException" />. It
            does not add any new functionality but does differentiate the
            type of exception being thrown.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConversionNotSupportedException.#ctor">
      <summary>
            Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConversionNotSupportedException.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="message">A message to include with the exception.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException" /> class
            with the specified message.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConversionNotSupportedException.#ctor(System.String,System.Exception)">
      <summary>
            Constructor
            </summary>
      <param name="message">A message to include with the exception.</param>
      <param name="innerException">A nested exception to include.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException" /> class
            with the specified message and inner exception.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConversionNotSupportedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Serialization constructor
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException" /> class 
            with serialized data.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConversionNotSupportedException.Create(System.Type,System.Object)">
      <summary>
            Creates a new instance of the <see cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException" /> class.
            </summary>
      <param name="destinationType">The conversion destination type.</param>
      <param name="sourceValue">The value to convert.</param>
      <returns>An instance of the <see cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException" />.</returns>
      <remarks>
        <para>
            Creates a new instance of the <see cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConversionNotSupportedException.Create(System.Type,System.Object,System.Exception)">
      <summary>
            Creates a new instance of the <see cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException" /> class.
            </summary>
      <param name="destinationType">The conversion destination type.</param>
      <param name="sourceValue">The value to convert.</param>
      <param name="innerException">A nested exception to include.</param>
      <returns>An instance of the <see cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException" />.</returns>
      <remarks>
        <para>
            Creates a new instance of the <see cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException" /> class.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.TypeConverters.ConverterRegistry">
      <summary>
            Register of type converters for specific types.
            </summary>
      <remarks>
        <para>
            Maintains a registry of type converters used to convert between
            types.
            </para>
        <para>
            Use the <see cref="M:AddConverter(Type, object)" /> and 
            <see cref="M:AddConverter(Type, Type)" /> methods to register new converters.
            The <see cref="M:log4net.Util.TypeConverters.ConverterRegistry.GetConvertTo(System.Type,System.Type)" /> and <see cref="M:log4net.Util.TypeConverters.ConverterRegistry.GetConvertFrom(System.Type)" /> methods
            lookup appropriate converters to use.
            </para>
      </remarks>
      <seealso cref="T:log4net.Util.TypeConverters.IConvertFrom" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertTo" />
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.TypeConverters.ConverterRegistry.declaringType">
      <summary>
            The fully qualified type of the ConverterRegistry class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="F:log4net.Util.TypeConverters.ConverterRegistry.s_type2converter">
      <summary>
            Mapping from <see cref="T:System.Type" /> to type converter.
            </summary>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConverterRegistry.#ctor">
      <summary>
            Private constructor
            </summary>
      <remarks>
            Initializes a new instance of the <see cref="T:log4net.Util.TypeConverters.ConverterRegistry" /> class.
            </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConverterRegistry.AddConverter(System.Type,System.Object)">
      <summary>
            Adds a converter for a specific type.
            </summary>
      <param name="destinationType">The type being converted to.</param>
      <param name="converter">The type converter to use to convert to the destination type.</param>
      <remarks>
        <para>
            Adds a converter instance for a specific type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConverterRegistry.AddConverter(System.Type,System.Type)">
      <summary>
            Adds a converter for a specific type.
            </summary>
      <param name="destinationType">The type being converted to.</param>
      <param name="converterType">The type of the type converter to use to convert to the destination type.</param>
      <remarks>
        <para>
            Adds a converter <see cref="T:System.Type" /> for a specific type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConverterRegistry.GetConvertTo(System.Type,System.Type)">
      <summary>
            Gets the type converter to use to convert values to the destination type.
            </summary>
      <param name="sourceType">The type being converted from.</param>
      <param name="destinationType">The type being converted to.</param>
      <returns>
            The type converter instance to use for type conversions or <c>null</c> 
            if no type converter is found.
            </returns>
      <remarks>
        <para>
            Gets the type converter to use to convert values to the destination type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConverterRegistry.GetConvertFrom(System.Type)">
      <summary>
            Gets the type converter to use to convert values to the destination type.
            </summary>
      <param name="destinationType">The type being converted to.</param>
      <returns>
            The type converter instance to use for type conversions or <c>null</c> 
            if no type converter is found.
            </returns>
      <remarks>
        <para>
            Gets the type converter to use to convert values to the destination type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConverterRegistry.GetConverterFromAttribute(System.Type)">
      <summary>
            Lookups the type converter to use as specified by the attributes on the 
            destination type.
            </summary>
      <param name="destinationType">The type being converted to.</param>
      <returns>
            The type converter instance to use for type conversions or <c>null</c> 
            if no type converter is found.
            </returns>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConverterRegistry.CreateConverterInstance(System.Type)">
      <summary>
            Creates the instance of the type converter.
            </summary>
      <param name="converterType">The type of the type converter.</param>
      <returns>
            The type converter instance to use for type conversions or <c>null</c> 
            if no type converter is found.
            </returns>
      <remarks>
        <para>
            The type specified for the type converter must implement 
            the <see cref="T:log4net.Util.TypeConverters.IConvertFrom" /> or <see cref="T:log4net.Util.TypeConverters.IConvertTo" /> interfaces 
            and must have a public default (no argument) constructor.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.TypeConverters.EncodingConverter">
      <summary>
            Supports conversion from string to <see cref="T:System.Text.Encoding" /> type.
            </summary>
      <remarks>
        <para>
            Supports conversion from string to <see cref="T:System.Text.Encoding" /> type.
            </para>
      </remarks>
      <seealso cref="T:log4net.Util.TypeConverters.ConverterRegistry" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertFrom" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertTo" />
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Util.TypeConverters.EncodingConverter.CanConvertFrom(System.Type)">
      <summary>
            Can the source type be converted to the type supported by this object
            </summary>
      <param name="sourceType">the type to convert</param>
      <returns>true if the conversion is possible</returns>
      <remarks>
        <para>
            Returns <c>true</c> if the <paramref name="sourceType" /> is
            the <see cref="T:System.String" /> type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.EncodingConverter.ConvertFrom(System.Object)">
      <summary>
            Overrides the ConvertFrom method of IConvertFrom.
            </summary>
      <param name="source">the object to convert to an encoding</param>
      <returns>the encoding</returns>
      <remarks>
        <para>
            Uses the <see cref="M:Encoding.GetEncoding(string)" /> method to 
            convert the <see cref="T:System.String" /> argument to an <see cref="T:System.Text.Encoding" />.
            </para>
      </remarks>
      <exception cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException">
            The <paramref name="source" /> object cannot be converted to the
            target type. To check for this condition use the <see cref="M:log4net.Util.TypeConverters.EncodingConverter.CanConvertFrom(System.Type)" />
            method.
            </exception>
    </member>
    <member name="T:log4net.Util.TypeConverters.IConvertTo">
      <summary>
            Interface supported by type converters
            </summary>
      <remarks>
        <para>
            This interface supports conversion from a single type to arbitrary types.
            See <see cref="T:log4net.Util.TypeConverters.TypeConverterAttribute" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.TypeConverters.IConvertTo.CanConvertTo(System.Type)">
      <summary>
            Returns whether this converter can convert the object to the specified type
            </summary>
      <param name="targetType">A Type that represents the type you want to convert to</param>
      <returns>true if the conversion is possible</returns>
      <remarks>
        <para>
            Test if the type supported by this converter can be converted to the
            <paramref name="targetType" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.IConvertTo.ConvertTo(System.Object,System.Type)">
      <summary>
            Converts the given value object to the specified type, using the arguments
            </summary>
      <param name="source">the object to convert</param>
      <param name="targetType">The Type to convert the value parameter to</param>
      <returns>the converted object</returns>
      <remarks>
        <para>
            Converts the <paramref name="source" /> (which must be of the type supported
            by this converter) to the <paramref name="targetType" /> specified..
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.TypeConverters.IPAddressConverter">
      <summary>
            Supports conversion from string to <see cref="T:System.Net.IPAddress" /> type.
            </summary>
      <remarks>
        <para>
            Supports conversion from string to <see cref="T:System.Net.IPAddress" /> type.
            </para>
      </remarks>
      <seealso cref="T:log4net.Util.TypeConverters.ConverterRegistry" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertFrom" />
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Util.TypeConverters.IPAddressConverter.validIpAddressChars">
      <summary>
            Valid characters in an IPv4 or IPv6 address string. (Does not support subnets)
            </summary>
    </member>
    <member name="M:log4net.Util.TypeConverters.IPAddressConverter.CanConvertFrom(System.Type)">
      <summary>
            Can the source type be converted to the type supported by this object
            </summary>
      <param name="sourceType">the type to convert</param>
      <returns>true if the conversion is possible</returns>
      <remarks>
        <para>
            Returns <c>true</c> if the <paramref name="sourceType" /> is
            the <see cref="T:System.String" /> type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.IPAddressConverter.ConvertFrom(System.Object)">
      <summary>
            Overrides the ConvertFrom method of IConvertFrom.
            </summary>
      <param name="source">the object to convert to an IPAddress</param>
      <returns>the IPAddress</returns>
      <remarks>
        <para>
            Uses the <see cref="M:System.Net.IPAddress.Parse(System.String)" /> method to convert the
            <see cref="T:System.String" /> argument to an <see cref="T:System.Net.IPAddress" />.
            If that fails then the string is resolved as a DNS hostname.
            </para>
      </remarks>
      <exception cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException">
            The <paramref name="source" /> object cannot be converted to the
            target type. To check for this condition use the <see cref="M:log4net.Util.TypeConverters.IPAddressConverter.CanConvertFrom(System.Type)" />
            method.
            </exception>
    </member>
    <member name="T:log4net.Util.TypeConverters.PatternLayoutConverter">
      <summary>
            Supports conversion from string to <see cref="T:log4net.Layout.PatternLayout" /> type.
            </summary>
      <remarks>
        <para>
            Supports conversion from string to <see cref="T:log4net.Layout.PatternLayout" /> type.
            </para>
        <para>
            The string is used as the <see cref="P:log4net.Layout.PatternLayout.ConversionPattern" /> 
            of the <see cref="T:log4net.Layout.PatternLayout" />.
            </para>
      </remarks>
      <seealso cref="T:log4net.Util.TypeConverters.ConverterRegistry" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertFrom" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertTo" />
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.TypeConverters.PatternLayoutConverter.CanConvertFrom(System.Type)">
      <summary>
            Can the source type be converted to the type supported by this object
            </summary>
      <param name="sourceType">the type to convert</param>
      <returns>true if the conversion is possible</returns>
      <remarks>
        <para>
            Returns <c>true</c> if the <paramref name="sourceType" /> is
            the <see cref="T:System.String" /> type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.PatternLayoutConverter.ConvertFrom(System.Object)">
      <summary>
            Overrides the ConvertFrom method of IConvertFrom.
            </summary>
      <param name="source">the object to convert to a PatternLayout</param>
      <returns>the PatternLayout</returns>
      <remarks>
        <para>
            Creates and returns a new <see cref="T:log4net.Layout.PatternLayout" /> using
            the <paramref name="source" /><see cref="T:System.String" /> as the
            <see cref="P:log4net.Layout.PatternLayout.ConversionPattern" />.
            </para>
      </remarks>
      <exception cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException">
            The <paramref name="source" /> object cannot be converted to the
            target type. To check for this condition use the <see cref="M:log4net.Util.TypeConverters.PatternLayoutConverter.CanConvertFrom(System.Type)" />
            method.
            </exception>
    </member>
    <member name="T:log4net.Util.TypeConverters.PatternStringConverter">
      <summary>
            Convert between string and <see cref="T:log4net.Util.PatternString" /></summary>
      <remarks>
        <para>
            Supports conversion from string to <see cref="T:log4net.Util.PatternString" /> type, 
            and from a <see cref="T:log4net.Util.PatternString" /> type to a string.
            </para>
        <para>
            The string is used as the <see cref="P:log4net.Util.PatternString.ConversionPattern" /> 
            of the <see cref="T:log4net.Util.PatternString" />.
            </para>
      </remarks>
      <seealso cref="T:log4net.Util.TypeConverters.ConverterRegistry" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertFrom" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertTo" />
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.TypeConverters.PatternStringConverter.CanConvertTo(System.Type)">
      <summary>
            Can the target type be converted to the type supported by this object
            </summary>
      <param name="targetType">A <see cref="T:System.Type" /> that represents the type you want to convert to</param>
      <returns>true if the conversion is possible</returns>
      <remarks>
        <para>
            Returns <c>true</c> if the <paramref name="targetType" /> is
            assignable from a <see cref="T:System.String" /> type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.PatternStringConverter.ConvertTo(System.Object,System.Type)">
      <summary>
            Converts the given value object to the specified type, using the arguments
            </summary>
      <param name="source">the object to convert</param>
      <param name="targetType">The Type to convert the value parameter to</param>
      <returns>the converted object</returns>
      <remarks>
        <para>
            Uses the <see cref="M:PatternString.Format()" /> method to convert the
            <see cref="T:log4net.Util.PatternString" /> argument to a <see cref="T:System.String" />.
            </para>
      </remarks>
      <exception cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException">
            The <paramref name="source" /> object cannot be converted to the
            <paramref name="targetType" />. To check for this condition use the 
            <see cref="M:log4net.Util.TypeConverters.PatternStringConverter.CanConvertTo(System.Type)" /> method.
            </exception>
    </member>
    <member name="M:log4net.Util.TypeConverters.PatternStringConverter.CanConvertFrom(System.Type)">
      <summary>
            Can the source type be converted to the type supported by this object
            </summary>
      <param name="sourceType">the type to convert</param>
      <returns>true if the conversion is possible</returns>
      <remarks>
        <para>
            Returns <c>true</c> if the <paramref name="sourceType" /> is
            the <see cref="T:System.String" /> type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.PatternStringConverter.ConvertFrom(System.Object)">
      <summary>
            Overrides the ConvertFrom method of IConvertFrom.
            </summary>
      <param name="source">the object to convert to a PatternString</param>
      <returns>the PatternString</returns>
      <remarks>
        <para>
            Creates and returns a new <see cref="T:log4net.Util.PatternString" /> using
            the <paramref name="source" /><see cref="T:System.String" /> as the
            <see cref="P:log4net.Util.PatternString.ConversionPattern" />.
            </para>
      </remarks>
      <exception cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException">
            The <paramref name="source" /> object cannot be converted to the
            target type. To check for this condition use the <see cref="M:log4net.Util.TypeConverters.PatternStringConverter.CanConvertFrom(System.Type)" />
            method.
            </exception>
    </member>
    <member name="T:log4net.Util.TypeConverters.TypeConverter">
      <summary>
            Supports conversion from string to <see cref="T:System.Type" /> type.
            </summary>
      <remarks>
        <para>
            Supports conversion from string to <see cref="T:System.Type" /> type.
            </para>
      </remarks>
      <seealso cref="T:log4net.Util.TypeConverters.ConverterRegistry" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertFrom" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertTo" />
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.TypeConverters.TypeConverter.CanConvertFrom(System.Type)">
      <summary>
            Can the source type be converted to the type supported by this object
            </summary>
      <param name="sourceType">the type to convert</param>
      <returns>true if the conversion is possible</returns>
      <remarks>
        <para>
            Returns <c>true</c> if the <paramref name="sourceType" /> is
            the <see cref="T:System.String" /> type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.TypeConverter.ConvertFrom(System.Object)">
      <summary>
            Overrides the ConvertFrom method of IConvertFrom.
            </summary>
      <param name="source">the object to convert to a Type</param>
      <returns>the Type</returns>
      <remarks>
        <para>
            Uses the <see cref="M:Type.GetType(string,bool)" /> method to convert the
            <see cref="T:System.String" /> argument to a <see cref="T:System.Type" />.
            Additional effort is made to locate partially specified types
            by searching the loaded assemblies.
            </para>
      </remarks>
      <exception cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException">
            The <paramref name="source" /> object cannot be converted to the
            target type. To check for this condition use the <see cref="M:log4net.Util.TypeConverters.TypeConverter.CanConvertFrom(System.Type)" />
            method.
            </exception>
    </member>
    <member name="T:log4net.Util.TypeConverters.TypeConverterAttribute">
      <summary>
            Attribute used to associate a type converter
            </summary>
      <remarks>
        <para>
            Class and Interface level attribute that specifies a type converter
            to use with the associated type.
            </para>
        <para>
            To associate a type converter with a target type apply a
            <c>TypeConverterAttribute</c> to the target type. Specify the
            type of the type converter on the attribute.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.TypeConverters.TypeConverterAttribute.m_typeName">
      <summary>
            The string type name of the type converter
            </summary>
    </member>
    <member name="M:log4net.Util.TypeConverters.TypeConverterAttribute.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Default constructor
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.TypeConverterAttribute.#ctor(System.String)">
      <summary>
            Create a new type converter attribute for the specified type name
            </summary>
      <param name="typeName">The string type name of the type converter</param>
      <remarks>
        <para>
            The type specified must implement the <see cref="T:log4net.Util.TypeConverters.IConvertFrom" /> 
            or the <see cref="T:log4net.Util.TypeConverters.IConvertTo" /> interfaces.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.TypeConverterAttribute.#ctor(System.Type)">
      <summary>
            Create a new type converter attribute for the specified type
            </summary>
      <param name="converterType">The type of the type converter</param>
      <remarks>
        <para>
            The type specified must implement the <see cref="T:log4net.Util.TypeConverters.IConvertFrom" /> 
            or the <see cref="T:log4net.Util.TypeConverters.IConvertTo" /> interfaces.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.TypeConverters.TypeConverterAttribute.ConverterTypeName">
      <summary>
            The string type name of the type converter 
            </summary>
      <value>
            The string type name of the type converter 
            </value>
      <remarks>
        <para>
            The type specified must implement the <see cref="T:log4net.Util.TypeConverters.IConvertFrom" /> 
            or the <see cref="T:log4net.Util.TypeConverters.IConvertTo" /> interfaces.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.AppenderAttachedImpl">
      <summary>
            A straightforward implementation of the <see cref="T:log4net.Core.IAppenderAttachable" /> interface.
            </summary>
      <remarks>
        <para>
            This is the default implementation of the <see cref="T:log4net.Core.IAppenderAttachable" />
            interface. Implementors of the <see cref="T:log4net.Core.IAppenderAttachable" /> interface
            should aggregate an instance of this type.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.AppenderAttachedImpl.m_appenderList">
      <summary>
            List of appenders
            </summary>
    </member>
    <member name="F:log4net.Util.AppenderAttachedImpl.m_appenderArray">
      <summary>
            Array of appenders, used to cache the m_appenderList
            </summary>
    </member>
    <member name="F:log4net.Util.AppenderAttachedImpl.declaringType">
      <summary>
            The fully qualified type of the AppenderAttachedImpl class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Util.AppenderAttachedImpl.#ctor">
      <summary>
            Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.AppenderAttachedImpl" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.AppenderAttachedImpl.AppendLoopOnAppenders(log4net.Core.LoggingEvent)">
      <summary>
            Append on on all attached appenders.
            </summary>
      <param name="loggingEvent">The event being logged.</param>
      <returns>The number of appenders called.</returns>
      <remarks>
        <para>
            Calls the <see cref="M:log4net.Appender.IAppender.DoAppend(log4net.Core.LoggingEvent)" /> method on all 
            attached appenders.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.AppenderAttachedImpl.AppendLoopOnAppenders(log4net.Core.LoggingEvent[])">
      <summary>
            Append on on all attached appenders.
            </summary>
      <param name="loggingEvents">The array of events being logged.</param>
      <returns>The number of appenders called.</returns>
      <remarks>
        <para>
            Calls the <see cref="M:log4net.Appender.IAppender.DoAppend(log4net.Core.LoggingEvent)" /> method on all 
            attached appenders.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.AppenderAttachedImpl.CallAppend(log4net.Appender.IAppender,log4net.Core.LoggingEvent[])">
      <summary>
            Calls the DoAppende method on the <see cref="T:log4net.Appender.IAppender" /> with 
            the <see cref="T:log4net.Core.LoggingEvent" /> objects supplied.
            </summary>
      <param name="appender">The appender</param>
      <param name="loggingEvents">The events</param>
      <remarks>
        <para>
            If the <paramref name="appender" /> supports the <see cref="T:log4net.Appender.IBulkAppender" />
            interface then the <paramref name="loggingEvents" /> will be passed 
            through using that interface. Otherwise the <see cref="T:log4net.Core.LoggingEvent" />
            objects in the array will be passed one at a time.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.AppenderAttachedImpl.AddAppender(log4net.Appender.IAppender)">
      <summary>
            Attaches an appender.
            </summary>
      <param name="newAppender">The appender to add.</param>
      <remarks>
        <para>
            If the appender is already in the list it won't be added again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.AppenderAttachedImpl.GetAppender(System.String)">
      <summary>
            Gets an attached appender with the specified name.
            </summary>
      <param name="name">The name of the appender to get.</param>
      <returns>
            The appender with the name specified, or <c>null</c> if no appender with the
            specified name is found.
            </returns>
      <remarks>
        <para>
            Lookup an attached appender by name.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.AppenderAttachedImpl.RemoveAllAppenders">
      <summary>
            Removes all attached appenders.
            </summary>
      <remarks>
        <para>
            Removes and closes all attached appenders
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.AppenderAttachedImpl.RemoveAppender(log4net.Appender.IAppender)">
      <summary>
            Removes the specified appender from the list of attached appenders.
            </summary>
      <param name="appender">The appender to remove.</param>
      <returns>The appender removed from the list</returns>
      <remarks>
        <para>
            The appender removed is not closed.
            If you are discarding the appender you must call
            <see cref="M:log4net.Appender.IAppender.Close" /> on the appender removed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.AppenderAttachedImpl.RemoveAppender(System.String)">
      <summary>
            Removes the appender with the specified name from the list of appenders.
            </summary>
      <param name="name">The name of the appender to remove.</param>
      <returns>The appender removed from the list</returns>
      <remarks>
        <para>
            The appender removed is not closed.
            If you are discarding the appender you must call
            <see cref="M:log4net.Appender.IAppender.Close" /> on the appender removed.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.AppenderAttachedImpl.Appenders">
      <summary>
            Gets all attached appenders.
            </summary>
      <returns>
            A collection of attached appenders, or <c>null</c> if there
            are no attached appenders.
            </returns>
      <remarks>
        <para>
            The read only collection of all currently attached appenders.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.CompositeProperties">
      <summary>
            This class aggregates several PropertiesDictionary collections together.
            </summary>
      <remarks>
        <para>
            Provides a dictionary style lookup over an ordered list of
            <see cref="T:log4net.Util.PropertiesDictionary" /> collections.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.CompositeProperties.#ctor">
      <summary>
            Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.CompositeProperties" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.CompositeProperties.Add(log4net.Util.ReadOnlyPropertiesDictionary)">
      <summary>
            Add a Properties Dictionary to this composite collection
            </summary>
      <param name="properties">the properties to add</param>
      <remarks>
        <para>
            Properties dictionaries added first take precedence over dictionaries added
            later.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.CompositeProperties.Flatten">
      <summary>
            Flatten this composite collection into a single properties dictionary
            </summary>
      <returns>the flattened dictionary</returns>
      <remarks>
        <para>
            Reduces the collection of ordered dictionaries to a single dictionary
            containing the resultant values for the keys.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.CompositeProperties.Item(System.String)">
      <summary>
            Gets the value of a property
            </summary>
      <value>
            The value for the property with the specified key
            </value>
      <remarks>
        <para>
            Looks up the value for the <paramref name="key" /> specified.
            The <see cref="T:log4net.Util.PropertiesDictionary" /> collections are searched
            in the order in which they were added to this collection. The value
            returned is the value held by the first collection that contains
            the specified key.
            </para>
        <para>
            If none of the collections contain the specified key then
            <c>null</c> is returned.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.ContextPropertiesBase">
      <summary>
            Base class for Context Properties implementations
            </summary>
      <remarks>
        <para>
            This class defines a basic property get set accessor
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="P:log4net.Util.ContextPropertiesBase.Item(System.String)">
      <summary>
            Gets or sets the value of a property
            </summary>
      <value>
            The value for the property with the specified key
            </value>
      <remarks>
        <para>
            Gets or sets the value of a property
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.ConverterInfo">
      <summary>
            Wrapper class used to map converter names to converter types
            </summary>
      <remarks>
        <para>
            Pattern converter info class used during configuration by custom
            PatternString and PatternLayer converters.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ConverterInfo.#ctor">
      <summary>
            default constructor
            </summary>
    </member>
    <member name="M:log4net.Util.ConverterInfo.AddProperty(log4net.Util.PropertyEntry)">
      <summary>
      </summary>
      <param name="entry">
      </param>
    </member>
    <member name="P:log4net.Util.ConverterInfo.Name">
      <summary>
            Gets or sets the name of the conversion pattern
            </summary>
      <remarks>
        <para>
            The name of the pattern in the format string
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.ConverterInfo.Type">
      <summary>
            Gets or sets the type of the converter
            </summary>
      <remarks>
        <para>
            The value specified must extend the 
            <see cref="T:log4net.Util.PatternConverter" /> type.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.ConverterInfo.Properties">
      <summary>
      </summary>
    </member>
    <member name="T:log4net.Util.TextWriterAdapter">
      <summary>
            Adapter that extends <see cref="T:System.IO.TextWriter" /> and forwards all
            messages to an instance of <see cref="T:System.IO.TextWriter" />.
            </summary>
      <remarks>
        <para>
            Adapter that extends <see cref="T:System.IO.TextWriter" /> and forwards all
            messages to an instance of <see cref="T:System.IO.TextWriter" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Util.TextWriterAdapter.m_writer">
      <summary>
            The writer to forward messages to
            </summary>
    </member>
    <member name="M:log4net.Util.TextWriterAdapter.#ctor(System.IO.TextWriter)">
      <summary>
            Create an instance of <see cref="T:log4net.Util.TextWriterAdapter" /> that forwards all
            messages to a <see cref="T:System.IO.TextWriter" />.
            </summary>
      <param name="writer">The <see cref="T:System.IO.TextWriter" /> to forward to</param>
      <remarks>
        <para>
            Create an instance of <see cref="T:log4net.Util.TextWriterAdapter" /> that forwards all
            messages to a <see cref="T:System.IO.TextWriter" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TextWriterAdapter.Close">
      <summary>
            Closes the writer and releases any system resources associated with the writer
            </summary>
      <remarks>
        <para>
        </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TextWriterAdapter.Dispose(System.Boolean)">
      <summary>
            Dispose this writer
            </summary>
      <param name="disposing">flag indicating if we are being disposed</param>
      <remarks>
        <para>
            Dispose this writer
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TextWriterAdapter.Flush">
      <summary>
            Flushes any buffered output
            </summary>
      <remarks>
        <para>
            Clears all buffers for the writer and causes any buffered data to be written 
            to the underlying device
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TextWriterAdapter.Write(System.Char)">
      <summary>
            Writes a character to the wrapped TextWriter
            </summary>
      <param name="value">the value to write to the TextWriter</param>
      <remarks>
        <para>
            Writes a character to the wrapped TextWriter
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TextWriterAdapter.Write(System.Char[],System.Int32,System.Int32)">
      <summary>
            Writes a character buffer to the wrapped TextWriter
            </summary>
      <param name="buffer">the data buffer</param>
      <param name="index">the start index</param>
      <param name="count">the number of characters to write</param>
      <remarks>
        <para>
            Writes a character buffer to the wrapped TextWriter
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TextWriterAdapter.Write(System.String)">
      <summary>
            Writes a string to the wrapped TextWriter
            </summary>
      <param name="value">the value to write to the TextWriter</param>
      <remarks>
        <para>
            Writes a string to the wrapped TextWriter
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.TextWriterAdapter.Writer">
      <summary>
            Gets or sets the underlying <see cref="T:System.IO.TextWriter" />.
            </summary>
      <value>
            The underlying <see cref="T:System.IO.TextWriter" />.
            </value>
      <remarks>
        <para>
            Gets or sets the underlying <see cref="T:System.IO.TextWriter" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.TextWriterAdapter.Encoding">
      <summary>
            The Encoding in which the output is written
            </summary>
      <value>
            The <see cref="P:log4net.Util.TextWriterAdapter.Encoding" /></value>
      <remarks>
        <para>
            The Encoding in which the output is written
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.TextWriterAdapter.FormatProvider">
      <summary>
            Gets an object that controls formatting
            </summary>
      <value>
            The format provider
            </value>
      <remarks>
        <para>
            Gets an object that controls formatting
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.TextWriterAdapter.NewLine">
      <summary>
            Gets or sets the line terminator string used by the TextWriter
            </summary>
      <value>
            The line terminator to use
            </value>
      <remarks>
        <para>
            Gets or sets the line terminator string used by the TextWriter
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.QuietTextWriter">
      <summary>
        <see cref="T:System.IO.TextWriter" /> that does not leak exceptions
            </summary>
      <remarks>
        <para>
          <see cref="T:log4net.Util.QuietTextWriter" /> does not throw exceptions when things go wrong. 
            Instead, it delegates error handling to its <see cref="T:log4net.Core.IErrorHandler" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.QuietTextWriter.m_errorHandler">
      <summary>
            The error handler instance to pass all errors to
            </summary>
    </member>
    <member name="F:log4net.Util.QuietTextWriter.m_closed">
      <summary>
            Flag to indicate if this writer is closed
            </summary>
    </member>
    <member name="M:log4net.Util.QuietTextWriter.#ctor(System.IO.TextWriter,log4net.Core.IErrorHandler)">
      <summary>
            Constructor
            </summary>
      <param name="writer">the writer to actually write to</param>
      <param name="errorHandler">the error handler to report error to</param>
      <remarks>
        <para>
            Create a new QuietTextWriter using a writer and error handler
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.QuietTextWriter.Write(System.Char)">
      <summary>
            Writes a character to the underlying writer
            </summary>
      <param name="value">the char to write</param>
      <remarks>
        <para>
            Writes a character to the underlying writer
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.QuietTextWriter.Write(System.Char[],System.Int32,System.Int32)">
      <summary>
            Writes a buffer to the underlying writer
            </summary>
      <param name="buffer">the buffer to write</param>
      <param name="index">the start index to write from</param>
      <param name="count">the number of characters to write</param>
      <remarks>
        <para>
            Writes a buffer to the underlying writer
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.QuietTextWriter.Write(System.String)">
      <summary>
            Writes a string to the output.
            </summary>
      <param name="value">The string data to write to the output.</param>
      <remarks>
        <para>
            Writes a string to the output.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.QuietTextWriter.Close">
      <summary>
            Closes the underlying output writer.
            </summary>
      <remarks>
        <para>
            Closes the underlying output writer.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.QuietTextWriter.ErrorHandler">
      <summary>
            Gets or sets the error handler that all errors are passed to.
            </summary>
      <value>
            The error handler that all errors are passed to.
            </value>
      <remarks>
        <para>
            Gets or sets the error handler that all errors are passed to.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.QuietTextWriter.Closed">
      <summary>
            Gets a value indicating whether this writer is closed.
            </summary>
      <value>
        <c>true</c> if this writer is closed, otherwise <c>false</c>.
            </value>
      <remarks>
        <para>
            Gets a value indicating whether this writer is closed.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.CountingQuietTextWriter">
      <summary>
            Subclass of <see cref="T:log4net.Util.QuietTextWriter" /> that maintains a count of 
            the number of bytes written.
            </summary>
      <remarks>
        <para>
            This writer counts the number of bytes written.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.CountingQuietTextWriter.m_countBytes">
      <summary>
            Total number of bytes written.
            </summary>
    </member>
    <member name="M:log4net.Util.CountingQuietTextWriter.#ctor(System.IO.TextWriter,log4net.Core.IErrorHandler)">
      <summary>
            Constructor
            </summary>
      <param name="writer">The <see cref="T:System.IO.TextWriter" /> to actually write to.</param>
      <param name="errorHandler">The <see cref="T:log4net.Core.IErrorHandler" /> to report errors to.</param>
      <remarks>
        <para>
            Creates a new instance of the <see cref="T:log4net.Util.CountingQuietTextWriter" /> class 
            with the specified <see cref="T:System.IO.TextWriter" /> and <see cref="T:log4net.Core.IErrorHandler" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.CountingQuietTextWriter.Write(System.Char)">
      <summary>
            Writes a character to the underlying writer and counts the number of bytes written.
            </summary>
      <param name="value">the char to write</param>
      <remarks>
        <para>
            Overrides implementation of <see cref="T:log4net.Util.QuietTextWriter" />. Counts
            the number of bytes written.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.CountingQuietTextWriter.Write(System.Char[],System.Int32,System.Int32)">
      <summary>
            Writes a buffer to the underlying writer and counts the number of bytes written.
            </summary>
      <param name="buffer">the buffer to write</param>
      <param name="index">the start index to write from</param>
      <param name="count">the number of characters to write</param>
      <remarks>
        <para>
            Overrides implementation of <see cref="T:log4net.Util.QuietTextWriter" />. Counts
            the number of bytes written.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.CountingQuietTextWriter.Write(System.String)">
      <summary>
            Writes a string to the output and counts the number of bytes written.
            </summary>
      <param name="str">The string data to write to the output.</param>
      <remarks>
        <para>
            Overrides implementation of <see cref="T:log4net.Util.QuietTextWriter" />. Counts
            the number of bytes written.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.CountingQuietTextWriter.Count">
      <summary>
            Gets or sets the total number of bytes written.
            </summary>
      <value>
            The total number of bytes written.
            </value>
      <remarks>
        <para>
            Gets or sets the total number of bytes written.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.CyclicBuffer">
      <summary>
            A fixed size rolling buffer of logging events.
            </summary>
      <remarks>
        <para>
            An array backed fixed size leaky bucket.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Util.CyclicBuffer.#ctor(System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="maxSize">The maximum number of logging events in the buffer.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.CyclicBuffer" /> class with 
            the specified maximum number of buffered logging events.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="maxSize" /> argument is not a positive integer.</exception>
    </member>
    <member name="M:log4net.Util.CyclicBuffer.Append(log4net.Core.LoggingEvent)">
      <summary>
            Appends a <paramref name="loggingEvent" /> to the buffer.
            </summary>
      <param name="loggingEvent">The event to append to the buffer.</param>
      <returns>The event discarded from the buffer, if the buffer is full, otherwise <c>null</c>.</returns>
      <remarks>
        <para>
            Append an event to the buffer. If the buffer still contains free space then
            <c>null</c> is returned. If the buffer is full then an event will be dropped
            to make space for the new event, the event dropped is returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.CyclicBuffer.PopOldest">
      <summary>
            Get and remove the oldest event in the buffer.
            </summary>
      <returns>The oldest logging event in the buffer</returns>
      <remarks>
        <para>
            Gets the oldest (first) logging event in the buffer and removes it 
            from the buffer.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.CyclicBuffer.PopAll">
      <summary>
            Pops all the logging events from the buffer into an array.
            </summary>
      <returns>An array of all the logging events in the buffer.</returns>
      <remarks>
        <para>
            Get all the events in the buffer and clear the buffer.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.CyclicBuffer.Clear">
      <summary>
            Clear the buffer
            </summary>
      <remarks>
        <para>
            Clear the buffer of all events. The events in the buffer are lost.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.CyclicBuffer.Item(System.Int32)">
      <summary>
            Gets the <paramref name="i" />th oldest event currently in the buffer.
            </summary>
      <value>The <paramref name="i" />th oldest event currently in the buffer.</value>
      <remarks>
        <para>
            If <paramref name="i" /> is outside the range 0 to the number of events
            currently in the buffer, then <c>null</c> is returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.CyclicBuffer.MaxSize">
      <summary>
            Gets the maximum size of the buffer.
            </summary>
      <value>The maximum size of the buffer.</value>
      <remarks>
        <para>
            Gets the maximum size of the buffer
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.CyclicBuffer.Length">
      <summary>
            Gets the number of logging events in the buffer.
            </summary>
      <value>The number of logging events in the buffer.</value>
      <remarks>
        <para>
            This number is guaranteed to be in the range 0 to <see cref="P:log4net.Util.CyclicBuffer.MaxSize" />
            (inclusive).
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.EmptyCollection">
      <summary>
            An always empty <see cref="T:System.Collections.ICollection" />.
            </summary>
      <remarks>
        <para>
            A singleton implementation of the <see cref="T:System.Collections.ICollection" />
            interface that always represents an empty collection.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.EmptyCollection.s_instance">
      <summary>
            The singleton instance of the empty collection.
            </summary>
    </member>
    <member name="M:log4net.Util.EmptyCollection.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Util.EmptyCollection" /> class. 
            </summary>
      <remarks>
        <para>
            Uses a private access modifier to enforce the singleton pattern.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.EmptyCollection.CopyTo(System.Array,System.Int32)">
      <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection" /> to an 
            <see cref="T:System.Array" />, starting at a particular Array index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array" /> 
            that is the destination of the elements copied from 
            <see cref="T:System.Collections.ICollection" />. The Array must have zero-based 
            indexing.</param>
      <param name="index">The zero-based index in array at which 
            copying begins.</param>
      <remarks>
        <para>
            As the collection is empty no values are copied into the array.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.EmptyCollection.GetEnumerator">
      <summary>
            Returns an enumerator that can iterate through a collection.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" /> that can be used to 
            iterate through the collection.
            </returns>
      <remarks>
        <para>
            As the collection is empty a <see cref="T:log4net.Util.NullEnumerator" /> is returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyCollection.Instance">
      <summary>
            Gets the singleton instance of the empty collection.
            </summary>
      <returns>The singleton instance of the empty collection.</returns>
      <remarks>
        <para>
            Gets the singleton instance of the empty collection.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyCollection.IsSynchronized">
      <summary>
            Gets a value indicating if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread-safe).
            </summary>
      <value>
        <b>true</b> if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread-safe); otherwise, <b>false</b>.
            </value>
      <remarks>
        <para>
            For the <see cref="T:log4net.Util.EmptyCollection" /> this property is always <c>true</c>.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyCollection.Count">
      <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
            The number of elements contained in the <see cref="T:System.Collections.ICollection" />.
            </value>
      <remarks>
        <para>
            As the collection is empty the <see cref="P:log4net.Util.EmptyCollection.Count" /> is always <c>0</c>.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyCollection.SyncRoot">
      <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
            An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </value>
      <remarks>
        <para>
            As the collection is empty and thread safe and synchronized this instance is also
            the <see cref="P:log4net.Util.EmptyCollection.SyncRoot" /> object.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.EmptyDictionary">
      <summary>
            An always empty <see cref="T:System.Collections.IDictionary" />.
            </summary>
      <remarks>
        <para>
            A singleton implementation of the <see cref="T:System.Collections.IDictionary" />
            interface that always represents an empty collection.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.EmptyDictionary.s_instance">
      <summary>
            The singleton instance of the empty dictionary.
            </summary>
    </member>
    <member name="M:log4net.Util.EmptyDictionary.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Util.EmptyDictionary" /> class. 
            </summary>
      <remarks>
        <para>
            Uses a private access modifier to enforce the singleton pattern.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.EmptyDictionary.CopyTo(System.Array,System.Int32)">
      <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection" /> to an 
            <see cref="T:System.Array" />, starting at a particular Array index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array" /> 
            that is the destination of the elements copied from 
            <see cref="T:System.Collections.ICollection" />. The Array must have zero-based 
            indexing.</param>
      <param name="index">The zero-based index in array at which 
            copying begins.</param>
      <remarks>
        <para>
            As the collection is empty no values are copied into the array.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.EmptyDictionary.Add(System.Object,System.Object)">
      <summary>
            Adds an element with the provided key and value to the 
            <see cref="T:log4net.Util.EmptyDictionary" />.
            </summary>
      <param name="key">The <see cref="T:System.Object" /> to use as the key of the element to add.</param>
      <param name="value">The <see cref="T:System.Object" /> to use as the value of the element to add.</param>
      <remarks>
        <para>
            As the collection is empty no new values can be added. A <see cref="T:System.InvalidOperationException" />
            is thrown if this method is called.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">This dictionary is always empty and cannot be modified.</exception>
    </member>
    <member name="M:log4net.Util.EmptyDictionary.Clear">
      <summary>
            Removes all elements from the <see cref="T:log4net.Util.EmptyDictionary" />.
            </summary>
      <remarks>
        <para>
            As the collection is empty no values can be removed. A <see cref="T:System.InvalidOperationException" />
            is thrown if this method is called.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">This dictionary is always empty and cannot be modified.</exception>
    </member>
    <member name="M:log4net.Util.EmptyDictionary.Contains(System.Object)">
      <summary>
            Determines whether the <see cref="T:log4net.Util.EmptyDictionary" /> contains an element 
            with the specified key.
            </summary>
      <param name="key">The key to locate in the <see cref="T:log4net.Util.EmptyDictionary" />.</param>
      <returns>
        <c>false</c>
      </returns>
      <remarks>
        <para>
            As the collection is empty the <see cref="M:log4net.Util.EmptyDictionary.Contains(System.Object)" /> method always returns <c>false</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.EmptyDictionary.GetEnumerator">
      <summary>
            Returns an enumerator that can iterate through a collection.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" /> that can be used to 
            iterate through the collection.
            </returns>
      <remarks>
        <para>
            As the collection is empty a <see cref="T:log4net.Util.NullEnumerator" /> is returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.EmptyDictionary.Remove(System.Object)">
      <summary>
            Removes the element with the specified key from the <see cref="T:log4net.Util.EmptyDictionary" />.
            </summary>
      <param name="key">The key of the element to remove.</param>
      <remarks>
        <para>
            As the collection is empty no values can be removed. A <see cref="T:System.InvalidOperationException" />
            is thrown if this method is called.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">This dictionary is always empty and cannot be modified.</exception>
    </member>
    <member name="P:log4net.Util.EmptyDictionary.Instance">
      <summary>
            Gets the singleton instance of the <see cref="T:log4net.Util.EmptyDictionary" />.
            </summary>
      <returns>The singleton instance of the <see cref="T:log4net.Util.EmptyDictionary" />.</returns>
      <remarks>
        <para>
            Gets the singleton instance of the <see cref="T:log4net.Util.EmptyDictionary" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyDictionary.IsSynchronized">
      <summary>
            Gets a value indicating if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread-safe).
            </summary>
      <value>
        <b>true</b> if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread-safe); otherwise, <b>false</b>.
            </value>
      <remarks>
        <para>
            For the <see cref="T:log4net.Util.EmptyCollection" /> this property is always <b>true</b>.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyDictionary.Count">
      <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.ICollection" /></summary>
      <value>
            The number of elements contained in the <see cref="T:System.Collections.ICollection" />.
            </value>
      <remarks>
        <para>
            As the collection is empty the <see cref="P:log4net.Util.EmptyDictionary.Count" /> is always <c>0</c>.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyDictionary.SyncRoot">
      <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
            An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </value>
      <remarks>
        <para>
            As the collection is empty and thread safe and synchronized this instance is also
            the <see cref="P:log4net.Util.EmptyDictionary.SyncRoot" /> object.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyDictionary.IsFixedSize">
      <summary>
            Gets a value indicating whether the <see cref="T:log4net.Util.EmptyDictionary" /> has a fixed size.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            As the collection is empty <see cref="P:log4net.Util.EmptyDictionary.IsFixedSize" /> always returns <c>true</c>.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyDictionary.IsReadOnly">
      <summary>
            Gets a value indicating whether the <see cref="T:log4net.Util.EmptyDictionary" /> is read-only.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            As the collection is empty <see cref="P:log4net.Util.EmptyDictionary.IsReadOnly" /> always returns <c>true</c>.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyDictionary.Keys">
      <summary>
            Gets an <see cref="T:System.Collections.ICollection" /> containing the keys of the <see cref="T:log4net.Util.EmptyDictionary" />.
            </summary>
      <value>An <see cref="T:System.Collections.ICollection" /> containing the keys of the <see cref="T:log4net.Util.EmptyDictionary" />.</value>
      <remarks>
        <para>
            As the collection is empty a <see cref="T:log4net.Util.EmptyCollection" /> is returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyDictionary.Values">
      <summary>
            Gets an <see cref="T:System.Collections.ICollection" /> containing the values of the <see cref="T:log4net.Util.EmptyDictionary" />.
            </summary>
      <value>An <see cref="T:System.Collections.ICollection" /> containing the values of the <see cref="T:log4net.Util.EmptyDictionary" />.</value>
      <remarks>
        <para>
            As the collection is empty a <see cref="T:log4net.Util.EmptyCollection" /> is returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyDictionary.Item(System.Object)">
      <summary>
            Gets or sets the element with the specified key.
            </summary>
      <param name="key">The key of the element to get or set.</param>
      <value>
        <c>null</c>
      </value>
      <remarks>
        <para>
            As the collection is empty no values can be looked up or stored. 
            If the index getter is called then <c>null</c> is returned.
            A <see cref="T:System.InvalidOperationException" /> is thrown if the setter is called.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">This dictionary is always empty and cannot be modified.</exception>
    </member>
    <member name="T:log4net.Util.FormattingInfo">
      <summary>
            Contain the information obtained when parsing formatting modifiers 
            in conversion modifiers.
            </summary>
      <remarks>
        <para>
            Holds the formatting information extracted from the format string by
            the <see cref="T:log4net.Util.PatternParser" />. This is used by the <see cref="T:log4net.Util.PatternConverter" />
            objects when rendering the output.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Util.FormattingInfo.#ctor">
      <summary>
            Defaut Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.FormattingInfo" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.FormattingInfo.#ctor(System.Int32,System.Int32,System.Boolean)">
      <summary>
            Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.FormattingInfo" /> class
            with the specified parameters.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.FormattingInfo.Min">
      <summary>
            Gets or sets the minimum value.
            </summary>
      <value>
            The minimum value.
            </value>
      <remarks>
        <para>
            Gets or sets the minimum value.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.FormattingInfo.Max">
      <summary>
            Gets or sets the maximum value.
            </summary>
      <value>
            The maximum value.
            </value>
      <remarks>
        <para>
            Gets or sets the maximum value.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.FormattingInfo.LeftAlign">
      <summary>
            Gets or sets a flag indicating whether left align is enabled
            or not.
            </summary>
      <value>
            A flag indicating whether left align is enabled or not.
            </value>
      <remarks>
        <para>
            Gets or sets a flag indicating whether left align is enabled or not.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.GlobalContextProperties">
      <summary>
            Implementation of Properties collection for the <see cref="T:log4net.GlobalContext" /></summary>
      <remarks>
        <para>
            This class implements a properties collection that is thread safe and supports both
            storing properties and capturing a read only copy of the current propertied.
            </para>
        <para>
            This class is optimized to the scenario where the properties are read frequently
            and are modified infrequently.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Util.GlobalContextProperties.m_readOnlyProperties">
      <summary>
            The read only copy of the properties.
            </summary>
      <remarks>
        <para>
            This variable is declared <c>volatile</c> to prevent the compiler and JIT from
            reordering reads and writes of this thread performed on different threads.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Util.GlobalContextProperties.m_syncRoot">
      <summary>
            Lock object used to synchronize updates within this instance
            </summary>
    </member>
    <member name="M:log4net.Util.GlobalContextProperties.#ctor">
      <summary>
            Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.GlobalContextProperties" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.GlobalContextProperties.Remove(System.String)">
      <summary>
            Remove a property from the global context
            </summary>
      <param name="key">the key for the entry to remove</param>
      <remarks>
        <para>
            Removing an entry from the global context properties is relatively expensive compared
            with reading a value. 
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.GlobalContextProperties.Clear">
      <summary>
            Clear the global context properties
            </summary>
    </member>
    <member name="M:log4net.Util.GlobalContextProperties.GetReadOnlyProperties">
      <summary>
            Get a readonly immutable copy of the properties
            </summary>
      <returns>the current global context properties</returns>
      <remarks>
        <para>
            This implementation is fast because the GlobalContextProperties class
            stores a readonly copy of the properties.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.GlobalContextProperties.Item(System.String)">
      <summary>
            Gets or sets the value of a property
            </summary>
      <value>
            The value for the property with the specified key
            </value>
      <remarks>
        <para>
            Reading the value for a key is faster than setting the value.
            When the value is written a new read only copy of 
            the properties is created.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.ILogExtensions">
      <summary>
            The static class ILogExtensions contains a set of widely used
            methods that ease the interaction with the ILog interface implementations.
            </summary>
      <remarks>
        <para>
            This class contains methods for logging at different levels and checks the
            properties for determining if those logging levels are enabled in the current
            configuration.
            </para>
      </remarks>
      <example>Simple example of logging messages
            <code lang="C#">
            using log4net.Util;
            
            ILog log = LogManager.GetLogger("application-log");
            
            log.InfoExt("Application Start");
            log.DebugExt("This is a debug message");
            </code></example>
    </member>
    <member name="F:log4net.Util.ILogExtensions.declaringType">
      <summary>
            The fully qualified type of the Logger class.
            </summary>
    </member>
    <member name="M:log4net.Util.ILogExtensions.DebugExt(log4net.ILog,System.Func{System.Object})">
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Debug" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="callback">The lambda expression that gets the object to log.</param>
      <remarks>
        <para>
            This method first checks if this logger is <c>INFO</c>
            enabled by reading the value <seealso cref="P:log4net.ILog.IsDebugEnabled" /> property.
            This check happens always and does not depend on the <seealso cref="T:log4net.ILog" />
            implementation.  If this logger is <c>INFO</c> enabled, then it converts 
            the message object (retrieved by invocation of the provided callback) to a 
            string by invoking the appropriate <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />.
            It then proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of 
            the additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:log4net.Util.ILogExtensions.DebugExt(log4net.ILog,System.Func{System.Object},System.Exception)" /> form instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Debug(System.Object)" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.DebugExt(log4net.ILog,System.Func{System.Object},System.Exception)">
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Debug" /> level including
            the stack trace of the <see cref="T:System.Exception" /> passed
            as a parameter.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="callback">The lambda expression that gets the object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            See the <see cref="M:log4net.Util.ILogExtensions.DebugExt(log4net.ILog,System.Object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Debug(System.Object)" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.DebugExt(log4net.ILog,System.Object)">
      <overloads>Log a message object with the <see cref="F:log4net.Core.Level.Debug" /> level.</overloads> //TODO
            <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Debug" /> level.
            </summary><param name="logger">The logger on which the message is logged.</param><param name="message">The message object to log.</param><remarks><para>
            This method first checks if this logger is <c>INFO</c>
            enabled by reading the value <seealso cref="P:log4net.ILog.IsDebugEnabled" /> property.
            This check happens always and does not depend on the <seealso cref="T:log4net.ILog" />
            implementation. If this logger is <c>INFO</c> enabled, then it converts 
            the message object (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of 
            the additivity flag.
            </para><para><b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:log4net.Util.ILogExtensions.DebugExt(log4net.ILog,System.Object,System.Exception)" /> form instead.
            </para></remarks><seealso cref="M:log4net.ILog.Debug(System.Object)" /><seealso cref="P:log4net.ILog.IsDebugEnabled" /></member>
    <member name="M:log4net.Util.ILogExtensions.DebugExt(log4net.ILog,System.Object,System.Exception)">
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Debug" /> level including
            the stack trace of the <see cref="T:System.Exception" /> passed
            as a parameter.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            See the <see cref="M:log4net.Util.ILogExtensions.DebugExt(log4net.ILog,System.Object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Debug(System.Object)" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.DebugFormatExt(log4net.ILog,System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Debug" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.DebugExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Debug(System.Object)" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.DebugFormatExt(log4net.ILog,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Debug" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.DebugExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Debug(System.Object)" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.DebugFormatExt(log4net.ILog,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Debug" /> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.DebugExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Debug(System.Object)" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.DebugFormatExt(log4net.ILog,System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Debug" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.DebugExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Debug(System.Object)" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.DebugFormatExt(log4net.ILog,System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Debug" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.DebugExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Debug(System.Object)" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.InfoExt(log4net.ILog,System.Func{System.Object})">
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Info" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="callback">The lambda expression that gets the object to log.</param>
      <remarks>
        <para>
            This method first checks if this logger is <c>INFO</c>
            enabled by reading the value <seealso cref="P:log4net.ILog.IsInfoEnabled" /> property.
            This check happens always and does not depend on the <seealso cref="T:log4net.ILog" />
            implementation.  If this logger is <c>INFO</c> enabled, then it converts 
            the message object (retrieved by invocation of the provided callback) to a 
            string by invoking the appropriate <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />.
            It then proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of 
            the additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:log4net.Util.ILogExtensions.InfoExt(log4net.ILog,System.Func{System.Object},System.Exception)" /> form instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Info(System.Object)" />
      <seealso cref="P:log4net.ILog.IsInfoEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.InfoExt(log4net.ILog,System.Func{System.Object},System.Exception)">
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Info" /> level including
            the stack trace of the <see cref="T:System.Exception" /> passed
            as a parameter.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="callback">The lambda expression that gets the object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            See the <see cref="M:log4net.Util.ILogExtensions.InfoExt(log4net.ILog,System.Object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Info(System.Object)" />
      <seealso cref="P:log4net.ILog.IsInfoEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.InfoExt(log4net.ILog,System.Object)">
      <overloads>Log a message object with the <see cref="F:log4net.Core.Level.Info" /> level.</overloads> //TODO
            <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Info" /> level.
            </summary><param name="logger">The logger on which the message is logged.</param><param name="message">The message object to log.</param><remarks><para>
            This method first checks if this logger is <c>INFO</c>
            enabled by reading the value <seealso cref="P:log4net.ILog.IsInfoEnabled" /> property.
            This check happens always and does not depend on the <seealso cref="T:log4net.ILog" />
            implementation. If this logger is <c>INFO</c> enabled, then it converts 
            the message object (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of 
            the additivity flag.
            </para><para><b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:log4net.Util.ILogExtensions.InfoExt(log4net.ILog,System.Object,System.Exception)" /> form instead.
            </para></remarks><seealso cref="M:log4net.ILog.Info(System.Object)" /><seealso cref="P:log4net.ILog.IsInfoEnabled" /></member>
    <member name="M:log4net.Util.ILogExtensions.InfoExt(log4net.ILog,System.Object,System.Exception)">
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Info" /> level including
            the stack trace of the <see cref="T:System.Exception" /> passed
            as a parameter.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            See the <see cref="M:log4net.Util.ILogExtensions.InfoExt(log4net.ILog,System.Object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Info(System.Object)" />
      <seealso cref="P:log4net.ILog.IsInfoEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.InfoFormatExt(log4net.ILog,System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Info" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.InfoExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Info(System.Object)" />
      <seealso cref="P:log4net.ILog.IsInfoEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.InfoFormatExt(log4net.ILog,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Info" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.InfoExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Info(System.Object)" />
      <seealso cref="P:log4net.ILog.IsInfoEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.InfoFormatExt(log4net.ILog,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Info" /> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.InfoExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Info(System.Object)" />
      <seealso cref="P:log4net.ILog.IsInfoEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.InfoFormatExt(log4net.ILog,System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Info" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.InfoExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Info(System.Object)" />
      <seealso cref="P:log4net.ILog.IsInfoEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.InfoFormatExt(log4net.ILog,System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Info" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.InfoExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Info(System.Object)" />
      <seealso cref="P:log4net.ILog.IsInfoEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.WarnExt(log4net.ILog,System.Func{System.Object})">
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Warn" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="callback">The lambda expression that gets the object to log.</param>
      <remarks>
        <para>
            This method first checks if this logger is <c>WARN</c>
            enabled by reading the value <seealso cref="P:log4net.ILog.IsWarnEnabled" /> property.
            This check happens always and does not depend on the <seealso cref="T:log4net.ILog" />
            implementation.  If this logger is <c>WARN</c> enabled, then it converts 
            the message object (retrieved by invocation of the provided callback) to a 
            string by invoking the appropriate <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />.
            It then proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of 
            the additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:log4net.Util.ILogExtensions.WarnExt(log4net.ILog,System.Func{System.Object},System.Exception)" /> form instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Warn(System.Object)" />
      <seealso cref="P:log4net.ILog.IsWarnEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.WarnExt(log4net.ILog,System.Func{System.Object},System.Exception)">
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Warn" /> level including
            the stack trace of the <see cref="T:System.Exception" /> passed
            as a parameter.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="callback">The lambda expression that gets the object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            See the <see cref="M:log4net.Util.ILogExtensions.WarnExt(log4net.ILog,System.Object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Warn(System.Object)" />
      <seealso cref="P:log4net.ILog.IsWarnEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.WarnExt(log4net.ILog,System.Object)">
      <overloads>Log a message object with the <see cref="F:log4net.Core.Level.Warn" /> level.</overloads> //TODO
            <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Warn" /> level.
            </summary><param name="logger">The logger on which the message is logged.</param><param name="message">The message object to log.</param><remarks><para>
            This method first checks if this logger is <c>WARN</c>
            enabled by reading the value <seealso cref="P:log4net.ILog.IsWarnEnabled" /> property.
            This check happens always and does not depend on the <seealso cref="T:log4net.ILog" />
            implementation. If this logger is <c>WARN</c> enabled, then it converts 
            the message object (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of 
            the additivity flag.
            </para><para><b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:log4net.Util.ILogExtensions.WarnExt(log4net.ILog,System.Object,System.Exception)" /> form instead.
            </para></remarks><seealso cref="M:log4net.ILog.Warn(System.Object)" /><seealso cref="P:log4net.ILog.IsWarnEnabled" /></member>
    <member name="M:log4net.Util.ILogExtensions.WarnExt(log4net.ILog,System.Object,System.Exception)">
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Warn" /> level including
            the stack trace of the <see cref="T:System.Exception" /> passed
            as a parameter.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            See the <see cref="M:log4net.Util.ILogExtensions.WarnExt(log4net.ILog,System.Object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Warn(System.Object)" />
      <seealso cref="P:log4net.ILog.IsWarnEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.WarnFormatExt(log4net.ILog,System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Warn" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.WarnExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Warn(System.Object)" />
      <seealso cref="P:log4net.ILog.IsWarnEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.WarnFormatExt(log4net.ILog,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Warn" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.WarnExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Warn(System.Object)" />
      <seealso cref="P:log4net.ILog.IsWarnEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.WarnFormatExt(log4net.ILog,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Warn" /> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.WarnExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Warn(System.Object)" />
      <seealso cref="P:log4net.ILog.IsWarnEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.WarnFormatExt(log4net.ILog,System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Warn" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.WarnExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Warn(System.Object)" />
      <seealso cref="P:log4net.ILog.IsWarnEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.WarnFormatExt(log4net.ILog,System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Warn" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.WarnExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Warn(System.Object)" />
      <seealso cref="P:log4net.ILog.IsWarnEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.ErrorExt(log4net.ILog,System.Func{System.Object})">
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Error" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="callback">The lambda expression that gets the object to log.</param>
      <remarks>
        <para>
            This method first checks if this logger is <c>ERROR</c>
            enabled by reading the value <seealso cref="P:log4net.ILog.IsErrorEnabled" /> property.
            This check happens always and does not depend on the <seealso cref="T:log4net.ILog" />
            implementation.  If this logger is <c>ERROR</c> enabled, then it converts 
            the message object (retrieved by invocation of the provided callback) to a 
            string by invoking the appropriate <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />.
            It then proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of 
            the additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:log4net.Util.ILogExtensions.ErrorExt(log4net.ILog,System.Func{System.Object},System.Exception)" /> form instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Error(System.Object)" />
      <seealso cref="P:log4net.ILog.IsErrorEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.ErrorExt(log4net.ILog,System.Func{System.Object},System.Exception)">
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Error" /> level including
            the stack trace of the <see cref="T:System.Exception" /> passed
            as a parameter.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="callback">The lambda expression that gets the object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            See the <see cref="M:log4net.Util.ILogExtensions.ErrorExt(log4net.ILog,System.Object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Error(System.Object)" />
      <seealso cref="P:log4net.ILog.IsErrorEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.ErrorExt(log4net.ILog,System.Object)">
      <overloads>Log a message object with the <see cref="F:log4net.Core.Level.Error" /> level.</overloads> //TODO
            <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Error" /> level.
            </summary><param name="logger">The logger on which the message is logged.</param><param name="message">The message object to log.</param><remarks><para>
            This method first checks if this logger is <c>ERROR</c>
            enabled by reading the value <seealso cref="P:log4net.ILog.IsErrorEnabled" /> property.
            This check happens always and does not depend on the <seealso cref="T:log4net.ILog" />
            implementation. If this logger is <c>ERROR</c> enabled, then it converts 
            the message object (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of 
            the additivity flag.
            </para><para><b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:log4net.Util.ILogExtensions.ErrorExt(log4net.ILog,System.Object,System.Exception)" /> form instead.
            </para></remarks><seealso cref="M:log4net.ILog.Error(System.Object)" /><seealso cref="P:log4net.ILog.IsErrorEnabled" /></member>
    <member name="M:log4net.Util.ILogExtensions.ErrorExt(log4net.ILog,System.Object,System.Exception)">
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Error" /> level including
            the stack trace of the <see cref="T:System.Exception" /> passed
            as a parameter.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            See the <see cref="M:log4net.Util.ILogExtensions.ErrorExt(log4net.ILog,System.Object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Error(System.Object)" />
      <seealso cref="P:log4net.ILog.IsErrorEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.ErrorFormatExt(log4net.ILog,System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Error" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.ErrorExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Error(System.Object)" />
      <seealso cref="P:log4net.ILog.IsErrorEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.ErrorFormatExt(log4net.ILog,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Error" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.ErrorExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Error(System.Object)" />
      <seealso cref="P:log4net.ILog.IsErrorEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.ErrorFormatExt(log4net.ILog,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Error" /> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.ErrorExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Error(System.Object)" />
      <seealso cref="P:log4net.ILog.IsErrorEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.ErrorFormatExt(log4net.ILog,System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Error" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.ErrorExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Error(System.Object)" />
      <seealso cref="P:log4net.ILog.IsErrorEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.ErrorFormatExt(log4net.ILog,System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Error" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.ErrorExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Error(System.Object)" />
      <seealso cref="P:log4net.ILog.IsErrorEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.FatalExt(log4net.ILog,System.Func{System.Object})">
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Fatal" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="callback">The lambda expression that gets the object to log.</param>
      <remarks>
        <para>
            This method first checks if this logger is <c>FATAL</c>
            enabled by reading the value <seealso cref="P:log4net.ILog.IsFatalEnabled" /> property.
            This check happens always and does not depend on the <seealso cref="T:log4net.ILog" />
            implementation.  If this logger is <c>FATAL</c> enabled, then it converts 
            the message object (retrieved by invocation of the provided callback) to a 
            string by invoking the appropriate <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />.
            It then proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of 
            the additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:log4net.Util.ILogExtensions.FatalExt(log4net.ILog,System.Func{System.Object},System.Exception)" /> form instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Fatal(System.Object)" />
      <seealso cref="P:log4net.ILog.IsFatalEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.FatalExt(log4net.ILog,System.Func{System.Object},System.Exception)">
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Fatal" /> level including
            the stack trace of the <see cref="T:System.Exception" /> passed
            as a parameter.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="callback">The lambda expression that gets the object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            See the <see cref="M:log4net.Util.ILogExtensions.FatalExt(log4net.ILog,System.Object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Fatal(System.Object)" />
      <seealso cref="P:log4net.ILog.IsFatalEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.FatalExt(log4net.ILog,System.Object)">
      <overloads>Log a message object with the <see cref="F:log4net.Core.Level.Fatal" /> level.</overloads> //TODO
            <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Fatal" /> level.
            </summary><param name="logger">The logger on which the message is logged.</param><param name="message">The message object to log.</param><remarks><para>
            This method first checks if this logger is <c>FATAL</c>
            enabled by reading the value <seealso cref="P:log4net.ILog.IsFatalEnabled" /> property.
            This check happens always and does not depend on the <seealso cref="T:log4net.ILog" />
            implementation. If this logger is <c>FATAL</c> enabled, then it converts 
            the message object (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of 
            the additivity flag.
            </para><para><b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:log4net.Util.ILogExtensions.FatalExt(log4net.ILog,System.Object,System.Exception)" /> form instead.
            </para></remarks><seealso cref="M:log4net.ILog.Fatal(System.Object)" /><seealso cref="P:log4net.ILog.IsFatalEnabled" /></member>
    <member name="M:log4net.Util.ILogExtensions.FatalExt(log4net.ILog,System.Object,System.Exception)">
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Fatal" /> level including
            the stack trace of the <see cref="T:System.Exception" /> passed
            as a parameter.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            See the <see cref="M:log4net.Util.ILogExtensions.FatalExt(log4net.ILog,System.Object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Fatal(System.Object)" />
      <seealso cref="P:log4net.ILog.IsFatalEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.FatalFormatExt(log4net.ILog,System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Fatal" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.FatalExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Fatal(System.Object)" />
      <seealso cref="P:log4net.ILog.IsFatalEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.FatalFormatExt(log4net.ILog,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Fatal" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.FatalExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Fatal(System.Object)" />
      <seealso cref="P:log4net.ILog.IsFatalEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.FatalFormatExt(log4net.ILog,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Fatal" /> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.FatalExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Fatal(System.Object)" />
      <seealso cref="P:log4net.ILog.IsFatalEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.FatalFormatExt(log4net.ILog,System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Fatal" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.FatalExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Fatal(System.Object)" />
      <seealso cref="P:log4net.ILog.IsFatalEnabled" />
    </member>
    <member name="M:log4net.Util.ILogExtensions.FatalFormatExt(log4net.ILog,System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Fatal" /> level.
            </summary>
      <param name="logger">The logger on which the message is logged.</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Util.ILogExtensions.FatalExt(log4net.ILog,System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Fatal(System.Object)" />
      <seealso cref="P:log4net.ILog.IsFatalEnabled" />
    </member>
    <member name="T:log4net.Util.LevelMapping">
      <summary>
            Manages a mapping from levels to <see cref="T:log4net.Util.LevelMappingEntry" /></summary>
      <remarks>
        <para>
            Manages an ordered mapping from <see cref="T:log4net.Core.Level" /> instances 
            to <see cref="T:log4net.Util.LevelMappingEntry" /> subclasses.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.LevelMapping.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Initialise a new instance of <see cref="T:log4net.Util.LevelMapping" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LevelMapping.Add(log4net.Util.LevelMappingEntry)">
      <summary>
            Add a <see cref="T:log4net.Util.LevelMappingEntry" /> to this mapping
            </summary>
      <param name="entry">the entry to add</param>
      <remarks>
        <para>
            If a <see cref="T:log4net.Util.LevelMappingEntry" /> has previously been added
            for the same <see cref="T:log4net.Core.Level" /> then that entry will be 
            overwritten.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LevelMapping.Lookup(log4net.Core.Level)">
      <summary>
            Lookup the mapping for the specified level
            </summary>
      <param name="level">the level to lookup</param>
      <returns>the <see cref="T:log4net.Util.LevelMappingEntry" /> for the level or <c>null</c> if no mapping found</returns>
      <remarks>
        <para>
            Lookup the value for the specified level. Finds the nearest
            mapping value for the level that is equal to or less than the
            <paramref name="level" /> specified.
            </para>
        <para>
            If no mapping could be found then <c>null</c> is returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LevelMapping.ActivateOptions">
      <summary>
            Initialize options
            </summary>
      <remarks>
        <para>
            Caches the sorted list of <see cref="T:log4net.Util.LevelMappingEntry" /> in an array
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.LogicalThreadContextProperties">
      <summary>
            Implementation of Properties collection for the <see cref="T:log4net.LogicalThreadContext" /></summary>
      <remarks>
        <para>
            Class implements a collection of properties that is specific to each thread.
            The class is not synchronized as each thread has its own <see cref="T:log4net.Util.PropertiesDictionary" />.
            </para>
        <para>
            This class stores its properties in a slot on the <see cref="T:System.Runtime.Remoting.Messaging.CallContext" /> named
            <c>log4net.Util.LogicalThreadContextProperties</c>.
            </para>
        <para>
            The <see cref="T:System.Runtime.Remoting.Messaging.CallContext" /> requires a link time 
            <see cref="T:System.Security.Permissions.SecurityPermission" /> for the
            <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.
            If the calling code does not have this permission then this context will be disabled.
            It will not store any property values set on it.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Util.LogicalThreadContextProperties.m_disabled">
      <summary>
            Flag used to disable this context if we don't have permission to access the CallContext.
            </summary>
    </member>
    <member name="F:log4net.Util.LogicalThreadContextProperties.declaringType">
      <summary>
            The fully qualified type of the LogicalThreadContextProperties class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Util.LogicalThreadContextProperties.#ctor">
      <summary>
            Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.LogicalThreadContextProperties" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LogicalThreadContextProperties.Remove(System.String)">
      <summary>
            Remove a property
            </summary>
      <param name="key">the key for the entry to remove</param>
      <remarks>
        <para>
            Remove the value for the specified <paramref name="key" /> from the context.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LogicalThreadContextProperties.Clear">
      <summary>
            Clear all the context properties
            </summary>
      <remarks>
        <para>
            Clear all the context properties
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LogicalThreadContextProperties.GetProperties(System.Boolean)">
      <summary>
            Get the PropertiesDictionary stored in the LocalDataStoreSlot for this thread.
            </summary>
      <param name="create">create the dictionary if it does not exist, otherwise return null if is does not exist</param>
      <returns>the properties for this thread</returns>
      <remarks>
        <para>
            The collection returned is only to be used on the calling thread. If the
            caller needs to share the collection between different threads then the 
            caller must clone the collection before doings so.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LogicalThreadContextProperties.GetCallContextData">
      <summary>
            Gets the call context get data.
            </summary>
      <returns>The peroperties dictionary stored in the call context</returns>
      <remarks>
            The <see cref="T:System.Runtime.Remoting.Messaging.CallContext" /> method <see cref="M:System.Runtime.Remoting.Messaging.CallContext.GetData(System.String)" /> has a
            security link demand, therfore we must put the method call in a seperate method
            that we can wrap in an exception handler.
            </remarks>
    </member>
    <member name="M:log4net.Util.LogicalThreadContextProperties.SetCallContextData(log4net.Util.PropertiesDictionary)">
      <summary>
            Sets the call context data.
            </summary>
      <param name="properties">The properties.</param>
      <remarks>
            The <see cref="T:System.Runtime.Remoting.Messaging.CallContext" /> method <see cref="M:System.Runtime.Remoting.Messaging.CallContext.SetData(System.String,System.Object)" /> has a
            security link demand, therfore we must put the method call in a seperate method
            that we can wrap in an exception handler.
            </remarks>
    </member>
    <member name="P:log4net.Util.LogicalThreadContextProperties.Item(System.String)">
      <summary>
            Gets or sets the value of a property
            </summary>
      <value>
            The value for the property with the specified key
            </value>
      <remarks>
        <para>
            Get or set the property value for the <paramref name="key" /> specified.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.LogReceivedEventHandler">
      <summary>
      </summary>
      <param name="source">
      </param>
      <param name="e">
      </param>
    </member>
    <member name="T:log4net.Util.LogLog">
      <summary>
            Outputs log statements from within the log4net assembly.
            </summary>
      <remarks>
        <para>
            Log4net components cannot make log4net logging calls. However, it is
            sometimes useful for the user to learn about what log4net is
            doing.
            </para>
        <para>
            All log4net internal debug calls go to the standard output stream
            whereas internal error messages are sent to the standard error output 
            stream.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="T:log4net.Util.LogLog.LogReceivedAdapter">
      <summary>
            Subscribes to the LogLog.LogReceived event and stores messages
            to the supplied IList instance.
            </summary>
    </member>
    <member name="M:log4net.Util.LogLog.LogReceivedAdapter.#ctor(System.Collections.IList)">
      <summary>
      </summary>
      <param name="items">
      </param>
    </member>
    <member name="M:log4net.Util.LogLog.LogReceivedAdapter.Dispose">
      <summary>
      </summary>
    </member>
    <member name="P:log4net.Util.LogLog.LogReceivedAdapter.Items">
      <summary>
      </summary>
    </member>
    <member name="F:log4net.Util.LogLog.s_debugEnabled">
      <summary>
             Default debug level
            </summary>
    </member>
    <member name="F:log4net.Util.LogLog.s_quietMode">
      <summary>
            In quietMode not even errors generate any output.
            </summary>
    </member>
    <member name="M:log4net.Util.LogLog.ToString">
      <summary>
            Formats Prefix, Source, and Message in the same format as the value
            sent to Console.Out and Trace.Write.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:log4net.Util.LogLog.#ctor(System.Type,System.String,System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Util.LogLog" /> class. 
            </summary>
      <param name="source">
      </param>
      <param name="prefix">
      </param>
      <param name="message">
      </param>
      <param name="exception">
      </param>
    </member>
    <member name="M:log4net.Util.LogLog.OnLogReceived(System.Type,System.String,System.String,System.Exception)">
      <summary>
            Raises the LogReceived event when an internal messages is received.
            </summary>
      <param name="source">
      </param>
      <param name="prefix">
      </param>
      <param name="message">
      </param>
      <param name="exception">
      </param>
    </member>
    <member name="M:log4net.Util.LogLog.Debug(System.Type,System.String)">
      <summary>
            Writes log4net internal debug messages to the 
            standard output stream.
            </summary>
      <param name="source">
      </param>
      <param name="message">The message to log.</param>
      <remarks>
        <para>
            All internal debug messages are prepended with 
            the string "log4net: ".
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LogLog.Debug(System.Type,System.String,System.Exception)">
      <summary>
            Writes log4net internal debug messages to the 
            standard output stream.
            </summary>
      <param name="source">The Type that generated this message.</param>
      <param name="message">The message to log.</param>
      <param name="exception">An exception to log.</param>
      <remarks>
        <para>
            All internal debug messages are prepended with 
            the string "log4net: ".
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LogLog.Warn(System.Type,System.String)">
      <summary>
            Writes log4net internal warning messages to the 
            standard error stream.
            </summary>
      <param name="source">The Type that generated this message.</param>
      <param name="message">The message to log.</param>
      <remarks>
        <para>
            All internal warning messages are prepended with 
            the string "log4net:WARN ".
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LogLog.Warn(System.Type,System.String,System.Exception)">
      <summary>
            Writes log4net internal warning messages to the 
            standard error stream.
            </summary>
      <param name="source">The Type that generated this message.</param>
      <param name="message">The message to log.</param>
      <param name="exception">An exception to log.</param>
      <remarks>
        <para>
            All internal warning messages are prepended with 
            the string "log4net:WARN ".
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LogLog.Error(System.Type,System.String)">
      <summary>
            Writes log4net internal error messages to the 
            standard error stream.
            </summary>
      <param name="source">The Type that generated this message.</param>
      <param name="message">The message to log.</param>
      <remarks>
        <para>
            All internal error messages are prepended with 
            the string "log4net:ERROR ".
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LogLog.Error(System.Type,System.String,System.Exception)">
      <summary>
            Writes log4net internal error messages to the 
            standard error stream.
            </summary>
      <param name="source">The Type that generated this message.</param>
      <param name="message">The message to log.</param>
      <param name="exception">An exception to log.</param>
      <remarks>
        <para>
            All internal debug messages are prepended with 
            the string "log4net:ERROR ".
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LogLog.EmitOutLine(System.String)">
      <summary>
            Writes output to the standard output stream.  
            </summary>
      <param name="message">The message to log.</param>
      <remarks>
        <para>
            Writes to both Console.Out and System.Diagnostics.Trace.
            Note that the System.Diagnostics.Trace is not supported
            on the Compact Framework.
            </para>
        <para>
            If the AppDomain is not configured with a config file then
            the call to System.Diagnostics.Trace may fail. This is only
            an issue if you are programmatically creating your own AppDomains.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LogLog.EmitErrorLine(System.String)">
      <summary>
            Writes output to the standard error stream.  
            </summary>
      <param name="message">The message to log.</param>
      <remarks>
        <para>
            Writes to both Console.Error and System.Diagnostics.Trace.
            Note that the System.Diagnostics.Trace is not supported
            on the Compact Framework.
            </para>
        <para>
            If the AppDomain is not configured with a config file then
            the call to System.Diagnostics.Trace may fail. This is only
            an issue if you are programmatically creating your own AppDomains.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.LogLog.Source">
      <summary>
            The Type that generated the internal message.
            </summary>
    </member>
    <member name="P:log4net.Util.LogLog.TimeStamp">
      <summary>
            The DateTime stamp of when the internal message was received.
            </summary>
    </member>
    <member name="P:log4net.Util.LogLog.Prefix">
      <summary>
            A string indicating the severity of the internal message.
            </summary>
      <remarks>
            "log4net: ", 
            "log4net:ERROR ", 
            "log4net:WARN "
            </remarks>
    </member>
    <member name="P:log4net.Util.LogLog.Message">
      <summary>
            The internal log message.
            </summary>
    </member>
    <member name="P:log4net.Util.LogLog.Exception">
      <summary>
            The Exception related to the message.
            </summary>
      <remarks>
            Optional. Will be null if no Exception was passed.
            </remarks>
    </member>
    <member name="P:log4net.Util.LogLog.InternalDebugging">
      <summary>
            Gets or sets a value indicating whether log4net internal logging
            is enabled or disabled.
            </summary>
      <value>
        <c>true</c> if log4net internal logging is enabled, otherwise 
            <c>false</c>.
            </value>
      <remarks>
        <para>
            When set to <c>true</c>, internal debug level logging will be 
            displayed.
            </para>
        <para>
            This value can be set by setting the application setting 
            <c>log4net.Internal.Debug</c> in the application configuration
            file.
            </para>
        <para>
            The default value is <c>false</c>, i.e. debugging is
            disabled.
            </para>
      </remarks>
      <example>
        <para>
            The following example enables internal debugging using the 
            application configuration file :
            </para>
        <code lang="XML" escaped="true">
          <configuration>
            <appSettings>
              <add key="log4net.Internal.Debug" value="true" />
            </appSettings>
          </configuration>
        </code>
      </example>
    </member>
    <member name="P:log4net.Util.LogLog.QuietMode">
      <summary>
            Gets or sets a value indicating whether log4net should generate no output
            from internal logging, not even for errors. 
            </summary>
      <value>
        <c>true</c> if log4net should generate no output at all from internal 
            logging, otherwise <c>false</c>.
            </value>
      <remarks>
        <para>
            When set to <c>true</c> will cause internal logging at all levels to be 
            suppressed. This means that no warning or error reports will be logged. 
            This option overrides the <see cref="P:log4net.Util.LogLog.InternalDebugging" /> setting and 
            disables all debug also.
            </para>
        <para>This value can be set by setting the application setting
            <c>log4net.Internal.Quiet</c> in the application configuration file.
            </para>
        <para>
            The default value is <c>false</c>, i.e. internal logging is not
            disabled.
            </para>
      </remarks>
      <example>
            The following example disables internal logging using the 
            application configuration file :
            <code lang="XML" escaped="true"><configuration><appSettings><add key="log4net.Internal.Quiet" value="true" /></appSettings></configuration></code></example>
    </member>
    <member name="P:log4net.Util.LogLog.EmitInternalMessages">
      <summary>
      </summary>
    </member>
    <member name="P:log4net.Util.LogLog.IsDebugEnabled">
      <summary>
            Test if LogLog.Debug is enabled for output.
            </summary>
      <value>
        <c>true</c> if Debug is enabled
            </value>
      <remarks>
        <para>
            Test if LogLog.Debug is enabled for output.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.LogLog.IsWarnEnabled">
      <summary>
            Test if LogLog.Warn is enabled for output.
            </summary>
      <value>
        <c>true</c> if Warn is enabled
            </value>
      <remarks>
        <para>
            Test if LogLog.Warn is enabled for output.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.LogLog.IsErrorEnabled">
      <summary>
            Test if LogLog.Error is enabled for output.
            </summary>
      <value>
        <c>true</c> if Error is enabled
            </value>
      <remarks>
        <para>
            Test if LogLog.Error is enabled for output.
            </para>
      </remarks>
    </member>
    <member name="E:log4net.Util.LogLog.LogReceived">
      <summary>
            The event raised when an internal message has been received.
            </summary>
    </member>
    <member name="T:log4net.Util.LogReceivedEventArgs">
      <summary>
      </summary>
    </member>
    <member name="M:log4net.Util.LogReceivedEventArgs.#ctor(log4net.Util.LogLog)">
      <summary>
      </summary>
      <param name="loglog">
      </param>
    </member>
    <member name="P:log4net.Util.LogReceivedEventArgs.LogLog">
      <summary>
      </summary>
    </member>
    <member name="T:log4net.Util.NativeError">
      <summary>
            Represents a native error code and message.
            </summary>
      <remarks>
        <para>
            Represents a Win32 platform native error.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Util.NativeError.#ctor(System.Int32,System.String)">
      <summary>
            Create an instance of the <see cref="T:log4net.Util.NativeError" /> class with the specified 
            error number and message.
            </summary>
      <param name="number">The number of the native error.</param>
      <param name="message">The message of the native error.</param>
      <remarks>
        <para>
            Create an instance of the <see cref="T:log4net.Util.NativeError" /> class with the specified 
            error number and message.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.NativeError.GetLastError">
      <summary>
            Create a new instance of the <see cref="T:log4net.Util.NativeError" /> class for the last Windows error.
            </summary>
      <returns>
            An instance of the <see cref="T:log4net.Util.NativeError" /> class for the last windows error.
            </returns>
      <remarks>
        <para>
            The message for the <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" /> error number is lookup up using the 
            native Win32 <c>FormatMessage</c> function.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.NativeError.GetError(System.Int32)">
      <summary>
            Create a new instance of the <see cref="T:log4net.Util.NativeError" /> class.
            </summary>
      <param name="number">the error number for the native error</param>
      <returns>
            An instance of the <see cref="T:log4net.Util.NativeError" /> class for the specified 
            error number.
            </returns>
      <remarks>
        <para>
            The message for the specified error number is lookup up using the 
            native Win32 <c>FormatMessage</c> function.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.NativeError.GetErrorMessage(System.Int32)">
      <summary>
            Retrieves the message corresponding with a Win32 message identifier.
            </summary>
      <param name="messageId">Message identifier for the requested message.</param>
      <returns>
            The message corresponding with the specified message identifier.
            </returns>
      <remarks>
        <para>
            The message will be searched for in system message-table resource(s)
            using the native <c>FormatMessage</c> function.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.NativeError.ToString">
      <summary>
            Return error information string
            </summary>
      <returns>error information string</returns>
      <remarks>
        <para>
            Return error information string
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.NativeError.FormatMessage(System.Int32,System.IntPtr@,System.Int32,System.Int32,System.String@,System.Int32,System.IntPtr)">
      <summary>
            Formats a message string.
            </summary>
      <param name="dwFlags">Formatting options, and how to interpret the <paramref name="lpSource" /> parameter.</param>
      <param name="lpSource">Location of the message definition.</param>
      <param name="dwMessageId">Message identifier for the requested message.</param>
      <param name="dwLanguageId">Language identifier for the requested message.</param>
      <param name="lpBuffer">If <paramref name="dwFlags" /> includes FORMAT_MESSAGE_ALLOCATE_BUFFER, the function allocates a buffer using the <c>LocalAlloc</c> function, and places the pointer to the buffer at the address specified in <paramref name="lpBuffer" />.</param>
      <param name="nSize">If the FORMAT_MESSAGE_ALLOCATE_BUFFER flag is not set, this parameter specifies the maximum number of TCHARs that can be stored in the output buffer. If FORMAT_MESSAGE_ALLOCATE_BUFFER is set, this parameter specifies the minimum number of TCHARs to allocate for an output buffer.</param>
      <param name="Arguments">Pointer to an array of values that are used as insert values in the formatted message.</param>
      <remarks>
        <para>
            The function requires a message definition as input. The message definition can come from a 
            buffer passed into the function. It can come from a message table resource in an 
            already-loaded module. Or the caller can ask the function to search the system's message 
            table resource(s) for the message definition. The function finds the message definition 
            in a message table resource based on a message identifier and a language identifier. 
            The function copies the formatted message text to an output buffer, processing any embedded 
            insert sequences if requested.
            </para>
        <para>
            To prevent the usage of unsafe code, this stub does not support inserting values in the formatted message.
            </para>
      </remarks>
      <returns>
        <para>
            If the function succeeds, the return value is the number of TCHARs stored in the output 
            buffer, excluding the terminating null character.
            </para>
        <para>
            If the function fails, the return value is zero. To get extended error information, 
            call <see cref="M:Marshal.GetLastWin32Error()" />.
            </para>
      </returns>
    </member>
    <member name="P:log4net.Util.NativeError.Number">
      <summary>
            Gets the number of the native error.
            </summary>
      <value>
            The number of the native error.
            </value>
      <remarks>
        <para>
            Gets the number of the native error.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.NativeError.Message">
      <summary>
            Gets the message of the native error.
            </summary>
      <value>
            The message of the native error.
            </value>
      <remarks>
        <para>
        </para>
            Gets the message of the native error.
            </remarks>
    </member>
    <member name="T:log4net.Util.NullDictionaryEnumerator">
      <summary>
            An always empty <see cref="T:System.Collections.IDictionaryEnumerator" />.
            </summary>
      <remarks>
        <para>
            A singleton implementation of the <see cref="T:System.Collections.IDictionaryEnumerator" /> over a collection
            that is empty and not modifiable.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.NullDictionaryEnumerator.s_instance">
      <summary>
            The singleton instance of the <see cref="T:log4net.Util.NullDictionaryEnumerator" />.
            </summary>
    </member>
    <member name="M:log4net.Util.NullDictionaryEnumerator.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Util.NullDictionaryEnumerator" /> class. 
            </summary>
      <remarks>
        <para>
            Uses a private access modifier to enforce the singleton pattern.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.NullDictionaryEnumerator.MoveNext">
      <summary>
            Test if the enumerator can advance, if so advance.
            </summary>
      <returns>
        <c>false</c> as the <see cref="T:log4net.Util.NullDictionaryEnumerator" /> cannot advance.</returns>
      <remarks>
        <para>
            As the enumerator is over an empty collection its <see cref="P:log4net.Util.NullDictionaryEnumerator.Current" />
            value cannot be moved over a valid position, therefore <see cref="M:log4net.Util.NullDictionaryEnumerator.MoveNext" />
            will always return <c>false</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.NullDictionaryEnumerator.Reset">
      <summary>
            Resets the enumerator back to the start.
            </summary>
      <remarks>
        <para>
            As the enumerator is over an empty collection <see cref="M:log4net.Util.NullDictionaryEnumerator.Reset" /> does nothing.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.NullDictionaryEnumerator.Instance">
      <summary>
            Gets the singleton instance of the <see cref="T:log4net.Util.NullDictionaryEnumerator" />.
            </summary>
      <returns>The singleton instance of the <see cref="T:log4net.Util.NullDictionaryEnumerator" />.</returns>
      <remarks>
        <para>
            Gets the singleton instance of the <see cref="T:log4net.Util.NullDictionaryEnumerator" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.NullDictionaryEnumerator.Current">
      <summary>
            Gets the current object from the enumerator.
            </summary>
      <remarks>
            Throws an <see cref="T:System.InvalidOperationException" /> because the 
            <see cref="T:log4net.Util.NullDictionaryEnumerator" /> never has a current value.
            </remarks>
      <remarks>
        <para>
            As the enumerator is over an empty collection its <see cref="P:log4net.Util.NullDictionaryEnumerator.Current" />
            value cannot be moved over a valid position, therefore <see cref="P:log4net.Util.NullDictionaryEnumerator.Current" />
            will throw an <see cref="T:System.InvalidOperationException" />.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">The collection is empty and <see cref="P:log4net.Util.NullDictionaryEnumerator.Current" /> 
            cannot be positioned over a valid location.</exception>
    </member>
    <member name="P:log4net.Util.NullDictionaryEnumerator.Key">
      <summary>
            Gets the current key from the enumerator.
            </summary>
      <remarks>
            Throws an exception because the <see cref="T:log4net.Util.NullDictionaryEnumerator" />
            never has a current value.
            </remarks>
      <remarks>
        <para>
            As the enumerator is over an empty collection its <see cref="P:log4net.Util.NullDictionaryEnumerator.Current" />
            value cannot be moved over a valid position, therefore <see cref="P:log4net.Util.NullDictionaryEnumerator.Key" />
            will throw an <see cref="T:System.InvalidOperationException" />.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">The collection is empty and <see cref="P:log4net.Util.NullDictionaryEnumerator.Current" /> 
            cannot be positioned over a valid location.</exception>
    </member>
    <member name="P:log4net.Util.NullDictionaryEnumerator.Value">
      <summary>
            Gets the current value from the enumerator.
            </summary>
      <value>The current value from the enumerator.</value>
      <remarks>
            Throws an <see cref="T:System.InvalidOperationException" /> because the 
            <see cref="T:log4net.Util.NullDictionaryEnumerator" /> never has a current value.
            </remarks>
      <remarks>
        <para>
            As the enumerator is over an empty collection its <see cref="P:log4net.Util.NullDictionaryEnumerator.Current" />
            value cannot be moved over a valid position, therefore <see cref="P:log4net.Util.NullDictionaryEnumerator.Value" />
            will throw an <see cref="T:System.InvalidOperationException" />.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">The collection is empty and <see cref="P:log4net.Util.NullDictionaryEnumerator.Current" /> 
            cannot be positioned over a valid location.</exception>
    </member>
    <member name="P:log4net.Util.NullDictionaryEnumerator.Entry">
      <summary>
            Gets the current entry from the enumerator.
            </summary>
      <remarks>
            Throws an <see cref="T:System.InvalidOperationException" /> because the 
            <see cref="T:log4net.Util.NullDictionaryEnumerator" /> never has a current entry.
            </remarks>
      <remarks>
        <para>
            As the enumerator is over an empty collection its <see cref="P:log4net.Util.NullDictionaryEnumerator.Current" />
            value cannot be moved over a valid position, therefore <see cref="P:log4net.Util.NullDictionaryEnumerator.Entry" />
            will throw an <see cref="T:System.InvalidOperationException" />.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">The collection is empty and <see cref="P:log4net.Util.NullDictionaryEnumerator.Current" /> 
            cannot be positioned over a valid location.</exception>
    </member>
    <member name="T:log4net.Util.NullEnumerator">
      <summary>
            An always empty <see cref="T:System.Collections.IEnumerator" />.
            </summary>
      <remarks>
        <para>
            A singleton implementation of the <see cref="T:System.Collections.IEnumerator" /> over a collection
            that is empty and not modifiable.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.NullEnumerator.s_instance">
      <summary>
            The singleton instance of the <see cref="T:log4net.Util.NullEnumerator" />.
            </summary>
    </member>
    <member name="M:log4net.Util.NullEnumerator.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Util.NullEnumerator" /> class. 
            </summary>
      <remarks>
        <para>
            Uses a private access modifier to enforce the singleton pattern.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.NullEnumerator.MoveNext">
      <summary>
            Test if the enumerator can advance, if so advance
            </summary>
      <returns>
        <c>false</c> as the <see cref="T:log4net.Util.NullEnumerator" /> cannot advance.</returns>
      <remarks>
        <para>
            As the enumerator is over an empty collection its <see cref="P:log4net.Util.NullEnumerator.Current" />
            value cannot be moved over a valid position, therefore <see cref="M:log4net.Util.NullEnumerator.MoveNext" />
            will always return <c>false</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.NullEnumerator.Reset">
      <summary>
            Resets the enumerator back to the start.
            </summary>
      <remarks>
        <para>
            As the enumerator is over an empty collection <see cref="M:log4net.Util.NullEnumerator.Reset" /> does nothing.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.NullEnumerator.Instance">
      <summary>
            Get the singleton instance of the <see cref="T:log4net.Util.NullEnumerator" />.
            </summary>
      <returns>The singleton instance of the <see cref="T:log4net.Util.NullEnumerator" />.</returns>
      <remarks>
        <para>
            Gets the singleton instance of the <see cref="T:log4net.Util.NullEnumerator" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.NullEnumerator.Current">
      <summary>
            Gets the current object from the enumerator.
            </summary>
      <remarks>
            Throws an <see cref="T:System.InvalidOperationException" /> because the 
            <see cref="T:log4net.Util.NullDictionaryEnumerator" /> never has a current value.
            </remarks>
      <remarks>
        <para>
            As the enumerator is over an empty collection its <see cref="P:log4net.Util.NullEnumerator.Current" />
            value cannot be moved over a valid position, therefore <see cref="P:log4net.Util.NullEnumerator.Current" />
            will throw an <see cref="T:System.InvalidOperationException" />.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">The collection is empty and <see cref="P:log4net.Util.NullEnumerator.Current" /> 
            cannot be positioned over a valid location.</exception>
    </member>
    <member name="T:log4net.Util.NullSecurityContext">
      <summary>
            A SecurityContext used when a SecurityContext is not required
            </summary>
      <remarks>
        <para>
            The <see cref="T:log4net.Util.NullSecurityContext" /> is a no-op implementation of the
            <see cref="T:log4net.Core.SecurityContext" /> base class. It is used where a <see cref="T:log4net.Core.SecurityContext" />
            is required but one has not been provided.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Util.NullSecurityContext.Instance">
      <summary>
            Singleton instance of <see cref="T:log4net.Util.NullSecurityContext" /></summary>
      <remarks>
        <para>
            Singleton instance of <see cref="T:log4net.Util.NullSecurityContext" /></para>
      </remarks>
    </member>
    <member name="M:log4net.Util.NullSecurityContext.#ctor">
      <summary>
            Private constructor
            </summary>
      <remarks>
        <para>
            Private constructor for singleton pattern.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.NullSecurityContext.Impersonate(System.Object)">
      <summary>
            Impersonate this SecurityContext
            </summary>
      <param name="state">State supplied by the caller</param>
      <returns>
        <c>null</c>
      </returns>
      <remarks>
        <para>
            No impersonation is done and <c>null</c> is always returned.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.OnlyOnceErrorHandler">
      <summary>
            Implements log4net's default error handling policy which consists 
            of emitting a message for the first error in an appender and 
            ignoring all subsequent errors.
            </summary>
      <remarks>
        <para>
            The error message is processed using the LogLog sub-system by default.
            </para>
        <para>
            This policy aims at protecting an otherwise working application
            from being flooded with error messages when logging fails.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Ron Grabowski</author>
    </member>
    <member name="F:log4net.Util.OnlyOnceErrorHandler.m_enabledDate">
      <summary>
            The date the error was recorded.
            </summary>
    </member>
    <member name="F:log4net.Util.OnlyOnceErrorHandler.m_firstTime">
      <summary>
            Flag to indicate if it is the first error
            </summary>
    </member>
    <member name="F:log4net.Util.OnlyOnceErrorHandler.m_message">
      <summary>
            The message recorded during the first error.
            </summary>
    </member>
    <member name="F:log4net.Util.OnlyOnceErrorHandler.m_exception">
      <summary>
            The exception recorded during the first error.
            </summary>
    </member>
    <member name="F:log4net.Util.OnlyOnceErrorHandler.m_errorCode">
      <summary>
            The error code recorded during the first error.
            </summary>
    </member>
    <member name="F:log4net.Util.OnlyOnceErrorHandler.m_prefix">
      <summary>
            String to prefix each message with
            </summary>
    </member>
    <member name="F:log4net.Util.OnlyOnceErrorHandler.declaringType">
      <summary>
            The fully qualified type of the OnlyOnceErrorHandler class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Util.OnlyOnceErrorHandler.#ctor">
      <summary>
            Default Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.OnlyOnceErrorHandler" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.OnlyOnceErrorHandler.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="prefix">The prefix to use for each message.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.OnlyOnceErrorHandler" /> class
            with the specified prefix.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.OnlyOnceErrorHandler.Reset">
      <summary>
            Reset the error handler back to its initial disabled state.
            </summary>
    </member>
    <member name="M:log4net.Util.OnlyOnceErrorHandler.Error(System.String,System.Exception,log4net.Core.ErrorCode)">
      <summary>
            Log an Error
            </summary>
      <param name="message">The error message.</param>
      <param name="e">The exception.</param>
      <param name="errorCode">The internal error code.</param>
      <remarks>
        <para>
            Invokes <see cref="M:log4net.Util.OnlyOnceErrorHandler.FirstError(System.String,System.Exception,log4net.Core.ErrorCode)" /> if and only if this is the first error or the first error after <see cref="M:log4net.Util.OnlyOnceErrorHandler.Reset" /> has been called.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.OnlyOnceErrorHandler.FirstError(System.String,System.Exception,log4net.Core.ErrorCode)">
      <summary>
            Log the very first error
            </summary>
      <param name="message">The error message.</param>
      <param name="e">The exception.</param>
      <param name="errorCode">The internal error code.</param>
      <remarks>
        <para>
            Sends the error information to <see cref="T:log4net.Util.LogLog" />'s Error method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.OnlyOnceErrorHandler.Error(System.String,System.Exception)">
      <summary>
            Log an Error
            </summary>
      <param name="message">The error message.</param>
      <param name="e">The exception.</param>
      <remarks>
        <para>
            Invokes <see cref="M:log4net.Util.OnlyOnceErrorHandler.FirstError(System.String,System.Exception,log4net.Core.ErrorCode)" /> if and only if this is the first error or the first error after <see cref="M:log4net.Util.OnlyOnceErrorHandler.Reset" /> has been called.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.OnlyOnceErrorHandler.Error(System.String)">
      <summary>
            Log an error
            </summary>
      <param name="message">The error message.</param>
      <remarks>
        <para>
            Invokes <see cref="M:log4net.Util.OnlyOnceErrorHandler.FirstError(System.String,System.Exception,log4net.Core.ErrorCode)" /> if and only if this is the first error or the first error after <see cref="M:log4net.Util.OnlyOnceErrorHandler.Reset" /> has been called.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.OnlyOnceErrorHandler.IsEnabled">
      <summary>
            Is error logging enabled
            </summary>
      <remarks>
        <para>
            Is error logging enabled. Logging is only enabled for the
            first error delivered to the <see cref="T:log4net.Util.OnlyOnceErrorHandler" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.OnlyOnceErrorHandler.EnabledDate">
      <summary>
            The date the first error that trigged this error handler occured.
            </summary>
    </member>
    <member name="P:log4net.Util.OnlyOnceErrorHandler.ErrorMessage">
      <summary>
            The message from the first error that trigged this error handler.
            </summary>
    </member>
    <member name="P:log4net.Util.OnlyOnceErrorHandler.Exception">
      <summary>
            The exception from the first error that trigged this error handler.
            </summary>
      <remarks>
            May be <see langword="null" />.
            </remarks>
    </member>
    <member name="P:log4net.Util.OnlyOnceErrorHandler.ErrorCode">
      <summary>
            The error code from the first error that trigged this error handler.
            </summary>
      <remarks>
            Defaults to <see cref="F:log4net.Core.ErrorCode.GenericFailure" /></remarks>
    </member>
    <member name="T:log4net.Util.OptionConverter">
      <summary>
            A convenience class to convert property values to specific types.
            </summary>
      <remarks>
        <para>
            Utility functions for converting types and parsing values.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.OptionConverter.declaringType">
      <summary>
            The fully qualified type of the OptionConverter class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Util.OptionConverter.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Util.OptionConverter" /> class. 
            </summary>
      <remarks>
        <para>
            Uses a private access modifier to prevent instantiation of this class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.OptionConverter.ToBoolean(System.String,System.Boolean)">
      <summary>
            Converts a string to a <see cref="T:System.Boolean" /> value.
            </summary>
      <param name="argValue">String to convert.</param>
      <param name="defaultValue">The default value.</param>
      <returns>The <see cref="T:System.Boolean" /> value of <paramref name="argValue" />.</returns>
      <remarks>
        <para>
            If <paramref name="argValue" /> is "true", then <c>true</c> is returned. 
            If <paramref name="argValue" /> is "false", then <c>false</c> is returned. 
            Otherwise, <paramref name="defaultValue" /> is returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.OptionConverter.ToFileSize(System.String,System.Int64)">
      <summary>
            Parses a file size into a number.
            </summary>
      <param name="argValue">String to parse.</param>
      <param name="defaultValue">The default value.</param>
      <returns>The <see cref="T:System.Int64" /> value of <paramref name="argValue" />.</returns>
      <remarks>
        <para>
            Parses a file size of the form: number[KB|MB|GB] into a
            long value. It is scaled with the appropriate multiplier.
            </para>
        <para>
          <paramref name="defaultValue" /> is returned when <paramref name="argValue" />
            cannot be converted to a <see cref="T:System.Int64" /> value.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.OptionConverter.ConvertStringTo(System.Type,System.String)">
      <summary>
            Converts a string to an object.
            </summary>
      <param name="target">The target type to convert to.</param>
      <param name="txt">The string to convert to an object.</param>
      <returns>
            The object converted from a string or <c>null</c> when the 
            conversion failed.
            </returns>
      <remarks>
        <para>
            Converts a string to an object. Uses the converter registry to try
            to convert the string value into the specified target type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.OptionConverter.CanConvertTypeTo(System.Type,System.Type)">
      <summary>
            Checks if there is an appropriate type conversion from the source type to the target type.
            </summary>
      <param name="sourceType">The type to convert from.</param>
      <param name="targetType">The type to convert to.</param>
      <returns>
        <c>true</c> if there is a conversion from the source type to the target type.</returns>
      <remarks>
            Checks if there is an appropriate type conversion from the source type to the target type.
            <para></para></remarks>
    </member>
    <member name="M:log4net.Util.OptionConverter.ConvertTypeTo(System.Object,System.Type)">
      <summary>
            Converts an object to the target type.
            </summary>
      <param name="sourceInstance">The object to convert to the target type.</param>
      <param name="targetType">The type to convert to.</param>
      <returns>The converted object.</returns>
      <remarks>
        <para>
            Converts an object to the target type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.OptionConverter.InstantiateByClassName(System.String,System.Type,System.Object)">
      <summary>
            Instantiates an object given a class name.
            </summary>
      <param name="className">The fully qualified class name of the object to instantiate.</param>
      <param name="superClass">The class to which the new object should belong.</param>
      <param name="defaultValue">The object to return in case of non-fulfillment.</param>
      <returns>
            An instance of the <paramref name="className" /> or <paramref name="defaultValue" />
            if the object could not be instantiated.
            </returns>
      <remarks>
        <para>
            Checks that the <paramref name="className" /> is a subclass of
            <paramref name="superClass" />. If that test fails or the object could
            not be instantiated, then <paramref name="defaultValue" /> is returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.OptionConverter.SubstituteVariables(System.String,System.Collections.IDictionary)">
      <summary>
            Performs variable substitution in string <paramref name="value" /> from the 
            values of keys found in <paramref name="props" />.
            </summary>
      <param name="value">The string on which variable substitution is performed.</param>
      <param name="props">The dictionary to use to lookup variables.</param>
      <returns>The result of the substitutions.</returns>
      <remarks>
        <para>
            The variable substitution delimiters are <b>${</b> and <b>}</b>.
            </para>
        <para>
            For example, if props contains <c>key=value</c>, then the call
            </para>
        <para>
          <code lang="C#">
            string s = OptionConverter.SubstituteVariables("Value of key is ${key}.");
            </code>
        </para>
        <para>
            will set the variable <c>s</c> to "Value of key is value.".
            </para>
        <para>
            If no value could be found for the specified key, then substitution 
            defaults to an empty string.
            </para>
        <para>
            For example, if system properties contains no value for the key
            "nonExistentKey", then the call
            </para>
        <para>
          <code lang="C#">
            string s = OptionConverter.SubstituteVariables("Value of nonExistentKey is [${nonExistentKey}]");
            </code>
        </para>
        <para>
            will set <s>s</s> to "Value of nonExistentKey is []".	 
            </para>
        <para>
            An Exception is thrown if <paramref name="value" /> contains a start 
            delimiter "${" which is not balanced by a stop delimiter "}". 
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.OptionConverter.ParseEnum(System.Type,System.String,System.Boolean)">
      <summary>
            Converts the string representation of the name or numeric value of one or 
            more enumerated constants to an equivalent enumerated object.
            </summary>
      <param name="enumType">The type to convert to.</param>
      <param name="value">The enum string value.</param>
      <param name="ignoreCase">If <c>true</c>, ignore case; otherwise, regard case.</param>
      <returns>An object of type <paramref name="enumType" /> whose value is represented by <paramref name="value" />.</returns>
    </member>
    <member name="T:log4net.Util.PatternParser">
      <summary>
            Most of the work of the <see cref="T:log4net.Layout.PatternLayout" /> class
            is delegated to the PatternParser class.
            </summary>
      <remarks>
        <para>
            The <c>PatternParser</c> processes a pattern string and
            returns a chain of <see cref="T:log4net.Util.PatternConverter" /> objects.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="T:log4net.Util.PatternParser.StringLengthComparer">
      <summary>
            Sort strings by length
            </summary>
      <remarks>
        <para>
          <see cref="T:System.Collections.IComparer" /> that orders strings by string length.
            The longest strings are placed first
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Util.PatternParser.m_head">
      <summary>
            The first pattern converter in the chain
            </summary>
    </member>
    <member name="F:log4net.Util.PatternParser.m_tail">
      <summary>
             the last pattern converter in the chain
            </summary>
    </member>
    <member name="F:log4net.Util.PatternParser.m_pattern">
      <summary>
            The pattern
            </summary>
    </member>
    <member name="F:log4net.Util.PatternParser.m_patternConverters">
      <summary>
            Internal map of converter identifiers to converter types
            </summary>
      <remarks>
        <para>
            This map overrides the static s_globalRulesRegistry map.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Util.PatternParser.declaringType">
      <summary>
            The fully qualified type of the PatternParser class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Util.PatternParser.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="pattern">The pattern to parse.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.PatternParser" /> class 
            with the specified pattern string.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternParser.Parse">
      <summary>
            Parses the pattern into a chain of pattern converters.
            </summary>
      <returns>The head of a chain of pattern converters.</returns>
      <remarks>
        <para>
            Parses the pattern into a chain of pattern converters.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternParser.BuildCache">
      <summary>
            Build the unified cache of converters from the static and instance maps
            </summary>
      <returns>the list of all the converter names</returns>
      <remarks>
        <para>
            Build the unified cache of converters from the static and instance maps
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternParser.ParseInternal(System.String,System.String[])">
      <summary>
            Internal method to parse the specified pattern to find specified matches
            </summary>
      <param name="pattern">the pattern to parse</param>
      <param name="matches">the converter names to match in the pattern</param>
      <remarks>
        <para>
            The matches param must be sorted such that longer strings come before shorter ones.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternParser.ProcessLiteral(System.String)">
      <summary>
            Process a parsed literal
            </summary>
      <param name="text">the literal text</param>
    </member>
    <member name="M:log4net.Util.PatternParser.ProcessConverter(System.String,System.String,log4net.Util.FormattingInfo)">
      <summary>
            Process a parsed converter pattern
            </summary>
      <param name="converterName">the name of the converter</param>
      <param name="option">the optional option for the converter</param>
      <param name="formattingInfo">the formatting info for the converter</param>
    </member>
    <member name="M:log4net.Util.PatternParser.AddConverter(log4net.Util.PatternConverter)">
      <summary>
            Resets the internal state of the parser and adds the specified pattern converter 
            to the chain.
            </summary>
      <param name="pc">The pattern converter to add.</param>
    </member>
    <member name="P:log4net.Util.PatternParser.PatternConverters">
      <summary>
            Get the converter registry used by this parser
            </summary>
      <value>
            The converter registry used by this parser
            </value>
      <remarks>
        <para>
            Get the converter registry used by this parser
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternString">
      <summary>
            This class implements a patterned string.
            </summary>
      <remarks>
        <para>
            This string has embedded patterns that are resolved and expanded
            when the string is formatted.
            </para>
        <para>
            This class functions similarly to the <see cref="T:log4net.Layout.PatternLayout" />
            in that it accepts a pattern and renders it to a string. Unlike the 
            <see cref="T:log4net.Layout.PatternLayout" /> however the <c>PatternString</c>
            does not render the properties of a specific <see cref="T:log4net.Core.LoggingEvent" /> but
            of the process in general.
            </para>
        <para>
            The recognized conversion pattern names are:
            </para>
        <list type="table">
          <listheader>
            <term>Conversion Pattern Name</term>
            <description>Effect</description>
          </listheader>
          <item>
            <term>appdomain</term>
            <description>
              <para>
                        Used to output the friendly name of the current AppDomain.
                        </para>
            </description>
          </item>
          <item>
            <term>date</term>
            <description>
              <para>
            			Used to output the current date and time in the local time zone. 
            			To output the date in universal time use the <c>%utcdate</c> pattern.
            			The date conversion 
            			specifier may be followed by a <i>date format specifier</i> enclosed 
            			between braces. For example, <b>%date{HH:mm:ss,fff}</b> or
            			<b>%date{dd MMM yyyy HH:mm:ss,fff}</b>.  If no date format specifier is 
            			given then ISO8601 format is
            			assumed (<see cref="T:log4net.DateFormatter.Iso8601DateFormatter" />).
            			</para>
              <para>
            			The date format specifier admits the same syntax as the
            			time pattern string of the <see cref="M:DateTime.ToString(string)" />.
            			</para>
              <para>
            			For better results it is recommended to use the log4net date
            			formatters. These can be specified using one of the strings
            			"ABSOLUTE", "DATE" and "ISO8601" for specifying 
            			<see cref="T:log4net.DateFormatter.AbsoluteTimeDateFormatter" />, 
            			<see cref="T:log4net.DateFormatter.DateTimeDateFormatter" /> and respectively 
            			<see cref="T:log4net.DateFormatter.Iso8601DateFormatter" />. For example, 
            			<b>%date{ISO8601}</b> or <b>%date{ABSOLUTE}</b>.
            			</para>
              <para>
            			These dedicated date formatters perform significantly
            			better than <see cref="M:DateTime.ToString(string)" />.
            			</para>
            </description>
          </item>
          <item>
            <term>env</term>
            <description>
              <para>
            			Used to output the a specific environment variable. The key to 
            			lookup must be specified within braces and directly following the
            			pattern specifier, e.g. <b>%env{COMPUTERNAME}</b> would include the value
            			of the <c>COMPUTERNAME</c> environment variable.
                        </para>
              <para>
                        The <c>env</c> pattern is not supported on the .NET Compact Framework.
                        </para>
            </description>
          </item>
          <item>
            <term>identity</term>
            <description>
              <para>
            			Used to output the user name for the currently active user
            			(Principal.Identity.Name).
            			</para>
            </description>
          </item>
          <item>
            <term>newline</term>
            <description>
              <para>
            			Outputs the platform dependent line separator character or
            			characters.
            			</para>
              <para>
            			This conversion pattern name offers the same performance as using 
            			non-portable line separator strings such as	"\n", or "\r\n". 
            			Thus, it is the preferred way of specifying a line separator.
            			</para>
            </description>
          </item>
          <item>
            <term>processid</term>
            <description>
              <para>
            			Used to output the system process ID for the current process.
                        </para>
            </description>
          </item>
          <item>
            <term>property</term>
            <description>
              <para>
            			Used to output a specific context property. The key to 
            			lookup must be specified within braces and directly following the
            			pattern specifier, e.g. <b>%property{user}</b> would include the value
            			from the property that is keyed by the string 'user'. Each property value
            			that is to be included in the log must be specified separately.
            			Properties are stored in logging contexts. By default 
            			the <c>log4net:HostName</c> property is set to the name of machine on 
            			which the event was originally logged.
            			</para>
              <para>
            			If no key is specified, e.g. <b>%property</b> then all the keys and their
            			values are printed in a comma separated list.
            			</para>
              <para>
            			The properties of an event are combined from a number of different
            			contexts. These are listed below in the order in which they are searched.
            			</para>
              <list type="definition">
                <item>
                  <term>the thread properties</term>
                  <description>
            					The <see cref="P:log4net.ThreadContext.Properties" /> that are set on the current
            					thread. These properties are shared by all events logged on this thread.
            					</description>
                </item>
                <item>
                  <term>the global properties</term>
                  <description>
            					The <see cref="P:log4net.GlobalContext.Properties" /> that are set globally. These 
            					properties are shared by all the threads in the AppDomain.
            					</description>
                </item>
              </list>
            </description>
          </item>
          <item>
            <term>random</term>
            <description>
              <para>
                        Used to output a random string of characters. The string is made up of
                        uppercase letters and numbers. By default the string is 4 characters long.
                        The length of the string can be specified within braces directly following the
            			pattern specifier, e.g. <b>%random{8}</b> would output an 8 character string.
                        </para>
            </description>
          </item>
          <item>
            <term>username</term>
            <description>
              <para>
            			Used to output the WindowsIdentity for the currently
            			active user.
            			</para>
            </description>
          </item>
          <item>
            <term>utcdate</term>
            <description>
              <para>
            			Used to output the date of the logging event in universal time. 
            			The date conversion 
            			specifier may be followed by a <i>date format specifier</i> enclosed 
            			between braces. For example, <b>%utcdate{HH:mm:ss,fff}</b> or
            			<b>%utcdate{dd MMM yyyy HH:mm:ss,fff}</b>.  If no date format specifier is 
            			given then ISO8601 format is
            			assumed (<see cref="T:log4net.DateFormatter.Iso8601DateFormatter" />).
            			</para>
              <para>
            			The date format specifier admits the same syntax as the
            			time pattern string of the <see cref="M:DateTime.ToString(string)" />.
            			</para>
              <para>
            			For better results it is recommended to use the log4net date
            			formatters. These can be specified using one of the strings
            			"ABSOLUTE", "DATE" and "ISO8601" for specifying 
            			<see cref="T:log4net.DateFormatter.AbsoluteTimeDateFormatter" />, 
            			<see cref="T:log4net.DateFormatter.DateTimeDateFormatter" /> and respectively 
            			<see cref="T:log4net.DateFormatter.Iso8601DateFormatter" />. For example, 
            			<b>%utcdate{ISO8601}</b> or <b>%utcdate{ABSOLUTE}</b>.
            			</para>
              <para>
            			These dedicated date formatters perform significantly
            			better than <see cref="M:DateTime.ToString(string)" />.
            			</para>
            </description>
          </item>
          <item>
            <term>%</term>
            <description>
              <para>
            			The sequence %% outputs a single percent sign.
            			</para>
            </description>
          </item>
        </list>
        <para>
            Additional pattern converters may be registered with a specific <see cref="T:log4net.Util.PatternString" />
            instance using <see cref="M:AddConverter(ConverterInfo)" /> or
            <see cref="M:AddConverter(string, Type)" />.
            </para>
        <para>
            See the <see cref="T:log4net.Layout.PatternLayout" /> for details on the 
            <i>format modifiers</i> supported by the patterns.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Util.PatternString.s_globalRulesRegistry">
      <summary>
            Internal map of converter identifiers to converter types.
            </summary>
    </member>
    <member name="F:log4net.Util.PatternString.m_pattern">
      <summary>
            the pattern
            </summary>
    </member>
    <member name="F:log4net.Util.PatternString.m_head">
      <summary>
            the head of the pattern converter chain
            </summary>
    </member>
    <member name="F:log4net.Util.PatternString.m_instanceRulesRegistry">
      <summary>
            patterns defined on this PatternString only
            </summary>
    </member>
    <member name="M:log4net.Util.PatternString.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Initialize a new instance of <see cref="T:log4net.Util.PatternString" /></para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternString.#ctor(System.String)">
      <summary>
            Constructs a PatternString
            </summary>
      <param name="pattern">The pattern to use with this PatternString</param>
      <remarks>
        <para>
            Initialize a new instance of <see cref="T:log4net.Util.PatternString" /> with the pattern specified.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternString.ActivateOptions">
      <summary>
            Initialize object options
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Util.PatternString.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Util.PatternString.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Util.PatternString.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternString.CreatePatternParser(System.String)">
      <summary>
            Create the <see cref="T:log4net.Util.PatternParser" /> used to parse the pattern
            </summary>
      <param name="pattern">the pattern to parse</param>
      <returns>The <see cref="T:log4net.Util.PatternParser" /></returns>
      <remarks>
        <para>
            Returns PatternParser used to parse the conversion string. Subclasses
            may override this to return a subclass of PatternParser which recognize
            custom conversion pattern name.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternString.Format(System.IO.TextWriter)">
      <summary>
            Produces a formatted string as specified by the conversion pattern.
            </summary>
      <param name="writer">The TextWriter to write the formatted event to</param>
      <remarks>
        <para>
            Format the pattern to the <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternString.Format">
      <summary>
            Format the pattern as a string
            </summary>
      <returns>the pattern formatted as a string</returns>
      <remarks>
        <para>
            Format the pattern to a string.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternString.AddConverter(log4net.Util.ConverterInfo)">
      <summary>
            Add a converter to this PatternString
            </summary>
      <param name="converterInfo">the converter info</param>
      <remarks>
        <para>
            This version of the method is used by the configurator.
            Programmatic users should use the alternative <see cref="M:AddConverter(string,Type)" /> method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternString.AddConverter(System.String,System.Type)">
      <summary>
            Add a converter to this PatternString
            </summary>
      <param name="name">the name of the conversion pattern for this converter</param>
      <param name="type">the type of the converter</param>
      <remarks>
        <para>
            Add a converter to this PatternString
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.PatternString.ConversionPattern">
      <summary>
            Gets or sets the pattern formatting string
            </summary>
      <value>
            The pattern formatting string
            </value>
      <remarks>
        <para>
            The <b>ConversionPattern</b> option. This is the string which
            controls formatting and consists of a mix of literal content and
            conversion specifiers.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.ReadOnlyPropertiesDictionary">
      <summary>
            String keyed object map that is read only.
            </summary>
      <remarks>
        <para>
            This collection is readonly and cannot be modified.
            </para>
        <para>
            While this collection is serializable only member 
            objects that are serializable will
            be serialized along with this collection.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.ReadOnlyPropertiesDictionary.m_hashtable">
      <summary>
            The Hashtable used to store the properties data
            </summary>
    </member>
    <member name="M:log4net.Util.ReadOnlyPropertiesDictionary.#ctor">
      <summary>
            Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.ReadOnlyPropertiesDictionary" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReadOnlyPropertiesDictionary.#ctor(log4net.Util.ReadOnlyPropertiesDictionary)">
      <summary>
            Copy Constructor
            </summary>
      <param name="propertiesDictionary">properties to copy</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.ReadOnlyPropertiesDictionary" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReadOnlyPropertiesDictionary.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Deserialization constructor
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.ReadOnlyPropertiesDictionary" /> class 
            with serialized data.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReadOnlyPropertiesDictionary.GetKeys">
      <summary>
            Gets the key names.
            </summary>
      <returns>An array of all the keys.</returns>
      <remarks>
        <para>
            Gets the key names.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReadOnlyPropertiesDictionary.Contains(System.String)">
      <summary>
            Test if the dictionary contains a specified key
            </summary>
      <param name="key">the key to look for</param>
      <returns>true if the dictionary contains the specified key</returns>
      <remarks>
        <para>
            Test if the dictionary contains a specified key
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReadOnlyPropertiesDictionary.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Serializes this object into the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> provided.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
      <param name="context">The destination for this serialization.</param>
      <remarks>
        <para>
            Serializes this object into the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> provided.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReadOnlyPropertiesDictionary.Clear">
      <summary>
            Remove all properties from the properties collection
            </summary>
    </member>
    <member name="P:log4net.Util.ReadOnlyPropertiesDictionary.Item(System.String)">
      <summary>
            Gets or sets the value of the  property with the specified key.
            </summary>
      <value>
            The value of the property with the specified key.
            </value>
      <param name="key">The key of the property to get or set.</param>
      <remarks>
        <para>
            The property value will only be serialized if it is serializable.
            If it cannot be serialized it will be silently ignored if
            a serialization operation is performed.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.ReadOnlyPropertiesDictionary.InnerHashtable">
      <summary>
            The hashtable used to store the properties
            </summary>
      <value>
            The internal collection used to store the properties
            </value>
      <remarks>
        <para>
            The hashtable used to store the properties
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.ReadOnlyPropertiesDictionary.Count">
      <summary>
            The number of properties in this collection
            </summary>
    </member>
    <member name="T:log4net.Util.PropertiesDictionary">
      <summary>
            String keyed object map.
            </summary>
      <remarks>
        <para>
            While this collection is serializable only member 
            objects that are serializable will
            be serialized along with this collection.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Util.PropertiesDictionary.#ctor">
      <summary>
            Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.PropertiesDictionary" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PropertiesDictionary.#ctor(log4net.Util.ReadOnlyPropertiesDictionary)">
      <summary>
            Constructor
            </summary>
      <param name="propertiesDictionary">properties to copy</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.PropertiesDictionary" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PropertiesDictionary.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Util.PropertiesDictionary" /> class 
            with serialized data.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <remarks>
        <para>
            Because this class is sealed the serialization constructor is private.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PropertiesDictionary.Remove(System.String)">
      <summary>
            Remove the entry with the specified key from this dictionary
            </summary>
      <param name="key">the key for the entry to remove</param>
      <remarks>
        <para>
            Remove the entry with the specified key from this dictionary
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PropertiesDictionary.Clear">
      <summary>
            Remove all properties from the properties collection
            </summary>
      <remarks>
        <para>
            Remove all properties from the properties collection
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.PropertiesDictionary.Item(System.String)">
      <summary>
            Gets or sets the value of the  property with the specified key.
            </summary>
      <value>
            The value of the property with the specified key.
            </value>
      <param name="key">The key of the property to get or set.</param>
      <remarks>
        <para>
            The property value will only be serialized if it is serializable.
            If it cannot be serialized it will be silently ignored if
            a serialization operation is performed.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PropertyEntry">
      <summary>
            A class to hold the key and data for a property set in the config file
            </summary>
      <remarks>
        <para>
            A class to hold the key and data for a property set in the config file
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PropertyEntry.ToString">
      <summary>
            Override <c>Object.ToString</c> to return sensible debug info
            </summary>
      <returns>string info about this object</returns>
    </member>
    <member name="P:log4net.Util.PropertyEntry.Key">
      <summary>
            Property Key
            </summary>
      <value>
            Property Key
            </value>
      <remarks>
        <para>
            Property Key.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.PropertyEntry.Value">
      <summary>
            Property Value
            </summary>
      <value>
            Property Value
            </value>
      <remarks>
        <para>
            Property Value.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.ProtectCloseTextWriter">
      <summary>
            A <see cref="T:System.IO.TextWriter" /> that ignores the <see cref="M:log4net.Util.ProtectCloseTextWriter.Close" /> message
            </summary>
      <remarks>
        <para>
            This writer is used in special cases where it is necessary 
            to protect a writer from being closed by a client.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.ProtectCloseTextWriter.#ctor(System.IO.TextWriter)">
      <summary>
            Constructor
            </summary>
      <param name="writer">the writer to actually write to</param>
      <remarks>
        <para>
            Create a new ProtectCloseTextWriter using a writer
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ProtectCloseTextWriter.Attach(System.IO.TextWriter)">
      <summary>
            Attach this instance to a different underlying <see cref="T:System.IO.TextWriter" /></summary>
      <param name="writer">the writer to attach to</param>
      <remarks>
        <para>
            Attach this instance to a different underlying <see cref="T:System.IO.TextWriter" /></para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ProtectCloseTextWriter.Close">
      <summary>
            Does not close the underlying output writer.
            </summary>
      <remarks>
        <para>
            Does not close the underlying output writer.
            This method does nothing.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.ReaderWriterLock">
      <summary>
            Defines a lock that supports single writers and multiple readers
            </summary>
      <remarks>
        <para>
          <c>ReaderWriterLock</c> is used to synchronize access to a resource. 
            At any given time, it allows either concurrent read access for 
            multiple threads, or write access for a single thread. In a 
            situation where a resource is changed infrequently, a 
            <c>ReaderWriterLock</c> provides better throughput than a simple 
            one-at-a-time lock, such as <see cref="T:System.Threading.Monitor" />.
            </para>
        <para>
            If a platform does not support a <c>System.Threading.ReaderWriterLock</c> 
            implementation then all readers and writers are serialized. Therefore 
            the caller must not rely on multiple simultaneous readers.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.ReaderWriterLock.#ctor">
      <summary>
            Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.ReaderWriterLock" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReaderWriterLock.AcquireReaderLock">
      <summary>
            Acquires a reader lock
            </summary>
      <remarks>
        <para>
          <see cref="M:log4net.Util.ReaderWriterLock.AcquireReaderLock" /> blocks if a different thread has the writer 
            lock, or if at least one thread is waiting for the writer lock.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReaderWriterLock.ReleaseReaderLock">
      <summary>
            Decrements the lock count
            </summary>
      <remarks>
        <para>
          <see cref="M:log4net.Util.ReaderWriterLock.ReleaseReaderLock" /> decrements the lock count. When the count 
            reaches zero, the lock is released.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReaderWriterLock.AcquireWriterLock">
      <summary>
            Acquires the writer lock
            </summary>
      <remarks>
        <para>
            This method blocks if another thread has a reader lock or writer lock.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReaderWriterLock.ReleaseWriterLock">
      <summary>
            Decrements the lock count on the writer lock
            </summary>
      <remarks>
        <para>
            ReleaseWriterLock decrements the writer lock count. 
            When the count reaches zero, the writer lock is released.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.ReusableStringWriter">
      <summary>
            A <see cref="T:System.IO.StringWriter" /> that can be <see cref="M:log4net.Util.ReusableStringWriter.Reset(System.Int32,System.Int32)" /> and reused
            </summary>
      <remarks>
        <para>
            A <see cref="T:System.IO.StringWriter" /> that can be <see cref="M:log4net.Util.ReusableStringWriter.Reset(System.Int32,System.Int32)" /> and reused.
            This uses a single buffer for string operations.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.ReusableStringWriter.#ctor(System.IFormatProvider)">
      <summary>
            Create an instance of <see cref="T:log4net.Util.ReusableStringWriter" /></summary>
      <param name="formatProvider">the format provider to use</param>
      <remarks>
        <para>
            Create an instance of <see cref="T:log4net.Util.ReusableStringWriter" /></para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReusableStringWriter.Dispose(System.Boolean)">
      <summary>
            Override Dispose to prevent closing of writer
            </summary>
      <param name="disposing">flag</param>
      <remarks>
        <para>
            Override Dispose to prevent closing of writer
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReusableStringWriter.Reset(System.Int32,System.Int32)">
      <summary>
            Reset this string writer so that it can be reused.
            </summary>
      <param name="maxCapacity">the maximum buffer capacity before it is trimmed</param>
      <param name="defaultSize">the default size to make the buffer</param>
      <remarks>
        <para>
            Reset this string writer so that it can be reused.
            The internal buffers are cleared and reset.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.SystemInfo">
      <summary>
            Utility class for system specific information.
            </summary>
      <remarks>
        <para>
            Utility class of static methods for system specific information.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Alexey Solofnenko</author>
    </member>
    <member name="F:log4net.Util.SystemInfo.EmptyTypes">
      <summary>
            Gets an empty array of types.
            </summary>
      <remarks>
        <para>
            The <c>Type.EmptyTypes</c> field is not available on
            the .NET Compact Framework 1.0.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Util.SystemInfo.declaringType">
      <summary>
            The fully qualified type of the SystemInfo class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="F:log4net.Util.SystemInfo.s_hostName">
      <summary>
            Cache the host name for the current machine
            </summary>
    </member>
    <member name="F:log4net.Util.SystemInfo.s_appFriendlyName">
      <summary>
            Cache the application friendly name
            </summary>
    </member>
    <member name="F:log4net.Util.SystemInfo.s_nullText">
      <summary>
            Text to output when a <c>null</c> is encountered.
            </summary>
    </member>
    <member name="F:log4net.Util.SystemInfo.s_notAvailableText">
      <summary>
            Text to output when an unsupported feature is requested.
            </summary>
    </member>
    <member name="F:log4net.Util.SystemInfo.s_processStartTime">
      <summary>
            Start time for the current process.
            </summary>
    </member>
    <member name="M:log4net.Util.SystemInfo.#ctor">
      <summary>
            Private constructor to prevent instances.
            </summary>
      <remarks>
        <para>
            Only static methods are exposed from this type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.AssemblyLocationInfo(System.Reflection.Assembly)">
      <summary>
            Gets the assembly location path for the specified assembly.
            </summary>
      <param name="myAssembly">The assembly to get the location for.</param>
      <returns>The location of the assembly.</returns>
      <remarks>
        <para>
            This method does not guarantee to return the correct path
            to the assembly. If only tries to give an indication as to
            where the assembly was loaded from.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.AssemblyQualifiedName(System.Type)">
      <summary>
            Gets the fully qualified name of the <see cref="T:System.Type" />, including 
            the name of the assembly from which the <see cref="T:System.Type" /> was 
            loaded.
            </summary>
      <param name="type">The <see cref="T:System.Type" /> to get the fully qualified name for.</param>
      <returns>The fully qualified name for the <see cref="T:System.Type" />.</returns>
      <remarks>
        <para>
            This is equivalent to the <c>Type.AssemblyQualifiedName</c> property,
            but this method works on the .NET Compact Framework 1.0 as well as
            the full .NET runtime.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.AssemblyShortName(System.Reflection.Assembly)">
      <summary>
            Gets the short name of the <see cref="T:System.Reflection.Assembly" />.
            </summary>
      <param name="myAssembly">The <see cref="T:System.Reflection.Assembly" /> to get the name for.</param>
      <returns>The short name of the <see cref="T:System.Reflection.Assembly" />.</returns>
      <remarks>
        <para>
            The short name of the assembly is the <see cref="P:System.Reflection.Assembly.FullName" /> 
            without the version, culture, or public key. i.e. it is just the 
            assembly's file name without the extension.
            </para>
        <para>
            Use this rather than <c>Assembly.GetName().Name</c> because that
            is not available on the Compact Framework.
            </para>
        <para>
            Because of a FileIOPermission security demand we cannot do
            the obvious Assembly.GetName().Name. We are allowed to get
            the <see cref="P:System.Reflection.Assembly.FullName" /> of the assembly so we 
            start from there and strip out just the assembly name.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.AssemblyFileName(System.Reflection.Assembly)">
      <summary>
            Gets the file name portion of the <see cref="T:System.Reflection.Assembly" />, including the extension.
            </summary>
      <param name="myAssembly">The <see cref="T:System.Reflection.Assembly" /> to get the file name for.</param>
      <returns>The file name of the assembly.</returns>
      <remarks>
        <para>
            Gets the file name portion of the <see cref="T:System.Reflection.Assembly" />, including the extension.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.GetTypeFromString(System.Type,System.String,System.Boolean,System.Boolean)">
      <summary>
            Loads the type specified in the type string.
            </summary>
      <param name="relativeType">A sibling type to use to load the type.</param>
      <param name="typeName">The name of the type to load.</param>
      <param name="throwOnError">Flag set to <c>true</c> to throw an exception if the type cannot be loaded.</param>
      <param name="ignoreCase">
        <c>true</c> to ignore the case of the type name; otherwise, <c>false</c></param>
      <returns>The type loaded or <c>null</c> if it could not be loaded.</returns>
      <remarks>
        <para>
            If the type name is fully qualified, i.e. if contains an assembly name in 
            the type name, the type will be loaded from the system using 
            <see cref="M:Type.GetType(string,bool)" />.
            </para>
        <para>
            If the type name is not fully qualified, it will be loaded from the assembly
            containing the specified relative type. If the type is not found in the assembly 
            then all the loaded assemblies will be searched for the type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.GetTypeFromString(System.String,System.Boolean,System.Boolean)">
      <summary>
            Loads the type specified in the type string.
            </summary>
      <param name="typeName">The name of the type to load.</param>
      <param name="throwOnError">Flag set to <c>true</c> to throw an exception if the type cannot be loaded.</param>
      <param name="ignoreCase">
        <c>true</c> to ignore the case of the type name; otherwise, <c>false</c></param>
      <returns>The type loaded or <c>null</c> if it could not be loaded.</returns>
      <remarks>
        <para>
            If the type name is fully qualified, i.e. if contains an assembly name in 
            the type name, the type will be loaded from the system using 
            <see cref="M:Type.GetType(string,bool)" />.
            </para>
        <para>
            If the type name is not fully qualified it will be loaded from the
            assembly that is directly calling this method. If the type is not found 
            in the assembly then all the loaded assemblies will be searched for the type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.GetTypeFromString(System.Reflection.Assembly,System.String,System.Boolean,System.Boolean)">
      <summary>
            Loads the type specified in the type string.
            </summary>
      <param name="relativeAssembly">An assembly to load the type from.</param>
      <param name="typeName">The name of the type to load.</param>
      <param name="throwOnError">Flag set to <c>true</c> to throw an exception if the type cannot be loaded.</param>
      <param name="ignoreCase">
        <c>true</c> to ignore the case of the type name; otherwise, <c>false</c></param>
      <returns>The type loaded or <c>null</c> if it could not be loaded.</returns>
      <remarks>
        <para>
            If the type name is fully qualified, i.e. if contains an assembly name in 
            the type name, the type will be loaded from the system using 
            <see cref="M:Type.GetType(string,bool)" />.
            </para>
        <para>
            If the type name is not fully qualified it will be loaded from the specified
            assembly. If the type is not found in the assembly then all the loaded assemblies 
            will be searched for the type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.NewGuid">
      <summary>
            Generate a new guid
            </summary>
      <returns>A new Guid</returns>
      <remarks>
        <para>
            Generate a new guid
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.CreateArgumentOutOfRangeException(System.String,System.Object,System.String)">
      <summary>
            Create an <see cref="T:System.ArgumentOutOfRangeException" /></summary>
      <param name="parameterName">The name of the parameter that caused the exception</param>
      <param name="actualValue">The value of the argument that causes this exception</param>
      <param name="message">The message that describes the error</param>
      <returns>the ArgumentOutOfRangeException object</returns>
      <remarks>
        <para>
            Create a new instance of the <see cref="T:System.ArgumentOutOfRangeException" /> class 
            with a specified error message, the parameter name, and the value 
            of the argument.
            </para>
        <para>
            The Compact Framework does not support the 3 parameter constructor for the
            <see cref="T:System.ArgumentOutOfRangeException" /> type. This method provides an
            implementation that works for all platforms.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.TryParse(System.String,System.Int32@)">
      <summary>
            Parse a string into an <see cref="T:System.Int32" /> value
            </summary>
      <param name="s">the string to parse</param>
      <param name="val">out param where the parsed value is placed</param>
      <returns>
        <c>true</c> if the string was able to be parsed into an integer</returns>
      <remarks>
        <para>
            Attempts to parse the string into an integer. If the string cannot
            be parsed then this method returns <c>false</c>. The method does not throw an exception.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.TryParse(System.String,System.Int64@)">
      <summary>
            Parse a string into an <see cref="T:System.Int64" /> value
            </summary>
      <param name="s">the string to parse</param>
      <param name="val">out param where the parsed value is placed</param>
      <returns>
        <c>true</c> if the string was able to be parsed into an integer</returns>
      <remarks>
        <para>
            Attempts to parse the string into an integer. If the string cannot
            be parsed then this method returns <c>false</c>. The method does not throw an exception.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.TryParse(System.String,System.Int16@)">
      <summary>
            Parse a string into an <see cref="T:System.Int16" /> value
            </summary>
      <param name="s">the string to parse</param>
      <param name="val">out param where the parsed value is placed</param>
      <returns>
        <c>true</c> if the string was able to be parsed into an integer</returns>
      <remarks>
        <para>
            Attempts to parse the string into an integer. If the string cannot
            be parsed then this method returns <c>false</c>. The method does not throw an exception.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.GetAppSetting(System.String)">
      <summary>
            Lookup an application setting
            </summary>
      <param name="key">the application settings key to lookup</param>
      <returns>the value for the key, or <c>null</c></returns>
      <remarks>
        <para>
            Configuration APIs are not supported under the Compact Framework
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.ConvertToFullPath(System.String)">
      <summary>
            Convert a path into a fully qualified local file path.
            </summary>
      <param name="path">The path to convert.</param>
      <returns>The fully qualified path.</returns>
      <remarks>
        <para>
            Converts the path specified to a fully
            qualified path. If the path is relative it is
            taken as relative from the application base 
            directory.
            </para>
        <para>
            The path specified must be a local file path, a URI is not supported.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.CreateCaseInsensitiveHashtable">
      <summary>
            Creates a new case-insensitive instance of the <see cref="T:System.Collections.Hashtable" /> class with the default initial capacity. 
            </summary>
      <returns>A new case-insensitive instance of the <see cref="T:System.Collections.Hashtable" /> class with the default initial capacity</returns>
      <remarks>
        <para>
            The new Hashtable instance uses the default load factor, the CaseInsensitiveHashCodeProvider, and the CaseInsensitiveComparer.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.SystemInfo.NewLine">
      <summary>
            Gets the system dependent line terminator.
            </summary>
      <value>
            The system dependent line terminator.
            </value>
      <remarks>
        <para>
            Gets the system dependent line terminator.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.SystemInfo.ApplicationBaseDirectory">
      <summary>
            Gets the base directory for this <see cref="T:System.AppDomain" />.
            </summary>
      <value>The base directory path for the current <see cref="T:System.AppDomain" />.</value>
      <remarks>
        <para>
            Gets the base directory for this <see cref="T:System.AppDomain" />.
            </para>
        <para>
            The value returned may be either a local file path or a URI.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.SystemInfo.ConfigurationFileLocation">
      <summary>
            Gets the path to the configuration file for the current <see cref="T:System.AppDomain" />.
            </summary>
      <value>The path to the configuration file for the current <see cref="T:System.AppDomain" />.</value>
      <remarks>
        <para>
            The .NET Compact Framework 1.0 does not have a concept of a configuration
            file. For this runtime, we use the entry assembly location as the root for
            the configuration file name.
            </para>
        <para>
            The value returned may be either a local file path or a URI.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.SystemInfo.EntryAssemblyLocation">
      <summary>
            Gets the path to the file that first executed in the current <see cref="T:System.AppDomain" />.
            </summary>
      <value>The path to the entry assembly.</value>
      <remarks>
        <para>
            Gets the path to the file that first executed in the current <see cref="T:System.AppDomain" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.SystemInfo.CurrentThreadId">
      <summary>
            Gets the ID of the current thread.
            </summary>
      <value>The ID of the current thread.</value>
      <remarks>
        <para>
            On the .NET framework, the <c>AppDomain.GetCurrentThreadId</c> method
            is used to obtain the thread ID for the current thread. This is the 
            operating system ID for the thread.
            </para>
        <para>
            On the .NET Compact Framework 1.0 it is not possible to get the 
            operating system thread ID for the current thread. The native method 
            <c>GetCurrentThreadId</c> is implemented inline in a header file
            and cannot be called.
            </para>
        <para>
            On the .NET Framework 2.0 the <c>Thread.ManagedThreadId</c> is used as this
            gives a stable id unrelated to the operating system thread ID which may 
            change if the runtime is using fibers.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.SystemInfo.HostName">
      <summary>
            Get the host name or machine name for the current machine
            </summary>
      <value>
            The hostname or machine name
            </value>
      <remarks>
        <para>
            Get the host name or machine name for the current machine
            </para>
        <para>
            The host name (<see cref="M:System.Net.Dns.GetHostName" />) or
            the machine name (<c>Environment.MachineName</c>) for
            the current machine, or if neither of these are available
            then <c>NOT AVAILABLE</c> is returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.SystemInfo.ApplicationFriendlyName">
      <summary>
            Get this application's friendly name
            </summary>
      <value>
            The friendly name of this application as a string
            </value>
      <remarks>
        <para>
            If available the name of the application is retrieved from
            the <c>AppDomain</c> using <c>AppDomain.CurrentDomain.FriendlyName</c>.
            </para>
        <para>
            Otherwise the file name of the entry assembly is used.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.SystemInfo.ProcessStartTime">
      <summary>
            Get the start time for the current process.
            </summary>
      <remarks>
        <para>
            This is the time at which the log4net library was loaded into the
            AppDomain. Due to reports of a hang in the call to <c>System.Diagnostics.Process.StartTime</c>
            this is not the start time for the current process.
            </para>
        <para>
            The log4net library should be loaded by an application early during its
            startup, therefore this start time should be a good approximation for
            the actual start time.
            </para>
        <para>
            Note that AppDomains may be loaded and unloaded within the
            same process without the process terminating, however this start time
            will be set per AppDomain.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.SystemInfo.NullText">
      <summary>
            Text to output when a <c>null</c> is encountered.
            </summary>
      <remarks>
        <para>
            Use this value to indicate a <c>null</c> has been encountered while
            outputting a string representation of an item.
            </para>
        <para>
            The default value is <c>(null)</c>. This value can be overridden by specifying
            a value for the <c>log4net.NullText</c> appSetting in the application's
            .config file.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.SystemInfo.NotAvailableText">
      <summary>
            Text to output when an unsupported feature is requested.
            </summary>
      <remarks>
        <para>
            Use this value when an unsupported feature is requested.
            </para>
        <para>
            The default value is <c>NOT AVAILABLE</c>. This value can be overridden by specifying
            a value for the <c>log4net.NotAvailableText</c> appSetting in the application's
            .config file.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.SystemStringFormat">
      <summary>
            Utility class that represents a format string.
            </summary>
      <remarks>
        <para>
            Utility class that represents a format string.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Util.SystemStringFormat.declaringType">
      <summary>
            The fully qualified type of the SystemStringFormat class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Util.SystemStringFormat.#ctor(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Initialise the <see cref="T:log4net.Util.SystemStringFormat" /></summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information.</param>
      <param name="format">A <see cref="T:System.String" /> containing zero or more format items.</param>
      <param name="args">An <see cref="T:System.Object" /> array containing zero or more objects to format.</param>
    </member>
    <member name="M:log4net.Util.SystemStringFormat.ToString">
      <summary>
            Format the string and arguments
            </summary>
      <returns>the formatted string</returns>
    </member>
    <member name="M:log4net.Util.SystemStringFormat.StringFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Replaces the format item in a specified <see cref="T:System.String" /> with the text equivalent 
            of the value of a corresponding <see cref="T:System.Object" /> instance in a specified array.
            A specified parameter supplies culture-specific formatting information.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information.</param>
      <param name="format">A <see cref="T:System.String" /> containing zero or more format items.</param>
      <param name="args">An <see cref="T:System.Object" /> array containing zero or more objects to format.</param>
      <returns>
            A copy of format in which the format items have been replaced by the <see cref="T:System.String" /> 
            equivalent of the corresponding instances of <see cref="T:System.Object" /> in args.
            </returns>
      <remarks>
        <para>
            This method does not throw exceptions. If an exception thrown while formatting the result the
            exception and arguments are returned in the result string.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemStringFormat.StringFormatError(System.Exception,System.String,System.Object[])">
      <summary>
            Process an error during StringFormat
            </summary>
    </member>
    <member name="M:log4net.Util.SystemStringFormat.RenderArray(System.Array,System.Text.StringBuilder)">
      <summary>
            Dump the contents of an array into a string builder
            </summary>
    </member>
    <member name="M:log4net.Util.SystemStringFormat.RenderObject(System.Object,System.Text.StringBuilder)">
      <summary>
            Dump an object to a string
            </summary>
    </member>
    <member name="T:log4net.Util.ThreadContextProperties">
      <summary>
            Implementation of Properties collection for the <see cref="T:log4net.ThreadContext" /></summary>
      <remarks>
        <para>
            Class implements a collection of properties that is specific to each thread.
            The class is not synchronized as each thread has its own <see cref="T:log4net.Util.PropertiesDictionary" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Util.ThreadContextProperties._dictionary">
      <summary>
            Each thread will automatically have its instance.
            </summary>
    </member>
    <member name="M:log4net.Util.ThreadContextProperties.#ctor">
      <summary>
            Internal constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.ThreadContextProperties" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ThreadContextProperties.Remove(System.String)">
      <summary>
            Remove a property
            </summary>
      <param name="key">the key for the entry to remove</param>
      <remarks>
        <para>
            Remove a property
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ThreadContextProperties.GetKeys">
      <summary>
            Get the keys stored in the properties.
            </summary>
      <para>
            Gets the keys stored in the properties.
            </para>
      <returns>a set of the defined keys</returns>
    </member>
    <member name="M:log4net.Util.ThreadContextProperties.Clear">
      <summary>
            Clear all properties
            </summary>
      <remarks>
        <para>
            Clear all properties
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ThreadContextProperties.GetProperties(System.Boolean)">
      <summary>
            Get the <c>PropertiesDictionary</c> for this thread.
            </summary>
      <param name="create">create the dictionary if it does not exist, otherwise return null if does not exist</param>
      <returns>the properties for this thread</returns>
      <remarks>
        <para>
            The collection returned is only to be used on the calling thread. If the
            caller needs to share the collection between different threads then the 
            caller must clone the collection before doing so.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.ThreadContextProperties.Item(System.String)">
      <summary>
            Gets or sets the value of a property
            </summary>
      <value>
            The value for the property with the specified key
            </value>
      <remarks>
        <para>
            Gets or sets the value of a property
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.ThreadContextStack">
      <summary>
            Implementation of Stack for the <see cref="T:log4net.ThreadContext" /></summary>
      <remarks>
        <para>
            Implementation of Stack for the <see cref="T:log4net.ThreadContext" /></para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="T:log4net.Util.ThreadContextStack.StackFrame">
      <summary>
            Inner class used to represent a single context frame in the stack.
            </summary>
      <remarks>
        <para>
            Inner class used to represent a single context frame in the stack.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ThreadContextStack.StackFrame.#ctor(System.String,log4net.Util.ThreadContextStack.StackFrame)">
      <summary>
            Constructor
            </summary>
      <param name="message">The message for this context.</param>
      <param name="parent">The parent context in the chain.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.ThreadContextStack.StackFrame" /> class
            with the specified message and parent context.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.ThreadContextStack.StackFrame.Message">
      <summary>
            Get the message.
            </summary>
      <value>The message.</value>
      <remarks>
        <para>
            Get the message.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.ThreadContextStack.StackFrame.FullMessage">
      <summary>
            Gets the full text of the context down to the root level.
            </summary>
      <value>
            The full text of the context down to the root level.
            </value>
      <remarks>
        <para>
            Gets the full text of the context down to the root level.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.ThreadContextStack.AutoPopStackFrame">
      <summary>
            Struct returned from the <see cref="M:log4net.Util.ThreadContextStack.Push(System.String)" /> method.
            </summary>
      <remarks>
        <para>
            This struct implements the <see cref="T:System.IDisposable" /> and is designed to be used
            with the <see langword="using" /> pattern to remove the stack frame at the end of the scope.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ThreadContextStack.AutoPopStackFrame.#ctor(System.Collections.Stack,System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="frameStack">The internal stack used by the ThreadContextStack.</param>
      <param name="frameDepth">The depth to return the stack to when this object is disposed.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.ThreadContextStack.AutoPopStackFrame" /> class with
            the specified stack and return depth.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ThreadContextStack.AutoPopStackFrame.Dispose">
      <summary>
            Returns the stack to the correct depth.
            </summary>
      <remarks>
        <para>
            Returns the stack to the correct depth.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Util.ThreadContextStack.m_stack">
      <summary>
            The stack store.
            </summary>
    </member>
    <member name="M:log4net.Util.ThreadContextStack.#ctor">
      <summary>
            Internal constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.ThreadContextStack" /> class. 
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ThreadContextStack.Clear">
      <summary>
            Clears all the contextual information held in this stack.
            </summary>
      <remarks>
        <para>
            Clears all the contextual information held in this stack.
            Only call this if you think that this tread is being reused after
            a previous call execution which may not have completed correctly.
            You do not need to use this method if you always guarantee to call
            the <see cref="M:System.IDisposable.Dispose" /> method of the <see cref="T:System.IDisposable" />
            returned from <see cref="M:log4net.Util.ThreadContextStack.Push(System.String)" /> even in exceptional circumstances,
            for example by using the <c>using(log4net.ThreadContext.Stacks["NDC"].Push("Stack_Message"))</c> 
            syntax.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ThreadContextStack.Pop">
      <summary>
            Removes the top context from this stack.
            </summary>
      <returns>The message in the context that was removed from the top of this stack.</returns>
      <remarks>
        <para>
            Remove the top context from this stack, and return
            it to the caller. If this stack is empty then an
            empty string (not <see langword="null" />) is returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ThreadContextStack.Push(System.String)">
      <summary>
            Pushes a new context message into this stack.
            </summary>
      <param name="message">The new context message.</param>
      <returns>
            An <see cref="T:System.IDisposable" /> that can be used to clean up the context stack.
            </returns>
      <remarks>
        <para>
            Pushes a new context onto this stack. An <see cref="T:System.IDisposable" />
            is returned that can be used to clean up this stack. This
            can be easily combined with the <c>using</c> keyword to scope the
            context.
            </para>
      </remarks>
      <example>Simple example of using the <c>Push</c> method with the <c>using</c> keyword.
            <code lang="C#">
            using(log4net.ThreadContext.Stacks["NDC"].Push("Stack_Message"))
            {
            	log.Warn("This should have an ThreadContext Stack message");
            }
            </code></example>
    </member>
    <member name="M:log4net.Util.ThreadContextStack.GetFullMessage">
      <summary>
            Gets the current context information for this stack.
            </summary>
      <returns>The current context information.</returns>
    </member>
    <member name="M:log4net.Util.ThreadContextStack.ToString">
      <summary>
            Gets the current context information for this stack.
            </summary>
      <returns>Gets the current context information</returns>
      <remarks>
        <para>
            Gets the current context information for this stack.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.ThreadContextStack.Count">
      <summary>
            The number of messages in the stack
            </summary>
      <value>
            The current number of messages in the stack
            </value>
      <remarks>
        <para>
            The current number of messages in the stack. That is
            the number of times <see cref="M:log4net.Util.ThreadContextStack.Push(System.String)" /> has been called
            minus the number of times <see cref="M:log4net.Util.ThreadContextStack.Pop" /> has been called.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.ThreadContextStack.InternalStack">
      <summary>
            Gets and sets the internal stack used by this <see cref="T:log4net.Util.ThreadContextStack" /></summary>
      <value>The internal storage stack</value>
      <remarks>
        <para>
            This property is provided only to support backward compatability 
            of the <see cref="T:log4net.NDC" />. Tytpically the internal stack should not
            be modified.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.ThreadContextStacks">
      <summary>
            Implementation of Stacks collection for the <see cref="T:log4net.ThreadContext" /></summary>
      <remarks>
        <para>
            Implementation of Stacks collection for the <see cref="T:log4net.ThreadContext" /></para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Util.ThreadContextStacks.declaringType">
      <summary>
            The fully qualified type of the ThreadContextStacks class.
            </summary>
      <remarks>
            Used by the internal logger to record the Type of the
            log message.
            </remarks>
    </member>
    <member name="M:log4net.Util.ThreadContextStacks.#ctor(log4net.Util.ContextPropertiesBase)">
      <summary>
            Internal constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.ThreadContextStacks" /> class.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.ThreadContextStacks.Item(System.String)">
      <summary>
            Gets the named thread context stack
            </summary>
      <value>
            The named stack
            </value>
      <remarks>
        <para>
            Gets the named thread context stack
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.Transform">
      <summary>
            Utility class for transforming strings.
            </summary>
      <remarks>
        <para>
            Utility class for transforming strings.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.Transform.INVALIDCHARS">
      <summary>
            Characters illegal in XML 1.0
            </summary>
    </member>
    <member name="M:log4net.Util.Transform.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Util.Transform" /> class. 
            </summary>
      <remarks>
        <para>
            Uses a private access modifier to prevent instantiation of this class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.Transform.WriteEscapedXmlString(System.Xml.XmlWriter,System.String,System.String)">
      <summary>
            Write a string to an <see cref="T:System.Xml.XmlWriter" /></summary>
      <param name="writer">the writer to write to</param>
      <param name="textData">the string to write</param>
      <param name="invalidCharReplacement">The string to replace non XML compliant chars with</param>
      <remarks>
        <para>
            The test is escaped either using XML escape entities
            or using CDATA sections.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.Transform.MaskXmlInvalidCharacters(System.String,System.String)">
      <summary>
            Replace invalid XML characters in text string
            </summary>
      <param name="textData">the XML text input string</param>
      <param name="mask">the string to use in place of invalid characters</param>
      <returns>A string that does not contain invalid XML characters.</returns>
      <remarks>
        <para>
            Certain Unicode code points are not allowed in the XML InfoSet, for
            details see: <a href="http://www.w3.org/TR/REC-xml/#charsets">http://www.w3.org/TR/REC-xml/#charsets</a>.
            </para>
        <para>
            This method replaces any illegal characters in the input string
            with the mask string specified.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.Transform.CountSubstrings(System.String,System.String)">
      <summary>
            Count the number of times that the substring occurs in the text
            </summary>
      <param name="text">the text to search</param>
      <param name="substring">the substring to find</param>
      <returns>the number of times the substring occurs in the text</returns>
      <remarks>
        <para>
            The substring is assumed to be non repeating within itself.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.WindowsSecurityContext">
      <summary>
            Impersonate a Windows Account
            </summary>
      <remarks>
        <para>
            This <see cref="T:log4net.Core.SecurityContext" /> impersonates a Windows account.
            </para>
        <para>
            How the impersonation is done depends on the value of <see cref="M:log4net.Util.WindowsSecurityContext.Impersonate(System.Object)" />.
            This allows the context to either impersonate a set of user credentials specified 
            using username, domain name and password or to revert to the process credentials.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.WindowsSecurityContext.ImpersonationMode">
      <summary>
            The impersonation modes for the <see cref="T:log4net.Util.WindowsSecurityContext" /></summary>
      <remarks>
        <para>
            See the <see cref="P:log4net.Util.WindowsSecurityContext.Credentials" /> property for
            details.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.WindowsSecurityContext.DisposableImpersonationContext">
      <summary>
            Adds <see cref="T:System.IDisposable" /> to <see cref="T:System.Security.Principal.WindowsImpersonationContext" /></summary>
      <remarks>
        <para>
            Helper class to expose the <see cref="T:System.Security.Principal.WindowsImpersonationContext" />
            through the <see cref="T:System.IDisposable" /> interface.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.WindowsSecurityContext.DisposableImpersonationContext.#ctor(System.Security.Principal.WindowsImpersonationContext)">
      <summary>
            Constructor
            </summary>
      <param name="impersonationContext">the impersonation context being wrapped</param>
      <remarks>
        <para>
            Constructor
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.WindowsSecurityContext.DisposableImpersonationContext.Dispose">
      <summary>
            Revert the impersonation
            </summary>
      <remarks>
        <para>
            Revert the impersonation
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.WindowsSecurityContext.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Default constructor
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.WindowsSecurityContext.ActivateOptions">
      <summary>
            Initialize the SecurityContext based on the options set.
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Util.WindowsSecurityContext.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Util.WindowsSecurityContext.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Util.WindowsSecurityContext.ActivateOptions" /> must be called again.
            </para>
        <para>
            The security context will try to Logon the specified user account and
            capture a primary token for impersonation.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">The required <see cref="P:log4net.Util.WindowsSecurityContext.UserName" />, 
            <see cref="P:log4net.Util.WindowsSecurityContext.DomainName" /> or <see cref="P:log4net.Util.WindowsSecurityContext.Password" /> properties were not specified.</exception>
    </member>
    <member name="M:log4net.Util.WindowsSecurityContext.Impersonate(System.Object)">
      <summary>
            Impersonate the Windows account specified by the <see cref="P:log4net.Util.WindowsSecurityContext.UserName" /> and <see cref="P:log4net.Util.WindowsSecurityContext.DomainName" /> properties.
            </summary>
      <param name="state">caller provided state</param>
      <returns>
            An <see cref="T:System.IDisposable" /> instance that will revoke the impersonation of this SecurityContext
            </returns>
      <remarks>
        <para>
            Depending on the <see cref="P:log4net.Util.WindowsSecurityContext.Credentials" /> property either
            impersonate a user using credentials supplied or revert 
            to the process credentials.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.WindowsSecurityContext.LogonUser(System.String,System.String,System.String)">
      <summary>
            Create a <see cref="T:System.Security.Principal.WindowsIdentity" /> given the userName, domainName and password.
            </summary>
      <param name="userName">the user name</param>
      <param name="domainName">the domain name</param>
      <param name="password">the password</param>
      <returns>the <see cref="T:System.Security.Principal.WindowsIdentity" /> for the account specified</returns>
      <remarks>
        <para>
            Uses the Windows API call LogonUser to get a principal token for the account. This
            token is used to initialize the WindowsIdentity.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.WindowsSecurityContext.Credentials">
      <summary>
            Gets or sets the impersonation mode for this security context
            </summary>
      <value>
            The impersonation mode for this security context
            </value>
      <remarks>
        <para>
            Impersonate either a user with user credentials or
            revert this thread to the credentials of the process.
            The value is one of the <see cref="T:log4net.Util.WindowsSecurityContext.ImpersonationMode" />
            enum.
            </para>
        <para>
            The default value is <see cref="F:log4net.Util.WindowsSecurityContext.ImpersonationMode.User" /></para>
        <para>
            When the mode is set to <see cref="F:log4net.Util.WindowsSecurityContext.ImpersonationMode.User" />
            the user's credentials are established using the
            <see cref="P:log4net.Util.WindowsSecurityContext.UserName" />, <see cref="P:log4net.Util.WindowsSecurityContext.DomainName" /> and <see cref="P:log4net.Util.WindowsSecurityContext.Password" />
            values.
            </para>
        <para>
            When the mode is set to <see cref="F:log4net.Util.WindowsSecurityContext.ImpersonationMode.Process" />
            no other properties need to be set. If the calling thread is 
            impersonating then it will be reverted back to the process credentials.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.WindowsSecurityContext.UserName">
      <summary>
            Gets or sets the Windows username for this security context
            </summary>
      <value>
            The Windows username for this security context
            </value>
      <remarks>
        <para>
            This property must be set if <see cref="P:log4net.Util.WindowsSecurityContext.Credentials" />
            is set to <see cref="F:log4net.Util.WindowsSecurityContext.ImpersonationMode.User" /> (the default setting).
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.WindowsSecurityContext.DomainName">
      <summary>
            Gets or sets the Windows domain name for this security context
            </summary>
      <value>
            The Windows domain name for this security context
            </value>
      <remarks>
        <para>
            The default value for <see cref="P:log4net.Util.WindowsSecurityContext.DomainName" /> is the local machine name
            taken from the <see cref="P:System.Environment.MachineName" /> property.
            </para>
        <para>
            This property must be set if <see cref="P:log4net.Util.WindowsSecurityContext.Credentials" />
            is set to <see cref="F:log4net.Util.WindowsSecurityContext.ImpersonationMode.User" /> (the default setting).
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.WindowsSecurityContext.Password">
      <summary>
            Sets the password for the Windows account specified by the <see cref="P:log4net.Util.WindowsSecurityContext.UserName" /> and <see cref="P:log4net.Util.WindowsSecurityContext.DomainName" /> properties.
            </summary>
      <value>
            The password for the Windows account specified by the <see cref="P:log4net.Util.WindowsSecurityContext.UserName" /> and <see cref="P:log4net.Util.WindowsSecurityContext.DomainName" /> properties.
            </value>
      <remarks>
        <para>
            This property must be set if <see cref="P:log4net.Util.WindowsSecurityContext.Credentials" />
            is set to <see cref="F:log4net.Util.WindowsSecurityContext.ImpersonationMode.User" /> (the default setting).
            </para>
      </remarks>
    </member>
    <member name="T:log4net.GlobalContext">
      <summary>
            The log4net Global Context.
            </summary>
      <remarks>
        <para>
            The <c>GlobalContext</c> provides a location for global debugging 
            information to be stored.
            </para>
        <para>
            The global context has a properties map and these properties can 
            be included in the output of log messages. The <see cref="T:log4net.Layout.PatternLayout" />
            supports selecting and outputing these properties.
            </para>
        <para>
            By default the <c>log4net:HostName</c> property is set to the name of 
            the current machine.
            </para>
      </remarks>
      <example>
        <code lang="C#">
            GlobalContext.Properties["hostname"] = Environment.MachineName;
            </code>
      </example>
      <threadsafety static="true" instance="true" />
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.GlobalContext.s_properties">
      <summary>
            The global context properties instance
            </summary>
    </member>
    <member name="M:log4net.GlobalContext.#ctor">
      <summary>
            Private Constructor. 
            </summary>
      <remarks>
            Uses a private access modifier to prevent instantiation of this class.
            </remarks>
    </member>
    <member name="P:log4net.GlobalContext.Properties">
      <summary>
            The global properties map.
            </summary>
      <value>
            The global properties map.
            </value>
      <remarks>
        <para>
            The global properties map.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.AssemblyInfo">
      <summary>
            Provides information about the environment the assembly has
            been built for.
            </summary>
    </member>
    <member name="F:log4net.AssemblyInfo.Version">
      <summary>Version of the assembly</summary>
    </member>
    <member name="F:log4net.AssemblyInfo.TargetFrameworkVersion">
      <summary>Version of the framework targeted</summary>
    </member>
    <member name="F:log4net.AssemblyInfo.TargetFramework">
      <summary>Type of framework targeted</summary>
    </member>
    <member name="F:log4net.AssemblyInfo.ClientProfile">
      <summary>Does it target a client profile?</summary>
    </member>
    <member name="P:log4net.AssemblyInfo.Info">
      <summary>
            Identifies the version and target for this assembly.
            </summary>
    </member>
    <member name="T:log4net.LogicalThreadContext">
      <summary>
            The log4net Logical Thread Context.
            </summary>
      <remarks>
        <para>
            The <c>LogicalThreadContext</c> provides a location for <see cref="T:System.Runtime.Remoting.Messaging.CallContext" /> specific debugging 
            information to be stored.
            The <c>LogicalThreadContext</c> properties override any <see cref="T:log4net.ThreadContext" /> or <see cref="T:log4net.GlobalContext" />
            properties with the same name.
            </para>
        <para>
            The Logical Thread Context has a properties map and a stack.
            The properties and stack can 
            be included in the output of log messages. The <see cref="T:log4net.Layout.PatternLayout" />
            supports selecting and outputting these properties.
            </para>
        <para>
            The Logical Thread Context provides a diagnostic context for the current call context. 
            This is an instrument for distinguishing interleaved log
            output from different sources. Log output is typically interleaved
            when a server handles multiple clients near-simultaneously.
            </para>
        <para>
            The Logical Thread Context is managed on a per <see cref="T:System.Runtime.Remoting.Messaging.CallContext" /> basis.
            </para>
        <para>
            The <see cref="T:System.Runtime.Remoting.Messaging.CallContext" /> requires a link time 
            <see cref="T:System.Security.Permissions.SecurityPermission" /> for the
            <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.
            If the calling code does not have this permission then this context will be disabled.
            It will not store any property values set on it.
            </para>
      </remarks>
      <example>Example of using the thread context properties to store a username.
            <code lang="C#">
            LogicalThreadContext.Properties["user"] = userName;
            log.Info("This log message has a LogicalThreadContext Property called 'user'");
            </code></example>
      <example>Example of how to push a message into the context stack
            <code lang="C#">
            using(LogicalThreadContext.Stacks["LDC"].Push("my context message"))
            {
            	log.Info("This log message has a LogicalThreadContext Stack message that includes 'my context message'");
            
            } // at the end of the using block the message is automatically popped 
            </code></example>
      <threadsafety static="true" instance="true" />
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.LogicalThreadContext.s_properties">
      <summary>
            The thread context properties instance
            </summary>
    </member>
    <member name="F:log4net.LogicalThreadContext.s_stacks">
      <summary>
            The thread context stacks instance
            </summary>
    </member>
    <member name="M:log4net.LogicalThreadContext.#ctor">
      <summary>
            Private Constructor. 
            </summary>
      <remarks>
        <para>
            Uses a private access modifier to prevent instantiation of this class.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.LogicalThreadContext.Properties">
      <summary>
            The thread properties map
            </summary>
      <value>
            The thread properties map
            </value>
      <remarks>
        <para>
            The <c>LogicalThreadContext</c> properties override any <see cref="T:log4net.ThreadContext" /> 
            or <see cref="T:log4net.GlobalContext" /> properties with the same name.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.LogicalThreadContext.Stacks">
      <summary>
            The thread stacks
            </summary>
      <value>
            stack map
            </value>
      <remarks>
        <para>
            The logical thread stacks.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.LogManager">
      <summary>
            This class is used by client applications to request logger instances.
            </summary>
      <remarks>
        <para>
            This class has static methods that are used by a client to request
            a logger instance. The <see cref="M:GetLogger(string)" /> method is 
            used to retrieve a logger.
            </para>
        <para>
            See the <see cref="T:log4net.ILog" /> interface for more details.
            </para>
      </remarks>
      <example>Simple example of logging messages
            <code lang="C#">
            ILog log = LogManager.GetLogger("application-log");
            
            log.Info("Application Start");
            log.Debug("This is a debug message");
            
            if (log.IsDebugEnabled)
            {
            	log.Debug("This is another debug message");
            }
            </code></example>
      <threadsafety static="true" instance="true" />
      <seealso cref="T:log4net.ILog" />
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.LogManager.s_wrapperMap">
      <summary>
            The wrapper map to use to hold the <see cref="T:log4net.Core.LogImpl" /> objects.
            </summary>
    </member>
    <member name="M:log4net.LogManager.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.LogManager" /> class. 
            </summary>
      <remarks>
            Uses a private access modifier to prevent instantiation of this class.
            </remarks>
    </member>
    <member name="M:log4net.LogManager.Exists(System.String)">
      <overloads>Returns the named logger if it exists.</overloads>
      <summary>
            Returns the named logger if it exists.
            </summary>
      <remarks>
        <para>
            If the named logger exists (in the default repository) then it
            returns a reference to the logger, otherwise it returns <c>null</c>.
            </para>
      </remarks>
      <param name="name">The fully qualified logger name to look for.</param>
      <returns>The logger found, or <c>null</c> if no logger could be found.</returns>
    </member>
    <member name="M:log4net.LogManager.Exists(System.String,System.String)">
      <summary>
            Returns the named logger if it exists.
            </summary>
      <remarks>
        <para>
            If the named logger exists (in the specified repository) then it
            returns a reference to the logger, otherwise it returns
            <c>null</c>.
            </para>
      </remarks>
      <param name="repository">The repository to lookup in.</param>
      <param name="name">The fully qualified logger name to look for.</param>
      <returns>
            The logger found, or <c>null</c> if the logger doesn't exist in the specified 
            repository.
            </returns>
    </member>
    <member name="M:log4net.LogManager.Exists(System.Reflection.Assembly,System.String)">
      <summary>
            Returns the named logger if it exists.
            </summary>
      <remarks>
        <para>
            If the named logger exists (in the repository for the specified assembly) then it
            returns a reference to the logger, otherwise it returns
            <c>null</c>.
            </para>
      </remarks>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
      <param name="name">The fully qualified logger name to look for.</param>
      <returns>
            The logger, or <c>null</c> if the logger doesn't exist in the specified
            assembly's repository.
            </returns>
    </member>
    <member name="M:log4net.LogManager.GetCurrentLoggers">
      <overloads>Get the currently defined loggers.</overloads>
      <summary>
            Returns all the currently defined loggers in the default repository.
            </summary>
      <remarks>
        <para>The root logger is <b>not</b> included in the returned array.</para>
      </remarks>
      <returns>All the defined loggers.</returns>
    </member>
    <member name="M:log4net.LogManager.GetCurrentLoggers(System.String)">
      <summary>
            Returns all the currently defined loggers in the specified repository.
            </summary>
      <param name="repository">The repository to lookup in.</param>
      <remarks>
            The root logger is <b>not</b> included in the returned array.
            </remarks>
      <returns>All the defined loggers.</returns>
    </member>
    <member name="M:log4net.LogManager.GetCurrentLoggers(System.Reflection.Assembly)">
      <summary>
            Returns all the currently defined loggers in the specified assembly's repository.
            </summary>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
      <remarks>
            The root logger is <b>not</b> included in the returned array.
            </remarks>
      <returns>All the defined loggers.</returns>
    </member>
    <member name="M:log4net.LogManager.GetLogger(System.String)">
      <overloads>Get or create a logger.</overloads>
      <summary>
            Retrieves or creates a named logger.
            </summary>
      <remarks>
        <para>
            Retrieves a logger named as the <paramref name="name" />
            parameter. If the named logger already exists, then the
            existing instance will be returned. Otherwise, a new instance is
            created.
            </para>
        <para>By default, loggers do not have a set level but inherit
            it from the hierarchy. This is one of the central features of
            log4net.
            </para>
      </remarks>
      <param name="name">The name of the logger to retrieve.</param>
      <returns>The logger with the name specified.</returns>
    </member>
    <member name="M:log4net.LogManager.GetLogger(System.String,System.String)">
      <summary>
            Retrieves or creates a named logger.
            </summary>
      <remarks>
        <para>
            Retrieve a logger named as the <paramref name="name" />
            parameter. If the named logger already exists, then the
            existing instance will be returned. Otherwise, a new instance is
            created.
            </para>
        <para>
            By default, loggers do not have a set level but inherit
            it from the hierarchy. This is one of the central features of
            log4net.
            </para>
      </remarks>
      <param name="repository">The repository to lookup in.</param>
      <param name="name">The name of the logger to retrieve.</param>
      <returns>The logger with the name specified.</returns>
    </member>
    <member name="M:log4net.LogManager.GetLogger(System.Reflection.Assembly,System.String)">
      <summary>
            Retrieves or creates a named logger.
            </summary>
      <remarks>
        <para>
            Retrieve a logger named as the <paramref name="name" />
            parameter. If the named logger already exists, then the
            existing instance will be returned. Otherwise, a new instance is
            created.
            </para>
        <para>
            By default, loggers do not have a set level but inherit
            it from the hierarchy. This is one of the central features of
            log4net.
            </para>
      </remarks>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
      <param name="name">The name of the logger to retrieve.</param>
      <returns>The logger with the name specified.</returns>
    </member>
    <member name="M:log4net.LogManager.GetLogger(System.Type)">
      <summary>
            Shorthand for <see cref="M:LogManager.GetLogger(string)" />.
            </summary>
      <remarks>
            Get the logger for the fully qualified name of the type specified.
            </remarks>
      <param name="type">The full name of <paramref name="type" /> will be used as the name of the logger to retrieve.</param>
      <returns>The logger with the name specified.</returns>
    </member>
    <member name="M:log4net.LogManager.GetLogger(System.String,System.Type)">
      <summary>
            Shorthand for <see cref="M:LogManager.GetLogger(string)" />.
            </summary>
      <remarks>
            Gets the logger for the fully qualified name of the type specified.
            </remarks>
      <param name="repository">The repository to lookup in.</param>
      <param name="type">The full name of <paramref name="type" /> will be used as the name of the logger to retrieve.</param>
      <returns>The logger with the name specified.</returns>
    </member>
    <member name="M:log4net.LogManager.GetLogger(System.Reflection.Assembly,System.Type)">
      <summary>
            Shorthand for <see cref="M:LogManager.GetLogger(string)" />.
            </summary>
      <remarks>
            Gets the logger for the fully qualified name of the type specified.
            </remarks>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
      <param name="type">The full name of <paramref name="type" /> will be used as the name of the logger to retrieve.</param>
      <returns>The logger with the name specified.</returns>
    </member>
    <member name="M:log4net.LogManager.Shutdown">
      <summary>
            Shuts down the log4net system.
            </summary>
      <remarks>
        <para>
            Calling this method will <b>safely</b> close and remove all
            appenders in all the loggers including root contained in all the
            default repositories.
            </para>
        <para>
            Some appenders need to be closed before the application exists. 
            Otherwise, pending logging events might be lost.
            </para>
        <para>The <c>shutdown</c> method is careful to close nested
            appenders before closing regular appenders. This is allows
            configurations where a regular appender is attached to a logger
            and again to a nested appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.LogManager.ShutdownRepository">
      <overloads>Shutdown a logger repository.</overloads>
      <summary>
            Shuts down the default repository.
            </summary>
      <remarks>
        <para>
            Calling this method will <b>safely</b> close and remove all
            appenders in all the loggers including root contained in the
            default repository.
            </para>
        <para>Some appenders need to be closed before the application exists. 
            Otherwise, pending logging events might be lost.
            </para>
        <para>The <c>shutdown</c> method is careful to close nested
            appenders before closing regular appenders. This is allows
            configurations where a regular appender is attached to a logger
            and again to a nested appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.LogManager.ShutdownRepository(System.String)">
      <summary>
            Shuts down the repository for the repository specified.
            </summary>
      <remarks>
        <para>
            Calling this method will <b>safely</b> close and remove all
            appenders in all the loggers including root contained in the
            <paramref name="repository" /> specified.
            </para>
        <para>
            Some appenders need to be closed before the application exists. 
            Otherwise, pending logging events might be lost.
            </para>
        <para>The <c>shutdown</c> method is careful to close nested
            appenders before closing regular appenders. This is allows
            configurations where a regular appender is attached to a logger
            and again to a nested appender.
            </para>
      </remarks>
      <param name="repository">The repository to shutdown.</param>
    </member>
    <member name="M:log4net.LogManager.ShutdownRepository(System.Reflection.Assembly)">
      <summary>
            Shuts down the repository specified.
            </summary>
      <remarks>
        <para>
            Calling this method will <b>safely</b> close and remove all
            appenders in all the loggers including root contained in the
            repository. The repository is looked up using
            the <paramref name="repositoryAssembly" /> specified.
            </para>
        <para>
            Some appenders need to be closed before the application exists. 
            Otherwise, pending logging events might be lost.
            </para>
        <para>
            The <c>shutdown</c> method is careful to close nested
            appenders before closing regular appenders. This is allows
            configurations where a regular appender is attached to a logger
            and again to a nested appender.
            </para>
      </remarks>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
    </member>
    <member name="M:log4net.LogManager.ResetConfiguration">
      <overloads>Reset the configuration of a repository</overloads>
      <summary>
            Resets all values contained in this repository instance to their defaults.
            </summary>
      <remarks>
        <para>
            Resets all values contained in the repository instance to their
            defaults.  This removes all appenders from all loggers, sets
            the level of all non-root loggers to <c>null</c>,
            sets their additivity flag to <c>true</c> and sets the level
            of the root logger to <see cref="F:log4net.Core.Level.Debug" />. Moreover,
            message disabling is set to its default "off" value.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.LogManager.ResetConfiguration(System.String)">
      <summary>
            Resets all values contained in this repository instance to their defaults.
            </summary>
      <remarks>
        <para>
            Reset all values contained in the repository instance to their
            defaults.  This removes all appenders from all loggers, sets
            the level of all non-root loggers to <c>null</c>,
            sets their additivity flag to <c>true</c> and sets the level
            of the root logger to <see cref="F:log4net.Core.Level.Debug" />. Moreover,
            message disabling is set to its default "off" value.
            </para>
      </remarks>
      <param name="repository">The repository to reset.</param>
    </member>
    <member name="M:log4net.LogManager.ResetConfiguration(System.Reflection.Assembly)">
      <summary>
            Resets all values contained in this repository instance to their defaults.
            </summary>
      <remarks>
        <para>
            Reset all values contained in the repository instance to their
            defaults.  This removes all appenders from all loggers, sets
            the level of all non-root loggers to <c>null</c>,
            sets their additivity flag to <c>true</c> and sets the level
            of the root logger to <see cref="F:log4net.Core.Level.Debug" />. Moreover,
            message disabling is set to its default "off" value.
            </para>
      </remarks>
      <param name="repositoryAssembly">The assembly to use to lookup the repository to reset.</param>
    </member>
    <member name="M:log4net.LogManager.GetLoggerRepository">
      <overloads>Get the logger repository.</overloads>
      <summary>
            Returns the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.
            </summary>
      <remarks>
        <para>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified
            by the callers assembly (<see cref="M:Assembly.GetCallingAssembly()" />).
            </para>
      </remarks>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> instance for the default repository.</returns>
    </member>
    <member name="M:log4net.LogManager.GetLoggerRepository(System.String)">
      <summary>
            Returns the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.
            </summary>
      <returns>The default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.</returns>
      <remarks>
        <para>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified
            by the <paramref name="repository" /> argument.
            </para>
      </remarks>
      <param name="repository">The repository to lookup in.</param>
    </member>
    <member name="M:log4net.LogManager.GetLoggerRepository(System.Reflection.Assembly)">
      <summary>
            Returns the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.
            </summary>
      <returns>The default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.</returns>
      <remarks>
        <para>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified
            by the <paramref name="repositoryAssembly" /> argument.
            </para>
      </remarks>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
    </member>
    <member name="M:log4net.LogManager.GetRepository">
      <overloads>Get a logger repository.</overloads>
      <summary>
            Returns the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.
            </summary>
      <remarks>
        <para>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified
            by the callers assembly (<see cref="M:Assembly.GetCallingAssembly()" />).
            </para>
      </remarks>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> instance for the default repository.</returns>
    </member>
    <member name="M:log4net.LogManager.GetRepository(System.String)">
      <summary>
            Returns the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.
            </summary>
      <returns>The default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.</returns>
      <remarks>
        <para>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified
            by the <paramref name="repository" /> argument.
            </para>
      </remarks>
      <param name="repository">The repository to lookup in.</param>
    </member>
    <member name="M:log4net.LogManager.GetRepository(System.Reflection.Assembly)">
      <summary>
            Returns the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.
            </summary>
      <returns>The default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.</returns>
      <remarks>
        <para>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified
            by the <paramref name="repositoryAssembly" /> argument.
            </para>
      </remarks>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
    </member>
    <member name="M:log4net.LogManager.CreateDomain(System.Type)">
      <overloads>Create a domain</overloads>
      <summary>
            Creates a repository with the specified repository type.
            </summary>
      <remarks>
        <para>
          <b>CreateDomain is obsolete. Use CreateRepository instead of CreateDomain.</b>
        </para>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the repository
            specified such that a call to <see cref="M:GetRepository()" /> will return 
            the same repository instance.
            </para>
      </remarks>
      <param name="repositoryType">A <see cref="T:System.Type" /> that implements <see cref="T:log4net.Repository.ILoggerRepository" />
            and has a no arg constructor. An instance of this type will be created to act
            as the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
    </member>
    <member name="M:log4net.LogManager.CreateRepository(System.Type)">
      <overloads>Create a logger repository.</overloads>
      <summary>
            Creates a repository with the specified repository type.
            </summary>
      <param name="repositoryType">A <see cref="T:System.Type" /> that implements <see cref="T:log4net.Repository.ILoggerRepository" />
            and has a no arg constructor. An instance of this type will be created to act
            as the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the repository
            specified such that a call to <see cref="M:GetRepository()" /> will return 
            the same repository instance.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.LogManager.CreateDomain(System.String)">
      <summary>
            Creates a repository with the specified name.
            </summary>
      <remarks>
        <para>
          <b>CreateDomain is obsolete. Use CreateRepository instead of CreateDomain.</b>
        </para>
        <para>
            Creates the default type of <see cref="T:log4net.Repository.ILoggerRepository" /> which is a
            <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> object.
            </para>
        <para>
            The <paramref name="repository" /> name must be unique. Repositories cannot be redefined.
            An <see cref="T:System.Exception" /> will be thrown if the repository already exists.
            </para>
      </remarks>
      <param name="repository">The name of the repository, this must be unique amongst repositories.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
      <exception cref="T:log4net.Core.LogException">The specified repository already exists.</exception>
    </member>
    <member name="M:log4net.LogManager.CreateRepository(System.String)">
      <summary>
            Creates a repository with the specified name.
            </summary>
      <remarks>
        <para>
            Creates the default type of <see cref="T:log4net.Repository.ILoggerRepository" /> which is a
            <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> object.
            </para>
        <para>
            The <paramref name="repository" /> name must be unique. Repositories cannot be redefined.
            An <see cref="T:System.Exception" /> will be thrown if the repository already exists.
            </para>
      </remarks>
      <param name="repository">The name of the repository, this must be unique amongst repositories.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
      <exception cref="T:log4net.Core.LogException">The specified repository already exists.</exception>
    </member>
    <member name="M:log4net.LogManager.CreateDomain(System.String,System.Type)">
      <summary>
            Creates a repository with the specified name and repository type.
            </summary>
      <remarks>
        <para>
          <b>CreateDomain is obsolete. Use CreateRepository instead of CreateDomain.</b>
        </para>
        <para>
            The <paramref name="repository" /> name must be unique. Repositories cannot be redefined.
            An <see cref="T:System.Exception" /> will be thrown if the repository already exists.
            </para>
      </remarks>
      <param name="repository">The name of the repository, this must be unique to the repository.</param>
      <param name="repositoryType">A <see cref="T:System.Type" /> that implements <see cref="T:log4net.Repository.ILoggerRepository" />
            and has a no arg constructor. An instance of this type will be created to act
            as the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
      <exception cref="T:log4net.Core.LogException">The specified repository already exists.</exception>
    </member>
    <member name="M:log4net.LogManager.CreateRepository(System.String,System.Type)">
      <summary>
            Creates a repository with the specified name and repository type.
            </summary>
      <remarks>
        <para>
            The <paramref name="repository" /> name must be unique. Repositories cannot be redefined.
            An <see cref="T:System.Exception" /> will be thrown if the repository already exists.
            </para>
      </remarks>
      <param name="repository">The name of the repository, this must be unique to the repository.</param>
      <param name="repositoryType">A <see cref="T:System.Type" /> that implements <see cref="T:log4net.Repository.ILoggerRepository" />
            and has a no arg constructor. An instance of this type will be created to act
            as the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
      <exception cref="T:log4net.Core.LogException">The specified repository already exists.</exception>
    </member>
    <member name="M:log4net.LogManager.CreateDomain(System.Reflection.Assembly,System.Type)">
      <summary>
            Creates a repository for the specified assembly and repository type.
            </summary>
      <remarks>
        <para>
          <b>CreateDomain is obsolete. Use CreateRepository instead of CreateDomain.</b>
        </para>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the repository
            specified such that a call to <see cref="M:GetRepository(Assembly)" /> with the
            same assembly specified will return the same repository instance.
            </para>
      </remarks>
      <param name="repositoryAssembly">The assembly to use to get the name of the repository.</param>
      <param name="repositoryType">A <see cref="T:System.Type" /> that implements <see cref="T:log4net.Repository.ILoggerRepository" />
            and has a no arg constructor. An instance of this type will be created to act
            as the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
    </member>
    <member name="M:log4net.LogManager.CreateRepository(System.Reflection.Assembly,System.Type)">
      <summary>
            Creates a repository for the specified assembly and repository type.
            </summary>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the repository
            specified such that a call to <see cref="M:GetRepository(Assembly)" /> with the
            same assembly specified will return the same repository instance.
            </para>
      </remarks>
      <param name="repositoryAssembly">The assembly to use to get the name of the repository.</param>
      <param name="repositoryType">A <see cref="T:System.Type" /> that implements <see cref="T:log4net.Repository.ILoggerRepository" />
            and has a no arg constructor. An instance of this type will be created to act
            as the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
    </member>
    <member name="M:log4net.LogManager.GetAllRepositories">
      <summary>
            Gets the list of currently defined repositories.
            </summary>
      <remarks>
        <para>
            Get an array of all the <see cref="T:log4net.Repository.ILoggerRepository" /> objects that have been created.
            </para>
      </remarks>
      <returns>An array of all the known <see cref="T:log4net.Repository.ILoggerRepository" /> objects.</returns>
    </member>
    <member name="M:log4net.LogManager.WrapLogger(log4net.Core.ILogger)">
      <summary>
            Looks up the wrapper object for the logger specified.
            </summary>
      <param name="logger">The logger to get the wrapper for.</param>
      <returns>The wrapper for the logger specified.</returns>
    </member>
    <member name="M:log4net.LogManager.WrapLoggers(log4net.Core.ILogger[])">
      <summary>
            Looks up the wrapper objects for the loggers specified.
            </summary>
      <param name="loggers">The loggers to get the wrappers for.</param>
      <returns>The wrapper objects for the loggers specified.</returns>
    </member>
    <member name="M:log4net.LogManager.WrapperCreationHandler(log4net.Core.ILogger)">
      <summary>
            Create the <see cref="T:log4net.Core.ILoggerWrapper" /> objects used by
            this manager.
            </summary>
      <param name="logger">The logger to wrap.</param>
      <returns>The wrapper for the logger specified.</returns>
    </member>
    <member name="T:log4net.MDC">
      <summary>
            Implementation of Mapped Diagnostic Contexts.
            </summary>
      <remarks>
        <note>
          <para>
            The MDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Properties" />.
            The current MDC implementation forwards to the <c>ThreadContext.Properties</c>.
            </para>
        </note>
        <para>
            The MDC class is similar to the <see cref="T:log4net.NDC" /> class except that it is
            based on a map instead of a stack. It provides <i>mapped
            diagnostic contexts</i>. A <i>Mapped Diagnostic Context</i>, or
            MDC in short, is an instrument for distinguishing interleaved log
            output from different sources. Log output is typically interleaved
            when a server handles multiple clients near-simultaneously.
            </para>
        <para>
            The MDC is managed on a per thread basis.
            </para>
      </remarks>
      <threadsafety static="true" instance="true" />
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.MDC.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.MDC" /> class. 
            </summary>
      <remarks>
            Uses a private access modifier to prevent instantiation of this class.
            </remarks>
    </member>
    <member name="M:log4net.MDC.Get(System.String)">
      <summary>
            Gets the context value identified by the <paramref name="key" /> parameter.
            </summary>
      <param name="key">The key to lookup in the MDC.</param>
      <returns>The string value held for the key, or a <c>null</c> reference if no corresponding value is found.</returns>
      <remarks>
        <note>
          <para>
            The MDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Properties" />.
            The current MDC implementation forwards to the <c>ThreadContext.Properties</c>.
            </para>
        </note>
        <para>
            If the <paramref name="key" /> parameter does not look up to a
            previously defined context then <c>null</c> will be returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.MDC.Set(System.String,System.String)">
      <summary>
            Add an entry to the MDC
            </summary>
      <param name="key">The key to store the value under.</param>
      <param name="value">The value to store.</param>
      <remarks>
        <note>
          <para>
            The MDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Properties" />.
            The current MDC implementation forwards to the <c>ThreadContext.Properties</c>.
            </para>
        </note>
        <para>
            Puts a context value (the <paramref name="value" /> parameter) as identified
            with the <paramref name="key" /> parameter into the current thread's
            context map.
            </para>
        <para>
            If a value is already defined for the <paramref name="key" />
            specified then the value will be replaced. If the <paramref name="value" /> 
            is specified as <c>null</c> then the key value mapping will be removed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.MDC.Remove(System.String)">
      <summary>
            Removes the key value mapping for the key specified.
            </summary>
      <param name="key">The key to remove.</param>
      <remarks>
        <note>
          <para>
            The MDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Properties" />.
            The current MDC implementation forwards to the <c>ThreadContext.Properties</c>.
            </para>
        </note>
        <para>
            Remove the specified entry from this thread's MDC
            </para>
      </remarks>
    </member>
    <member name="M:log4net.MDC.Clear">
      <summary>
            Clear all entries in the MDC
            </summary>
      <remarks>
        <note>
          <para>
            The MDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Properties" />.
            The current MDC implementation forwards to the <c>ThreadContext.Properties</c>.
            </para>
        </note>
        <para>
            Remove all the entries from this thread's MDC
            </para>
      </remarks>
    </member>
    <member name="T:log4net.NDC">
      <summary>
            Implementation of Nested Diagnostic Contexts.
            </summary>
      <remarks>
        <note>
          <para>
            The NDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Stacks" />.
            The current NDC implementation forwards to the <c>ThreadContext.Stacks["NDC"]</c>.
            </para>
        </note>
        <para>
            A Nested Diagnostic Context, or NDC in short, is an instrument
            to distinguish interleaved log output from different sources. Log
            output is typically interleaved when a server handles multiple
            clients near-simultaneously.
            </para>
        <para>
            Interleaved log output can still be meaningful if each log entry
            from different contexts had a distinctive stamp. This is where NDCs
            come into play.
            </para>
        <para>
            Note that NDCs are managed on a per thread basis. The NDC class
            is made up of static methods that operate on the context of the
            calling thread.
            </para>
      </remarks>
      <example>How to push a message into the context
            <code lang="C#">
            using(NDC.Push("my context message"))
            {
            	... all log calls will have 'my context message' included ...
            
            } // at the end of the using block the message is automatically removed 
            </code></example>
      <threadsafety static="true" instance="true" />
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.NDC.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.NDC" /> class. 
            </summary>
      <remarks>
            Uses a private access modifier to prevent instantiation of this class.
            </remarks>
    </member>
    <member name="M:log4net.NDC.Clear">
      <summary>
            Clears all the contextual information held on the current thread.
            </summary>
      <remarks>
        <note>
          <para>
            The NDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Stacks" />.
            The current NDC implementation forwards to the <c>ThreadContext.Stacks["NDC"]</c>.
            </para>
        </note>
        <para>
            Clears the stack of NDC data held on the current thread.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.NDC.CloneStack">
      <summary>
            Creates a clone of the stack of context information.
            </summary>
      <returns>A clone of the context info for this thread.</returns>
      <remarks>
        <note>
          <para>
            The NDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Stacks" />.
            The current NDC implementation forwards to the <c>ThreadContext.Stacks["NDC"]</c>.
            </para>
        </note>
        <para>
            The results of this method can be passed to the <see cref="M:log4net.NDC.Inherit(System.Collections.Stack)" /> 
            method to allow child threads to inherit the context of their 
            parent thread.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.NDC.Inherit(System.Collections.Stack)">
      <summary>
            Inherits the contextual information from another thread.
            </summary>
      <param name="stack">The context stack to inherit.</param>
      <remarks>
        <note>
          <para>
            The NDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Stacks" />.
            The current NDC implementation forwards to the <c>ThreadContext.Stacks["NDC"]</c>.
            </para>
        </note>
        <para>
            This thread will use the context information from the stack
            supplied. This can be used to initialize child threads with
            the same contextual information as their parent threads. These
            contexts will <b>NOT</b> be shared. Any further contexts that
            are pushed onto the stack will not be visible to the other.
            Call <see cref="M:log4net.NDC.CloneStack" /> to obtain a stack to pass to
            this method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.NDC.Pop">
      <summary>
            Removes the top context from the stack.
            </summary>
      <returns>
            The message in the context that was removed from the top 
            of the stack.
            </returns>
      <remarks>
        <note>
          <para>
            The NDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Stacks" />.
            The current NDC implementation forwards to the <c>ThreadContext.Stacks["NDC"]</c>.
            </para>
        </note>
        <para>
            Remove the top context from the stack, and return
            it to the caller. If the stack is empty then an
            empty string (not <c>null</c>) is returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.NDC.Push(System.String)">
      <summary>
            Pushes a new context message.
            </summary>
      <param name="message">The new context message.</param>
      <returns>
            An <see cref="T:System.IDisposable" /> that can be used to clean up 
            the context stack.
            </returns>
      <remarks>
        <note>
          <para>
            The NDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Stacks" />.
            The current NDC implementation forwards to the <c>ThreadContext.Stacks["NDC"]</c>.
            </para>
        </note>
        <para>
            Pushes a new context onto the context stack. An <see cref="T:System.IDisposable" />
            is returned that can be used to clean up the context stack. This
            can be easily combined with the <c>using</c> keyword to scope the
            context.
            </para>
      </remarks>
      <example>Simple example of using the <c>Push</c> method with the <c>using</c> keyword.
            <code lang="C#">
            using(log4net.NDC.Push("NDC_Message"))
            {
            	log.Warn("This should have an NDC message");
            }
            </code></example>
    </member>
    <member name="M:log4net.NDC.Remove">
      <summary>
            Removes the context information for this thread. It is
            not required to call this method.
            </summary>
      <remarks>
        <note>
          <para>
            The NDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Stacks" />.
            The current NDC implementation forwards to the <c>ThreadContext.Stacks["NDC"]</c>.
            </para>
        </note>
        <para>
            This method is not implemented.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.NDC.SetMaxDepth(System.Int32)">
      <summary>
            Forces the stack depth to be at most <paramref name="maxDepth" />.
            </summary>
      <param name="maxDepth">The maximum depth of the stack</param>
      <remarks>
        <note>
          <para>
            The NDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Stacks" />.
            The current NDC implementation forwards to the <c>ThreadContext.Stacks["NDC"]</c>.
            </para>
        </note>
        <para>
            Forces the stack depth to be at most <paramref name="maxDepth" />.
            This may truncate the head of the stack. This only affects the 
            stack in the current thread. Also it does not prevent it from
            growing, it only sets the maximum depth at the time of the
            call. This can be used to return to a known context depth.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.NDC.Depth">
      <summary>
            Gets the current context depth.
            </summary>
      <value>The current context depth.</value>
      <remarks>
        <note>
          <para>
            The NDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Stacks" />.
            The current NDC implementation forwards to the <c>ThreadContext.Stacks["NDC"]</c>.
            </para>
        </note>
        <para>
            The number of context values pushed onto the context stack.
            </para>
        <para>
            Used to record the current depth of the context. This can then 
            be restored using the <see cref="M:log4net.NDC.SetMaxDepth(System.Int32)" /> method.
            </para>
      </remarks>
      <seealso cref="M:log4net.NDC.SetMaxDepth(System.Int32)" />
    </member>
    <member name="T:log4net.ThreadContext">
      <summary>
            The log4net Thread Context.
            </summary>
      <remarks>
        <para>
            The <c>ThreadContext</c> provides a location for thread specific debugging 
            information to be stored.
            The <c>ThreadContext</c> properties override any <see cref="T:log4net.GlobalContext" />
            properties with the same name.
            </para>
        <para>
            The thread context has a properties map and a stack.
            The properties and stack can 
            be included in the output of log messages. The <see cref="T:log4net.Layout.PatternLayout" />
            supports selecting and outputting these properties.
            </para>
        <para>
            The Thread Context provides a diagnostic context for the current thread. 
            This is an instrument for distinguishing interleaved log
            output from different sources. Log output is typically interleaved
            when a server handles multiple clients near-simultaneously.
            </para>
        <para>
            The Thread Context is managed on a per thread basis.
            </para>
      </remarks>
      <example>Example of using the thread context properties to store a username.
            <code lang="C#">
            ThreadContext.Properties["user"] = userName;
            log.Info("This log message has a ThreadContext Property called 'user'");
            </code></example>
      <example>Example of how to push a message into the context stack
            <code lang="C#">
            using(ThreadContext.Stacks["NDC"].Push("my context message"))
            {
            	log.Info("This log message has a ThreadContext Stack message that includes 'my context message'");
            
            } // at the end of the using block the message is automatically popped 
            </code></example>
      <threadsafety static="true" instance="true" />
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.ThreadContext.s_properties">
      <summary>
            The thread context properties instance
            </summary>
    </member>
    <member name="F:log4net.ThreadContext.s_stacks">
      <summary>
            The thread context stacks instance
            </summary>
    </member>
    <member name="M:log4net.ThreadContext.#ctor">
      <summary>
            Private Constructor. 
            </summary>
      <remarks>
        <para>
            Uses a private access modifier to prevent instantiation of this class.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.ThreadContext.Properties">
      <summary>
            The thread properties map
            </summary>
      <value>
            The thread properties map
            </value>
      <remarks>
        <para>
            The <c>ThreadContext</c> properties override any <see cref="T:log4net.GlobalContext" />
            properties with the same name.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.ThreadContext.Stacks">
      <summary>
            The thread stacks
            </summary>
      <value>
            stack map
            </value>
      <remarks>
        <para>
            The thread local stacks.
            </para>
      </remarks>
    </member>
    <member name="T:Newtonsoft.Json.JsonReader">
      <summary>
            Represents a reader that provides fast, non-cached, forward-only access to serialized Json data.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonReader.State">
      <summary>
            Specifies the state of the reader.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReader" /> class with the specified <see cref="T:System.IO.TextReader" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.Read">
      <summary>
            Reads the next JSON token from the stream.
            </summary>
      <returns>true if the next token was read successfully; false if there are no more tokens to read.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.ReadAsInt32">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.ReadAsString">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.String" />.
            </summary>
      <returns>A <see cref="T:System.String" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.ReadAsBytes">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:Byte[]" />.
            </summary>
      <returns>A <see cref="T:Byte[]" /> or a null reference if the next JSON token is null. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.ReadAsDecimal">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.ReadAsDateTime">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.String" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.ReadAsDateTimeOffset">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.Skip">
      <summary>
            Skips the children of the current token.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.SetToken(Newtonsoft.Json.JsonToken)">
      <summary>
            Sets the current token.
            </summary>
      <param name="newToken">The new token.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.SetToken(Newtonsoft.Json.JsonToken,System.Object)">
      <summary>
            Sets the current token and value.
            </summary>
      <param name="newToken">The new token.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.SetStateBasedOnCurrent">
      <summary>
            Sets the state based on current token type.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.Dispose(System.Boolean)">
      <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
      <param name="disposing">
        <c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.Close">
      <summary>
            Changes the <see cref="T:Newtonsoft.Json.JsonReader.State" /> to Closed. 
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.CurrentState">
      <summary>
            Gets the current reader state.
            </summary>
      <value>The current reader state.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.CloseInput">
      <summary>
            Gets or sets a value indicating whether the underlying stream or
            <see cref="T:System.IO.TextReader" /> should be closed when the reader is closed.
            </summary>
      <value>
            true to close the underlying stream or <see cref="T:System.IO.TextReader" /> when
            the reader is closed; otherwise false. The default is true.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.SupportMultipleContent">
      <summary>
            Gets or sets a value indicating whether multiple pieces of JSON content can
            be read from a continuous stream without erroring.
            </summary>
      <value>
            true to support reading multiple pieces of JSON content; otherwise false. The default is false.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.QuoteChar">
      <summary>
            Gets the quotation mark character used to enclose the value of a string.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.DateTimeZoneHandling">
      <summary>
            Get or set how <see cref="T:System.DateTime" /> time zones are handling when reading JSON.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.DateParseHandling">
      <summary>
            Get or set how date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed when reading JSON.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.FloatParseHandling">
      <summary>
            Get or set how floating point numbers, e.g. 1.0 and 9.9, are parsed when reading JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.DateFormatString">
      <summary>
            Get or set how custom date formatted strings are parsed when reading JSON.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.MaxDepth">
      <summary>
            Gets or sets the maximum depth allowed when reading JSON. Reading past this depth will throw a <see cref="T:Newtonsoft.Json.JsonReaderException" />.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.TokenType">
      <summary>
            Gets the type of the current JSON token. 
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.Value">
      <summary>
            Gets the text value of the current JSON token.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.ValueType">
      <summary>
            Gets The Common Language Runtime (CLR) type for the current JSON token.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.Depth">
      <summary>
            Gets the depth of the current token in the JSON document.
            </summary>
      <value>The depth of the current token in the JSON document.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.Path">
      <summary>
            Gets the path of the current JSON token. 
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.Culture">
      <summary>
            Gets or sets the culture used when reading JSON. Defaults to <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Bson.BsonReader">
      <summary>
            Represents a reader that provides fast, non-cached, forward-only access to serialized Json data.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.#ctor(System.IO.Stream)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonReader" /> class.
            </summary>
      <param name="stream">The stream.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.#ctor(System.IO.BinaryReader)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonReader" /> class.
            </summary>
      <param name="reader">The reader.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.#ctor(System.IO.Stream,System.Boolean,System.DateTimeKind)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonReader" /> class.
            </summary>
      <param name="stream">The stream.</param>
      <param name="readRootValueAsArray">if set to <c>true</c> the root object will be read as a JSON array.</param>
      <param name="dateTimeKindHandling">The <see cref="T:System.DateTimeKind" /> used when reading <see cref="T:System.DateTime" /> values from BSON.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.#ctor(System.IO.BinaryReader,System.Boolean,System.DateTimeKind)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonReader" /> class.
            </summary>
      <param name="reader">The reader.</param>
      <param name="readRootValueAsArray">if set to <c>true</c> the root object will be read as a JSON array.</param>
      <param name="dateTimeKindHandling">The <see cref="T:System.DateTimeKind" /> used when reading <see cref="T:System.DateTime" /> values from BSON.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.ReadAsBytes">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:Byte[]" />.
            </summary>
      <returns>
            A <see cref="T:Byte[]" /> or a null reference if the next JSON token is null. This method will return <c>null</c> at the end of an array.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.ReadAsDecimal">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.ReadAsInt32">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.ReadAsString">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.String" />.
            </summary>
      <returns>A <see cref="T:System.String" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.ReadAsDateTime">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.String" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.ReadAsDateTimeOffset">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>
            A <see cref="T:System.Nullable`1" />. This method will return <c>null</c> at the end of an array.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.Read">
      <summary>
            Reads the next JSON token from the stream.
            </summary>
      <returns>
            true if the next token was read successfully; false if there are no more tokens to read.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.Close">
      <summary>
            Changes the <see cref="T:Newtonsoft.Json.JsonReader.State" /> to Closed.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Bson.BsonReader.JsonNet35BinaryCompatibility">
      <summary>
            Gets or sets a value indicating whether binary data reading should compatible with incorrect Json.NET 3.5 written binary.
            </summary>
      <value>
        <c>true</c> if binary data reading will be compatible with incorrect Json.NET 3.5 written binary; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Bson.BsonReader.ReadRootValueAsArray">
      <summary>
            Gets or sets a value indicating whether the root object will be read as a JSON array.
            </summary>
      <value>
        <c>true</c> if the root object will be read as a JSON array; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Bson.BsonReader.DateTimeKindHandling">
      <summary>
            Gets or sets the <see cref="T:System.DateTimeKind" /> used when reading <see cref="T:System.DateTime" /> values from BSON.
            </summary>
      <value>The <see cref="T:System.DateTimeKind" /> used when reading <see cref="T:System.DateTime" /> values from BSON.</value>
    </member>
    <member name="T:Newtonsoft.Json.JsonWriter">
      <summary>
            Represents a writer that provides a fast, non-cached, forward-only way of generating Json data.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.#ctor">
      <summary>
            Creates an instance of the <c>JsonWriter</c> class. 
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.Flush">
      <summary>
            Flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.Close">
      <summary>
            Closes this stream and the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteStartObject">
      <summary>
            Writes the beginning of a Json object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteEndObject">
      <summary>
            Writes the end of a Json object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteStartArray">
      <summary>
            Writes the beginning of a Json array.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteEndArray">
      <summary>
            Writes the end of an array.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteStartConstructor(System.String)">
      <summary>
            Writes the start of a constructor with the given name.
            </summary>
      <param name="name">The name of the constructor.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteEndConstructor">
      <summary>
            Writes the end constructor.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WritePropertyName(System.String)">
      <summary>
            Writes the property name of a name/value pair on a JSON object.
            </summary>
      <param name="name">The name of the property.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WritePropertyName(System.String,System.Boolean)">
      <summary>
            Writes the property name of a name/value pair on a JSON object.
            </summary>
      <param name="name">The name of the property.</param>
      <param name="escape">A flag to indicate whether the text should be escaped when it is written as a JSON property name.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteEnd">
      <summary>
            Writes the end of the current Json object or array.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteToken(Newtonsoft.Json.JsonReader)">
      <summary>
            Writes the current <see cref="T:Newtonsoft.Json.JsonReader" /> token and its children.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read the token from.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteToken(Newtonsoft.Json.JsonReader,System.Boolean)">
      <summary>
            Writes the current <see cref="T:Newtonsoft.Json.JsonReader" /> token.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read the token from.</param>
      <param name="writeChildren">A flag indicating whether the current token's children should be written.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteEnd(Newtonsoft.Json.JsonToken)">
      <summary>
            Writes the specified end token.
            </summary>
      <param name="token">The end token to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteIndent">
      <summary>
            Writes indent characters.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValueDelimiter">
      <summary>
            Writes the JSON value delimiter.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteIndentSpace">
      <summary>
            Writes an indent space.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteNull">
      <summary>
            Writes a null value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteUndefined">
      <summary>
            Writes an undefined value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteRaw(System.String)">
      <summary>
            Writes raw JSON without changing the writer's state.
            </summary>
      <param name="json">The raw JSON to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteRawValue(System.String)">
      <summary>
            Writes raw JSON where a value is expected and updates the writer's state.
            </summary>
      <param name="json">The raw JSON to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.String)">
      <summary>
            Writes a <see cref="T:System.String" /> value.
            </summary>
      <param name="value">The <see cref="T:System.String" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Int32)">
      <summary>
            Writes a <see cref="T:System.Int32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.UInt32)">
      <summary>
            Writes a <see cref="T:System.UInt32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Int64)">
      <summary>
            Writes a <see cref="T:System.Int64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.UInt64)">
      <summary>
            Writes a <see cref="T:System.UInt64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Single)">
      <summary>
            Writes a <see cref="T:System.Single" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Single" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Double)">
      <summary>
            Writes a <see cref="T:System.Double" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Double" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Boolean)">
      <summary>
            Writes a <see cref="T:System.Boolean" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Boolean" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Int16)">
      <summary>
            Writes a <see cref="T:System.Int16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.UInt16)">
      <summary>
            Writes a <see cref="T:System.UInt16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Char)">
      <summary>
            Writes a <see cref="T:System.Char" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Byte)">
      <summary>
            Writes a <see cref="T:System.Byte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Byte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.SByte)">
      <summary>
            Writes a <see cref="T:System.SByte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.SByte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Decimal)">
      <summary>
            Writes a <see cref="T:System.Decimal" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Decimal" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.DateTime)">
      <summary>
            Writes a <see cref="T:System.DateTime" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTime" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.DateTimeOffset)">
      <summary>
            Writes a <see cref="T:System.DateTimeOffset" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTimeOffset" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Guid)">
      <summary>
            Writes a <see cref="T:System.Guid" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Guid" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.TimeSpan)">
      <summary>
            Writes a <see cref="T:System.TimeSpan" /> value.
            </summary>
      <param name="value">The <see cref="T:System.TimeSpan" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Int32})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.UInt32})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Int64})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.UInt64})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Single})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Double})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Boolean})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Int16})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.UInt16})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Char})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Byte})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.SByte})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Decimal})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.DateTime})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.DateTimeOffset})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Guid})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.TimeSpan})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Byte[])">
      <summary>
            Writes a <see cref="T:Byte[]" /> value.
            </summary>
      <param name="value">The <see cref="T:Byte[]" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Uri)">
      <summary>
            Writes a <see cref="T:System.Uri" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Uri" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Object)">
      <summary>
            Writes a <see cref="T:System.Object" /> value.
            An error will raised if the value cannot be written as a single JSON token.
            </summary>
      <param name="value">The <see cref="T:System.Object" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteComment(System.String)">
      <summary>
            Writes out a comment <code>/*...*/</code> containing the specified text. 
            </summary>
      <param name="text">Text to place inside the comment.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteWhitespace(System.String)">
      <summary>
            Writes out the given white space.
            </summary>
      <param name="ws">The string of white space characters.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.SetWriteState(Newtonsoft.Json.JsonToken,System.Object)">
      <summary>
            Sets the state of the JsonWriter,
            </summary>
      <param name="token">The JsonToken being written.</param>
      <param name="value">The value being written.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.CloseOutput">
      <summary>
            Gets or sets a value indicating whether the underlying stream or
            <see cref="T:System.IO.TextReader" /> should be closed when the writer is closed.
            </summary>
      <value>
            true to close the underlying stream or <see cref="T:System.IO.TextReader" /> when
            the writer is closed; otherwise false. The default is true.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.Top">
      <summary>
            Gets the top.
            </summary>
      <value>The top.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.WriteState">
      <summary>
            Gets the state of the writer.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.Path">
      <summary>
            Gets the path of the writer. 
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.Formatting">
      <summary>
            Indicates how JSON text output is formatted.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.DateFormatHandling">
      <summary>
            Get or set how dates are written to JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.DateTimeZoneHandling">
      <summary>
            Get or set how <see cref="T:System.DateTime" /> time zones are handling when writing JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.StringEscapeHandling">
      <summary>
            Get or set how strings are escaped when writing JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.FloatFormatHandling">
      <summary>
            Get or set how special floating point numbers, e.g. <see cref="F:System.Double.NaN" />,
            <see cref="F:System.Double.PositiveInfinity" /> and <see cref="F:System.Double.NegativeInfinity" />,
            are written to JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.DateFormatString">
      <summary>
            Get or set how <see cref="T:System.DateTime" /> and <see cref="T:System.DateTimeOffset" /> values are formatting when writing JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.Culture">
      <summary>
            Gets or sets the culture used when writing JSON. Defaults to <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Bson.BsonWriter">
      <summary>
            Represents a writer that provides a fast, non-cached, forward-only way of generating JSON data.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.#ctor(System.IO.Stream)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonWriter" /> class.
            </summary>
      <param name="stream">The stream.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.#ctor(System.IO.BinaryWriter)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonWriter" /> class.
            </summary>
      <param name="writer">The writer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.Flush">
      <summary>
            Flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteEnd(Newtonsoft.Json.JsonToken)">
      <summary>
            Writes the end.
            </summary>
      <param name="token">The token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteComment(System.String)">
      <summary>
            Writes out a comment <code>/*...*/</code> containing the specified text.
            </summary>
      <param name="text">Text to place inside the comment.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteStartConstructor(System.String)">
      <summary>
            Writes the start of a constructor with the given name.
            </summary>
      <param name="name">The name of the constructor.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteRaw(System.String)">
      <summary>
            Writes raw JSON.
            </summary>
      <param name="json">The raw JSON to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteRawValue(System.String)">
      <summary>
            Writes raw JSON where a value is expected and updates the writer's state.
            </summary>
      <param name="json">The raw JSON to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteStartArray">
      <summary>
            Writes the beginning of a Json array.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteStartObject">
      <summary>
            Writes the beginning of a Json object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WritePropertyName(System.String)">
      <summary>
            Writes the property name of a name/value pair on a Json object.
            </summary>
      <param name="name">The name of the property.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.Close">
      <summary>
            Closes this stream and the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Object)">
      <summary>
            Writes a <see cref="T:System.Object" /> value.
            An error will raised if the value cannot be written as a single JSON token.
            </summary>
      <param name="value">The <see cref="T:System.Object" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteNull">
      <summary>
            Writes a null value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteUndefined">
      <summary>
            Writes an undefined value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.String)">
      <summary>
            Writes a <see cref="T:System.String" /> value.
            </summary>
      <param name="value">The <see cref="T:System.String" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Int32)">
      <summary>
            Writes a <see cref="T:System.Int32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.UInt32)">
      <summary>
            Writes a <see cref="T:System.UInt32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Int64)">
      <summary>
            Writes a <see cref="T:System.Int64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.UInt64)">
      <summary>
            Writes a <see cref="T:System.UInt64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Single)">
      <summary>
            Writes a <see cref="T:System.Single" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Single" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Double)">
      <summary>
            Writes a <see cref="T:System.Double" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Double" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Boolean)">
      <summary>
            Writes a <see cref="T:System.Boolean" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Boolean" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Int16)">
      <summary>
            Writes a <see cref="T:System.Int16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.UInt16)">
      <summary>
            Writes a <see cref="T:System.UInt16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Char)">
      <summary>
            Writes a <see cref="T:System.Char" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Byte)">
      <summary>
            Writes a <see cref="T:System.Byte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Byte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.SByte)">
      <summary>
            Writes a <see cref="T:System.SByte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.SByte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Decimal)">
      <summary>
            Writes a <see cref="T:System.Decimal" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Decimal" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.DateTime)">
      <summary>
            Writes a <see cref="T:System.DateTime" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTime" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.DateTimeOffset)">
      <summary>
            Writes a <see cref="T:System.DateTimeOffset" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTimeOffset" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Byte[])">
      <summary>
            Writes a <see cref="T:Byte[]" /> value.
            </summary>
      <param name="value">The <see cref="T:Byte[]" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Guid)">
      <summary>
            Writes a <see cref="T:System.Guid" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Guid" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.TimeSpan)">
      <summary>
            Writes a <see cref="T:System.TimeSpan" /> value.
            </summary>
      <param name="value">The <see cref="T:System.TimeSpan" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Uri)">
      <summary>
            Writes a <see cref="T:System.Uri" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Uri" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteObjectId(System.Byte[])">
      <summary>
            Writes a <see cref="T:Byte[]" /> value that represents a BSON object id.
            </summary>
      <param name="value">The Object ID value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteRegex(System.String,System.String)">
      <summary>
            Writes a BSON regex.
            </summary>
      <param name="pattern">The regex pattern.</param>
      <param name="options">The regex options.</param>
    </member>
    <member name="P:Newtonsoft.Json.Bson.BsonWriter.DateTimeKindHandling">
      <summary>
            Gets or sets the <see cref="T:System.DateTimeKind" /> used when writing <see cref="T:System.DateTime" /> values to BSON.
            When set to <see cref="F:System.DateTimeKind.Unspecified" /> no conversion will occur.
            </summary>
      <value>The <see cref="T:System.DateTimeKind" /> used when writing <see cref="T:System.DateTime" /> values to BSON.</value>
    </member>
    <member name="T:Newtonsoft.Json.Bson.BsonObjectId">
      <summary>
            Represents a BSON Oid (object id).
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonObjectId.#ctor(System.Byte[])">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonObjectId" /> class.
            </summary>
      <param name="value">The Oid value.</param>
    </member>
    <member name="P:Newtonsoft.Json.Bson.BsonObjectId.Value">
      <summary>
            Gets or sets the value of the Oid.
            </summary>
      <value>The value of the Oid.</value>
    </member>
    <member name="T:Newtonsoft.Json.JsonConverter">
      <summary>
            Converts an object to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConverter.GetSchema">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of the JSON produced by the JsonConverter.
            </summary>
      <returns>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of the JSON produced by the JsonConverter.</returns>
    </member>
    <member name="P:Newtonsoft.Json.JsonConverter.CanRead">
      <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.JsonConverter" /> can read JSON.
            </summary>
      <value>
        <c>true</c> if this <see cref="T:Newtonsoft.Json.JsonConverter" /> can read JSON; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonConverter.CanWrite">
      <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.JsonConverter" /> can write JSON.
            </summary>
      <value>
        <c>true</c> if this <see cref="T:Newtonsoft.Json.JsonConverter" /> can write JSON; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Newtonsoft.Json.Converters.BinaryConverter">
      <summary>
            Converts a binary value to and from a base 64 string value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.BinaryConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.BinaryConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.BinaryConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.DataSetConverter">
      <summary>
            Converts a <see cref="T:System.Data.DataSet" /> to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DataSetConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DataSetConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DataSetConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified value type.
            </summary>
      <param name="valueType">Type of the value.</param>
      <returns>
        <c>true</c> if this instance can convert the specified value type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.DataTableConverter">
      <summary>
            Converts a <see cref="T:System.Data.DataTable" /> to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DataTableConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DataTableConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DataTableConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified value type.
            </summary>
      <param name="valueType">Type of the value.</param>
      <returns>
        <c>true</c> if this instance can convert the specified value type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.CustomCreationConverter`1">
      <summary>
            Create a custom object
            </summary>
      <typeparam name="T">The object type to convert.</typeparam>
    </member>
    <member name="M:Newtonsoft.Json.Converters.CustomCreationConverter`1.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.CustomCreationConverter`1.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.CustomCreationConverter`1.Create(System.Type)">
      <summary>
            Creates an object which will then be populated by the serializer.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>The created object.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.CustomCreationConverter`1.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Converters.CustomCreationConverter`1.CanWrite">
      <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.JsonConverter" /> can write JSON.
            </summary>
      <value>
        <c>true</c> if this <see cref="T:Newtonsoft.Json.JsonConverter" /> can write JSON; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Newtonsoft.Json.Converters.DateTimeConverterBase">
      <summary>
            Provides a base class for converting a <see cref="T:System.DateTime" /> to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DateTimeConverterBase.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.DiscriminatedUnionConverter">
      <summary>
            Converts a F# discriminated union type to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DiscriminatedUnionConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DiscriminatedUnionConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DiscriminatedUnionConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.EntityKeyMemberConverter">
      <summary>
            Converts an Entity Framework EntityKey to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.EntityKeyMemberConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.EntityKeyMemberConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.EntityKeyMemberConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.ExpandoObjectConverter">
      <summary>
            Converts an ExpandoObject to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.ExpandoObjectConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.ExpandoObjectConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.ExpandoObjectConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Converters.ExpandoObjectConverter.CanWrite">
      <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.JsonConverter" /> can write JSON.
            </summary>
      <value>
        <c>true</c> if this <see cref="T:Newtonsoft.Json.JsonConverter" /> can write JSON; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Newtonsoft.Json.Converters.KeyValuePairConverter">
      <summary>
            Converts a <see cref="T:System.Collections.Generic.KeyValuePair`2" /> to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.KeyValuePairConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.KeyValuePairConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.KeyValuePairConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.BsonObjectIdConverter">
      <summary>
            Converts a <see cref="T:Newtonsoft.Json.Bson.BsonObjectId" /> to and from JSON and BSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.BsonObjectIdConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.BsonObjectIdConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.BsonObjectIdConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.RegexConverter">
      <summary>
            Converts a <see cref="T:System.Text.RegularExpressions.Regex" /> to and from JSON and BSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.RegexConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.RegexConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.RegexConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.StringEnumConverter">
      <summary>
            Converts an <see cref="T:System.Enum" /> to and from its name string value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.StringEnumConverter.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Converters.StringEnumConverter" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.StringEnumConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.StringEnumConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.StringEnumConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Converters.StringEnumConverter.CamelCaseText">
      <summary>
            Gets or sets a value indicating whether the written enum text should be camel case.
            </summary>
      <value>
        <c>true</c> if the written enum text will be camel case; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Newtonsoft.Json.Converters.StringEnumConverter.AllowIntegerValues">
      <summary>
            Gets or sets a value indicating whether integer values are allowed.
            </summary>
      <value>
        <c>true</c> if integers are allowed; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Newtonsoft.Json.ConstructorHandling">
      <summary>
            Specifies how constructors are used when initializing objects during deserialization by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ConstructorHandling.Default">
      <summary>
            First attempt to use the public default constructor, then fall back to single paramatized constructor, then the non-public default constructor.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ConstructorHandling.AllowNonPublicDefaultConstructor">
      <summary>
            Json.NET will use a non-public default constructor before falling back to a paramatized constructor.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Converters.VersionConverter">
      <summary>
            Converts a <see cref="T:System.Version" /> to and from a string (e.g. "1.2.3.4").
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.VersionConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.VersionConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing property value of the JSON that is being converted.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.VersionConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.FloatFormatHandling">
      <summary>
            Specifies float format handling options when writing special floating point numbers, e.g. <see cref="F:System.Double.NaN" />,
            <see cref="F:System.Double.PositiveInfinity" /> and <see cref="F:System.Double.NegativeInfinity" /> with <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.FloatFormatHandling.String">
      <summary>
            Write special floating point values as strings in JSON, e.g. "NaN", "Infinity", "-Infinity".
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.FloatFormatHandling.Symbol">
      <summary>
            Write special floating point values as symbols in JSON, e.g. NaN, Infinity, -Infinity.
            Note that this will produce non-valid JSON.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.FloatFormatHandling.DefaultValue">
      <summary>
            Write special floating point values as the property's default value in JSON, e.g. 0.0 for a <see cref="T:System.Double" /> property, null for a <see cref="T:System.Nullable`1" /> property.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.FloatParseHandling">
      <summary>
            Specifies how floating point numbers, e.g. 1.0 and 9.9, are parsed when reading JSON text.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.FloatParseHandling.Double">
      <summary>
            Floating point numbers are parsed to <see cref="F:Newtonsoft.Json.FloatParseHandling.Double" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.FloatParseHandling.Decimal">
      <summary>
            Floating point numbers are parsed to <see cref="F:Newtonsoft.Json.FloatParseHandling.Decimal" />.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonContainerAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> how to serialize the object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonContainerAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonContainerAttribute" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonContainerAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonContainerAttribute" /> class with the specified container Id.
            </summary>
      <param name="id">The container Id.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonContainerAttribute.Id">
      <summary>
            Gets or sets the id.
            </summary>
      <value>The id.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonContainerAttribute.Title">
      <summary>
            Gets or sets the title.
            </summary>
      <value>The title.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonContainerAttribute.Description">
      <summary>
            Gets or sets the description.
            </summary>
      <value>The description.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonContainerAttribute.ItemConverterType">
      <summary>
            Gets the collection's items converter.
            </summary>
      <value>The collection's items converter.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonContainerAttribute.IsReference">
      <summary>
            Gets or sets a value that indicates whether to preserve object references.
            </summary>
      <value>
        <c>true</c> to keep object reference; otherwise, <c>false</c>. The default is <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonContainerAttribute.ItemIsReference">
      <summary>
            Gets or sets a value that indicates whether to preserve collection's items references.
            </summary>
      <value>
        <c>true</c> to keep collection's items object references; otherwise, <c>false</c>. The default is <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonContainerAttribute.ItemReferenceLoopHandling">
      <summary>
            Gets or sets the reference loop handling used when serializing the collection's items.
            </summary>
      <value>The reference loop handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonContainerAttribute.ItemTypeNameHandling">
      <summary>
            Gets or sets the type name handling used when serializing the collection's items.
            </summary>
      <value>The type name handling.</value>
    </member>
    <member name="T:Newtonsoft.Json.JsonDictionaryAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> how to serialize the collection.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonDictionaryAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonDictionaryAttribute" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonDictionaryAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonDictionaryAttribute" /> class with the specified container Id.
            </summary>
      <param name="id">The container Id.</param>
    </member>
    <member name="T:Newtonsoft.Json.JsonException">
      <summary>
            The exception thrown when an error occurs during Json serialization or deserialization.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonException" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonException" /> class
            with a specified error message.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonException" /> class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="T:Newtonsoft.Json.DateFormatHandling">
      <summary>
            Specifies how dates are formatted when writing JSON text.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DateFormatHandling.IsoDateFormat">
      <summary>
            Dates are written in the ISO 8601 format, e.g. "2012-03-21T05:40Z".
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DateFormatHandling.MicrosoftDateFormat">
      <summary>
            Dates are written in the Microsoft JSON format, e.g. "\/Date(1198908717056)\/".
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.DateParseHandling">
      <summary>
            Specifies how date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed when reading JSON text.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DateParseHandling.None">
      <summary>
            Date formatted strings are not parsed to a date type and are read as strings.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DateParseHandling.DateTime">
      <summary>
            Date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed to <see cref="F:Newtonsoft.Json.DateParseHandling.DateTime" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DateParseHandling.DateTimeOffset">
      <summary>
            Date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed to <see cref="F:Newtonsoft.Json.DateParseHandling.DateTimeOffset" />.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.DateTimeZoneHandling">
      <summary>
            Specifies how to treat the time value when converting between string and <see cref="T:System.DateTime" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DateTimeZoneHandling.Local">
      <summary>
            Treat as local time. If the <see cref="T:System.DateTime" /> object represents a Coordinated Universal Time (UTC), it is converted to the local time.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DateTimeZoneHandling.Utc">
      <summary>
            Treat as a UTC. If the <see cref="T:System.DateTime" /> object represents a local time, it is converted to a UTC.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DateTimeZoneHandling.Unspecified">
      <summary>
            Treat as a local time if a <see cref="T:System.DateTime" /> is being converted to a string.
            If a string is being converted to <see cref="T:System.DateTime" />, convert to a local time if a time zone is specified.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DateTimeZoneHandling.RoundtripKind">
      <summary>
            Time zone information should be preserved when converting.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Formatting">
      <summary>
            Specifies formatting options for the <see cref="T:Newtonsoft.Json.JsonTextWriter" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Formatting.None">
      <summary>
            No special formatting is applied. This is the default.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Formatting.Indented">
      <summary>
            Causes child objects to be indented according to the <see cref="P:Newtonsoft.Json.JsonTextWriter.Indentation" /> and <see cref="P:Newtonsoft.Json.JsonTextWriter.IndentChar" /> settings.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonConstructorAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> to use the specified constructor when deserializing that object.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonExtensionDataAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> to deserialize properties with no matching class member into the specified collection
            and write values during serialization.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonExtensionDataAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonExtensionDataAttribute" /> class.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonExtensionDataAttribute.WriteData">
      <summary>
            Gets or sets a value that indicates whether to write extension data when serializing the object.
            </summary>
      <value>
        <c>true</c> to write extension data when serializing the object; otherwise, <c>false</c>. The default is <c>true</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonExtensionDataAttribute.ReadData">
      <summary>
            Gets or sets a value that indicates whether to read extension data when deserializing the object.
            </summary>
      <value>
        <c>true</c> to read extension data when deserializing the object; otherwise, <c>false</c>. The default is <c>true</c>.
            </value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JsonMergeSettings">
      <summary>
            Specifies the settings used when merging JSON.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JsonMergeSettings.MergeArrayHandling">
      <summary>
            Gets or sets the method used when merging JSON arrays.
            </summary>
      <value>The method used when merging JSON arrays.</value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.MergeArrayHandling">
      <summary>
            Specifies how JSON arrays are merged together.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.MergeArrayHandling.Concat">
      <summary>Concatenate arrays.</summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.MergeArrayHandling.Union">
      <summary>Union arrays, skipping items that already exist.</summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.MergeArrayHandling.Replace">
      <summary>Replace all array items.</summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.MergeArrayHandling.Merge">
      <summary>Merge array items together, matched by index.</summary>
    </member>
    <member name="T:Newtonsoft.Json.MetadataPropertyHandling">
      <summary>
            Specifies metadata property handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.MetadataPropertyHandling.Default">
      <summary>
            Read metadata properties located at the start of a JSON object.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.MetadataPropertyHandling.ReadAhead">
      <summary>
            Read metadata properties located anywhere in a JSON object. Note that this setting will impact performance.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.MetadataPropertyHandling.Ignore">
      <summary>
            Do not try to read metadata properties.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.ITraceWriter">
      <summary>
            Represents a trace writer.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.ITraceWriter.Trace(System.Diagnostics.TraceLevel,System.String,System.Exception)">
      <summary>
            Writes the specified trace level, message and optional exception.
            </summary>
      <param name="level">The <see cref="T:System.Diagnostics.TraceLevel" /> at which to write this trace.</param>
      <param name="message">The trace message.</param>
      <param name="ex">The trace exception. This parameter is optional.</param>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.ITraceWriter.LevelFilter">
      <summary>
            Gets the <see cref="T:System.Diagnostics.TraceLevel" /> that will be used to filter the trace messages passed to the writer.
            For example a filter level of <code>Info</code> will exclude <code>Verbose</code> messages and include <code>Info</code>,
            <code>Warning</code> and <code>Error</code> messages.
            </summary>
      <value>The <see cref="T:System.Diagnostics.TraceLevel" /> that will be used to filter the trace messages passed to the writer.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.DiagnosticsTraceWriter">
      <summary>
            Represents a trace writer that writes to the application's <see cref="T:System.Diagnostics.TraceListener" /> instances.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DiagnosticsTraceWriter.Trace(System.Diagnostics.TraceLevel,System.String,System.Exception)">
      <summary>
            Writes the specified trace level, message and optional exception.
            </summary>
      <param name="level">The <see cref="T:System.Diagnostics.TraceLevel" /> at which to write this trace.</param>
      <param name="message">The trace message.</param>
      <param name="ex">The trace exception. This parameter is optional.</param>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.DiagnosticsTraceWriter.LevelFilter">
      <summary>
            Gets the <see cref="T:System.Diagnostics.TraceLevel" /> that will be used to filter the trace messages passed to the writer.
            For example a filter level of <code>Info</code> will exclude <code>Verbose</code> messages and include <code>Info</code>,
            <code>Warning</code> and <code>Error</code> messages.
            </summary>
      <value>
            The <see cref="T:System.Diagnostics.TraceLevel" /> that will be used to filter the trace messages passed to the writer.
            </value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.IValueProvider">
      <summary>
            Provides methods to get and set values.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.IValueProvider.SetValue(System.Object,System.Object)">
      <summary>
            Sets the value.
            </summary>
      <param name="target">The target to set the value on.</param>
      <param name="value">The value to set on the target.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.IValueProvider.GetValue(System.Object)">
      <summary>
            Gets the value.
            </summary>
      <param name="target">The target to get the value from.</param>
      <returns>The value.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.ExpressionValueProvider">
      <summary>
            Get and set values for a <see cref="T:System.Reflection.MemberInfo" /> using dynamic methods.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.ExpressionValueProvider.#ctor(System.Reflection.MemberInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.ExpressionValueProvider" /> class.
            </summary>
      <param name="memberInfo">The member info.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.ExpressionValueProvider.SetValue(System.Object,System.Object)">
      <summary>
            Sets the value.
            </summary>
      <param name="target">The target to set the value on.</param>
      <param name="value">The value to set on the target.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.ExpressionValueProvider.GetValue(System.Object)">
      <summary>
            Gets the value.
            </summary>
      <param name="target">The target to get the value from.</param>
      <returns>The value.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.UnderlyingType">
      <summary>
            Gets the underlying type for the contract.
            </summary>
      <value>The underlying type for the contract.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.CreatedType">
      <summary>
            Gets or sets the type created during deserialization.
            </summary>
      <value>The type created during deserialization.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.IsReference">
      <summary>
            Gets or sets whether this type contract is serialized as a reference.
            </summary>
      <value>Whether this type contract is serialized as a reference.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.Converter">
      <summary>
            Gets or sets the default <see cref="T:Newtonsoft.Json.JsonConverter" /> for this contract.
            </summary>
      <value>The converter.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnDeserializedCallbacks">
      <summary>
            Gets or sets all methods called immediately after deserialization of the object.
            </summary>
      <value>The methods called immediately after deserialization of the object.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnDeserializingCallbacks">
      <summary>
            Gets or sets all methods called during deserialization of the object.
            </summary>
      <value>The methods called during deserialization of the object.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnSerializedCallbacks">
      <summary>
            Gets or sets all methods called after serialization of the object graph.
            </summary>
      <value>The methods called after serialization of the object graph.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnSerializingCallbacks">
      <summary>
            Gets or sets all methods called before serialization of the object.
            </summary>
      <value>The methods called before serialization of the object.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnErrorCallbacks">
      <summary>
            Gets or sets all method called when an error is thrown during the serialization of the object.
            </summary>
      <value>The methods called when an error is thrown during the serialization of the object.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnDeserialized">
      <summary>
            Gets or sets the method called immediately after deserialization of the object.
            </summary>
      <value>The method called immediately after deserialization of the object.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnDeserializing">
      <summary>
            Gets or sets the method called during deserialization of the object.
            </summary>
      <value>The method called during deserialization of the object.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnSerialized">
      <summary>
            Gets or sets the method called after serialization of the object graph.
            </summary>
      <value>The method called after serialization of the object graph.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnSerializing">
      <summary>
            Gets or sets the method called before serialization of the object.
            </summary>
      <value>The method called before serialization of the object.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnError">
      <summary>
            Gets or sets the method called when an error is thrown during the serialization of the object.
            </summary>
      <value>The method called when an error is thrown during the serialization of the object.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.DefaultCreator">
      <summary>
            Gets or sets the default creator method used to create the object.
            </summary>
      <value>The default creator method used to create the object.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.DefaultCreatorNonPublic">
      <summary>
            Gets or sets a value indicating whether the default creator is non public.
            </summary>
      <value>
        <c>true</c> if the default object creator is non-public; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonContainerContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonContainerContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonContainerContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContainerContract.ItemConverter">
      <summary>
            Gets or sets the default collection items <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
      <value>The converter.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContainerContract.ItemIsReference">
      <summary>
            Gets or sets a value indicating whether the collection items preserve object references.
            </summary>
      <value>
        <c>true</c> if collection items preserve object references; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContainerContract.ItemReferenceLoopHandling">
      <summary>
            Gets or sets the collection item reference loop handling.
            </summary>
      <value>The reference loop handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContainerContract.ItemTypeNameHandling">
      <summary>
            Gets or sets the collection item type name handling.
            </summary>
      <value>The type name handling.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.MemoryTraceWriter">
      <summary>
            Represents a trace writer that writes to memory. When the trace message limit is
            reached then old trace messages will be removed as new messages are added.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.MemoryTraceWriter.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.MemoryTraceWriter" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.MemoryTraceWriter.Trace(System.Diagnostics.TraceLevel,System.String,System.Exception)">
      <summary>
            Writes the specified trace level, message and optional exception.
            </summary>
      <param name="level">The <see cref="T:System.Diagnostics.TraceLevel" /> at which to write this trace.</param>
      <param name="message">The trace message.</param>
      <param name="ex">The trace exception. This parameter is optional.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.MemoryTraceWriter.GetTraceMessages">
      <summary>
            Returns an enumeration of the most recent trace messages.
            </summary>
      <returns>An enumeration of the most recent trace messages.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.MemoryTraceWriter.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> of the most recent trace messages.
            </summary>
      <returns>
            A <see cref="T:System.String" /> of the most recent trace messages.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.MemoryTraceWriter.LevelFilter">
      <summary>
            Gets the <see cref="T:System.Diagnostics.TraceLevel" /> that will be used to filter the trace messages passed to the writer.
            For example a filter level of <code>Info</code> will exclude <code>Verbose</code> messages and include <code>Info</code>,
            <code>Warning</code> and <code>Error</code> messages.
            </summary>
      <value>
            The <see cref="T:System.Diagnostics.TraceLevel" /> that will be used to filter the trace messages passed to the writer.
            </value>
    </member>
    <member name="T:Newtonsoft.Json.IJsonLineInfo">
      <summary>
            Provides an interface to enable a class to return line and position information.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.IJsonLineInfo.HasLineInfo">
      <summary>
            Gets a value indicating whether the class can return line information.
            </summary>
      <returns>
        <c>true</c> if LineNumber and LinePosition can be provided; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.IJsonLineInfo.LineNumber">
      <summary>
            Gets the current line number.
            </summary>
      <value>The current line number or 0 if no line information is available (for example, HasLineInfo returns false).</value>
    </member>
    <member name="P:Newtonsoft.Json.IJsonLineInfo.LinePosition">
      <summary>
            Gets the current line position.
            </summary>
      <value>The current line position or 0 if no line information is available (for example, HasLineInfo returns false).</value>
    </member>
    <member name="T:Newtonsoft.Json.StringEscapeHandling">
      <summary>
            Specifies how strings are escaped when writing JSON text.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.StringEscapeHandling.Default">
      <summary>
            Only control characters (e.g. newline) are escaped.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.StringEscapeHandling.EscapeNonAscii">
      <summary>
            All non-ASCII and control characters (e.g. newline) are escaped.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.StringEscapeHandling.EscapeHtml">
      <summary>
            HTML (&lt;, &gt;, &amp;, ', ") and control characters (e.g. newline) are escaped.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Linq.IJEnumerable`1">
      <summary>
            Represents a collection of <see cref="T:Newtonsoft.Json.Linq.JToken" /> objects.
            </summary>
      <typeparam name="T">The type of token</typeparam>
    </member>
    <member name="P:Newtonsoft.Json.Linq.IJEnumerable`1.Item(System.Object)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" /> with the specified key.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JToken">
      <summary>
            Represents an abstract JSON token.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.DeepEquals(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Linq.JToken)">
      <summary>
            Compares the values of two tokens, including the values of all descendant tokens.
            </summary>
      <param name="t1">The first <see cref="T:Newtonsoft.Json.Linq.JToken" /> to compare.</param>
      <param name="t2">The second <see cref="T:Newtonsoft.Json.Linq.JToken" /> to compare.</param>
      <returns>true if the tokens are equal; otherwise false.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.AddAfterSelf(System.Object)">
      <summary>
            Adds the specified content immediately after this token.
            </summary>
      <param name="content">A content object that contains simple content or a collection of content objects to be added after this token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.AddBeforeSelf(System.Object)">
      <summary>
            Adds the specified content immediately before this token.
            </summary>
      <param name="content">A content object that contains simple content or a collection of content objects to be added before this token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Ancestors">
      <summary>
            Returns a collection of the ancestor tokens of this token.
            </summary>
      <returns>A collection of the ancestor tokens of this token.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.AfterSelf">
      <summary>
            Returns a collection of the sibling tokens after this token, in document order.
            </summary>
      <returns>A collection of the sibling tokens after this tokens, in document order.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.BeforeSelf">
      <summary>
            Returns a collection of the sibling tokens before this token, in document order.
            </summary>
      <returns>A collection of the sibling tokens before this token, in document order.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Value``1(System.Object)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key converted to the specified type.
            </summary>
      <typeparam name="T">The type to convert the token to.</typeparam>
      <param name="key">The token key.</param>
      <returns>The converted token value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Children">
      <summary>
            Returns a collection of the child tokens of this token, in document order.
            </summary>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the child tokens of this <see cref="T:Newtonsoft.Json.Linq.JToken" />, in document order.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Children``1">
      <summary>
            Returns a collection of the child tokens of this token, in document order, filtered by the specified type.
            </summary>
      <typeparam name="T">The type to filter the child tokens on.</typeparam>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JEnumerable`1" /> containing the child tokens of this <see cref="T:Newtonsoft.Json.Linq.JToken" />, in document order.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Values``1">
      <summary>
            Returns a collection of the child values of this token, in document order.
            </summary>
      <typeparam name="T">The type to convert the values to.</typeparam>
      <returns>A <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing the child values of this <see cref="T:Newtonsoft.Json.Linq.JToken" />, in document order.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Remove">
      <summary>
            Removes this token from its parent.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Replace(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Replaces this token with the specified token.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
      <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.ToString">
      <summary>
            Returns the indented JSON for this token.
            </summary>
      <returns>
            The indented JSON for this token.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.ToString(Newtonsoft.Json.Formatting,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Returns the JSON for this token using the given formatting and converters.
            </summary>
      <param name="formatting">Indicates how the output is formatted.</param>
      <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
      <returns>The JSON for this token using the given formatting and converters.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Boolean">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Boolean" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.DateTimeOffset">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.DateTimeOffset" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Boolean}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Int64">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Int64" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.DateTime}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.DateTimeOffset}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Decimal}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Double}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Char}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Int32">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Int32" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Int16">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Int16" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.UInt16">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.UInt16" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Char">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Char" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Byte">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Byte" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.SByte">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.SByte" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Int32}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Int16}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.UInt16}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Byte}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.SByte}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.DateTime">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.DateTime" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Int64}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Single}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Decimal">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Decimal" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.UInt32}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.UInt64}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Double">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Double" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Single">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Single" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.String">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.String" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.UInt32">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.UInt32" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.UInt64">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.UInt64" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Byte[]">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Byte[]" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Guid">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Guid" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Guid}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Guid" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.TimeSpan">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.TimeSpan" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.TimeSpan}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.TimeSpan" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Uri">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Uri" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Boolean)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Boolean" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.DateTimeOffset)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.DateTimeOffset" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Byte)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Byte" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Byte})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.SByte)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.SByte" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.SByte})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Boolean})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Int64)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.DateTime})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.DateTimeOffset})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Decimal})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Double})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Int16)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Int16" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.UInt16)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.UInt16" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Int32)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Int32" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Int32})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.DateTime)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.DateTime" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Int64})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Single})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Decimal)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Decimal" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Int16})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.UInt16})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.UInt32})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.UInt64})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Double)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Double" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Single)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Single" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.String)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.String" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.UInt32)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.UInt32" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.UInt64)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.UInt64" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Byte[])~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Byte[]" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Uri)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Uri" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.TimeSpan)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.TimeSpan" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.TimeSpan})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Guid)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Guid" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Guid})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.CreateReader">
      <summary>
            Creates an <see cref="T:Newtonsoft.Json.JsonReader" /> for this token.
            </summary>
      <returns>An <see cref="T:Newtonsoft.Json.JsonReader" /> that can be used to read this token and its descendants.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.FromObject(System.Object)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JToken" /> from an object.
            </summary>
      <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the value of the specified object</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.FromObject(System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JToken" /> from an object using the specified <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
      <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
      <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer" /> that will be used when reading the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the value of the specified object</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.ToObject``1">
      <summary>
            Creates the specified .NET type from the <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <typeparam name="T">The object type that the token will be deserialized to.</typeparam>
      <returns>The new object created from the JSON value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.ToObject(System.Type)">
      <summary>
            Creates the specified .NET type from the <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="objectType">The object type that the token will be deserialized to.</param>
      <returns>The new object created from the JSON value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.ToObject``1(Newtonsoft.Json.JsonSerializer)">
      <summary>
            Creates the specified .NET type from the <see cref="T:Newtonsoft.Json.Linq.JToken" /> using the specified <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
      <typeparam name="T">The object type that the token will be deserialized to.</typeparam>
      <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer" /> that will be used when creating the object.</param>
      <returns>The new object created from the JSON value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.ToObject(System.Type,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Creates the specified .NET type from the <see cref="T:Newtonsoft.Json.Linq.JToken" /> using the specified <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
      <param name="objectType">The object type that the token will be deserialized to.</param>
      <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer" /> that will be used when creating the object.</param>
      <returns>The new object created from the JSON value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.ReadFrom(Newtonsoft.Json.JsonReader)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JToken" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
      <param name="reader">An <see cref="T:Newtonsoft.Json.JsonReader" /> positioned at the token to read into this <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
      <returns>
            An <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the token and its descendant tokens
            that were read from the reader. The runtime type of the token is determined
            by the token type of the first token encountered in the reader.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Parse(System.String)">
      <summary>
            Load a <see cref="T:Newtonsoft.Json.Linq.JToken" /> from a string that contains JSON.
            </summary>
      <param name="json">A <see cref="T:System.String" /> that contains JSON.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken" /> populated from the string that contains JSON.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Load(Newtonsoft.Json.JsonReader)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JToken" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
      <param name="reader">An <see cref="T:Newtonsoft.Json.JsonReader" /> positioned at the token to read into this <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
      <returns>
            An <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the token and its descendant tokens
            that were read from the reader. The runtime type of the token is determined
            by the token type of the first token encountered in the reader.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.SelectToken(System.String)">
      <summary>
            Selects a <see cref="T:Newtonsoft.Json.Linq.JToken" /> using a JPath expression. Selects the token that matches the object path.
            </summary>
      <param name="path">
            A <see cref="T:System.String" /> that contains a JPath expression.
            </param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken" />, or null.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.SelectToken(System.String,System.Boolean)">
      <summary>
            Selects a <see cref="T:Newtonsoft.Json.Linq.JToken" /> using a JPath expression. Selects the token that matches the object path.
            </summary>
      <param name="path">
            A <see cref="T:System.String" /> that contains a JPath expression.
            </param>
      <param name="errorWhenNoMatch">A flag to indicate whether an error should be thrown if no tokens are found when evaluating part of the expression.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.SelectTokens(System.String)">
      <summary>
            Selects a collection of elements using a JPath expression.
            </summary>
      <param name="path">
            A <see cref="T:System.String" /> that contains a JPath expression.
            </param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the selected elements.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.SelectTokens(System.String,System.Boolean)">
      <summary>
            Selects a collection of elements using a JPath expression.
            </summary>
      <param name="path">
            A <see cref="T:System.String" /> that contains a JPath expression.
            </param>
      <param name="errorWhenNoMatch">A flag to indicate whether an error should be thrown if no tokens are found when evaluating part of the expression.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the selected elements.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>
            Returns the <see cref="T:System.Dynamic.DynamicMetaObject" /> responsible for binding operations performed on this object.
            </summary>
      <param name="parameter">The expression tree representation of the runtime value.</param>
      <returns>
            The <see cref="T:System.Dynamic.DynamicMetaObject" /> to bind this object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.DeepClone">
      <summary>
            Creates a new instance of the <see cref="T:Newtonsoft.Json.Linq.JToken" />. All child tokens are recursively cloned.
            </summary>
      <returns>A new instance of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.</returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.EqualityComparer">
      <summary>
            Gets a comparer that can compare two tokens for value equality.
            </summary>
      <value>A <see cref="T:Newtonsoft.Json.Linq.JTokenEqualityComparer" /> that can compare two nodes for value equality.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.Parent">
      <summary>
            Gets or sets the parent.
            </summary>
      <value>The parent.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.Root">
      <summary>
            Gets the root <see cref="T:Newtonsoft.Json.Linq.JToken" /> of this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <value>The root <see cref="T:Newtonsoft.Json.Linq.JToken" /> of this <see cref="T:Newtonsoft.Json.Linq.JToken" />.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.Type">
      <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <value>The type.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.HasValues">
      <summary>
            Gets a value indicating whether this token has child tokens.
            </summary>
      <value>
        <c>true</c> if this token has child values; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.Next">
      <summary>
            Gets the next sibling token of this node.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the next sibling token.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.Previous">
      <summary>
            Gets the previous sibling token of this node.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the previous sibling token.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.Path">
      <summary>
            Gets the path of the JSON token. 
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.Item(System.Object)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.First">
      <summary>
            Get the first child token of this token.
            </summary>
      <value>A <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the first child token of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.Last">
      <summary>
            Get the last child token of this token.
            </summary>
      <value>A <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the last child token of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.</value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JValue">
      <summary>
            Represents a value in JSON (string, integer, date, etc).
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(Newtonsoft.Json.Linq.JValue)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class from another <see cref="T:Newtonsoft.Json.Linq.JValue" /> object.
            </summary>
      <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JValue" /> object to copy from.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Int64)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Decimal)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Char)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.UInt64)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Double)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Single)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.DateTime)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.DateTimeOffset)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Guid)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Uri)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.TimeSpan)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.CreateComment(System.String)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JValue" /> comment with the given value.
            </summary>
      <param name="value">The value.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JValue" /> comment with the given value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.CreateString(System.String)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JValue" /> string with the given value.
            </summary>
      <param name="value">The value.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JValue" /> string with the given value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.CreateNull">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JValue" /> null value.
            </summary>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JValue" /> null value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.CreateUndefined">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JValue" /> null value.
            </summary>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JValue" /> null value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
      <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.Equals(Newtonsoft.Json.Linq.JValue)">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
      <param name="other">An object to compare with this object.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
      <exception cref="T:System.NullReferenceException">
            The <paramref name="obj" /> parameter is null.
            </exception>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.ToString(System.String)">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <param name="format">The format.</param>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.ToString(System.IFormatProvider)">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <param name="formatProvider">The format provider.</param>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.ToString(System.String,System.IFormatProvider)">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <param name="format">The format.</param>
      <param name="formatProvider">The format provider.</param>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>
            Returns the <see cref="T:System.Dynamic.DynamicMetaObject" /> responsible for binding operations performed on this object.
            </summary>
      <param name="parameter">The expression tree representation of the runtime value.</param>
      <returns>
            The <see cref="T:System.Dynamic.DynamicMetaObject" /> to bind this object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.CompareTo(Newtonsoft.Json.Linq.JValue)">
      <summary>
            Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.
            </summary>
      <param name="obj">An object to compare with this instance.</param>
      <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has these meanings:
            Value
            Meaning
            Less than zero
            This instance is less than <paramref name="obj" />.
            Zero
            This instance is equal to <paramref name="obj" />.
            Greater than zero
            This instance is greater than <paramref name="obj" />.
            </returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="obj" /> is not the same type as this instance.
            </exception>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JValue.HasValues">
      <summary>
            Gets a value indicating whether this token has child tokens.
            </summary>
      <value>
        <c>true</c> if this token has child values; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JValue.Type">
      <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <value>The type.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JValue.Value">
      <summary>
            Gets or sets the underlying token value.
            </summary>
      <value>The underlying token value.</value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JRaw">
      <summary>
            Represents a raw JSON string.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JRaw.#ctor(Newtonsoft.Json.Linq.JRaw)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JRaw" /> class from another <see cref="T:Newtonsoft.Json.Linq.JRaw" /> object.
            </summary>
      <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JRaw" /> object to copy from.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JRaw.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JRaw" /> class.
            </summary>
      <param name="rawJson">The raw json.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JRaw.Create(Newtonsoft.Json.JsonReader)">
      <summary>
            Creates an instance of <see cref="T:Newtonsoft.Json.Linq.JRaw" /> with the content of the reader's current token.
            </summary>
      <param name="reader">The reader.</param>
      <returns>An instance of <see cref="T:Newtonsoft.Json.Linq.JRaw" /> with the content of the reader's current token.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Required">
      <summary>
            Indicating whether a property is required.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Required.Default">
      <summary>
            The property is not required. The default state.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Required.AllowNull">
      <summary>
            The property must be defined in JSON but can be a null value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Required.Always">
      <summary>
            The property must be defined in JSON and cannot be a null value.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonDynamicContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonDynamicContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonDynamicContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonDynamicContract.Properties">
      <summary>
            Gets the object's properties.
            </summary>
      <value>The object's properties.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonDynamicContract.PropertyNameResolver">
      <summary>
            Gets or sets the property name resolver.
            </summary>
      <value>The property name resolver.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonISerializableContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonISerializableContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonISerializableContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonISerializableContract.ISerializableCreator">
      <summary>
            Gets or sets the ISerializable object constructor.
            </summary>
      <value>The ISerializable object constructor.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonLinqContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonLinqContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonLinqContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonPrimitiveContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonPrimitiveContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonPrimitiveContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.DynamicValueProvider">
      <summary>
            Get and set values for a <see cref="T:System.Reflection.MemberInfo" /> using dynamic methods.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DynamicValueProvider.#ctor(System.Reflection.MemberInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.DynamicValueProvider" /> class.
            </summary>
      <param name="memberInfo">The member info.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DynamicValueProvider.SetValue(System.Object,System.Object)">
      <summary>
            Sets the value.
            </summary>
      <param name="target">The target to set the value on.</param>
      <param name="value">The value to set on the target.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DynamicValueProvider.GetValue(System.Object)">
      <summary>
            Gets the value.
            </summary>
      <param name="target">The target to get the value from.</param>
      <returns>The value.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.ErrorEventArgs">
      <summary>
            Provides data for the Error event.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.ErrorEventArgs.#ctor(System.Object,Newtonsoft.Json.Serialization.ErrorContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.ErrorEventArgs" /> class.
            </summary>
      <param name="currentObject">The current object.</param>
      <param name="errorContext">The error context.</param>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.ErrorEventArgs.CurrentObject">
      <summary>
            Gets the current object the error event is being raised against.
            </summary>
      <value>The current object the error event is being raised against.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.ErrorEventArgs.ErrorContext">
      <summary>
            Gets the error context.
            </summary>
      <value>The error context.</value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JPropertyDescriptor">
      <summary>
            Represents a view of a <see cref="T:Newtonsoft.Json.Linq.JProperty" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JPropertyDescriptor" /> class.
            </summary>
      <param name="name">The name.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.CanResetValue(System.Object)">
      <summary>
            When overridden in a derived class, returns whether resetting an object changes its value.
            </summary>
      <returns>
            true if resetting the component changes its value; otherwise, false.
            </returns>
      <param name="component">The component to test for reset capability. 
                            </param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.GetValue(System.Object)">
      <summary>
            When overridden in a derived class, gets the current value of the property on a component.
            </summary>
      <returns>
            The value of a property for a given component.
            </returns>
      <param name="component">The component with the property for which to retrieve the value. 
                            </param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.ResetValue(System.Object)">
      <summary>
            When overridden in a derived class, resets the value for this property of the component to the default value.
            </summary>
      <param name="component">The component with the property value that is to be reset to the default value. 
                            </param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.SetValue(System.Object,System.Object)">
      <summary>
            When overridden in a derived class, sets the value of the component to a different value.
            </summary>
      <param name="component">The component with the property value that is to be set. 
                            </param>
      <param name="value">The new value. 
                            </param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.ShouldSerializeValue(System.Object)">
      <summary>
            When overridden in a derived class, determines a value indicating whether the value of this property needs to be persisted.
            </summary>
      <returns>
            true if the property should be persisted; otherwise, false.
            </returns>
      <param name="component">The component with the property to be examined for persistence. 
                            </param>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JPropertyDescriptor.ComponentType">
      <summary>
            When overridden in a derived class, gets the type of the component this property is bound to.
            </summary>
      <returns>
            A <see cref="T:System.Type" /> that represents the type of component this property is bound to. When the <see cref="M:System.ComponentModel.PropertyDescriptor.GetValue(System.Object)" /> or <see cref="M:System.ComponentModel.PropertyDescriptor.SetValue(System.Object,System.Object)" /> methods are invoked, the object specified might be an instance of this type.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JPropertyDescriptor.IsReadOnly">
      <summary>
            When overridden in a derived class, gets a value indicating whether this property is read-only.
            </summary>
      <returns>
            true if the property is read-only; otherwise, false.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JPropertyDescriptor.PropertyType">
      <summary>
            When overridden in a derived class, gets the type of the property.
            </summary>
      <returns>
            A <see cref="T:System.Type" /> that represents the type of the property.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JPropertyDescriptor.NameHashCode">
      <summary>
            Gets the hash code for the name of the member.
            </summary>
      <value>
      </value>
      <returns>
            The hash code for the name of the member.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.IReferenceResolver">
      <summary>
            Used to resolve references when serializing and deserializing JSON by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.IReferenceResolver.ResolveReference(System.Object,System.String)">
      <summary>
            Resolves a reference to its object.
            </summary>
      <param name="context">The serialization context.</param>
      <param name="reference">The reference to resolve.</param>
      <returns>The object that</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.IReferenceResolver.GetReference(System.Object,System.Object)">
      <summary>
            Gets the reference for the sepecified object.
            </summary>
      <param name="context">The serialization context.</param>
      <param name="value">The object to get a reference for.</param>
      <returns>The reference to the object.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.IReferenceResolver.IsReferenced(System.Object,System.Object)">
      <summary>
            Determines whether the specified object is referenced.
            </summary>
      <param name="context">The serialization context.</param>
      <param name="value">The object to test for a reference.</param>
      <returns>
        <c>true</c> if the specified object is referenced; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.IReferenceResolver.AddReference(System.Object,System.String,System.Object)">
      <summary>
            Adds a reference to the specified object.
            </summary>
      <param name="context">The serialization context.</param>
      <param name="reference">The reference.</param>
      <param name="value">The object to reference.</param>
    </member>
    <member name="T:Newtonsoft.Json.PreserveReferencesHandling">
      <summary>
            Specifies reference handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            Note that references cannot be preserved when a value is set via a non-default constructor such as types that implement ISerializable.
            </summary>
      <example>
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="PreservingObjectReferencesOn" title="Preserve Object References" />
      </example>
    </member>
    <member name="F:Newtonsoft.Json.PreserveReferencesHandling.None">
      <summary>
            Do not preserve references when serializing types.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.PreserveReferencesHandling.Objects">
      <summary>
            Preserve references when serializing into a JSON object structure.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.PreserveReferencesHandling.Arrays">
      <summary>
            Preserve references when serializing into a JSON array structure.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.PreserveReferencesHandling.All">
      <summary>
            Preserve references when serializing.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonArrayAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> how to serialize the collection.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonArrayAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonArrayAttribute" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonArrayAttribute.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonObjectAttribute" /> class with a flag indicating whether the array can contain null items
            </summary>
      <param name="allowNullItems">A flag indicating whether the array can contain null items.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonArrayAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonArrayAttribute" /> class with the specified container Id.
            </summary>
      <param name="id">The container Id.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonArrayAttribute.AllowNullItems">
      <summary>
            Gets or sets a value indicating whether null items are allowed in the collection.
            </summary>
      <value>
        <c>true</c> if null items are allowed in the collection; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Newtonsoft.Json.DefaultValueHandling">
      <summary>
            Specifies default value handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
      <example>
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeDefaultValueHandlingObject" title="DefaultValueHandling Class" />
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeDefaultValueHandlingExample" title="DefaultValueHandling Ignore Example" />
      </example>
    </member>
    <member name="F:Newtonsoft.Json.DefaultValueHandling.Include">
      <summary>
            Include members where the member value is the same as the member's default value when serializing objects.
            Included members are written to JSON. Has no effect when deserializing.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DefaultValueHandling.Ignore">
      <summary>
            Ignore members where the member value is the same as the member's default value when serializing objects
            so that is is not written to JSON.
            This option will ignore all default values (e.g. <c>null</c> for objects and nullable types; <c>0</c> for integers,
            decimals and floating point numbers; and <c>false</c> for booleans). The default value ignored can be changed by
            placing the <see cref="T:System.ComponentModel.DefaultValueAttribute" /> on the property.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DefaultValueHandling.Populate">
      <summary>
            Members with a default value but no JSON will be set to their default value when deserializing.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DefaultValueHandling.IgnoreAndPopulate">
      <summary>
            Ignore members where the member value is the same as the member's default value when serializing objects
            and sets members to their default value when deserializing.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonConverterAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> to use the specified <see cref="T:Newtonsoft.Json.JsonConverter" /> when serializing the member or class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonConverterAttribute.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonConverterAttribute" /> class.
            </summary>
      <param name="converterType">Type of the converter.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonConverterAttribute.ConverterType">
      <summary>
            Gets the type of the converter.
            </summary>
      <value>The type of the converter.</value>
    </member>
    <member name="T:Newtonsoft.Json.JsonObjectAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> how to serialize the object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonObjectAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonObjectAttribute" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonObjectAttribute.#ctor(Newtonsoft.Json.MemberSerialization)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonObjectAttribute" /> class with the specified member serialization.
            </summary>
      <param name="memberSerialization">The member serialization.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonObjectAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonObjectAttribute" /> class with the specified container Id.
            </summary>
      <param name="id">The container Id.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonObjectAttribute.MemberSerialization">
      <summary>
            Gets or sets the member serialization.
            </summary>
      <value>The member serialization.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonObjectAttribute.ItemRequired">
      <summary>
            Gets or sets a value that indicates whether the object's properties are required.
            </summary>
      <value>
            	A value indicating whether the object's properties are required.
            </value>
    </member>
    <member name="T:Newtonsoft.Json.JsonSerializerSettings">
      <summary>
            Specifies the settings on a <see cref="T:Newtonsoft.Json.JsonSerializer" /> object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializerSettings.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> class.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.ReferenceLoopHandling">
      <summary>
            Gets or sets how reference loops (e.g. a class referencing itself) is handled.
            </summary>
      <value>Reference loop handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.MissingMemberHandling">
      <summary>
            Gets or sets how missing members (e.g. JSON contains a property that isn't a member on the object) are handled during deserialization.
            </summary>
      <value>Missing member handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.ObjectCreationHandling">
      <summary>
            Gets or sets how objects are created during deserialization.
            </summary>
      <value>The object creation handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.NullValueHandling">
      <summary>
            Gets or sets how null values are handled during serialization and deserialization.
            </summary>
      <value>Null value handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.DefaultValueHandling">
      <summary>
            Gets or sets how null default are handled during serialization and deserialization.
            </summary>
      <value>The default value handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.Converters">
      <summary>
            Gets or sets a collection <see cref="T:Newtonsoft.Json.JsonConverter" /> that will be used during serialization.
            </summary>
      <value>The converters.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.PreserveReferencesHandling">
      <summary>
            Gets or sets how object references are preserved by the serializer.
            </summary>
      <value>The preserve references handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.TypeNameHandling">
      <summary>
            Gets or sets how type name writing and reading is handled by the serializer.
            </summary>
      <value>The type name handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.MetadataPropertyHandling">
      <summary>
            Gets or sets how metadata properties are used during deserialization.
            </summary>
      <value>The metadata properties handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.TypeNameAssemblyFormat">
      <summary>
            Gets or sets how a type name assembly is written and resolved by the serializer.
            </summary>
      <value>The type name assembly format.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.ConstructorHandling">
      <summary>
            Gets or sets how constructors are used during deserialization.
            </summary>
      <value>The constructor handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.ContractResolver">
      <summary>
            Gets or sets the contract resolver used by the serializer when
            serializing .NET objects to JSON and vice versa.
            </summary>
      <value>The contract resolver.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.ReferenceResolver">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Serialization.IReferenceResolver" /> used by the serializer when resolving references.
            </summary>
      <value>The reference resolver.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.TraceWriter">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Serialization.ITraceWriter" /> used by the serializer when writing trace messages.
            </summary>
      <value>The trace writer.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.Binder">
      <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.SerializationBinder" /> used by the serializer when resolving type names.
            </summary>
      <value>The binder.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.Error">
      <summary>
            Gets or sets the error handler called during serialization and deserialization.
            </summary>
      <value>The error handler called during serialization and deserialization.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.Context">
      <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.StreamingContext" /> used by the serializer when invoking serialization callback methods.
            </summary>
      <value>The context.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.DateFormatString">
      <summary>
            Get or set how <see cref="T:System.DateTime" /> and <see cref="T:System.DateTimeOffset" /> values are formatting when writing JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.MaxDepth">
      <summary>
            Gets or sets the maximum depth allowed when reading JSON. Reading past this depth will throw a <see cref="T:Newtonsoft.Json.JsonReaderException" />.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.Formatting">
      <summary>
            Indicates how JSON text output is formatted.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.DateFormatHandling">
      <summary>
            Get or set how dates are written to JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.DateTimeZoneHandling">
      <summary>
            Get or set how <see cref="T:System.DateTime" /> time zones are handling during serialization and deserialization.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.DateParseHandling">
      <summary>
            Get or set how date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed when reading JSON.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.FloatFormatHandling">
      <summary>
            Get or set how special floating point numbers, e.g. <see cref="F:System.Double.NaN" />,
            <see cref="F:System.Double.PositiveInfinity" /> and <see cref="F:System.Double.NegativeInfinity" />,
            are written as JSON.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.FloatParseHandling">
      <summary>
            Get or set how floating point numbers, e.g. 1.0 and 9.9, are parsed when reading JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.StringEscapeHandling">
      <summary>
            Get or set how strings are escaped when writing JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.Culture">
      <summary>
            Gets or sets the culture used when reading JSON. Defaults to <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.CheckAdditionalContent">
      <summary>
            Gets a value indicating whether there will be a check for additional content after deserializing an object.
            </summary>
      <value>
        <c>true</c> if there will be a check for additional content after deserializing an object; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Newtonsoft.Json.JsonValidatingReader">
      <summary>
            Represents a reader that provides <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> validation.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonValidatingReader.#ctor(Newtonsoft.Json.JsonReader)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonValidatingReader" /> class that
            validates the content returned from the given <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from while validating.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonValidatingReader.ReadAsInt32">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonValidatingReader.ReadAsBytes">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:Byte[]" />.
            </summary>
      <returns>
            A <see cref="T:Byte[]" /> or a null reference if the next JSON token is null.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonValidatingReader.ReadAsDecimal">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonValidatingReader.ReadAsString">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.String" />.
            </summary>
      <returns>A <see cref="T:System.String" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonValidatingReader.ReadAsDateTime">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.String" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonValidatingReader.ReadAsDateTimeOffset">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonValidatingReader.Read">
      <summary>
            Reads the next JSON token from the stream.
            </summary>
      <returns>
            true if the next token was read successfully; false if there are no more tokens to read.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.JsonValidatingReader.Value">
      <summary>
            Gets the text value of the current JSON token.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonValidatingReader.Depth">
      <summary>
            Gets the depth of the current token in the JSON document.
            </summary>
      <value>The depth of the current token in the JSON document.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonValidatingReader.Path">
      <summary>
            Gets the path of the current JSON token. 
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonValidatingReader.QuoteChar">
      <summary>
            Gets the quotation mark character used to enclose the value of a string.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonValidatingReader.TokenType">
      <summary>
            Gets the type of the current JSON token.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonValidatingReader.ValueType">
      <summary>
            Gets the Common Language Runtime (CLR) type for the current JSON token.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonValidatingReader.Schema">
      <summary>
            Gets or sets the schema.
            </summary>
      <value>The schema.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonValidatingReader.Reader">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.JsonReader" /> used to construct this <see cref="T:Newtonsoft.Json.JsonValidatingReader" />.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.JsonReader" /> specified in the constructor.</value>
    </member>
    <member name="E:Newtonsoft.Json.JsonValidatingReader.ValidationEventHandler">
      <summary>
            Sets an event handler for receiving schema validation errors.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JTokenEqualityComparer">
      <summary>
            Compares tokens to determine whether they are equal.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenEqualityComparer.Equals(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Linq.JToken)">
      <summary>
            Determines whether the specified objects are equal.
            </summary>
      <param name="x">The first object of type <see cref="T:Newtonsoft.Json.Linq.JToken" /> to compare.</param>
      <param name="y">The second object of type <see cref="T:Newtonsoft.Json.Linq.JToken" /> to compare.</param>
      <returns>
            true if the specified objects are equal; otherwise, false.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenEqualityComparer.GetHashCode(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Returns a hash code for the specified object.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> for which a hash code is to be returned.</param>
      <returns>A hash code for the specified object.</returns>
      <exception cref="T:System.ArgumentNullException">The type of <paramref name="obj" /> is a reference type and <paramref name="obj" /> is null.</exception>
    </member>
    <member name="T:Newtonsoft.Json.MemberSerialization">
      <summary>
            Specifies the member serialization options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.MemberSerialization.OptOut">
      <summary>
            All public members are serialized by default. Members can be excluded using <see cref="T:Newtonsoft.Json.JsonIgnoreAttribute" /> or <see cref="T:System.NonSerializedAttribute" />.
            This is the default member serialization mode.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.MemberSerialization.OptIn">
      <summary>
            Only members must be marked with <see cref="T:Newtonsoft.Json.JsonPropertyAttribute" /> or <see cref="T:System.Runtime.Serialization.DataMemberAttribute" /> are serialized.
            This member serialization mode can also be set by marking the class with <see cref="T:System.Runtime.Serialization.DataContractAttribute" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.MemberSerialization.Fields">
      <summary>
            All public and private fields are serialized. Members can be excluded using <see cref="T:Newtonsoft.Json.JsonIgnoreAttribute" /> or <see cref="T:System.NonSerializedAttribute" />.
            This member serialization mode can also be set by marking the class with <see cref="T:System.SerializableAttribute" />
            and setting IgnoreSerializableAttribute on <see cref="T:Newtonsoft.Json.Serialization.DefaultContractResolver" /> to false.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.ObjectCreationHandling">
      <summary>
            Specifies how object creation is handled by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ObjectCreationHandling.Auto">
      <summary>
            Reuse existing objects, create new objects when needed.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ObjectCreationHandling.Reuse">
      <summary>
            Only reuse existing objects.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ObjectCreationHandling.Replace">
      <summary>
            Always create new objects.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Converters.IsoDateTimeConverter">
      <summary>
            Converts a <see cref="T:System.DateTime" /> to and from the ISO 8601 date format (e.g. 2008-04-12T12:53Z).
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.IsoDateTimeConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.IsoDateTimeConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="P:Newtonsoft.Json.Converters.IsoDateTimeConverter.DateTimeStyles">
      <summary>
            Gets or sets the date time styles used when converting a date to and from JSON.
            </summary>
      <value>The date time styles used when converting a date to and from JSON.</value>
    </member>
    <member name="P:Newtonsoft.Json.Converters.IsoDateTimeConverter.DateTimeFormat">
      <summary>
            Gets or sets the date time format used when converting a date to and from JSON.
            </summary>
      <value>The date time format used when converting a date to and from JSON.</value>
    </member>
    <member name="P:Newtonsoft.Json.Converters.IsoDateTimeConverter.Culture">
      <summary>
            Gets or sets the culture used when converting a date to and from JSON.
            </summary>
      <value>The culture used when converting a date to and from JSON.</value>
    </member>
    <member name="T:Newtonsoft.Json.Converters.JavaScriptDateTimeConverter">
      <summary>
            Converts a <see cref="T:System.DateTime" /> to and from a JavaScript date constructor (e.g. new Date(52231943)).
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.JavaScriptDateTimeConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.JavaScriptDateTimeConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing property value of the JSON that is being converted.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.XmlNodeConverter">
      <summary>
            Converts XML to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.XmlNodeConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="serializer">The calling serializer.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.XmlNodeConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.XmlNodeConverter.IsNamespaceAttribute(System.String,System.String@)">
      <summary>
            Checks if the attributeName is a namespace attribute.
            </summary>
      <param name="attributeName">Attribute name to test.</param>
      <param name="prefix">The attribute name prefix if it has one, otherwise an empty string.</param>
      <returns>True if attribute name is for a namespace attribute, otherwise false.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.XmlNodeConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified value type.
            </summary>
      <param name="valueType">Type of the value.</param>
      <returns>
        <c>true</c> if this instance can convert the specified value type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Converters.XmlNodeConverter.DeserializeRootElementName">
      <summary>
            Gets or sets the name of the root element to insert when deserializing to XML if the JSON structure has produces multiple root elements.
            </summary>
      <value>The name of the deserialize root element.</value>
    </member>
    <member name="P:Newtonsoft.Json.Converters.XmlNodeConverter.WriteArrayAttribute">
      <summary>
            Gets or sets a flag to indicate whether to write the Json.NET array attribute.
            This attribute helps preserve arrays when converting the written XML back to JSON.
            </summary>
      <value>
        <c>true</c> if the array attibute is written to the XML; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Newtonsoft.Json.Converters.XmlNodeConverter.OmitRootObject">
      <summary>
            Gets or sets a value indicating whether to write the root JSON object.
            </summary>
      <value>
        <c>true</c> if the JSON root object is omitted; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Newtonsoft.Json.JsonTextReader">
      <summary>
            Represents a reader that provides fast, non-cached, forward-only access to JSON text data.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.#ctor(System.IO.TextReader)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReader" /> class with the specified <see cref="T:System.IO.TextReader" />.
            </summary>
      <param name="reader">The <c>TextReader</c> containing the XML data to read.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.Read">
      <summary>
            Reads the next JSON token from the stream.
            </summary>
      <returns>
            true if the next token was read successfully; false if there are no more tokens to read.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.ReadAsBytes">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:Byte[]" />.
            </summary>
      <returns>
            A <see cref="T:Byte[]" /> or a null reference if the next JSON token is null. This method will return <c>null</c> at the end of an array.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.ReadAsDecimal">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.ReadAsInt32">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.ReadAsString">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.String" />.
            </summary>
      <returns>A <see cref="T:System.String" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.ReadAsDateTime">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.String" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.ReadAsDateTimeOffset">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.DateTimeOffset" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.Close">
      <summary>
            Changes the state to closed. 
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.HasLineInfo">
      <summary>
            Gets a value indicating whether the class can return line information.
            </summary>
      <returns>
        <c>true</c> if LineNumber and LinePosition can be provided; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.JsonTextReader.LineNumber">
      <summary>
            Gets the current line number.
            </summary>
      <value>
            The current line number or 0 if no line information is available (for example, HasLineInfo returns false).
            </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonTextReader.LinePosition">
      <summary>
            Gets the current line position.
            </summary>
      <value>
            The current line position or 0 if no line information is available (for example, HasLineInfo returns false).
            </value>
    </member>
    <member name="T:Newtonsoft.Json.JsonPropertyAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> to always serialize the member with the specified name.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonPropertyAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonPropertyAttribute" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonPropertyAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonPropertyAttribute" /> class with the specified name.
            </summary>
      <param name="propertyName">Name of the property.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.ItemConverterType">
      <summary>
            Gets or sets the converter used when serializing the property's collection items.
            </summary>
      <value>The collection's items converter.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.NullValueHandling">
      <summary>
            Gets or sets the null value handling used when serializing this property.
            </summary>
      <value>The null value handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.DefaultValueHandling">
      <summary>
            Gets or sets the default value handling used when serializing this property.
            </summary>
      <value>The default value handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.ReferenceLoopHandling">
      <summary>
            Gets or sets the reference loop handling used when serializing this property.
            </summary>
      <value>The reference loop handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.ObjectCreationHandling">
      <summary>
            Gets or sets the object creation handling used when deserializing this property.
            </summary>
      <value>The object creation handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.TypeNameHandling">
      <summary>
            Gets or sets the type name handling used when serializing this property.
            </summary>
      <value>The type name handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.IsReference">
      <summary>
            Gets or sets whether this property's value is serialized as a reference.
            </summary>
      <value>Whether this property's value is serialized as a reference.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.Order">
      <summary>
            Gets or sets the order of serialization and deserialization of a member.
            </summary>
      <value>The numeric order of serialization or deserialization.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.Required">
      <summary>
            Gets or sets a value indicating whether this property is required.
            </summary>
      <value>
            	A value indicating whether this property is required.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.PropertyName">
      <summary>
            Gets or sets the name of the property.
            </summary>
      <value>The name of the property.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.ItemReferenceLoopHandling">
      <summary>
            Gets or sets the the reference loop handling used when serializing the property's collection items.
            </summary>
      <value>The collection's items reference loop handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.ItemTypeNameHandling">
      <summary>
            Gets or sets the the type name handling used when serializing the property's collection items.
            </summary>
      <value>The collection's items type name handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.ItemIsReference">
      <summary>
            Gets or sets whether this property's collection items are serialized as a reference.
            </summary>
      <value>Whether this property's collection items are serialized as a reference.</value>
    </member>
    <member name="T:Newtonsoft.Json.JsonIgnoreAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> not to serialize the public field or public read/write property value.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonTextWriter">
      <summary>
            Represents a writer that provides a fast, non-cached, forward-only way of generating Json data.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.#ctor(System.IO.TextWriter)">
      <summary>
            Creates an instance of the <c>JsonWriter</c> class using the specified <see cref="T:System.IO.TextWriter" />. 
            </summary>
      <param name="textWriter">The <c>TextWriter</c> to write to.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.Flush">
      <summary>
            Flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.Close">
      <summary>
            Closes this stream and the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteStartObject">
      <summary>
            Writes the beginning of a Json object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteStartArray">
      <summary>
            Writes the beginning of a Json array.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteStartConstructor(System.String)">
      <summary>
            Writes the start of a constructor with the given name.
            </summary>
      <param name="name">The name of the constructor.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteEnd(Newtonsoft.Json.JsonToken)">
      <summary>
            Writes the specified end token.
            </summary>
      <param name="token">The end token to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WritePropertyName(System.String)">
      <summary>
            Writes the property name of a name/value pair on a Json object.
            </summary>
      <param name="name">The name of the property.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WritePropertyName(System.String,System.Boolean)">
      <summary>
            Writes the property name of a name/value pair on a JSON object.
            </summary>
      <param name="name">The name of the property.</param>
      <param name="escape">A flag to indicate whether the text should be escaped when it is written as a JSON property name.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteIndent">
      <summary>
            Writes indent characters.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValueDelimiter">
      <summary>
            Writes the JSON value delimiter.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteIndentSpace">
      <summary>
            Writes an indent space.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Object)">
      <summary>
            Writes a <see cref="T:System.Object" /> value.
            An error will raised if the value cannot be written as a single JSON token.
            </summary>
      <param name="value">The <see cref="T:System.Object" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteNull">
      <summary>
            Writes a null value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteUndefined">
      <summary>
            Writes an undefined value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteRaw(System.String)">
      <summary>
            Writes raw JSON.
            </summary>
      <param name="json">The raw JSON to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.String)">
      <summary>
            Writes a <see cref="T:System.String" /> value.
            </summary>
      <param name="value">The <see cref="T:System.String" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Int32)">
      <summary>
            Writes a <see cref="T:System.Int32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.UInt32)">
      <summary>
            Writes a <see cref="T:System.UInt32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Int64)">
      <summary>
            Writes a <see cref="T:System.Int64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.UInt64)">
      <summary>
            Writes a <see cref="T:System.UInt64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Single)">
      <summary>
            Writes a <see cref="T:System.Single" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Single" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Nullable{System.Single})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Double)">
      <summary>
            Writes a <see cref="T:System.Double" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Double" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Nullable{System.Double})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Boolean)">
      <summary>
            Writes a <see cref="T:System.Boolean" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Boolean" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Int16)">
      <summary>
            Writes a <see cref="T:System.Int16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.UInt16)">
      <summary>
            Writes a <see cref="T:System.UInt16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Char)">
      <summary>
            Writes a <see cref="T:System.Char" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Byte)">
      <summary>
            Writes a <see cref="T:System.Byte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Byte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.SByte)">
      <summary>
            Writes a <see cref="T:System.SByte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.SByte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Decimal)">
      <summary>
            Writes a <see cref="T:System.Decimal" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Decimal" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.DateTime)">
      <summary>
            Writes a <see cref="T:System.DateTime" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTime" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Byte[])">
      <summary>
            Writes a <see cref="T:Byte[]" /> value.
            </summary>
      <param name="value">The <see cref="T:Byte[]" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.DateTimeOffset)">
      <summary>
            Writes a <see cref="T:System.DateTimeOffset" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTimeOffset" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Guid)">
      <summary>
            Writes a <see cref="T:System.Guid" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Guid" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.TimeSpan)">
      <summary>
            Writes a <see cref="T:System.TimeSpan" /> value.
            </summary>
      <param name="value">The <see cref="T:System.TimeSpan" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Uri)">
      <summary>
            Writes a <see cref="T:System.Uri" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Uri" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteComment(System.String)">
      <summary>
            Writes out a comment <code>/*...*/</code> containing the specified text. 
            </summary>
      <param name="text">Text to place inside the comment.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteWhitespace(System.String)">
      <summary>
            Writes out the given white space.
            </summary>
      <param name="ws">The string of white space characters.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonTextWriter.Indentation">
      <summary>
            Gets or sets how many IndentChars to write for each level in the hierarchy when <see cref="T:Newtonsoft.Json.Formatting" /> is set to <c>Formatting.Indented</c>.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonTextWriter.QuoteChar">
      <summary>
            Gets or sets which character to use to quote attribute values.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonTextWriter.IndentChar">
      <summary>
            Gets or sets which character to use for indenting when <see cref="T:Newtonsoft.Json.Formatting" /> is set to <c>Formatting.Indented</c>.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonTextWriter.QuoteName">
      <summary>
            Gets or sets a value indicating whether object names will be surrounded with quotes.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonWriterException">
      <summary>
            The exception thrown when an error occurs while reading Json text.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriterException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonWriterException" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriterException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonWriterException" /> class
            with a specified error message.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriterException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonWriterException" /> class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriterException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonWriterException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriterException.Path">
      <summary>
            Gets the path to the JSON where the error occurred.
            </summary>
      <value>The path to the JSON where the error occurred.</value>
    </member>
    <member name="T:Newtonsoft.Json.JsonReaderException">
      <summary>
            The exception thrown when an error occurs while reading Json text.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonReaderException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReaderException" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonReaderException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReaderException" /> class
            with a specified error message.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonReaderException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReaderException" /> class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonReaderException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReaderException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="P:Newtonsoft.Json.JsonReaderException.LineNumber">
      <summary>
            Gets the line number indicating where the error occurred.
            </summary>
      <value>The line number indicating where the error occurred.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonReaderException.LinePosition">
      <summary>
            Gets the line position indicating where the error occurred.
            </summary>
      <value>The line position indicating where the error occurred.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonReaderException.Path">
      <summary>
            Gets the path to the JSON where the error occurred.
            </summary>
      <value>The path to the JSON where the error occurred.</value>
    </member>
    <member name="T:Newtonsoft.Json.JsonConverterCollection">
      <summary>
            Represents a collection of <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonConvert">
      <summary>
            Provides methods for converting between common language runtime types and JSON types.
            </summary>
      <example>
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="SerializeObject" title="Serializing and Deserializing JSON with JsonConvert" />
      </example>
    </member>
    <member name="F:Newtonsoft.Json.JsonConvert.True">
      <summary>
            Represents JavaScript's boolean value true as a string. This field is read-only.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonConvert.False">
      <summary>
            Represents JavaScript's boolean value false as a string. This field is read-only.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonConvert.Null">
      <summary>
            Represents JavaScript's null as a string. This field is read-only.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonConvert.Undefined">
      <summary>
            Represents JavaScript's undefined as a string. This field is read-only.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonConvert.PositiveInfinity">
      <summary>
            Represents JavaScript's positive infinity as a string. This field is read-only.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonConvert.NegativeInfinity">
      <summary>
            Represents JavaScript's negative infinity as a string. This field is read-only.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonConvert.NaN">
      <summary>
            Represents JavaScript's NaN as a string. This field is read-only.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.DateTime)">
      <summary>
            Converts the <see cref="T:System.DateTime" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.DateTime" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.DateTime,Newtonsoft.Json.DateFormatHandling,Newtonsoft.Json.DateTimeZoneHandling)">
      <summary>
            Converts the <see cref="T:System.DateTime" /> to its JSON string representation using the <see cref="T:Newtonsoft.Json.DateFormatHandling" /> specified.
            </summary>
      <param name="value">The value to convert.</param>
      <param name="format">The format the date will be converted to.</param>
      <param name="timeZoneHandling">The time zone handling when the date is converted to a string.</param>
      <returns>A JSON string representation of the <see cref="T:System.DateTime" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.DateTimeOffset)">
      <summary>
            Converts the <see cref="T:System.DateTimeOffset" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.DateTimeOffset" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.DateTimeOffset,Newtonsoft.Json.DateFormatHandling)">
      <summary>
            Converts the <see cref="T:System.DateTimeOffset" /> to its JSON string representation using the <see cref="T:Newtonsoft.Json.DateFormatHandling" /> specified.
            </summary>
      <param name="value">The value to convert.</param>
      <param name="format">The format the date will be converted to.</param>
      <returns>A JSON string representation of the <see cref="T:System.DateTimeOffset" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Boolean)">
      <summary>
            Converts the <see cref="T:System.Boolean" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Char)">
      <summary>
            Converts the <see cref="T:System.Char" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Char" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Enum)">
      <summary>
            Converts the <see cref="T:System.Enum" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Enum" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Int32)">
      <summary>
            Converts the <see cref="T:System.Int32" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Int16)">
      <summary>
            Converts the <see cref="T:System.Int16" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.UInt16)">
      <summary>
            Converts the <see cref="T:System.UInt16" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.UInt16" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.UInt32)">
      <summary>
            Converts the <see cref="T:System.UInt32" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Int64)">
      <summary>
            Converts the <see cref="T:System.Int64" />  to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.UInt64)">
      <summary>
            Converts the <see cref="T:System.UInt64" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Single)">
      <summary>
            Converts the <see cref="T:System.Single" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Single" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Double)">
      <summary>
            Converts the <see cref="T:System.Double" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Double" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Byte)">
      <summary>
            Converts the <see cref="T:System.Byte" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Byte" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.SByte)">
      <summary>
            Converts the <see cref="T:System.SByte" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.SByte" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Decimal)">
      <summary>
            Converts the <see cref="T:System.Decimal" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.SByte" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Guid)">
      <summary>
            Converts the <see cref="T:System.Guid" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.TimeSpan)">
      <summary>
            Converts the <see cref="T:System.TimeSpan" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.TimeSpan" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Uri)">
      <summary>
            Converts the <see cref="T:System.Uri" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Uri" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.String)">
      <summary>
            Converts the <see cref="T:System.String" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.String,System.Char)">
      <summary>
            Converts the <see cref="T:System.String" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <param name="delimiter">The string delimiter character.</param>
      <returns>A JSON string representation of the <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Object)">
      <summary>
            Converts the <see cref="T:System.Object" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Object" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object)">
      <summary>
            Serializes the specified object to a JSON string.
            </summary>
      <param name="value">The object to serialize.</param>
      <returns>A JSON string representation of the object.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft.Json.Formatting)">
      <summary>
            Serializes the specified object to a JSON string using formatting.
            </summary>
      <param name="value">The object to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <returns>
            A JSON string representation of the object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Serializes the specified object to a JSON string using a collection of <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
      <param name="value">The object to serialize.</param>
      <param name="converters">A collection converters used while serializing.</param>
      <returns>A JSON string representation of the object.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft.Json.Formatting,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Serializes the specified object to a JSON string using formatting and a collection of <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
      <param name="value">The object to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <param name="converters">A collection converters used while serializing.</param>
      <returns>A JSON string representation of the object.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Serializes the specified object to a JSON string using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
      <param name="value">The object to serialize.</param>
      <param name="settings">The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to serialize the object.
            If this is null, default serialization settings will be used.</param>
      <returns>
            A JSON string representation of the object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,System.Type,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Serializes the specified object to a JSON string using a type, formatting and <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
      <param name="value">The object to serialize.</param>
      <param name="settings">The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to serialize the object.
            If this is null, default serialization settings will be used.</param>
      <param name="type">
            The type of the value being serialized.
            This parameter is used when <see cref="T:Newtonsoft.Json.TypeNameHandling" /> is Auto to write out the type name if the type of the value does not match.
            Specifing the type is optional.
            </param>
      <returns>
            A JSON string representation of the object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft.Json.Formatting,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Serializes the specified object to a JSON string using formatting and <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
      <param name="value">The object to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <param name="settings">The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to serialize the object.
            If this is null, default serialization settings will be used.</param>
      <returns>
            A JSON string representation of the object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,System.Type,Newtonsoft.Json.Formatting,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Serializes the specified object to a JSON string using a type, formatting and <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
      <param name="value">The object to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <param name="settings">The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to serialize the object.
            If this is null, default serialization settings will be used.</param>
      <param name="type">
            The type of the value being serialized.
            This parameter is used when <see cref="T:Newtonsoft.Json.TypeNameHandling" /> is Auto to write out the type name if the type of the value does not match.
            Specifing the type is optional.
            </param>
      <returns>
            A JSON string representation of the object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObjectAsync(System.Object)">
      <summary>
            Asynchronously serializes the specified object to a JSON string.
            Serialization will happen on a new thread.
            </summary>
      <param name="value">The object to serialize.</param>
      <returns>
            A task that represents the asynchronous serialize operation. The value of the <c>TResult</c> parameter contains a JSON string representation of the object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObjectAsync(System.Object,Newtonsoft.Json.Formatting)">
      <summary>
            Asynchronously serializes the specified object to a JSON string using formatting.
            Serialization will happen on a new thread.
            </summary>
      <param name="value">The object to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <returns>
            A task that represents the asynchronous serialize operation. The value of the <c>TResult</c> parameter contains a JSON string representation of the object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObjectAsync(System.Object,Newtonsoft.Json.Formatting,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Asynchronously serializes the specified object to a JSON string using formatting and a collection of <see cref="T:Newtonsoft.Json.JsonConverter" />.
            Serialization will happen on a new thread.
            </summary>
      <param name="value">The object to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <param name="settings">The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to serialize the object.
            If this is null, default serialization settings will be used.</param>
      <returns>
            A task that represents the asynchronous serialize operation. The value of the <c>TResult</c> parameter contains a JSON string representation of the object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject(System.String)">
      <summary>
            Deserializes the JSON to a .NET object.
            </summary>
      <param name="value">The JSON to deserialize.</param>
      <returns>The deserialized object from the JSON string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject(System.String,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Deserializes the JSON to a .NET object using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
      <param name="value">The JSON to deserialize.</param>
      <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is null, default serialization settings will be used.
            </param>
      <returns>The deserialized object from the JSON string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject(System.String,System.Type)">
      <summary>
            Deserializes the JSON to the specified .NET type.
            </summary>
      <param name="value">The JSON to deserialize.</param>
      <param name="type">The <see cref="T:System.Type" /> of object being deserialized.</param>
      <returns>The deserialized object from the JSON string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject``1(System.String)">
      <summary>
            Deserializes the JSON to the specified .NET type.
            </summary>
      <typeparam name="T">The type of the object to deserialize to.</typeparam>
      <param name="value">The JSON to deserialize.</param>
      <returns>The deserialized object from the JSON string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeAnonymousType``1(System.String,``0)">
      <summary>
            Deserializes the JSON to the given anonymous type.
            </summary>
      <typeparam name="T">
            The anonymous type to deserialize to. This can't be specified
            traditionally and must be infered from the anonymous type passed
            as a parameter.
            </typeparam>
      <param name="value">The JSON to deserialize.</param>
      <param name="anonymousTypeObject">The anonymous type object.</param>
      <returns>The deserialized anonymous type from the JSON string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeAnonymousType``1(System.String,``0,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Deserializes the JSON to the given anonymous type using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
      <typeparam name="T">
            The anonymous type to deserialize to. This can't be specified
            traditionally and must be infered from the anonymous type passed
            as a parameter.
            </typeparam>
      <param name="value">The JSON to deserialize.</param>
      <param name="anonymousTypeObject">The anonymous type object.</param>
      <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is null, default serialization settings will be used.
            </param>
      <returns>The deserialized anonymous type from the JSON string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject``1(System.String,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Deserializes the JSON to the specified .NET type using a collection of <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
      <typeparam name="T">The type of the object to deserialize to.</typeparam>
      <param name="value">The JSON to deserialize.</param>
      <param name="converters">Converters to use while deserializing.</param>
      <returns>The deserialized object from the JSON string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject``1(System.String,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Deserializes the JSON to the specified .NET type using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
      <typeparam name="T">The type of the object to deserialize to.</typeparam>
      <param name="value">The object to deserialize.</param>
      <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is null, default serialization settings will be used.
            </param>
      <returns>The deserialized object from the JSON string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject(System.String,System.Type,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Deserializes the JSON to the specified .NET type using a collection of <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
      <param name="value">The JSON to deserialize.</param>
      <param name="type">The type of the object to deserialize.</param>
      <param name="converters">Converters to use while deserializing.</param>
      <returns>The deserialized object from the JSON string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject(System.String,System.Type,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Deserializes the JSON to the specified .NET type using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
      <param name="value">The JSON to deserialize.</param>
      <param name="type">The type of the object to deserialize to.</param>
      <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is null, default serialization settings will be used.
            </param>
      <returns>The deserialized object from the JSON string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObjectAsync``1(System.String)">
      <summary>
            Asynchronously deserializes the JSON to the specified .NET type.
            Deserialization will happen on a new thread.
            </summary>
      <typeparam name="T">The type of the object to deserialize to.</typeparam>
      <param name="value">The JSON to deserialize.</param>
      <returns>
            A task that represents the asynchronous deserialize operation. The value of the <c>TResult</c> parameter contains the deserialized object from the JSON string.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObjectAsync``1(System.String,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Asynchronously deserializes the JSON to the specified .NET type using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            Deserialization will happen on a new thread.
            </summary>
      <typeparam name="T">The type of the object to deserialize to.</typeparam>
      <param name="value">The JSON to deserialize.</param>
      <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is null, default serialization settings will be used.
            </param>
      <returns>
            A task that represents the asynchronous deserialize operation. The value of the <c>TResult</c> parameter contains the deserialized object from the JSON string.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObjectAsync(System.String)">
      <summary>
            Asynchronously deserializes the JSON to the specified .NET type.
            Deserialization will happen on a new thread.
            </summary>
      <param name="value">The JSON to deserialize.</param>
      <returns>
            A task that represents the asynchronous deserialize operation. The value of the <c>TResult</c> parameter contains the deserialized object from the JSON string.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObjectAsync(System.String,System.Type,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Asynchronously deserializes the JSON to the specified .NET type using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            Deserialization will happen on a new thread.
            </summary>
      <param name="value">The JSON to deserialize.</param>
      <param name="type">The type of the object to deserialize to.</param>
      <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is null, default serialization settings will be used.
            </param>
      <returns>
            A task that represents the asynchronous deserialize operation. The value of the <c>TResult</c> parameter contains the deserialized object from the JSON string.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.PopulateObject(System.String,System.Object)">
      <summary>
            Populates the object with values from the JSON string.
            </summary>
      <param name="value">The JSON to populate values from.</param>
      <param name="target">The target object to populate values onto.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.PopulateObject(System.String,System.Object,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Populates the object with values from the JSON string using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
      <param name="value">The JSON to populate values from.</param>
      <param name="target">The target object to populate values onto.</param>
      <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is null, default serialization settings will be used.
            </param>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.PopulateObjectAsync(System.String,System.Object,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Asynchronously populates the object with values from the JSON string using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
      <param name="value">The JSON to populate values from.</param>
      <param name="target">The target object to populate values onto.</param>
      <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is null, default serialization settings will be used.
            </param>
      <returns>
            A task that represents the asynchronous populate operation.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeXmlNode(System.Xml.XmlNode)">
      <summary>
            Serializes the XML node to a JSON string.
            </summary>
      <param name="node">The node to serialize.</param>
      <returns>A JSON string of the XmlNode.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeXmlNode(System.Xml.XmlNode,Newtonsoft.Json.Formatting)">
      <summary>
            Serializes the XML node to a JSON string using formatting.
            </summary>
      <param name="node">The node to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <returns>A JSON string of the XmlNode.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeXmlNode(System.Xml.XmlNode,Newtonsoft.Json.Formatting,System.Boolean)">
      <summary>
            Serializes the XML node to a JSON string using formatting and omits the root object if <paramref name="omitRootObject" /> is <c>true</c>.
            </summary>
      <param name="node">The node to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <param name="omitRootObject">Omits writing the root object.</param>
      <returns>A JSON string of the XmlNode.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXmlNode(System.String)">
      <summary>
            Deserializes the XmlNode from a JSON string.
            </summary>
      <param name="value">The JSON string.</param>
      <returns>The deserialized XmlNode</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXmlNode(System.String,System.String)">
      <summary>
            Deserializes the XmlNode from a JSON string nested in a root elment specified by <paramref name="deserializeRootElementName" />.
            </summary>
      <param name="value">The JSON string.</param>
      <param name="deserializeRootElementName">The name of the root element to append when deserializing.</param>
      <returns>The deserialized XmlNode</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXmlNode(System.String,System.String,System.Boolean)">
      <summary>
            Deserializes the XmlNode from a JSON string nested in a root elment specified by <paramref name="deserializeRootElementName" />
            and writes a .NET array attribute for collections.
            </summary>
      <param name="value">The JSON string.</param>
      <param name="deserializeRootElementName">The name of the root element to append when deserializing.</param>
      <param name="writeArrayAttribute">
            A flag to indicate whether to write the Json.NET array attribute.
            This attribute helps preserve arrays when converting the written XML back to JSON.
            </param>
      <returns>The deserialized XmlNode</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeXNode(System.Xml.Linq.XObject)">
      <summary>
            Serializes the <see cref="T:System.Xml.Linq.XNode" /> to a JSON string.
            </summary>
      <param name="node">The node to convert to JSON.</param>
      <returns>A JSON string of the XNode.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeXNode(System.Xml.Linq.XObject,Newtonsoft.Json.Formatting)">
      <summary>
            Serializes the <see cref="T:System.Xml.Linq.XNode" /> to a JSON string using formatting.
            </summary>
      <param name="node">The node to convert to JSON.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <returns>A JSON string of the XNode.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeXNode(System.Xml.Linq.XObject,Newtonsoft.Json.Formatting,System.Boolean)">
      <summary>
            Serializes the <see cref="T:System.Xml.Linq.XNode" /> to a JSON string using formatting and omits the root object if <paramref name="omitRootObject" /> is <c>true</c>.
            </summary>
      <param name="node">The node to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <param name="omitRootObject">Omits writing the root object.</param>
      <returns>A JSON string of the XNode.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXNode(System.String)">
      <summary>
            Deserializes the <see cref="T:System.Xml.Linq.XNode" /> from a JSON string.
            </summary>
      <param name="value">The JSON string.</param>
      <returns>The deserialized XNode</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXNode(System.String,System.String)">
      <summary>
            Deserializes the <see cref="T:System.Xml.Linq.XNode" /> from a JSON string nested in a root elment specified by <paramref name="deserializeRootElementName" />.
            </summary>
      <param name="value">The JSON string.</param>
      <param name="deserializeRootElementName">The name of the root element to append when deserializing.</param>
      <returns>The deserialized XNode</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXNode(System.String,System.String,System.Boolean)">
      <summary>
            Deserializes the <see cref="T:System.Xml.Linq.XNode" /> from a JSON string nested in a root elment specified by <paramref name="deserializeRootElementName" />
            and writes a .NET array attribute for collections.
            </summary>
      <param name="value">The JSON string.</param>
      <param name="deserializeRootElementName">The name of the root element to append when deserializing.</param>
      <param name="writeArrayAttribute">
            A flag to indicate whether to write the Json.NET array attribute.
            This attribute helps preserve arrays when converting the written XML back to JSON.
            </param>
      <returns>The deserialized XNode</returns>
    </member>
    <member name="P:Newtonsoft.Json.JsonConvert.DefaultSettings">
      <summary>
            Gets or sets a function that creates default <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            Default settings are automatically used by serialization methods on <see cref="T:Newtonsoft.Json.JsonConvert" />,
            and <see cref="M:Newtonsoft.Json.Linq.JToken.ToObject``1" /> and <see cref="M:Newtonsoft.Json.Linq.JToken.FromObject(System.Object)" /> on <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            To serialize without using any default settings create a <see cref="T:Newtonsoft.Json.JsonSerializer" /> with
            <see cref="M:Newtonsoft.Json.JsonSerializer.Create" />.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonSerializationException">
      <summary>
            The exception thrown when an error occurs during Json serialization or deserialization.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializationException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializationException" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializationException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializationException" /> class
            with a specified error message.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializationException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializationException" /> class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializationException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="T:Newtonsoft.Json.JsonSerializer">
      <summary>
            Serializes and deserializes objects into and from the JSON format.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> enables you to control how objects are encoded into JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializer" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Create">
      <summary>
            Creates a new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will not use default settings.
            </summary>
      <returns>
            A new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will not use default settings.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Create(Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Creates a new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance using the specified <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will not use default settings.
            </summary>
      <param name="settings">The settings to be applied to the <see cref="T:Newtonsoft.Json.JsonSerializer" />.</param>
      <returns>
            A new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance using the specified <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will not use default settings.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.CreateDefault">
      <summary>
            Creates a new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will use default settings.
            </summary>
      <returns>
            A new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will use default settings.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.CreateDefault(Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Creates a new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance using the specified <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will use default settings.
            </summary>
      <param name="settings">The settings to be applied to the <see cref="T:Newtonsoft.Json.JsonSerializer" />.</param>
      <returns>
            A new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance using the specified <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will use default settings.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Populate(System.IO.TextReader,System.Object)">
      <summary>
            Populates the JSON values onto the target object.
            </summary>
      <param name="reader">The <see cref="T:System.IO.TextReader" /> that contains the JSON structure to reader values from.</param>
      <param name="target">The target object to populate values onto.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Populate(Newtonsoft.Json.JsonReader,System.Object)">
      <summary>
            Populates the JSON values onto the target object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> that contains the JSON structure to reader values from.</param>
      <param name="target">The target object to populate values onto.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Deserialize(Newtonsoft.Json.JsonReader)">
      <summary>
            Deserializes the Json structure contained by the specified <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> that contains the JSON structure to deserialize.</param>
      <returns>The <see cref="T:System.Object" /> being deserialized.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Deserialize(System.IO.TextReader,System.Type)">
      <summary>
            Deserializes the Json structure contained by the specified <see cref="T:System.IO.StringReader" />
            into an instance of the specified type.
            </summary>
      <param name="reader">The <see cref="T:System.IO.TextReader" /> containing the object.</param>
      <param name="objectType">The <see cref="T:System.Type" /> of object being deserialized.</param>
      <returns>The instance of <paramref name="objectType" /> being deserialized.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Deserialize``1(Newtonsoft.Json.JsonReader)">
      <summary>
            Deserializes the Json structure contained by the specified <see cref="T:Newtonsoft.Json.JsonReader" />
            into an instance of the specified type.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> containing the object.</param>
      <typeparam name="T">The type of the object to deserialize.</typeparam>
      <returns>The instance of <typeparamref name="T" /> being deserialized.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Deserialize(Newtonsoft.Json.JsonReader,System.Type)">
      <summary>
            Deserializes the Json structure contained by the specified <see cref="T:Newtonsoft.Json.JsonReader" />
            into an instance of the specified type.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> containing the object.</param>
      <param name="objectType">The <see cref="T:System.Type" /> of object being deserialized.</param>
      <returns>The instance of <paramref name="objectType" /> being deserialized.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Serialize(System.IO.TextWriter,System.Object)">
      <summary>
            Serializes the specified <see cref="T:System.Object" /> and writes the Json structure
            to a <c>Stream</c> using the specified <see cref="T:System.IO.TextWriter" />. 
            </summary>
      <param name="textWriter">The <see cref="T:System.IO.TextWriter" /> used to write the Json structure.</param>
      <param name="value">The <see cref="T:System.Object" /> to serialize.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Serialize(Newtonsoft.Json.JsonWriter,System.Object,System.Type)">
      <summary>
            Serializes the specified <see cref="T:System.Object" /> and writes the Json structure
            to a <c>Stream</c> using the specified <see cref="T:System.IO.TextWriter" />. 
            </summary>
      <param name="jsonWriter">The <see cref="T:Newtonsoft.Json.JsonWriter" /> used to write the Json structure.</param>
      <param name="value">The <see cref="T:System.Object" /> to serialize.</param>
      <param name="objectType">
            The type of the value being serialized.
            This parameter is used when <see cref="P:Newtonsoft.Json.JsonSerializer.TypeNameHandling" /> is Auto to write out the type name if the type of the value does not match.
            Specifing the type is optional.
            </param>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Serialize(System.IO.TextWriter,System.Object,System.Type)">
      <summary>
            Serializes the specified <see cref="T:System.Object" /> and writes the Json structure
            to a <c>Stream</c> using the specified <see cref="T:System.IO.TextWriter" />. 
            </summary>
      <param name="textWriter">The <see cref="T:System.IO.TextWriter" /> used to write the Json structure.</param>
      <param name="value">The <see cref="T:System.Object" /> to serialize.</param>
      <param name="objectType">
            The type of the value being serialized.
            This parameter is used when <see cref="P:Newtonsoft.Json.JsonSerializer.TypeNameHandling" /> is Auto to write out the type name if the type of the value does not match.
            Specifing the type is optional.
            </param>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Serialize(Newtonsoft.Json.JsonWriter,System.Object)">
      <summary>
            Serializes the specified <see cref="T:System.Object" /> and writes the Json structure
            to a <c>Stream</c> using the specified <see cref="T:Newtonsoft.Json.JsonWriter" />. 
            </summary>
      <param name="jsonWriter">The <see cref="T:Newtonsoft.Json.JsonWriter" /> used to write the Json structure.</param>
      <param name="value">The <see cref="T:System.Object" /> to serialize.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.ReferenceResolver">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Serialization.IReferenceResolver" /> used by the serializer when resolving references.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.Binder">
      <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.SerializationBinder" /> used by the serializer when resolving type names.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.TraceWriter">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Serialization.ITraceWriter" /> used by the serializer when writing trace messages.
            </summary>
      <value>The trace writer.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.TypeNameHandling">
      <summary>
            Gets or sets how type name writing and reading is handled by the serializer.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.TypeNameAssemblyFormat">
      <summary>
            Gets or sets how a type name assembly is written and resolved by the serializer.
            </summary>
      <value>The type name assembly format.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.PreserveReferencesHandling">
      <summary>
            Gets or sets how object references are preserved by the serializer.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.ReferenceLoopHandling">
      <summary>
            Get or set how reference loops (e.g. a class referencing itself) is handled.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.MissingMemberHandling">
      <summary>
            Get or set how missing members (e.g. JSON contains a property that isn't a member on the object) are handled during deserialization.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.NullValueHandling">
      <summary>
            Get or set how null values are handled during serialization and deserialization.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.DefaultValueHandling">
      <summary>
            Get or set how null default are handled during serialization and deserialization.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.ObjectCreationHandling">
      <summary>
            Gets or sets how objects are created during deserialization.
            </summary>
      <value>The object creation handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.ConstructorHandling">
      <summary>
            Gets or sets how constructors are used during deserialization.
            </summary>
      <value>The constructor handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.MetadataPropertyHandling">
      <summary>
            Gets or sets how metadata properties are used during deserialization.
            </summary>
      <value>The metadata properties handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.Converters">
      <summary>
            Gets a collection <see cref="T:Newtonsoft.Json.JsonConverter" /> that will be used during serialization.
            </summary>
      <value>Collection <see cref="T:Newtonsoft.Json.JsonConverter" /> that will be used during serialization.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.ContractResolver">
      <summary>
            Gets or sets the contract resolver used by the serializer when
            serializing .NET objects to JSON and vice versa.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.Context">
      <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.StreamingContext" /> used by the serializer when invoking serialization callback methods.
            </summary>
      <value>The context.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.Formatting">
      <summary>
            Indicates how JSON text output is formatted.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.DateFormatHandling">
      <summary>
            Get or set how dates are written to JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.DateTimeZoneHandling">
      <summary>
            Get or set how <see cref="T:System.DateTime" /> time zones are handling during serialization and deserialization.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.DateParseHandling">
      <summary>
            Get or set how date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed when reading JSON.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.FloatParseHandling">
      <summary>
            Get or set how floating point numbers, e.g. 1.0 and 9.9, are parsed when reading JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.FloatFormatHandling">
      <summary>
            Get or set how special floating point numbers, e.g. <see cref="F:System.Double.NaN" />,
            <see cref="F:System.Double.PositiveInfinity" /> and <see cref="F:System.Double.NegativeInfinity" />,
            are written as JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.StringEscapeHandling">
      <summary>
            Get or set how strings are escaped when writing JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.DateFormatString">
      <summary>
            Get or set how <see cref="T:System.DateTime" /> and <see cref="T:System.DateTimeOffset" /> values are formatting when writing JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.Culture">
      <summary>
            Gets or sets the culture used when reading JSON. Defaults to <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.MaxDepth">
      <summary>
            Gets or sets the maximum depth allowed when reading JSON. Reading past this depth will throw a <see cref="T:Newtonsoft.Json.JsonReaderException" />.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.CheckAdditionalContent">
      <summary>
            Gets a value indicating whether there will be a check for additional JSON content after deserializing an object.
            </summary>
      <value>
        <c>true</c> if there will be a check for additional JSON content after deserializing an object; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="E:Newtonsoft.Json.JsonSerializer.Error">
      <summary>
            Occurs when the <see cref="T:Newtonsoft.Json.JsonSerializer" /> errors during serialization and deserialization.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Linq.Extensions">
      <summary>
            Contains the LINQ to JSON extension methods.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Ancestors``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns a collection of tokens that contains the ancestors of every token in the source collection.
            </summary>
      <typeparam name="T">The type of the objects in source, constrained to <see cref="T:Newtonsoft.Json.Linq.JToken" />.</typeparam>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the ancestors of every node in the source collection.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Descendants``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns a collection of tokens that contains the descendants of every token in the source collection.
            </summary>
      <typeparam name="T">The type of the objects in source, constrained to <see cref="T:Newtonsoft.Json.Linq.JContainer" />.</typeparam>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the descendants of every node in the source collection.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Properties(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JObject})">
      <summary>
            Returns a collection of child properties of every object in the source collection.
            </summary>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JObject" /> that contains the source collection.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JProperty" /> that contains the properties of every object in the source collection.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Values(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken},System.Object)">
      <summary>
            Returns a collection of child values of every object in the source collection with the given key.
            </summary>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <param name="key">The token key.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the values of every node in the source collection with the given key.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Values(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken})">
      <summary>
            Returns a collection of child values of every object in the source collection.
            </summary>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the values of every node in the source collection.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Values``1(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken},System.Object)">
      <summary>
            Returns a collection of converted child values of every object in the source collection with the given key.
            </summary>
      <typeparam name="U">The type to convert the values to.</typeparam>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <param name="key">The token key.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the converted values of every node in the source collection with the given key.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Values``1(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken})">
      <summary>
            Returns a collection of converted child values of every object in the source collection.
            </summary>
      <typeparam name="U">The type to convert the values to.</typeparam>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the converted values of every node in the source collection.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Value``1(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken})">
      <summary>
            Converts the value.
            </summary>
      <typeparam name="U">The type to convert the value to.</typeparam>
      <param name="value">A <see cref="T:Newtonsoft.Json.Linq.JToken" /> cast as a <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
      <returns>A converted value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Value``2(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Converts the value.
            </summary>
      <typeparam name="T">The source collection type.</typeparam>
      <typeparam name="U">The type to convert the value to.</typeparam>
      <param name="value">A <see cref="T:Newtonsoft.Json.Linq.JToken" /> cast as a <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
      <returns>A converted value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Children``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns a collection of child tokens of every array in the source collection.
            </summary>
      <typeparam name="T">The source collection type.</typeparam>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the values of every node in the source collection.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Children``2(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns a collection of converted child tokens of every array in the source collection.
            </summary>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <typeparam name="U">The type to convert the values to.</typeparam>
      <typeparam name="T">The source collection type.</typeparam>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the converted values of every node in the source collection.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.AsJEnumerable(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken})">
      <summary>
            Returns the input typed as <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" />.
            </summary>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <returns>The input typed as <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.AsJEnumerable``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns the input typed as <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" />.
            </summary>
      <typeparam name="T">The source collection type.</typeparam>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <returns>The input typed as <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" />.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JContainer">
      <summary>
            Represents a token that can contain other tokens.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.OnAddingNew(System.ComponentModel.AddingNewEventArgs)">
      <summary>
            Raises the <see cref="E:Newtonsoft.Json.Linq.JContainer.AddingNew" /> event.
            </summary>
      <param name="e">The <see cref="T:System.ComponentModel.AddingNewEventArgs" /> instance containing the event data.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.OnListChanged(System.ComponentModel.ListChangedEventArgs)">
      <summary>
            Raises the <see cref="E:Newtonsoft.Json.Linq.JContainer.ListChanged" /> event.
            </summary>
      <param name="e">The <see cref="T:System.ComponentModel.ListChangedEventArgs" /> instance containing the event data.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
      <summary>
            Raises the <see cref="E:Newtonsoft.Json.Linq.JContainer.CollectionChanged" /> event.
            </summary>
      <param name="e">The <see cref="T:System.Collections.Specialized.NotifyCollectionChangedEventArgs" /> instance containing the event data.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.Children">
      <summary>
            Returns a collection of the child tokens of this token, in document order.
            </summary>
      <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the child tokens of this <see cref="T:Newtonsoft.Json.Linq.JToken" />, in document order.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.Values``1">
      <summary>
            Returns a collection of the child values of this token, in document order.
            </summary>
      <typeparam name="T">The type to convert the values to.</typeparam>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing the child values of this <see cref="T:Newtonsoft.Json.Linq.JToken" />, in document order.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.Descendants">
      <summary>
            Returns a collection of the descendant tokens for this token in document order.
            </summary>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing the descendant tokens of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.Add(System.Object)">
      <summary>
            Adds the specified content as children of this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="content">The content to be added.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.AddFirst(System.Object)">
      <summary>
            Adds the specified content as the first children of this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="content">The content to be added.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.CreateWriter">
      <summary>
            Creates an <see cref="T:Newtonsoft.Json.JsonWriter" /> that can be used to add tokens to the <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <returns>An <see cref="T:Newtonsoft.Json.JsonWriter" /> that is ready to have content written to it.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.ReplaceAll(System.Object)">
      <summary>
            Replaces the children nodes of this token with the specified content.
            </summary>
      <param name="content">The content.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.RemoveAll">
      <summary>
            Removes the child nodes from this token.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.Merge(System.Object)">
      <summary>
            Merge the specified content into this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="content">The content to be merged.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.Merge(System.Object,Newtonsoft.Json.Linq.JsonMergeSettings)">
      <summary>
            Merge the specified content into this <see cref="T:Newtonsoft.Json.Linq.JToken" /> using <see cref="T:Newtonsoft.Json.Linq.JsonMergeSettings" />.
            </summary>
      <param name="content">The content to be merged.</param>
      <param name="settings">The <see cref="T:Newtonsoft.Json.Linq.JsonMergeSettings" /> used to merge the content.</param>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JContainer.ChildrenTokens">
      <summary>
            Gets the container's children tokens.
            </summary>
      <value>The container's children tokens.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JContainer.HasValues">
      <summary>
            Gets a value indicating whether this token has child tokens.
            </summary>
      <value>
        <c>true</c> if this token has child values; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JContainer.First">
      <summary>
            Get the first child token of this token.
            </summary>
      <value>
            A <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the first child token of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JContainer.Last">
      <summary>
            Get the last child token of this token.
            </summary>
      <value>
            A <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the last child token of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JContainer.Count">
      <summary>
            Gets the count of child JSON tokens.
            </summary>
      <value>The count of child JSON tokens</value>
    </member>
    <member name="E:Newtonsoft.Json.Linq.JContainer.ListChanged">
      <summary>
            Occurs when the list changes or an item in the list changes.
            </summary>
    </member>
    <member name="E:Newtonsoft.Json.Linq.JContainer.AddingNew">
      <summary>
            Occurs before an item is added to the collection.
            </summary>
    </member>
    <member name="E:Newtonsoft.Json.Linq.JContainer.CollectionChanged">
      <summary>
            Occurs when the items list of the collection has changed, or the collection is reset.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JConstructor">
      <summary>
            Represents a JSON constructor.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JConstructor.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JConstructor.#ctor(Newtonsoft.Json.Linq.JConstructor)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> class from another <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> object.
            </summary>
      <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> object to copy from.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JConstructor.#ctor(System.String,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> class with the specified name and content.
            </summary>
      <param name="name">The constructor name.</param>
      <param name="content">The contents of the constructor.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JConstructor.#ctor(System.String,System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> class with the specified name and content.
            </summary>
      <param name="name">The constructor name.</param>
      <param name="content">The contents of the constructor.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JConstructor.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> class with the specified name.
            </summary>
      <param name="name">The constructor name.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JConstructor.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
      <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JConstructor.Load(Newtonsoft.Json.JsonReader)">
      <summary>
            Loads an <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />. 
            </summary>
      <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader" /> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" />.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.</returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JConstructor.ChildrenTokens">
      <summary>
            Gets the container's children tokens.
            </summary>
      <value>The container's children tokens.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JConstructor.Name">
      <summary>
            Gets or sets the name of this constructor.
            </summary>
      <value>The constructor name.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JConstructor.Type">
      <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <value>The type.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JConstructor.Item(System.Object)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.</value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JEnumerable`1">
      <summary>
            Represents a collection of <see cref="T:Newtonsoft.Json.Linq.JToken" /> objects.
            </summary>
      <typeparam name="T">The type of token</typeparam>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JEnumerable`1.Empty">
      <summary>
            An empty collection of <see cref="T:Newtonsoft.Json.Linq.JToken" /> objects.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JEnumerable`1" /> struct.
            </summary>
      <param name="enumerable">The enumerable.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JEnumerable`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JEnumerable`1.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JEnumerable`1.GetHashCode">
      <summary>
            Returns a hash code for this instance.
            </summary>
      <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JEnumerable`1.Item(System.Object)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" /> with the specified key.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JObject">
      <summary>
            Represents a JSON object.
            </summary>
      <example>
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\LinqToJsonTests.cs" region="LinqToJsonCreateParse" title="Parsing a JSON Object from Text" />
      </example>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JObject" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.#ctor(Newtonsoft.Json.Linq.JObject)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JObject" /> class from another <see cref="T:Newtonsoft.Json.Linq.JObject" /> object.
            </summary>
      <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JObject" /> object to copy from.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.#ctor(System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JObject" /> class with the specified content.
            </summary>
      <param name="content">The contents of the object.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JObject" /> class with the specified content.
            </summary>
      <param name="content">The contents of the object.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.Properties">
      <summary>
            Gets an <see cref="T:System.Collections.Generic.IEnumerable`1" /> of this object's properties.
            </summary>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of this object's properties.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.Property(System.String)">
      <summary>
            Gets a <see cref="T:Newtonsoft.Json.Linq.JProperty" /> the specified name.
            </summary>
      <param name="name">The property name.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JProperty" /> with the specified name or null.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.PropertyValues">
      <summary>
            Gets an <see cref="T:Newtonsoft.Json.Linq.JEnumerable`1" /> of this object's property values.
            </summary>
      <returns>An <see cref="T:Newtonsoft.Json.Linq.JEnumerable`1" /> of this object's property values.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.Load(Newtonsoft.Json.JsonReader)">
      <summary>
            Loads an <see cref="T:Newtonsoft.Json.Linq.JObject" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />. 
            </summary>
      <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader" /> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JObject" />.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JObject" /> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.Parse(System.String)">
      <summary>
            Load a <see cref="T:Newtonsoft.Json.Linq.JObject" /> from a string that contains JSON.
            </summary>
      <param name="json">A <see cref="T:System.String" /> that contains JSON.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JObject" /> populated from the string that contains JSON.</returns>
      <example>
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\LinqToJsonTests.cs" region="LinqToJsonCreateParse" title="Parsing a JSON Object from Text" />
      </example>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.FromObject(System.Object)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JObject" /> from an object.
            </summary>
      <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JObject" />.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JObject" /> with the values of the specified object</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.FromObject(System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JObject" /> from an object.
            </summary>
      <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JObject" />.</param>
      <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer" /> that will be used to read the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JObject" /> with the values of the specified object</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
      <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.GetValue(System.String)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified property name.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified property name.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.GetValue(System.String,System.StringComparison)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified property name.
            The exact property name will be searched for first and if no matching property is found then
            the <see cref="T:System.StringComparison" /> will be used to match a property.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <param name="comparison">One of the enumeration values that specifies how the strings will be compared.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified property name.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.TryGetValue(System.String,System.StringComparison,Newtonsoft.Json.Linq.JToken@)">
      <summary>
            Tries to get the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified property name.
            The exact property name will be searched for first and if no matching property is found then
            the <see cref="T:System.StringComparison" /> will be used to match a property.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <param name="value">The value.</param>
      <param name="comparison">One of the enumeration values that specifies how the strings will be compared.</param>
      <returns>true if a value was successfully retrieved; otherwise, false.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.Add(System.String,Newtonsoft.Json.Linq.JToken)">
      <summary>
            Adds the specified property name.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.Remove(System.String)">
      <summary>
            Removes the property with the specified name.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <returns>true if item was successfully removed; otherwise, false.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.TryGetValue(System.String,Newtonsoft.Json.Linq.JToken@)">
      <summary>
            Tries the get value.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <param name="value">The value.</param>
      <returns>true if a value was successfully retrieved; otherwise, false.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.OnPropertyChanged(System.String)">
      <summary>
            Raises the <see cref="E:Newtonsoft.Json.Linq.JObject.PropertyChanged" /> event with the provided arguments.
            </summary>
      <param name="propertyName">Name of the property.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.OnPropertyChanging(System.String)">
      <summary>
            Raises the <see cref="E:Newtonsoft.Json.Linq.JObject.PropertyChanging" /> event with the provided arguments.
            </summary>
      <param name="propertyName">Name of the property.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>
            Returns the <see cref="T:System.Dynamic.DynamicMetaObject" /> responsible for binding operations performed on this object.
            </summary>
      <param name="parameter">The expression tree representation of the runtime value.</param>
      <returns>
            The <see cref="T:System.Dynamic.DynamicMetaObject" /> to bind this object.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JObject.ChildrenTokens">
      <summary>
            Gets the container's children tokens.
            </summary>
      <value>The container's children tokens.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JObject.Type">
      <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <value>The type.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JObject.Item(System.Object)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JObject.Item(System.String)">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified property name.
            </summary>
      <value>
      </value>
    </member>
    <member name="E:Newtonsoft.Json.Linq.JObject.PropertyChanged">
      <summary>
            Occurs when a property value changes.
            </summary>
    </member>
    <member name="E:Newtonsoft.Json.Linq.JObject.PropertyChanging">
      <summary>
            Occurs when a property value is changing.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JArray">
      <summary>
            Represents a JSON array.
            </summary>
      <example>
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\LinqToJsonTests.cs" region="LinqToJsonCreateParseArray" title="Parsing a JSON Array from Text" />
      </example>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JArray" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.#ctor(Newtonsoft.Json.Linq.JArray)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JArray" /> class from another <see cref="T:Newtonsoft.Json.Linq.JArray" /> object.
            </summary>
      <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JArray" /> object to copy from.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.#ctor(System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JArray" /> class with the specified content.
            </summary>
      <param name="content">The contents of the array.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JArray" /> class with the specified content.
            </summary>
      <param name="content">The contents of the array.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.Load(Newtonsoft.Json.JsonReader)">
      <summary>
            Loads an <see cref="T:Newtonsoft.Json.Linq.JArray" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />. 
            </summary>
      <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader" /> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JArray" />.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray" /> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.Parse(System.String)">
      <summary>
            Load a <see cref="T:Newtonsoft.Json.Linq.JArray" /> from a string that contains JSON.
            </summary>
      <param name="json">A <see cref="T:System.String" /> that contains JSON.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray" /> populated from the string that contains JSON.</returns>
      <example>
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\LinqToJsonTests.cs" region="LinqToJsonCreateParseArray" title="Parsing a JSON Array from Text" />
      </example>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.FromObject(System.Object)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JArray" /> from an object.
            </summary>
      <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JArray" />.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray" /> with the values of the specified object</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.FromObject(System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JArray" /> from an object.
            </summary>
      <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JArray" />.</param>
      <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer" /> that will be used to read the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray" /> with the values of the specified object</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
      <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.IndexOf(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1" />.
            </summary>
      <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1" />.</param>
      <returns>
            The index of <paramref name="item" /> if found in the list; otherwise, -1.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.Insert(System.Int32,Newtonsoft.Json.Linq.JToken)">
      <summary>
            Inserts an item to the <see cref="T:System.Collections.Generic.IList`1" /> at the specified index.
            </summary>
      <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
      <param name="item">The object to insert into the <see cref="T:System.Collections.Generic.IList`1" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1" />.</exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1" /> is read-only.</exception>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.RemoveAt(System.Int32)">
      <summary>
            Removes the <see cref="T:System.Collections.Generic.IList`1" /> item at the specified index.
            </summary>
      <param name="index">The zero-based index of the item to remove.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1" />.</exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1" /> is read-only.</exception>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.Add(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</exception>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.Clear">
      <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only. </exception>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.Contains(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1" /> contains a specific value.
            </summary>
      <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
      <returns>
            true if <paramref name="item" /> is found in the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.CopyTo(Newtonsoft.Json.Linq.JToken[],System.Int32)">
      <summary>
            Copies to.
            </summary>
      <param name="array">The array.</param>
      <param name="arrayIndex">Index of the array.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.Remove(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
      <returns>
            true if <paramref name="item" /> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false. This method also returns false if <paramref name="item" /> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1" />.
            </returns>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</exception>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JArray.ChildrenTokens">
      <summary>
            Gets the container's children tokens.
            </summary>
      <value>The container's children tokens.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JArray.Type">
      <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <value>The type.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JArray.Item(System.Object)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JArray.Item(System.Int32)">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> at the specified index.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JArray.IsReadOnly">
      <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.
            </summary>
      <returns>true if the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only; otherwise, false.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JTokenReader">
      <summary>
            Represents a reader that provides fast, non-cached, forward-only access to serialized Json data.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenReader.#ctor(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JTokenReader" /> class.
            </summary>
      <param name="token">The token to read from.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenReader.ReadAsBytes">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:Byte[]" />.
            </summary>
      <returns>
            A <see cref="T:Byte[]" /> or a null reference if the next JSON token is null. This method will return <c>null</c> at the end of an array.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenReader.ReadAsDecimal">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenReader.ReadAsInt32">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenReader.ReadAsString">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.String" />.
            </summary>
      <returns>A <see cref="T:System.String" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenReader.ReadAsDateTime">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.String" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenReader.ReadAsDateTimeOffset">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenReader.Read">
      <summary>
            Reads the next JSON token from the stream.
            </summary>
      <returns>
            true if the next token was read successfully; false if there are no more tokens to read.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JTokenReader.Path">
      <summary>
            Gets the path of the current JSON token. 
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JTokenWriter">
      <summary>
            Represents a writer that provides a fast, non-cached, forward-only way of generating Json data.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.#ctor(Newtonsoft.Json.Linq.JContainer)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JTokenWriter" /> class writing to the given <see cref="T:Newtonsoft.Json.Linq.JContainer" />.
            </summary>
      <param name="container">The container being written to.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JTokenWriter" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.Flush">
      <summary>
            Flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.Close">
      <summary>
            Closes this stream and the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteStartObject">
      <summary>
            Writes the beginning of a Json object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteStartArray">
      <summary>
            Writes the beginning of a Json array.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteStartConstructor(System.String)">
      <summary>
            Writes the start of a constructor with the given name.
            </summary>
      <param name="name">The name of the constructor.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteEnd(Newtonsoft.Json.JsonToken)">
      <summary>
            Writes the end.
            </summary>
      <param name="token">The token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WritePropertyName(System.String)">
      <summary>
            Writes the property name of a name/value pair on a Json object.
            </summary>
      <param name="name">The name of the property.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Object)">
      <summary>
            Writes a <see cref="T:System.Object" /> value.
            An error will raised if the value cannot be written as a single JSON token.
            </summary>
      <param name="value">The <see cref="T:System.Object" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteNull">
      <summary>
            Writes a null value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteUndefined">
      <summary>
            Writes an undefined value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteRaw(System.String)">
      <summary>
            Writes raw JSON.
            </summary>
      <param name="json">The raw JSON to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteComment(System.String)">
      <summary>
            Writes out a comment <code>/*...*/</code> containing the specified text.
            </summary>
      <param name="text">Text to place inside the comment.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.String)">
      <summary>
            Writes a <see cref="T:System.String" /> value.
            </summary>
      <param name="value">The <see cref="T:System.String" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Int32)">
      <summary>
            Writes a <see cref="T:System.Int32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.UInt32)">
      <summary>
            Writes a <see cref="T:System.UInt32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Int64)">
      <summary>
            Writes a <see cref="T:System.Int64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.UInt64)">
      <summary>
            Writes a <see cref="T:System.UInt64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Single)">
      <summary>
            Writes a <see cref="T:System.Single" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Single" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Double)">
      <summary>
            Writes a <see cref="T:System.Double" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Double" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Boolean)">
      <summary>
            Writes a <see cref="T:System.Boolean" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Boolean" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Int16)">
      <summary>
            Writes a <see cref="T:System.Int16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.UInt16)">
      <summary>
            Writes a <see cref="T:System.UInt16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Char)">
      <summary>
            Writes a <see cref="T:System.Char" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Byte)">
      <summary>
            Writes a <see cref="T:System.Byte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Byte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.SByte)">
      <summary>
            Writes a <see cref="T:System.SByte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.SByte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Decimal)">
      <summary>
            Writes a <see cref="T:System.Decimal" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Decimal" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.DateTime)">
      <summary>
            Writes a <see cref="T:System.DateTime" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTime" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.DateTimeOffset)">
      <summary>
            Writes a <see cref="T:System.DateTimeOffset" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTimeOffset" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Byte[])">
      <summary>
            Writes a <see cref="T:Byte[]" /> value.
            </summary>
      <param name="value">The <see cref="T:Byte[]" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.TimeSpan)">
      <summary>
            Writes a <see cref="T:System.TimeSpan" /> value.
            </summary>
      <param name="value">The <see cref="T:System.TimeSpan" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Guid)">
      <summary>
            Writes a <see cref="T:System.Guid" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Guid" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Uri)">
      <summary>
            Writes a <see cref="T:System.Uri" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Uri" /> value to write.</param>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JTokenWriter.Token">
      <summary>
            Gets the token being writen.
            </summary>
      <value>The token being writen.</value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JProperty">
      <summary>
            Represents a JSON property.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JProperty.#ctor(Newtonsoft.Json.Linq.JProperty)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JProperty" /> class from another <see cref="T:Newtonsoft.Json.Linq.JProperty" /> object.
            </summary>
      <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JProperty" /> object to copy from.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JProperty.#ctor(System.String,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JProperty" /> class.
            </summary>
      <param name="name">The property name.</param>
      <param name="content">The property content.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JProperty.#ctor(System.String,System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JProperty" /> class.
            </summary>
      <param name="name">The property name.</param>
      <param name="content">The property content.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JProperty.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
      <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JProperty.Load(Newtonsoft.Json.JsonReader)">
      <summary>
            Loads an <see cref="T:Newtonsoft.Json.Linq.JProperty" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />. 
            </summary>
      <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader" /> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JProperty" />.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JProperty" /> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.</returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JProperty.ChildrenTokens">
      <summary>
            Gets the container's children tokens.
            </summary>
      <value>The container's children tokens.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JProperty.Name">
      <summary>
            Gets the property name.
            </summary>
      <value>The property name.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JProperty.Value">
      <summary>
            Gets or sets the property value.
            </summary>
      <value>The property value.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JProperty.Type">
      <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <value>The type.</value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JTokenType">
      <summary>
            Specifies the type of token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.None">
      <summary>
            No token type has been set.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Object">
      <summary>
            A JSON object.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Array">
      <summary>
            A JSON array.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Constructor">
      <summary>
            A JSON constructor.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Property">
      <summary>
            A JSON object property.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Comment">
      <summary>
            A comment.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Integer">
      <summary>
            An integer value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Float">
      <summary>
            A float value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.String">
      <summary>
            A string value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Boolean">
      <summary>
            A boolean value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Null">
      <summary>
            A null value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Undefined">
      <summary>
            An undefined value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Date">
      <summary>
            A date value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Raw">
      <summary>
            A raw JSON value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Bytes">
      <summary>
            A collection of bytes value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Guid">
      <summary>
            A Guid value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Uri">
      <summary>
            A Uri value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.TimeSpan">
      <summary>
            A TimeSpan value.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Schema.Extensions">
      <summary>
            Contains the JSON schema extension methods.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.Extensions.IsValid(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Schema.JsonSchema)">
      <summary>
            Determines whether the <see cref="T:Newtonsoft.Json.Linq.JToken" /> is valid.
            </summary>
      <param name="source">The source <see cref="T:Newtonsoft.Json.Linq.JToken" /> to test.</param>
      <param name="schema">The schema to test with.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:Newtonsoft.Json.Linq.JToken" /> is valid; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.Extensions.IsValid(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Schema.JsonSchema,System.Collections.Generic.IList{System.String}@)">
      <summary>
            Determines whether the <see cref="T:Newtonsoft.Json.Linq.JToken" /> is valid.
            </summary>
      <param name="source">The source <see cref="T:Newtonsoft.Json.Linq.JToken" /> to test.</param>
      <param name="schema">The schema to test with.</param>
      <param name="errorMessages">When this method returns, contains any error messages generated while validating. </param>
      <returns>
        <c>true</c> if the specified <see cref="T:Newtonsoft.Json.Linq.JToken" /> is valid; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.Extensions.Validate(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Schema.JsonSchema)">
      <summary>
            Validates the specified <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="source">The source <see cref="T:Newtonsoft.Json.Linq.JToken" /> to test.</param>
      <param name="schema">The schema to test with.</param>
    </member>
    <member name="M:Newtonsoft.Json.Schema.Extensions.Validate(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Schema.JsonSchema,Newtonsoft.Json.Schema.ValidationEventHandler)">
      <summary>
            Validates the specified <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="source">The source <see cref="T:Newtonsoft.Json.Linq.JToken" /> to test.</param>
      <param name="schema">The schema to test with.</param>
      <param name="validationEventHandler">The validation event handler.</param>
    </member>
    <member name="T:Newtonsoft.Json.Schema.JsonSchemaException">
      <summary>
            Returns detailed information about the schema exception.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaException" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaException" /> class
            with a specified error message.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaException" /> class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchemaException.LineNumber">
      <summary>
            Gets the line number indicating where the error occurred.
            </summary>
      <value>The line number indicating where the error occurred.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchemaException.LinePosition">
      <summary>
            Gets the line position indicating where the error occurred.
            </summary>
      <value>The line position indicating where the error occurred.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchemaException.Path">
      <summary>
            Gets the path to the JSON where the error occurred.
            </summary>
      <value>The path to the JSON where the error occurred.</value>
    </member>
    <member name="T:Newtonsoft.Json.Schema.JsonSchemaResolver">
      <summary>
            Resolves <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from an id.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaResolver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaResolver" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaResolver.GetSchema(System.String)">
      <summary>
            Gets a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> for the specified reference.
            </summary>
      <param name="reference">The id.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> for the specified reference.</returns>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchemaResolver.LoadedSchemas">
      <summary>
            Gets or sets the loaded schemas.
            </summary>
      <value>The loaded schemas.</value>
    </member>
    <member name="T:Newtonsoft.Json.Schema.UndefinedSchemaIdHandling">
      <summary>
            Specifies undefined schema Id handling options for the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaGenerator" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.UndefinedSchemaIdHandling.None">
      <summary>
            Do not infer a schema Id.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.UndefinedSchemaIdHandling.UseTypeName">
      <summary>
            Use the .NET type name as the schema Id.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.UndefinedSchemaIdHandling.UseAssemblyQualifiedName">
      <summary>
            Use the assembly qualified .NET type name as the schema Id.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Schema.ValidationEventArgs">
      <summary>
            Returns detailed information related to the <see cref="T:Newtonsoft.Json.Schema.ValidationEventHandler" />.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.ValidationEventArgs.Exception">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaException" /> associated with the validation error.
            </summary>
      <value>The JsonSchemaException associated with the validation error.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.ValidationEventArgs.Path">
      <summary>
            Gets the path of the JSON location where the validation error occurred.
            </summary>
      <value>The path of the JSON location where the validation error occurred.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.ValidationEventArgs.Message">
      <summary>
            Gets the text description corresponding to the validation error.
            </summary>
      <value>The text description.</value>
    </member>
    <member name="T:Newtonsoft.Json.Schema.ValidationEventHandler">
      <summary>
            Represents the callback method that will handle JSON schema validation events and the <see cref="T:Newtonsoft.Json.Schema.ValidationEventArgs" />.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.IContractResolver">
      <summary>
            Used by <see cref="T:Newtonsoft.Json.JsonSerializer" /> to resolves a <see cref="T:Newtonsoft.Json.Serialization.JsonContract" /> for a given <see cref="T:System.Type" />.
            </summary>
      <example>
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeContractResolverObject" title="IContractResolver Class" />
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeContractResolverExample" title="IContractResolver Example" />
      </example>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.IContractResolver.ResolveContract(System.Type)">
      <summary>
            Resolves the contract for a given type.
            </summary>
      <param name="type">The type to resolve a contract for.</param>
      <returns>The contract for a given type.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.DefaultContractResolver">
      <summary>
            Used by <see cref="T:Newtonsoft.Json.JsonSerializer" /> to resolves a <see cref="T:Newtonsoft.Json.Serialization.JsonContract" /> for a given <see cref="T:System.Type" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.DefaultContractResolver" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.DefaultContractResolver" /> class.
            </summary>
      <param name="shareCache">
            If set to <c>true</c> the <see cref="T:Newtonsoft.Json.Serialization.DefaultContractResolver" /> will use a cached shared with other resolvers of the same type.
            Sharing the cache will significantly performance because expensive reflection will only happen once but could cause unexpected
            behavior if different instances of the resolver are suppose to produce different results. When set to false it is highly
            recommended to reuse <see cref="T:Newtonsoft.Json.Serialization.DefaultContractResolver" /> instances with the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.ResolveContract(System.Type)">
      <summary>
            Resolves the contract for a given type.
            </summary>
      <param name="type">The type to resolve a contract for.</param>
      <returns>The contract for a given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.GetSerializableMembers(System.Type)">
      <summary>
            Gets the serializable members for the type.
            </summary>
      <param name="objectType">The type to get serializable members for.</param>
      <returns>The serializable members for the type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateObjectContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonObjectContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonObjectContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateConstructorParameters(System.Reflection.ConstructorInfo,Newtonsoft.Json.Serialization.JsonPropertyCollection)">
      <summary>
            Creates the constructor parameters.
            </summary>
      <param name="constructor">The constructor to create properties for.</param>
      <param name="memberProperties">The type's member properties.</param>
      <returns>Properties for the given <see cref="T:System.Reflection.ConstructorInfo" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreatePropertyFromConstructorParameter(Newtonsoft.Json.Serialization.JsonProperty,System.Reflection.ParameterInfo)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> for the given <see cref="T:System.Reflection.ParameterInfo" />.
            </summary>
      <param name="matchingMemberProperty">The matching member property.</param>
      <param name="parameterInfo">The constructor parameter.</param>
      <returns>A created <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> for the given <see cref="T:System.Reflection.ParameterInfo" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.ResolveContractConverter(System.Type)">
      <summary>
            Resolves the default <see cref="T:Newtonsoft.Json.JsonConverter" /> for the contract.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>The contract's default <see cref="T:Newtonsoft.Json.JsonConverter" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateDictionaryContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonDictionaryContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonDictionaryContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateArrayContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonArrayContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonArrayContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreatePrimitiveContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonPrimitiveContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonPrimitiveContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateLinqContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonLinqContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonLinqContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateISerializableContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonISerializableContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonISerializableContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateDynamicContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonDynamicContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonDynamicContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateStringContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonStringContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonStringContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateContract(System.Type)">
      <summary>
            Determines which contract type is created for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateProperties(System.Type,Newtonsoft.Json.MemberSerialization)">
      <summary>
            Creates properties for the given <see cref="T:Newtonsoft.Json.Serialization.JsonContract" />.
            </summary>
      <param name="type">The type to create properties for.</param>
            /// <param name="memberSerialization">The member serialization mode for the type.</param><returns>Properties for the given <see cref="T:Newtonsoft.Json.Serialization.JsonContract" />.</returns></member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateMemberValueProvider(System.Reflection.MemberInfo)">
      <summary>
            Creates the <see cref="T:Newtonsoft.Json.Serialization.IValueProvider" /> used by the serializer to get and set values from a member.
            </summary>
      <param name="member">The member.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Serialization.IValueProvider" /> used by the serializer to get and set values from a member.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateProperty(System.Reflection.MemberInfo,Newtonsoft.Json.MemberSerialization)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> for the given <see cref="T:System.Reflection.MemberInfo" />.
            </summary>
      <param name="memberSerialization">The member's parent <see cref="T:Newtonsoft.Json.MemberSerialization" />.</param>
      <param name="member">The member to create a <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> for.</param>
      <returns>A created <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> for the given <see cref="T:System.Reflection.MemberInfo" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.ResolvePropertyName(System.String)">
      <summary>
            Resolves the name of the property.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <returns>Name of the property.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.GetResolvedPropertyName(System.String)">
      <summary>
            Gets the resolved name of the property.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <returns>Name of the property.</returns>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.DefaultContractResolver.DynamicCodeGeneration">
      <summary>
            Gets a value indicating whether members are being get and set using dynamic code generation.
            This value is determined by the runtime permissions available.
            </summary>
      <value>
        <c>true</c> if using dynamic code generation; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.DefaultContractResolver.DefaultMembersSearchFlags">
      <summary>
            Gets or sets the default members search flags.
            </summary>
      <value>The default members search flags.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.DefaultContractResolver.SerializeCompilerGeneratedMembers">
      <summary>
            Gets or sets a value indicating whether compiler generated members should be serialized.
            </summary>
      <value>
        <c>true</c> if serialized compiler generated members; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.DefaultContractResolver.IgnoreSerializableInterface">
      <summary>
            Gets or sets a value indicating whether to ignore the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface when serializing and deserializing types.
            </summary>
      <value>
        <c>true</c> if the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface will be ignored when serializing and deserializing types; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.DefaultContractResolver.IgnoreSerializableAttribute">
      <summary>
            Gets or sets a value indicating whether to ignore the <see cref="T:System.SerializableAttribute" /> attribute when serializing and deserializing types.
            </summary>
      <value>
        <c>true</c> if the <see cref="T:System.SerializableAttribute" /> attribute will be ignored when serializing and deserializing types; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver">
      <summary>
            Resolves member mappings for a type, camel casing property names.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver.ResolvePropertyName(System.String)">
      <summary>
            Resolves the name of the property.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <returns>The property name camel cased.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.DefaultSerializationBinder">
      <summary>
            The default serialization binder used when resolving and loading classes from type names.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultSerializationBinder.BindToType(System.String,System.String)">
      <summary>
            When overridden in a derived class, controls the binding of a serialized object to a type.
            </summary>
      <param name="assemblyName">Specifies the <see cref="T:System.Reflection.Assembly" /> name of the serialized object.</param>
      <param name="typeName">Specifies the <see cref="T:System.Type" /> name of the serialized object.</param>
      <returns>
            The type of the object the formatter creates a new instance of.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultSerializationBinder.BindToName(System.Type,System.String@,System.String@)">
      <summary>
            When overridden in a derived class, controls the binding of a serialized object to a type.
            </summary>
      <param name="serializedType">The type of the object the formatter creates a new instance of.</param>
      <param name="assemblyName">Specifies the <see cref="T:System.Reflection.Assembly" /> name of the serialized object. </param>
      <param name="typeName">Specifies the <see cref="T:System.Type" /> name of the serialized object. </param>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.ErrorContext">
      <summary>
            Provides information surrounding an error.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.ErrorContext.Error">
      <summary>
            Gets the error.
            </summary>
      <value>The error.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.ErrorContext.OriginalObject">
      <summary>
            Gets the original object that caused the error.
            </summary>
      <value>The original object that caused the error.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.ErrorContext.Member">
      <summary>
            Gets the member that caused the error.
            </summary>
      <value>The member that caused the error.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.ErrorContext.Path">
      <summary>
            Gets the path of the JSON location where the error occurred.
            </summary>
      <value>The path of the JSON location where the error occurred.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.ErrorContext.Handled">
      <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.ErrorContext" /> is handled.
            </summary>
      <value>
        <c>true</c> if handled; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonArrayContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonArrayContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonArrayContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonArrayContract.CollectionItemType">
      <summary>
            Gets the <see cref="T:System.Type" /> of the collection items.
            </summary>
      <value>The <see cref="T:System.Type" /> of the collection items.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonArrayContract.IsMultidimensionalArray">
      <summary>
            Gets a value indicating whether the collection type is a multidimensional array.
            </summary>
      <value>
        <c>true</c> if the collection type is a multidimensional array; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.SerializationCallback">
      <summary>
            Handles <see cref="T:Newtonsoft.Json.JsonSerializer" /> serialization callback events.
            </summary>
      <param name="o">The object that raised the callback event.</param>
      <param name="context">The streaming context.</param>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.SerializationErrorCallback">
      <summary>
            Handles <see cref="T:Newtonsoft.Json.JsonSerializer" /> serialization error callback events.
            </summary>
      <param name="o">The object that raised the callback event.</param>
      <param name="context">The streaming context.</param>
      <param name="errorContext">The error context.</param>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.ExtensionDataSetter">
      <summary>
            Sets extension data for an object during deserialization.
            </summary>
      <param name="o">The object to set extension data on.</param>
      <param name="key">The extension data key.</param>
      <param name="value">The extension data value.</param>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.ExtensionDataGetter">
      <summary>
            Gets extension data for an object during serialization.
            </summary>
      <param name="o">The object to set extension data on.</param>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonDictionaryContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonDictionaryContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonDictionaryContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonDictionaryContract.PropertyNameResolver">
      <summary>
            Gets or sets the property name resolver.
            </summary>
      <value>The property name resolver.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonDictionaryContract.DictionaryKeyType">
      <summary>
            Gets the <see cref="T:System.Type" /> of the dictionary keys.
            </summary>
      <value>The <see cref="T:System.Type" /> of the dictionary keys.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonDictionaryContract.DictionaryValueType">
      <summary>
            Gets the <see cref="T:System.Type" /> of the dictionary values.
            </summary>
      <value>The <see cref="T:System.Type" /> of the dictionary values.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonProperty">
      <summary>
            Maps a JSON property to a .NET member or constructor parameter.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonProperty.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.PropertyName">
      <summary>
            Gets or sets the name of the property.
            </summary>
      <value>The name of the property.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.DeclaringType">
      <summary>
            Gets or sets the type that declared this property.
            </summary>
      <value>The type that declared this property.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Order">
      <summary>
            Gets or sets the order of serialization and deserialization of a member.
            </summary>
      <value>The numeric order of serialization or deserialization.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.UnderlyingName">
      <summary>
            Gets or sets the name of the underlying member or parameter.
            </summary>
      <value>The name of the underlying member or parameter.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ValueProvider">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Serialization.IValueProvider" /> that will get and set the <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> during serialization.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Serialization.IValueProvider" /> that will get and set the <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> during serialization.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.PropertyType">
      <summary>
            Gets or sets the type of the property.
            </summary>
      <value>The type of the property.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Converter">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.JsonConverter" /> for the property.
            If set this converter takes presidence over the contract converter for the property type.
            </summary>
      <value>The converter.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.MemberConverter">
      <summary>
            Gets or sets the member converter.
            </summary>
      <value>The member converter.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Ignored">
      <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> is ignored.
            </summary>
      <value>
        <c>true</c> if ignored; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Readable">
      <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> is readable.
            </summary>
      <value>
        <c>true</c> if readable; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Writable">
      <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> is writable.
            </summary>
      <value>
        <c>true</c> if writable; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.HasMemberAttribute">
      <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> has a member attribute.
            </summary>
      <value>
        <c>true</c> if has a member attribute; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.DefaultValue">
      <summary>
            Gets the default value.
            </summary>
      <value>The default value.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Required">
      <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> is required.
            </summary>
      <value>A value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> is required.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.IsReference">
      <summary>
            Gets or sets a value indicating whether this property preserves object references.
            </summary>
      <value>
        <c>true</c> if this instance is reference; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.NullValueHandling">
      <summary>
            Gets or sets the property null value handling.
            </summary>
      <value>The null value handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.DefaultValueHandling">
      <summary>
            Gets or sets the property default value handling.
            </summary>
      <value>The default value handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ReferenceLoopHandling">
      <summary>
            Gets or sets the property reference loop handling.
            </summary>
      <value>The reference loop handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ObjectCreationHandling">
      <summary>
            Gets or sets the property object creation handling.
            </summary>
      <value>The object creation handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.TypeNameHandling">
      <summary>
            Gets or sets or sets the type name handling.
            </summary>
      <value>The type name handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ShouldSerialize">
      <summary>
            Gets or sets a predicate used to determine whether the property should be serialize.
            </summary>
      <value>A predicate used to determine whether the property should be serialize.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.GetIsSpecified">
      <summary>
            Gets or sets a predicate used to determine whether the property should be serialized.
            </summary>
      <value>A predicate used to determine whether the property should be serialized.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.SetIsSpecified">
      <summary>
            Gets or sets an action used to set whether the property has been deserialized.
            </summary>
      <value>An action used to set whether the property has been deserialized.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ItemConverter">
      <summary>
            Gets or sets the converter used when serializing the property's collection items.
            </summary>
      <value>The collection's items converter.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ItemIsReference">
      <summary>
            Gets or sets whether this property's collection items are serialized as a reference.
            </summary>
      <value>Whether this property's collection items are serialized as a reference.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ItemTypeNameHandling">
      <summary>
            Gets or sets the the type name handling used when serializing the property's collection items.
            </summary>
      <value>The collection's items type name handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ItemReferenceLoopHandling">
      <summary>
            Gets or sets the the reference loop handling used when serializing the property's collection items.
            </summary>
      <value>The collection's items reference loop handling.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonPropertyCollection">
      <summary>
            A collection of <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> objects.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonPropertyCollection.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonPropertyCollection" /> class.
            </summary>
      <param name="type">The type.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonPropertyCollection.GetKeyForItem(Newtonsoft.Json.Serialization.JsonProperty)">
      <summary>
            When implemented in a derived class, extracts the key from the specified element.
            </summary>
      <param name="item">The element from which to extract the key.</param>
      <returns>The key for the specified element.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonPropertyCollection.AddProperty(Newtonsoft.Json.Serialization.JsonProperty)">
      <summary>
            Adds a <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> object.
            </summary>
      <param name="property">The property to add to the collection.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonPropertyCollection.GetClosestMatchProperty(System.String)">
      <summary>
            Gets the closest matching <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> object.
            First attempts to get an exact case match of propertyName and then
            a case insensitive match.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <returns>A matching property if found.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonPropertyCollection.GetProperty(System.String,System.StringComparison)">
      <summary>
            Gets a property by property name.
            </summary>
      <param name="propertyName">The name of the property to get.</param>
      <param name="comparisonType">Type property name string comparison.</param>
      <returns>A matching property if found.</returns>
    </member>
    <member name="T:Newtonsoft.Json.MissingMemberHandling">
      <summary>
            Specifies missing member handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.MissingMemberHandling.Ignore">
      <summary>
            Ignore a missing member and do not attempt to deserialize it.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.MissingMemberHandling.Error">
      <summary>
            Throw a <see cref="T:Newtonsoft.Json.JsonSerializationException" /> when a missing member is encountered during deserialization.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.NullValueHandling">
      <summary>
            Specifies null value handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
      <example>
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeNullValueHandlingObject" title="NullValueHandling Class" />
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeNullValueHandlingExample" title="NullValueHandling Ignore Example" />
      </example>
    </member>
    <member name="F:Newtonsoft.Json.NullValueHandling.Include">
      <summary>
            Include null values when serializing and deserializing objects.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.NullValueHandling.Ignore">
      <summary>
            Ignore null values when serializing and deserializing objects.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.ReferenceLoopHandling">
      <summary>
            Specifies reference loop handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ReferenceLoopHandling.Error">
      <summary>
            Throw a <see cref="T:Newtonsoft.Json.JsonSerializationException" /> when a loop is encountered.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ReferenceLoopHandling.Ignore">
      <summary>
            Ignore loop references and do not serialize.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ReferenceLoopHandling.Serialize">
      <summary>
            Serialize loop references.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Schema.JsonSchema">
      <summary>
            An in-memory representation of a JSON Schema.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.Read(Newtonsoft.Json.JsonReader)">
      <summary>
            Reads a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> containing the JSON Schema to read.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> object representing the JSON Schema.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.Read(Newtonsoft.Json.JsonReader,Newtonsoft.Json.Schema.JsonSchemaResolver)">
      <summary>
            Reads a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> containing the JSON Schema to read.</param>
      <param name="resolver">The <see cref="T:Newtonsoft.Json.Schema.JsonSchemaResolver" /> to use when resolving schema references.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> object representing the JSON Schema.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.Parse(System.String)">
      <summary>
            Load a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from a string that contains schema JSON.
            </summary>
      <param name="json">A <see cref="T:System.String" /> that contains JSON.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> populated from the string that contains JSON.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.Parse(System.String,Newtonsoft.Json.Schema.JsonSchemaResolver)">
      <summary>
            Parses the specified json.
            </summary>
      <param name="json">The json.</param>
      <param name="resolver">The resolver.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> populated from the string that contains JSON.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.WriteTo(Newtonsoft.Json.JsonWriter)">
      <summary>
            Writes this schema to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.Schema.JsonSchemaResolver)">
      <summary>
            Writes this schema to a <see cref="T:Newtonsoft.Json.JsonWriter" /> using the specified <see cref="T:Newtonsoft.Json.Schema.JsonSchemaResolver" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
      <param name="resolver">The resolver used.</param>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Id">
      <summary>
            Gets or sets the id.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Title">
      <summary>
            Gets or sets the title.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Required">
      <summary>
            Gets or sets whether the object is required.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.ReadOnly">
      <summary>
            Gets or sets whether the object is read only.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Hidden">
      <summary>
            Gets or sets whether the object is visible to users.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Transient">
      <summary>
            Gets or sets whether the object is transient.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Description">
      <summary>
            Gets or sets the description of the object.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Type">
      <summary>
            Gets or sets the types of values allowed by the object.
            </summary>
      <value>The type.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Pattern">
      <summary>
            Gets or sets the pattern.
            </summary>
      <value>The pattern.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.MinimumLength">
      <summary>
            Gets or sets the minimum length.
            </summary>
      <value>The minimum length.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.MaximumLength">
      <summary>
            Gets or sets the maximum length.
            </summary>
      <value>The maximum length.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.DivisibleBy">
      <summary>
            Gets or sets a number that the value should be divisble by.
            </summary>
      <value>A number that the value should be divisble by.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Minimum">
      <summary>
            Gets or sets the minimum.
            </summary>
      <value>The minimum.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Maximum">
      <summary>
            Gets or sets the maximum.
            </summary>
      <value>The maximum.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.ExclusiveMinimum">
      <summary>
            Gets or sets a flag indicating whether the value can not equal the number defined by the "minimum" attribute.
            </summary>
      <value>A flag indicating whether the value can not equal the number defined by the "minimum" attribute.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.ExclusiveMaximum">
      <summary>
            Gets or sets a flag indicating whether the value can not equal the number defined by the "maximum" attribute.
            </summary>
      <value>A flag indicating whether the value can not equal the number defined by the "maximum" attribute.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.MinimumItems">
      <summary>
            Gets or sets the minimum number of items.
            </summary>
      <value>The minimum number of items.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.MaximumItems">
      <summary>
            Gets or sets the maximum number of items.
            </summary>
      <value>The maximum number of items.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Items">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of items.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of items.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.PositionalItemsValidation">
      <summary>
            Gets or sets a value indicating whether items in an array are validated using the <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> instance at their array position from <see cref="P:Newtonsoft.Json.Schema.JsonSchema.Items" />.
            </summary>
      <value>
        <c>true</c> if items are validated using their array position; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.AdditionalItems">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of additional items.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of additional items.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.AllowAdditionalItems">
      <summary>
            Gets or sets a value indicating whether additional items are allowed.
            </summary>
      <value>
        <c>true</c> if additional items are allowed; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.UniqueItems">
      <summary>
            Gets or sets whether the array items must be unique.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Properties">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of properties.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of properties.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.AdditionalProperties">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of additional properties.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of additional properties.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.PatternProperties">
      <summary>
            Gets or sets the pattern properties.
            </summary>
      <value>The pattern properties.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.AllowAdditionalProperties">
      <summary>
            Gets or sets a value indicating whether additional properties are allowed.
            </summary>
      <value>
        <c>true</c> if additional properties are allowed; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Requires">
      <summary>
            Gets or sets the required property if this property is present.
            </summary>
      <value>The required property if this property is present.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Enum">
      <summary>
            Gets or sets the a collection of valid enum values allowed.
            </summary>
      <value>A collection of valid enum values allowed.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Disallow">
      <summary>
            Gets or sets disallowed types.
            </summary>
      <value>The disallow types.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Default">
      <summary>
            Gets or sets the default value.
            </summary>
      <value>The default value.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Extends">
      <summary>
            Gets or sets the collection of <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> that this schema extends.
            </summary>
      <value>The collection of <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> that this schema extends.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Format">
      <summary>
            Gets or sets the format.
            </summary>
      <value>The format.</value>
    </member>
    <member name="T:Newtonsoft.Json.Schema.JsonSchemaGenerator">
      <summary>
            Generates a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from a specified <see cref="T:System.Type" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaGenerator.Generate(System.Type)">
      <summary>
            Generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from the specified type.
            </summary>
      <param name="type">The type to generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> generated from the specified type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaGenerator.Generate(System.Type,Newtonsoft.Json.Schema.JsonSchemaResolver)">
      <summary>
            Generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from the specified type.
            </summary>
      <param name="type">The type to generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from.</param>
      <param name="resolver">The <see cref="T:Newtonsoft.Json.Schema.JsonSchemaResolver" /> used to resolve schema references.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> generated from the specified type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaGenerator.Generate(System.Type,System.Boolean)">
      <summary>
            Generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from the specified type.
            </summary>
      <param name="type">The type to generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from.</param>
      <param name="rootSchemaNullable">Specify whether the generated root <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> will be nullable.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> generated from the specified type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaGenerator.Generate(System.Type,Newtonsoft.Json.Schema.JsonSchemaResolver,System.Boolean)">
      <summary>
            Generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from the specified type.
            </summary>
      <param name="type">The type to generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from.</param>
      <param name="resolver">The <see cref="T:Newtonsoft.Json.Schema.JsonSchemaResolver" /> used to resolve schema references.</param>
      <param name="rootSchemaNullable">Specify whether the generated root <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> will be nullable.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> generated from the specified type.</returns>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchemaGenerator.UndefinedSchemaIdHandling">
      <summary>
            Gets or sets how undefined schemas are handled by the serializer.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchemaGenerator.ContractResolver">
      <summary>
            Gets or sets the contract resolver.
            </summary>
      <value>The contract resolver.</value>
    </member>
    <member name="T:Newtonsoft.Json.Schema.JsonSchemaType">
      <summary>
            The value types allowed by the <see cref="T:Newtonsoft.Json.Schema.JsonSchema" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.None">
      <summary>
            No type specified.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.String">
      <summary>
            String type.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Float">
      <summary>
            Float type.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Integer">
      <summary>
            Integer type.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Boolean">
      <summary>
            Boolean type.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Object">
      <summary>
            Object type.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Array">
      <summary>
            Array type.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Null">
      <summary>
            Null type.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Any">
      <summary>
            Any type.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonObjectContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonObjectContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonObjectContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.MemberSerialization">
      <summary>
            Gets or sets the object member serialization.
            </summary>
      <value>The member object serialization.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.ItemRequired">
      <summary>
            Gets or sets a value that indicates whether the object's properties are required.
            </summary>
      <value>
            	A value indicating whether the object's properties are required.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.Properties">
      <summary>
            Gets the object's properties.
            </summary>
      <value>The object's properties.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.ConstructorParameters">
      <summary>
            Gets the constructor parameters required for any non-default constructor
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.CreatorParameters">
      <summary>
            Gets a collection of <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> instances that define the parameters used with <see cref="P:Newtonsoft.Json.Serialization.JsonObjectContract.OverrideCreator" />.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.OverrideConstructor">
      <summary>
            Gets or sets the override constructor used to create the object.
            This is set when a constructor is marked up using the
            JsonConstructor attribute.
            </summary>
      <value>The override constructor.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.ParametrizedConstructor">
      <summary>
            Gets or sets the parametrized constructor used to create the object.
            </summary>
      <value>The parametrized constructor.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.OverrideCreator">
      <summary>
            Gets or sets the function used to create the object. When set this function will override <see cref="P:Newtonsoft.Json.Serialization.JsonContract.DefaultCreator" />.
            This function is called with a collection of arguments which are defined by the <see cref="P:Newtonsoft.Json.Serialization.JsonObjectContract.CreatorParameters" /> collection.
            </summary>
      <value>The function used to create the object.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.ExtensionDataSetter">
      <summary>
            Gets or sets the extension data setter.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.ExtensionDataGetter">
      <summary>
            Gets or sets the extension data getter.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonStringContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonStringContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonStringContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.ReflectionValueProvider">
      <summary>
            Get and set values for a <see cref="T:System.Reflection.MemberInfo" /> using reflection.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.ReflectionValueProvider.#ctor(System.Reflection.MemberInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.ReflectionValueProvider" /> class.
            </summary>
      <param name="memberInfo">The member info.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.ReflectionValueProvider.SetValue(System.Object,System.Object)">
      <summary>
            Sets the value.
            </summary>
      <param name="target">The target to set the value on.</param>
      <param name="value">The value to set on the target.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.ReflectionValueProvider.GetValue(System.Object)">
      <summary>
            Gets the value.
            </summary>
      <param name="target">The target to get the value from.</param>
      <returns>The value.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.OnErrorAttribute">
      <summary>
            When applied to a method, specifies that the method is called when an error occurs serializing an object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.DynamicProxyMetaObject`1.CallMethodWithResult(System.String,System.Dynamic.DynamicMetaObjectBinder,System.Linq.Expressions.Expression[],Newtonsoft.Json.Utilities.DynamicProxyMetaObject{`0}.Fallback,Newtonsoft.Json.Utilities.DynamicProxyMetaObject{`0}.Fallback)">
      <summary>
            Helper method for generating a MetaObject which calls a
            specific method on Dynamic that returns a result
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.DynamicProxyMetaObject`1.CallMethodReturnLast(System.String,System.Dynamic.DynamicMetaObjectBinder,System.Linq.Expressions.Expression[],Newtonsoft.Json.Utilities.DynamicProxyMetaObject{`0}.Fallback)">
      <summary>
            Helper method for generating a MetaObject which calls a
            specific method on Dynamic, but uses one of the arguments for
            the result.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.DynamicProxyMetaObject`1.CallMethodNoResult(System.String,System.Dynamic.DynamicMetaObjectBinder,System.Linq.Expressions.Expression[],Newtonsoft.Json.Utilities.DynamicProxyMetaObject{`0}.Fallback)">
      <summary>
            Helper method for generating a MetaObject which calls a
            specific method on Dynamic, but uses one of the arguments for
            the result.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.DynamicProxyMetaObject`1.GetRestrictions">
      <summary>
            Returns a Restrictions object which includes our current restrictions merged
            with a restriction limiting our type
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.ObjectConstructor`1">
      <summary>
            Represents a method that constructs an object.
            </summary>
      <typeparam name="T">The object type to create.</typeparam>
    </member>
    <member name="T:Newtonsoft.Json.TypeNameHandling">
      <summary>
            Specifies type name handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.TypeNameHandling.None">
      <summary>
            Do not include the .NET type name when serializing types.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.TypeNameHandling.Objects">
      <summary>
            Include the .NET type name when serializing into a JSON object structure.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.TypeNameHandling.Arrays">
      <summary>
            Include the .NET type name when serializing into a JSON array structure.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.TypeNameHandling.All">
      <summary>
            Always include the .NET type name when serializing.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.TypeNameHandling.Auto">
      <summary>
            Include the .NET type name when the type of the object being serialized is not the same as its declared type.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ConvertUtils.ConvertOrCast(System.Object,System.Globalization.CultureInfo,System.Type)">
      <summary>
            Converts the value to the specified type. If the value is unable to be converted, the
            value is checked whether it assignable to the specified type.
            </summary>
      <param name="initialValue">The value to convert.</param>
      <param name="culture">The culture to use when converting.</param>
      <param name="targetType">The type to convert or cast the value to.</param>
      <returns>
            The converted type. If conversion was unsuccessful, the initial value
            is returned if assignable to the target type.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.EnumUtils.GetNamesAndValues``1">
      <summary>
            Gets a dictionary of the names and values of an Enum type.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.EnumUtils.GetNamesAndValues``1(System.Type)">
      <summary>
            Gets a dictionary of the names and values of an Enum type.
            </summary>
      <param name="enumType">The enum type to get names and values for.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Newtonsoft.Json.JsonToken">
      <summary>
            Specifies the type of Json token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.None">
      <summary>
            This is returned by the <see cref="T:Newtonsoft.Json.JsonReader" /> if a <see cref="M:Newtonsoft.Json.JsonReader.Read" /> method has not been called. 
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.StartObject">
      <summary>
            An object start token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.StartArray">
      <summary>
            An array start token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.StartConstructor">
      <summary>
            A constructor start token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.PropertyName">
      <summary>
            An object property name.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Comment">
      <summary>
            A comment.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Raw">
      <summary>
            Raw JSON.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Integer">
      <summary>
            An integer.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Float">
      <summary>
            A float.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.String">
      <summary>
            A string.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Boolean">
      <summary>
            A boolean.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Null">
      <summary>
            A null token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Undefined">
      <summary>
            An undefined token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.EndObject">
      <summary>
            An object end token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.EndArray">
      <summary>
            An array end token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.EndConstructor">
      <summary>
            A constructor end token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Date">
      <summary>
            A Date.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Bytes">
      <summary>
            Byte data.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Utilities.StringBuffer">
      <summary>
            Builds a string. Unlike StringBuilder this class lets you reuse it's internal buffer.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.CollectionUtils.IsNullOrEmpty``1(System.Collections.Generic.ICollection{``0})">
      <summary>
            Determines whether the collection is null or empty.
            </summary>
      <param name="collection">The collection.</param>
      <returns>
        <c>true</c> if the collection is null or empty; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.CollectionUtils.AddRange``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Adds the elements of the specified collection to the specified generic IList.
            </summary>
      <param name="initial">The list to add to.</param>
      <param name="collection">The collection of elements to add.</param>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.CollectionUtils.IndexOf``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Returns the index of the first occurrence in a sequence by using a specified IEqualityComparer.
            </summary>
      <typeparam name="TSource">The type of the elements of source.</typeparam>
      <param name="list">A sequence in which to locate a value.</param>
      <param name="value">The object to locate in the sequence</param>
      <param name="comparer">An equality comparer to compare values.</param>
      <returns>The zero-based index of the first occurrence of value within the entire sequence, if found; otherwise, –1.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.GetCollectionItemType(System.Type)">
      <summary>
            Gets the type of the typed collection's items.
            </summary>
      <param name="type">The type.</param>
      <returns>The type of the typed collection's items.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.GetMemberUnderlyingType(System.Reflection.MemberInfo)">
      <summary>
            Gets the member's underlying type.
            </summary>
      <param name="member">The member.</param>
      <returns>The underlying type of the member.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.IsIndexedProperty(System.Reflection.MemberInfo)">
      <summary>
            Determines whether the member is an indexed property.
            </summary>
      <param name="member">The member.</param>
      <returns>
        <c>true</c> if the member is an indexed property; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.IsIndexedProperty(System.Reflection.PropertyInfo)">
      <summary>
            Determines whether the property is an indexed property.
            </summary>
      <param name="property">The property.</param>
      <returns>
        <c>true</c> if the property is an indexed property; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.GetMemberValue(System.Reflection.MemberInfo,System.Object)">
      <summary>
            Gets the member's value on the object.
            </summary>
      <param name="member">The member.</param>
      <param name="target">The target object.</param>
      <returns>The member's value on the object.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.SetMemberValue(System.Reflection.MemberInfo,System.Object,System.Object)">
      <summary>
            Sets the member's value on the target object.
            </summary>
      <param name="member">The member.</param>
      <param name="target">The target.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.CanReadMemberValue(System.Reflection.MemberInfo,System.Boolean)">
      <summary>
            Determines whether the specified MemberInfo can be read.
            </summary>
      <param name="member">The MemberInfo to determine whether can be read.</param>
            /// <param name="nonPublic">if set to <c>true</c> then allow the member to be gotten non-publicly.</param><returns><c>true</c> if the specified MemberInfo can be read; otherwise, <c>false</c>.
            </returns></member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.CanSetMemberValue(System.Reflection.MemberInfo,System.Boolean,System.Boolean)">
      <summary>
            Determines whether the specified MemberInfo can be set.
            </summary>
      <param name="member">The MemberInfo to determine whether can be set.</param>
      <param name="nonPublic">if set to <c>true</c> then allow the member to be set non-publicly.</param>
      <param name="canSetReadOnly">if set to <c>true</c> then allow the member to be set if read-only.</param>
      <returns>
        <c>true</c> if the specified MemberInfo can be set; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.StringUtils.IsWhiteSpace(System.String)">
      <summary>
            Determines whether the string is all white space. Empty string will return false.
            </summary>
      <param name="s">The string to test whether it is all white space.</param>
      <returns>
        <c>true</c> if the string is all white space; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.StringUtils.NullEmptyString(System.String)">
      <summary>
            Nulls an empty string.
            </summary>
      <param name="s">The string.</param>
      <returns>Null if the string was null, otherwise the string unchanged.</returns>
    </member>
    <member name="T:Newtonsoft.Json.WriteState">
      <summary>
            Specifies the state of the <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.WriteState.Error">
      <summary>
            An exception has been thrown, which has left the <see cref="T:Newtonsoft.Json.JsonWriter" /> in an invalid state.
            You may call the <see cref="M:Newtonsoft.Json.JsonWriter.Close" /> method to put the <see cref="T:Newtonsoft.Json.JsonWriter" /> in the <c>Closed</c> state.
            Any other <see cref="T:Newtonsoft.Json.JsonWriter" /> method calls results in an <see cref="T:System.InvalidOperationException" /> being thrown. 
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.WriteState.Closed">
      <summary>
            The <see cref="M:Newtonsoft.Json.JsonWriter.Close" /> method has been called. 
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.WriteState.Object">
      <summary>
            An object is being written. 
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.WriteState.Array">
      <summary>
            A array is being written.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.WriteState.Constructor">
      <summary>
            A constructor is being written.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.WriteState.Property">
      <summary>
            A property is being written.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.WriteState.Start">
      <summary>
            A write method has not been called.
            </summary>
    </member>
  </members>
</doc>